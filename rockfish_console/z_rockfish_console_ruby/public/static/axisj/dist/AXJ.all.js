/*! 
axisj - v1.1.10 - 2016-10-14 
*/
/*! 
axisj - v1.1.10 - 2016-10-14 
*/

if(!window.AXConfig){
/**
 * AXISJ UI 등에 기본값으로 사용되는 설정 변수
 * @namespace {Object} AXConfig
 * @example
 ```json
 AXConfig.weekDays = [{label:""},..];
 AXConfig.AXReq.contentType = "";
 // 처럼 기본값을 수정할 수 있습니다.
 // .net 에서 webMethod를 이용하여 개발할 때는 다음의 설정을 권장합니다.
 AXConfig.AXReq.okCode = "00";
 AXConfig.AXReq.contentType = "application/json; charset=utf-8";
 AXConfig.AXReq.dataSendMethod = "json";
 AXConfig.AXReq.resultFormatter = function () {
	return this.d.object();
 };
 ```
 */
	var AXConfig = {
		anchorHref: "href=\"javascript:;\"",
/**
 * calendar weekDays label
 * @memberof AXConfig
 * @example
 ```json
 weekDays: [
	 { label: "일" },
	 { label: "월" },
	 { label: "화" },
	 { label: "수" },
	 { label: "목" },
	 { label: "금" },
	 { label: "토" }
 ]
 ```
 */
		weekDays: [
			{ label: "일" },
			{ label: "월" },
			{ label: "화" },
			{ label: "수" },
			{ label: "목" },
			{ label: "금" },
			{ label: "토" }
		],
/**
 * AXReq default config
 * @memberof AXConfig
 * @example
 ```json
 AXReq: {
	async: true, // AJAX 비동기 처리 여부
	okCode: "ok", // 통신 성공 코드
	responseType: "", // AJAX responseType
	dataType: "", // AJAX return Data type
	contentType: "application/x-www-form-urlencoded; charset=UTF-8", // AJAX contentType
	dataSendMethod: "parameter", // AJAX parameter send type
	crossDomain: false,
	resultFormatter: function () { // onsucc formatter
		return this;
	}
}
 ```
 */
		AXReq: {
			async: true, // AJAX 비동기 처리 여부
			okCode: "ok", // 통신 성공 코드
			responseType: "", // AJAX responseType
			dataType: "", // AJAX return Data type
			contentType: "application/x-www-form-urlencoded; charset=UTF-8", // AJAX contentType
			dataSendMethod: "parameter", // AJAX parameter send type
			crossDomain: false,
			resultFormatter: function () { // onsucc formatter
				return this;
			}
		},
/**
 * AXGrid default config
 * @memberof AXConfig
 * @example
 ```json
 AXGrid: {
	passiveMode: false,
	passiveRemoveHide: false,
	fitToWidthRightMargin: 10,
	fitToWidth: false,
	pageSize: 10,
	pageHeight: 400,
	keyResult: "result",
	keyList: "list",
	emptyListMSG: "empty of list",
	listCountMSG: "<b>{listCount}</b> count(s)",
	pageCountMSG: "page(s)"
}
 ```
 */
		AXGrid: {
			passiveMode: false,
			passiveRemoveHide: false,
			fitToWidthRightMargin: 11,
			fitToWidth: false,
			pageSize: 10,
			pageHeight: 400,
			headTdHeight: 30,
			keyResult: "result",
			keyList: "list",
			emptyListMSG: "empty of list",
			listCountMSG: "<b>{listCount}</b> count(s)",
			pageCountMSG: "page(s)"
		},
/**
 * AXTree default config
 * @memberof AXConfig
 * @example
 ```json
 AXTree: {
	fitToWidthRightMargin: 10,
	fitToWidth: false,
	pageSize: 10,
	pageHeight: 400,
	keyResult: "result",
	keyTree: "tree",
	keyList: "list",
	emptyListMSG: "목록이 없습니다.",
	persist: true,
    cookiePrefix: "axtree-",
    cookieExpiredays: 7
}
 ```
 */
		AXTree: {
			fitToWidthRightMargin: 10,
			fitToWidth: false,
			pageSize: 10,
			pageHeight: 400,
			keyResult: "result",
			keyTree: "tree",
			keyList: "list",
			emptyListMSG: "목록이 없습니다.",
			persistExpanded: false,
			persistSelected: false,
			cookiePrefix: "axtree-",
			cookieExpiredays: 7
		},
/**
 * AXProgress default config
 * @memberof AXConfig
 * @example
 ```json
 AXProgress: {
	cancelMsg: "프로세스를 취소 하시겠습니까?"
}
 ```
 */
		AXProgress: {
			cancelMsg: "프로세스를 취소 하시겠습니까?"
		},
/**
 * AXUpload5 default config
 * @memberof AXConfig
 * @example
 ```json
 AXUpload5: {
	buttonTxt: "Upload files",
	deleteConfirm: "정말 삭제하시겠습니까?",
	uploadSelectTxt: "업로드 하실 파일을 선택해주세요.",
	dropZoneTxt: "업로드할 파일을 여기에 놓습니다."
}
 ```
 */
		AXUpload5: {
			buttonTxt: "Upload files",
			deleteConfirm: "정말 삭제하시겠습니까?",
			uploadSelectTxt: "업로드 하실 파일을 선택해주세요.",
			dropZoneTxt: "업로드할 파일을 여기에 놓습니다."
		},
/**
 * AXModal default config
 * @memberof AXConfig
 * @example
 ```json
 AXModal: {
	contentDivClass: "bodyHeightDiv"
}
 ```
 */
		AXModal: {
			contentDivClass: "bodyHeightDiv",
			pars: ""
		},
/**
 * AXInput default config
 * @memberof AXConfig
 * @example
 * ```json
 * AXInput: {
 * 	errorPrintType: "toast",
 * 	selectorOptionEmpty: "목록이 없습니다.",
 * 	yearText:"{year}년",
 * 	monthText:"{month}월",
 * 	confirmText:"확인",
 * 	keyOptions:"options",
 * 	keyOptionValue:"optionValue",
 * 	keyOptionText:"optionText"
 * }
 * ```
 */
		AXInput: {
			errorPrintType: "toast",
			selectorOptionEmpty: "목록이 없습니다.",
			yearText:"{year}년",
			monthText:"{month}월",
			confirmText:"확인",
			keyOptions:"options",
			keyOptionValue:"optionValue",
			keyOptionText:"optionText"
		},
/**
 * AXSelect default config
 * @memberof AXConfig
 * @example
 * ```json
 * AXSelect: {
 *  keyOptions:"options",
 *  keyOptionValue:"optionValue",
 *  keyOptionText:"optionText"
 * }
 * ```
 */
		AXSelect: {
			keyOptions:"options",
			keyOptionValue:"optionValue",
			keyOptionText:"optionText"
		},
/**
 * AXContextMenu default config
 * @memberof AXConfig
 * @example
 ```json
 AXContextMenu: {
	title:"선택하세요"
}
 ```
 */
		AXContextMenu: {
			title:"선택하세요"
		},
/**
 * mobile default config : 모바일 UI 반응너비
 * @memberof AXConfig
 * @example
 ```json
 mobile: {
	responsiveWidth: 0
}
 ```
 */
		mobile: {
			responsiveWidth: 0
		},
/**
 * AXEditor default config
 * @memberof AXConfig
 * @example
 ```json
 AXEditor: {
	editor_frameSrc : "/_AXJ/lib/AXEditor.html",
	iconDirectory : "/ui/icons/"
}
 ```
 */
		AXEditor: {
			editor_frameSrc : "/_AXJ/lib/AXEditor.html",
			iconDirectory : "/ui/icons/"
		},
/**
 * AXTab default config
 * @memberof AXConfig
 * @example
 ```json
 AXTab: {
	closable : false
 }
 ```
 */
		AXTab: {
			closable : false
		},
	/**
	 * AXValidator default config
	 * @memberof AXConfig
	 * @example
	 * ```json
	 * AXValidator: {
	 *	validateErrMessage: {
	 *		required: "[{label}](은)는 필수입력 사항입니다.",
	 *		requiredstring: "반드시 {required}(으)로 입력하셔야 하는 사항입니다.",
	 *		match: "[{label}](은)는 입력된 내용이 일치하지 않습니다.",
	 *		invalid: "[{label}](은)는 입력된 내용이 올바르지 않습니다.",
	 *		min: "[{label}](은)는 {min} 이상의 값을 입력해주세요.",
	 *		max: "[{label}](은)는 {max} 이하의 값을 입력해주세요.",
	 *		minbyte: "[{label}]의 입력된 내용의 길이가 {minbyte}Byte 이상이어야 합니다.",
	 *		maxbyte: "[{label}]의 입력된 내용의 길이가 {maxbyte}Byte를 초과할 수 없습니다.",
	 *		minlength: "[{label}]의 입력된 내용의 length가 {minlength} 이상이어야 합니다.",
	 *		maxlength: "[{label}]의 입력된 내용의 length가 {maxlength}을 초과할 수 없습니다.",
	 *
	 *		number: "숫자로만 입력하셔야 합니다.",
	 *		email: "이메일 형식이 올바르지 않습니다.",
	 *		hangul: "한글로만 입력하셔야 합니다.",
	 *		engonly: "영문으로만 입력하셔야 합니다.",
	 *		residentno: "주민등록번호 형식이 올바르지 않습니다.",
	 *		foreignerno: "외국인등록번호 형식이 올바르지 않습니다.",
	 *		bizno: "사업자등록번호 형식이 올바르지 않습니다.",
	 *		phone: "전화번호 형식이 올바르지 않습니다.",
	 *		isdate: "날짜 형식이 올바르지 않습니다.",
	 *		zip: "우편번호 형식이 올바르지 않습니다.",
	 *		money: "화폐형식으로만 입력하셔야 합니다.",
	 *		earlierThan: "[{label}] 보다 빠른 날짜를 입력해야 합니다.",
	 *		laterThan: "[{label}] 보다 느린 날짜를 입력해야 합니다.",
	 *
	 *		exception: "not found errmessage"
	 *	}
	 *}
	 * ```
 	 */
		AXValidator: {
			validateErrMessage: {
				/* for element */
				required: "[{label}](은)는 필수입력 사항입니다.",
				requiredstring: "반드시 {required}(으)로 입력하셔야 하는 사항입니다.",
				match: "[{label}](은)는 입력된 내용이 일치하지 않습니다.",
				invalid: "[{label}](은)는 입력된 내용이 올바르지 않습니다.",
				min: "[{label}](은)는 {min} 이상의 값을 입력해주세요.",
				max: "[{label}](은)는 {max} 이하의 값을 입력해주세요.",
				minbyte: "[{label}]의 입력된 내용의 길이가 {minbyte}Byte 이상이어야 합니다.",
				maxbyte: "[{label}]의 입력된 내용의 길이가 {maxbyte}Byte를 초과할 수 없습니다.",
				minlength: "[{label}]의 입력된 내용의 length가 {minlength} 이상이어야 합니다.",
				maxlength: "[{label}]의 입력된 내용의 length가 {maxlength}을 초과할 수 없습니다.",

				/* for format */
				number: "숫자로만 입력하셔야 합니다.",
				email: "이메일 형식이 올바르지 않습니다.",
				hangul: "한글로만 입력하셔야 합니다.",
				engonly: "영문으로만 입력하셔야 합니다.",
				residentno: "주민등록번호 형식이 올바르지 않습니다.",
				foreignerno: "외국인등록번호 형식이 올바르지 않습니다.",
				bizno: "사업자등록번호 형식이 올바르지 않습니다.",
				phone: "전화번호 형식이 올바르지 않습니다.",
				isdate: "날짜 형식이 올바르지 않습니다.",
				zip: "우편번호 형식이 올바르지 않습니다.",
				money: "화폐형식으로만 입력하셔야 합니다.",
				earlierThan: "[{label}] 보다 빠른 날짜를 입력해야 합니다.",
				laterThan: "[{label}] 보다 느린 날짜를 입력해야 합니다.",

				exception: "not found errmessage"
			}
		}
	};
}
/* ---------------------------- */
var axf = AXUtil = {
    async: true,
    ajaxOkCode: "ok",
    ajaxResponseType: "",
    ajaxDataType: "",
    gridPassiveMode: false,
    gridPassiveRemoveHide: false,
    gridFitToWidthRightMargin: 10,

    uniqueSeq: 0,

    /**
     * 현재페이지에서 고유한 순번을 반환합니다.
     * @method axf.getUniqueId
     * @returns {Number} uniqueSeq
     * @example
     * ```js
     * trace( axf.getUniqueId() );
     * ```
     */
    getUniqueId: function () {
        return (axf.uniqueSeq += 1);
    },

    /**
     * document.getElementById(id) 와 같습니다. 아이디가 같은 엘리먼트를 반환합니다.
     * @method axf.getId
     * @param {String} id
     * @returns {HtmlElement}
     * @example
     * ```js
     * if(axf.getId("myele_id")){
	 *    $("#myele_id").css({...});
	 * }
     * ```
     */
    getId: function (id) {
        return document.getElementById(id);
    },

    /**
     * @method axf.each
     * @param {Array|Object} obj
     * @param {Function} callback
     * @description Array 또는 Object의 아이템만큰 callback 함수를 call합니다.
     * @example
     * ```js
     * var new_array = [];
     * axf.each([0, 1, 2], function(){
	 * 	new_array.push(this*2);
	 * });
     * var new_object = {};
     * axf.each({a:1, b:2, c:3}, function(k, v){
	 * 	new_object[k] = v*2;
	 * });
     * ```
     */
    each: function (obj, callback) {
        if (obj) {
            var name, i = 0, length = obj.length,
                isObj = length === undefined || Object.isFunction(obj);
            if (isObj) {
                for (name in obj) {
                    if (callback.call(obj[name], name, obj[name]) === false) {
                        break;
                    }
                }
            }
            else {
                for (; i < length;) {
                    if (callback.call(obj[i], i, obj[i++]) === false) {
                        break;
                    }
                }
            }
        }
    },
    /**
     * 브라우저의 이름과 버전 모바일여부
     *
     * @member {Object} axf.browser
     * @example
     * ```js
     *{
     *	name: {String} - bowserName (ie|chrome|webkit|oprea),
     *	version: {Number} - browserVersion,
     *	mobile: {Boolean}
     *}
     * ```
     */
    browser: (function () {
        var ua = navigator.userAgent.toLowerCase();
        var mobile = (ua.search(/mobile/g) != -1);
        if (ua.search(/iphone/g) != -1) {
            return {name: "iphone", version: 0, mobile: true}
        }
        else if (ua.search(/ipad/g) != -1) {
            return {name: "ipad", version: 0, mobile: true}
        }
        else if (ua.search(/android/g) != -1) {
            var match = /(android)[ \/]([\w.]+)/.exec(ua) || [];
            var browserVersion = (match[2] || "0");
            return {name: "android", version: browserVersion, mobile: mobile}
        }
        else {
            var match = /(msie) ([\w.]+)/.exec(ua) ||
                /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                /(opera|opr)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
                /(chrome)[ \/]([\w.]+)/.exec(ua) ||
                /(webkit)[ \/]([\w.]+)/.exec(ua) ||
                ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                [];

            var browser = (match[1] || "");
            var browserVersion = (match[2] || "0");

            var browserName = {
                "msie": "ie",
                "trident": "ie",
                "opr": "opera"
            };
            if (browser in browserName) browser = browserName[browser];

            return {
                name: browser,
                version: browserVersion,
                mobile: mobile
            }
        }
    })(),
    /**
     * 호환성보기 여부
     * @member {String} axf.docTD
     * @example
     * ```js
     * axf.docTD = (Q|S)
     * ```
     */
    docTD: (function () {
        if (!document.compatMode || document.compatMode == 'BackCompat') return "Q";
        else return "S";
    })(),
    /**
     * @method axf.timekey
     * @returns {String} timeKey
     * @description 밀리세컨드까지 조합한 문자열을 반환합니다.
     * @example
     * ```js
     * trace(axf.timeKey()); // A004222760
     * ```
     */
    timekey: function () {
        var d = new Date();
        return ("A" + d.getHours().setDigit(2) + d.getMinutes().setDigit(2) + d.getSeconds().setDigit(2) + d.getMilliseconds());
    },
    /**
     * @method axf.overwriteObject
     * @param {Object} tg - 덮어쓰기 대상 오브젝트
     * @param {Object} obj - 덮어쓰기 할 오브젝트
     * @param {Boolean} [rewirte=false] - 덮어쓰기 모드
     * @returns {Object} 덮어쓰기된 tg
     * @description 덮어쓰기 대상 오브젝트에 덮어쓰기 할 오브젝트를 덮어쓰기 합니다.
     * @example
     * ```js
     * axf.overwriteObject({a:1}, {b:1});
     * // {a:1, b:1}
     * axf.overwriteObject({a:1}, {a:2}, true);
     * // {a:2}
     * // rewirte : false 이면 {a:1} 로 유지 됩니다. 대상오브젝트에 키가 없는 경우에만 덮어쓰기 합니다.
     * ```
     */
    overwriteObject: function (tg, obj, rewrite) {
        if (rewrite == undefined) rewrite = true;
        //trace(tg[k]);
        if (obj) AXUtil.each(obj, function (k, v) {
            if (rewrite) {
                tg[k] = v;
            }
            else {
                //trace(tg[k]);
                if (tg[k] == undefined) tg[k] = v;
            }
        });
        return tg;
    },
    /**
     * @method axf.copyObject
     * @param {Object} obj - 복제할 오브젝트
     * @returns {Object} 복제된 오브젝트
     * @description 오브젝트를 복제하여 새로운 참조를 리턴합니다.
     * @example
     * ```js
     * axf.copyObject({a:1});
     * // 내부코드가 Object.toJSON(obj).object(); 이므로 상황에 맞게 사용해야 합니다.
     * ```
     */
    copyObject: function (obj) {
        //return Object.clone(obj);
        return Object.toJSON(obj).object();
    },
    consonantKR: function (cword) {
        var cons = [
            {c: "ㄱ", re: "[가-깋]"}, {c: "ㄲ", re: "[까-낗]"}, {c: "ㄴ", re: "[나-닣]"}, {c: "ㄷ", re: "[다-딯]"}, {c: "ㄸ", re: "[따-띻]"}, {c: "ㄹ", re: "[라-맇]"},
            {c: "ㅁ", re: "[마-밓]"}, {c: "ㅂ", re: "[바-빟]"}, {c: "ㅃ", re: "[빠-삫]"}, {c: "ㅅ", re: "[사-싷]"}, {c: "ㅆ", re: "[싸-앃]"}, {c: "ㅇ", re: "[아-잏]"}, {c: "ㅈ", re: "[자-짛]"},
            {c: "ㅉ", re: "[짜-찧]"}, {c: "ㅊ", re: "[차-칳]"}, {c: "ㅋ", re: "[카-킿]"}, {c: "ㅌ", re: "[타-팋]"}, {c: "ㅍ", re: "[파-핗]"}, {c: "ㅎ", re: "[하-힣]"},
            {c: "(", re: "\\("}, {c: ")", re: "\\)"}, {c: "[", re: "\\["}, {c: "]", re: "\\]"}
        ];
        var rword = "";
        var cwords = cword.split("");
        for (var i = 0, l = cwords.length; i < l; i++) {
            var fos = cons.searchObject(function () {
                return this.item.c == cwords[i];
            });
            var fo = fos.first();
            if (fo) rword += fo.re;
            else rword += cwords[i];
        }
        return rword;
    },
    /**
     * @method axf.setCookie
     * @param {String} name
     * @param {String} value
     * @param {Number} [expiredays]
     * @param {Object} options
     * @description 쿠키에 값을 지정합니다.
     * @example
     * ```js
     * axf.setCookie("myname", "tomas", 10, {
	 *     path  : "/",             // {String} [현재 페이지의 path]
	 *     domain: "www.axisj.com", // {String} [현재 사이트의 domain]
	 *     secure: true             // {Boolean} [false]
	 * });
     * ```
     */
    setCookie: function (name, value, expiredays, options) {
        var expireDate;
        if (typeof expiredays === "number") {
            expireDate = new Date();
            expireDate.setDate(expireDate.getDate() + expiredays);
        }

        options = options || {};

        return (document.cookie = [
            encodeURIComponent(name), '=', String(value),
            expireDate ? "; expires=" + expireDate.toUTCString() : "", // use expires attribute, max-age is not supported by IE
            options.path ? "; path=" + options.path : "",
            options.domain ? "; domain=" + options.domain : "",
            options.secure ? "; secure" : ""
        ].join(""));
    },
    /**
     * @method axf.getCookie
     * @param {String} name
     * @description 쿠키에서 값을 읽어들입니다
     * @example
     * ```js
     * trace( axf.getCookie("myname") );
     * // tomas
     * ```
     */
    getCookie: function (name) {
        var nameOfCookie = name + "=";
        var x = 0;
        while (x <= document.cookie.length) {
            var y = (x + nameOfCookie.length);
            if (document.cookie.substring(x, y) == nameOfCookie) {
                if ((endOfCookie = document.cookie.indexOf(";", y)) == -1) endOfCookie = document.cookie.length;
                return decodeURIComponent(document.cookie.substring(y, endOfCookie));
            }
            x = document.cookie.indexOf(" ", x) + 1;
            if (x == 0) break;
        }
        return "";
    },
    JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
    /**
     * @method axf.dayLen
     * @param {Number} year
     * @param {Number} month
     * @returns {Number} end of daynum
     * @description 지정한 년도와 월의 날자수를 반환합니다.
     * @example
     * ```js
     * trace( axf.dayLen(2013, 1) );
     * // 28
     * // 주의 Data.getMonth() 의 반환값을 그대로 사용 하므로 1월은 0 으로 전달 해야 합니다. 0~11 까지의 값을 사용할 수 있습니다.
     * ```
     */
    dayLen: function (y, m) {
        if ([3, 5, 8, 10].has(function () {
                return this.item == m;
            })) {
            return 30;
        }
        else if (m == 1) {
            return (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) ? 29 : 28;
        }
        else {
            return 31;
        }
    },
    /**
     * @method  axf.clientHeight
     * @returns {Number} clientHeight
     * @description 브라우저 clientHeight 반환합니다. window 창 높이와 같습니다.
     * @example
     * ```js
     * axf.clientHeight();
     * ```
     */
    clientHeight: function () {
        return (AXUtil.docTD == "Q") ? document.body.clientHeight : document.documentElement.clientHeight;
    },
    /**
     * @method  axf.scrollHeight
     * @returns {Number} scrollHeight
     * @description HTML scrollHeight 반환합니다.
     * @example
     * ```js
     * axf.scrollHeight();
     * ```
     */
    scrollHeight: function () {
        return (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
    },
    /**
     * @method  axf.clientWidth
     * @returns {Number} clientWidth
     * @description 브라우저 clientWidth 반환합니다. window 창 너비와 같습니다.
     * @example
     * ```js
     * axf.clientWidth();
     * ```
     */
    clientWidth: function () {
        return (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
    },
    /**
     * @method  axf.scrollWidth
     * @returns {Number} scrollWidth
     * @description HTML scrollWidth 반환합니다.
     * @example
     * ```js
     * axf.scrollWidth();
     * ```
     */
    scrollWidth: function () {
        return (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
    },
    scrollTop: function () {
        return (document.documentElement && document.documentElement.scrollTop) ||
            document.body.scrollTop;
    },
    scrollLeft: function () {
        return (document.documentElement && document.documentElement.scrollLeft) ||
            document.body.scrollLeft;
    },
    /**
     * @member {Object} axf.Event
     * @description Event.keyCode 모음 ref => https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
     * @example
     * ```js
     *Event: {
	 *    KEY_BACKSPACE: 8,
	 *    KEY_TAB      : 9,
	 *    KEY_RETURN   : 13,
	 *    KEY_SHIFT    : 16,
	 *    KEY_CONTROL  : 17,
	 *    KEY_ALT      : 18,
	 *    KEY_ESC      : 27,
	 *    KEY_SPACE    : 32,
	 *    KEY_PAGEUP   : 33,
	 *    KEY_PAGEDOWN : 34,
	 *    KEY_END      : 35,
	 *    KEY_HOME     : 36,
	 *    KEY_LEFT     : 37,
	 *    KEY_UP       : 38,
	 *    KEY_RIGHT    : 39,
	 *    KEY_DOWN     : 40,
	 *    KEY_INSERT   : 45,
	 *    KEY_DELETE   : 46,
	 *    KEY_WINDOW   : 91,
	 *    KEY_EQUAL    : 187,
	 *    KEY_MINUS    : 189,
	 *    KEY_PERIOD   : 190,
	 *    NUMPAD_EQUAL   : 12,
	 *    NUMPAD_MULTIPLY: 106,
	 *    NUMPAD_ADD     : 107,
	 *    NUMPAD_SUBTRACT: 109,
	 *    NUMPAD_DECIMAL : 110,
	 *    NUMPAD_DIVIDE  : 111,
	 *    NUMPAD_COMMA   : 194,
	 *    cache: {}
	 *}
     * ```
     */
    Event: {
        KEY_BACKSPACE: 8,
        KEY_TAB: 9,
        KEY_RETURN: 13,
        KEY_SHIFT: 16,
        KEY_CONTROL: 17,
        KEY_ALT: 18,
        KEY_ESC: 27,
        KEY_SPACE: 32,
        KEY_PAGEUP: 33,
        KEY_PAGEDOWN: 34,
        KEY_END: 35,
        KEY_HOME: 36,
        KEY_LEFT: 37,
        KEY_UP: 38,
        KEY_RIGHT: 39,
        KEY_DOWN: 40,
        KEY_INSERT: 45,
        KEY_DELETE: 46,
        KEY_WINDOW: 91,
        KEY_EQUAL: 187,
        KEY_MINUS: 189,
        KEY_PERIOD: 190,
        NUMPAD_EQUAL: 12,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_ADD: 107,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_COMMA: 194,
        cache: {}
    },
    /**
     * @method axf.console
     * @param {String|Object|Array} obj
     * @description 브라우저 console 에 메세지를 출력하여 줍니다. trace 와 같습니다.
     * @example
     * ```js
     * axf.console("AXISJ");
     * // AXISJ
     *
     * axf.console(1234);
     * // 1234
     *
     * var myObj = {name:"AXISJ", url:"http://www.axisj.com"};
     * axf.console(myObj);
     * // {"name":"AXISJ", "url":"http://www.axisj.com"}
     * ```
     */
    console: function (obj) {
        var po = "";
        if (arguments.length > 1) {
            for (i = 0; i < arguments.length; i++) {
                var obji = arguments[i];
                var objStr = "";
                var type = (typeof obji).toLowerCase();
                if (type == "undefined" || type == "function") {
                    objStr = type;
                }
                else if (type == "boolean" || type == "number" || type == "string") {
                    objStr = obji;
                }
                else if (type == "object") {
                    objStr = Object.toJSON(obji);
                }
                if (po != "") po += ", ";
                po += "arg[" + i + "] : " + objStr;
            }
        }
        else {
            var type = (typeof obj).toLowerCase();
            if (type == "undefined" || type == "function") {
                po = type;
            }
            else if (type == "boolean" || type == "number" || type == "string") {
                po = obj;
            }
            else if (type == "object") {
                po = Object.toJSON(obj);
            }
        }

        if (axf.mobileConsole) {
            axf.mobileConsole.prepend("<div>" + po + "</div>");
        }
        else {
            if (window.console == undefined) {
            }
            else {
                try {
                    console.log(po);
                    //+ ":" + axf.console.caller.name
                } catch (e) {
                    alert(e);
                }
            }
        }
    },
    /**
     * @method  axf.alert
     * @param {String|Object|Array} obj
     * @description window.alert 를 확장하여 JSObject 구조를 출력 합니다.
     * @example
     * ```js
     * axf.alert("AXISJ");
     * // AXISJ
     *
     * axf.alert(1234);
     * // 1234
     *
     * var myObj = {name:"AXISJ", url:"http://www.axisj.com"};
     * axf.alert(myObj);
     * // {"name":"AXISJ", "url":"http://www.axisj.com"}
     * ```
     */
    alert: function (obj) {
        var po = "";
        if (arguments.length > 1) {
            for (i = 0; i < arguments.length; i++) {
                var obji = arguments[i];
                var objStr = "";
                var type = (typeof obji).toLowerCase();
                if (type == "undefined" || type == "function") {
                    objStr = type;
                }
                else if (type == "boolean" || type == "number" || type == "string") {
                    objStr = obji;
                }
                else if (type == "object") {
                    objStr = Object.toJSON(obji);
                }
                if (po != "") po += ", ";
                po += "arguments[" + i + "] : " + objStr;
            }
        }
        else {
            var type = (typeof obj).toLowerCase();
            if (type == "undefined" || type == "function") {
                po = type;
            }
            else if (type == "boolean" || type == "number" || type == "string") {
                po = obj;
            }
            else if (type == "object") {
                po = Object.toJSON(obj);
            }
        }
        alert(po);
    },
    /**
     * @method  axf.confirm
     * @param {String|Object|Array} obj
     * @description window.confirm 를 확장하여 JSObject 구조를 출력 합니다.
     * @example
     * ```js
     * axf.confirm("AXISJ");
     * // AXISJ
     *
     * axf.confirm(1234);
     * // 1234
     *
     * var myObj = {name:"AXISJ", url:"http://www.axisj.com"};
     * axf.confirm(myObj);
     * // {"name":"AXISJ", "url":"http://www.axisj.com"}
     * ```
     */
    confirm: function (obj) {
        var po = "";
        var type = (typeof obj).toLowerCase();
        if (type == "undefined" || type == "function") {
            po = type;
        }
        else if (type == "boolean" || type == "number" || type == "string") {
            po = obj;
        }
        else if (type == "object") {
            po = Object.toJSON(obj);
        }
        var result = confirm(po);
        return result;
    },
    importJS: function (src) {
        var scriptElement = document.createElement("script");
        scriptElement.setAttribute("src", src);
        scriptElement.setAttribute("type", "text/javascript");
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
    },
    bindPlaceholder: function () {

    },
    /**
     * @method axf.isEmpty
     * @param {obj} obj
     * @returns {Boolean}
     * @description 대상 개체가 undefined, null, "" 인지 체크 합니다.
     * @example
     * ```js
     * trace( axf.isEmpty("AXISJ") );
     * // false
     * trace( axf.isEmpty("") );
     * // true
     * trace( axf.isEmpty(undefined) );
     * // true
     * ```
     */
    isEmpty: function (obj) {
        return (obj === "" || obj === null || obj === undefined);
    },
    /**
     * @method axf.getUrlInfo
     * @returns {Object} urlInfo
     * @description 브라우저 각종 속성을 반환합니다.
     * @example
     * ```js
     * trace( axf.getUrlInfo() );
     * {
	 * 	"url":"http://127.0.0.1:2013/samples/AXcore/test.html",
	 * 	"param":"",
	 * 	"anchorData":"127.0.0.1:2013/samples/AXcore/test.html",
	 * 	"urlParam":"http://127.0.0.1:2013/samples/AXcore/test.html",
	 * 	"referUrl":"",
	 * 	"pathName":"/samples/AXcore/test.html",
	 * 	"protocol":"http:",
	 * 	"hostName":"127.0.0.1"
	 * }
     * ```
     */
    getUrlInfo: function () {
        var url, url_param, param, referUrl, pathName, AXparam, pageProtocol, pageHostName;
        url_param = window.location.href;
        param = window.location.search;
        referUrl = document.referrer;
        pathName = window.location.pathname;
        url = url_param.replace(param, '');
        param = param.replace(/^\?/, '');
        pageProtocol = window.location.protocol;
        pageHostName = window.location.hostname;
        AXparam = url_param.replace(pageProtocol + "//", "");
        AXparam = (param) ? AXparam.replace(pageHostName + pathName + "?" + param, "") : AXparam.replace(pageHostName + pathName, "");
        return {
            url: url,
            param: param,
            anchorData: AXparam,
            urlParam: url_param,
            referUrl: referUrl,
            pathName: pathName,
            protocol: pageProtocol,
            hostName: pageHostName
        };
    },
    /**
     * @method axf.encParam
     * @param {String} str - parameter
     * @returns {String} parameter
     * @description 파라미터에 value를 URLEncode해 줍니다.
     * @example
     * ```js
     * axf.encParam("name=장기영&sex=남");
     * //"name=%EC%9E%A5%EA%B8%B0%EC%98%81&sex=%EB%82%A8"
     * ```
     */
    encParam: function (str) {
        var re = new RegExp("[^&?]*?=[^&?]*", "ig");
        var pars = [];
        var arr;
        while ((arr = re.exec(str)) != null) {
            var strContent = arr.toString();
            var dotIndex = strContent.indexOf("=");
            pars.push(strContent.substring(0, dotIndex) + "=" + strContent.substring(dotIndex + 1).enc());
        }
        return pars.join("&");
    },
    readyMobileConsole: function () {
        AXUtil.mobileConsole = axdom("<div class=\"AXMobileConsole\"></div>");
        axdom(document.body).append(AXUtil.mobileConsole);
    },
    parsingTable: function (elemObj, returnType) {
        var head = {}, body = [];
        elemObj.find("thead tr td").each(function () {
            var elem = axdom(this);
            var attrs = {
                key: elem.attr("name"),
                label: (elem.html() || ""),
                width: (elem.attr("width") || "*"),
                align: (elem.attr("align") || "")
            };
            head[attrs.key] = attrs;
        });

        elemObj.find("tbody tr").each(function () {
            var item = {};
            axdom(this).find("td").each(function () {
                var elem = axdom(this);
                item[elem.attr("name")] = elem.html();
            });
            body.push(item);
        });
        return {
            head: head, body: body
        };
    },
    /**
     * @member {type} axf.mousewheelevt
     * @description 브라우저에 따른 마우스 휠 이벤트이름
     */
    mousewheelevt: ((/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"),

    //todo : event bubble catch
    /**
     * 타겟엘리먼트의 부모 엘리멘트에서 원하는 조건의 엘리먼트를 얻습니다.
     * @method axf.get_event_target
     * @param {Element} target - target element
     * @param {Object} cond - 원하는 element를 찾을 조건
     * @returns {Element}
     * @example
     * ```js
     * console.log(axf.get_event_target(e.target, {tagname:"a", clazz:"findclass", etc:"attribute"}));
     * ```
     */
    get_event_target: function (target, cond) {
        var _target = target;
        if (_target) {
            while ((function () {
                var result = true;
                if (Object.isFunction(cond)) {
                    result = cond(_target);
                }
                else if (Object.isObject(cond)) {
                    for (var k in cond) {
                        if (k === "tagname") {
                            if (_target.tagName.lcase() != cond[k]) {
                                result = false;
                                break;
                            }
                        }
                        else if (k === "clazz") {
                            var klasss = _target.className.split(/ /g);
                            var hasClass = false;
                            for (var a = 0; a < klasss.length; a++) {
                                if (klasss[a] == cond[k]) {
                                    hasClass = true;
                                    break;
                                }
                            }
                            result = hasClass;
                        }
                        else { // 그외 속성값들.
                            if (_target.getAttribute) {
                                if (_target.getAttribute(k) != cond[k]) {
                                    result = false;
                                    break;
                                }
                            }
                            else {
                                result = false;
                                break;
                            }
                        }
                    }
                }
                return !result;
            })()) {
                if (_target.parentNode) {
                    _target = _target.parentNode;
                }
                else {
                    _target = false;
                    break;
                }
            }
        }
        return _target;
    }
};
var axdom;
if (window.jQuery) axdom = jQuery;
if (window.axdomConverter) axdom = axdomConverter;

// extend implement block

/**
 * AXISJ Class 지원 오브젝트
 * @namespace {Object} Class
 */
var Class = (function () {
    function subclass() {
    }

    /**
     * @method Class.create
     * @param {Object} [superClass] - 부모 클래스 오브젝트
     * @param {Object} Class Body
     * @description 클래스를 만들어 줍니다.
     * @example
     * ```js
     * var AXJ = Class.create({
 *	initialize: function () {
 *		this.config = {
 *			debugMode: false,
 *			hashSpliter: "_",
 *			href: "href=\"javascript:;\""
 *		};
 *	},
 *	init: function () {
 *		trace(Object.toJSON(this.config));
 *	}
 * });
     * ```
     */
    function create() {
        var parent = null, properties = AX_A(arguments);
        if (Object.isFunction(properties[0])) parent = properties.shift();
        function klass() {
            this.initialize.apply(this, arguments);
        }

        Object.extend(klass, Class.Methods);
        klass.superclass = parent;
        klass.subclasses = [];
        if (parent) {
            subclass.prototype = parent.prototype;
            klass.prototype = new subclass;
            parent.subclasses.push(klass);
        }
        for (var i = 0; i < properties.length; i++) klass.addMethods(properties[i]);
        if (!klass.prototype.initialize) klass.prototype.initialize = Prototype.emptyFunction;
        klass.prototype.constructor = klass;
        return klass;
    }

    function addMethods(source) {
        var ancestor = this.superclass && this.superclass.prototype;
        var properties = Object.keys(source);
        if (!Object.keys({toString: true}).length) {
            if (source.toString != Object.prototype.toString) properties.push("toString");
            if (source.valueOf != Object.prototype.valueOf) properties.push("valueOf");
        }
        for (var i = 0, length = properties.length; i < length; i++) {
            var property = properties[i], value = source[property];
            if (ancestor && Object.isFunction(value) && value.argumentNames().first() == "AXJ_super") {
                var method = value;
                value = (function (m) {
                    return function () {
                        return ancestor[m].apply(this, arguments);
                    };
                })(property).wrap(method);
                value.valueOf = method.valueOf.bind(method);
                value.toString = method.toString.bind(method);
            }
            this.prototype[property] = value;
        }
        return this;
    }

    return {create: create, Methods: {addMethods: addMethods}};
})();

/**
 * Object.prototype
 * @namespace {Object} Object
 */
// Object extend
(function () {
    var _toString = Object.prototype.toString;
    //function extend(destination, source) { for (var property in source) destination[property] = source[property]; return destination; }

    /**
     * @method Object.extend
     * @param {Object} [target]
     * @param {Object} extend object
     * @param {Boolean} [overwrite=false] - 덮어쓰기 여부
     * @returns {Object} extended object
     * @description 오브젝트를 확장합니다. 타겟 오브젝트에 확장오브젝트의 키를 추가하거나 덮어쓰기 합니다.
     * @example
     * ```js
     * Object.extend({a:1}, {a:2});
     * // Object {a: 1}
     * Object.extend({a:1}, {b:2});
     * // Object {a: 1, b: 2}
     * Object.extend({a:1}, {a:2}, true);
     * // Object {a: 2}
     * ```
     */
    function extend() {
        var target = arguments[0] || {}, items = arguments[1], overwrite = arguments[2] || false;
        if (typeof target !== "object" && typeof target !== "function") {
            target = {};
        }
        if (typeof items === "string") {
            target = items;
        }
        else {
            if (overwrite === true) {
                for (var k in items) target[k] = items[k];
            }
            else if (overwrite === false) {
                for (var k in items) {
                    if (typeof target[k] === "undefined") target[k] = items[k];
                }
            }
        }
        return target;
    }

    function inspect(obj) {
        try {
            if (isUndefined(obj)) return 'undefined';
            if (obj === null) return 'null';
            return obj.inspect ? obj.inspect() : String(obj);
        } catch (e) {
            if (e instanceof RangeError) return '...';
            throw e;
        }
    }

    /**
     * @method Object.toJSON
     * @param {Object} object
     * @param {Boolean} [qoute=true] - 따옴표 표시 여부
     * @returns {String} JSON String
     * @description Object JSON String 으로 반환합니다. Function은 제외합니다.
     * @example
     * ```js
     * Object.toJSON({a:1, b:2});
     * // "{"a":1, "b":2}"
     * Object.toJSON({a:1, b:2}, false);
     * // "{a:1, b:2}"
     * ```
     */

    var toJSON = (function () {
        var r = /["]/g, f;
        return f = function (vContent, isqoute) {
            var result, i, j;
            switch (result = typeof vContent) {
                case'string':
                    return '"' + vContent.replace(r, '\\"') + '"';
                case'number':
                    return vContent;
                case'boolean':
                    return vContent.toString();
                case'undefined':
                    return 'undefined';
                case'function':
                    return '""';
                case'object':
                    if (_toString.call(vContent) == "[object Number]") {
                        return vContent;
                    }
                    if (_toString.call(vContent) == "[object String]") {
                        return '"' + vContent.replace(r, '\\"') + '"';
                    }
                    if (!vContent) return 'null';
                    result = '';
                    if (vContent.splice) {
                        for (i = 0, j = vContent.length; i < j; i++) result += ',' + f(vContent[i]);
                        return '[' + result.substr(1) + ']';
                    }
                    else {
                        for (i in vContent) if (vContent.hasOwnProperty(i) && vContent[i] !== undefined && typeof vContent[i] != 'function') result += ',"' + i + '":' + f(vContent[i]);
                        return '{' + result.substr(1) + '}';
                    }
            }
        };
    })();

    /*
     function toJSON(vContent, qoute) {
     var type = typeof object;
     var isqoute = qoute;
     if (isqoute == undefined) isqoute = true;
     switch (type) {
     case 'undefined': return "undefined";
     //case 'function': return "\"" + object.toString().replace(/\"/g, "\\\"") + "\"";
     case 'function': return;
     case 'unknown': return "unknown";
     case 'boolean': return object.toString();
     case 'number': return object.toString();
     case 'string': return object.axtoJSON(true);
     }
     if (object === null) return 'null';
     if (object.axtoJSON) return object.axtoJSON(isqoute);
     if (isElement(object)) return;
     var results = [];
     for (var property in object) {
     if (object.hasOwnProperty(property)) {
     var value = toJSON(object[property], isqoute);
     if (!isUndefined(value)) results.push(property.axtoJSON(isqoute) + ':' + value);
     }
     }
     return '{' + results.join(', ') + '}';
     }
     */

    /**
     * 오브젝트의 새로운 참조를 생성합니다.
     * @method Object.toJSONfn
     * @param {Object} object
     * @param {Boolean} [qoute=true] - 따옴표 표시 여부
     * @returns {String} JSON String
     */
    function toJSONfn(object, qoute) {
        var type = typeof object;
        var isqoute = qoute;
        if (isqoute == undefined) isqoute = true;
        switch (type) {
            case 'undefined':
                return "undefined";
            case 'function':
                try {
                    return toJSONfn(object(), isqoute);
                } catch (e) {
                    return;
                }
            case 'unknown':
                return "unknown";
            case 'boolean':
                return object.toString();
            case 'number':
                return object.toString();
            case 'string':
                return object.axtoJSON(true);
        }
        if (object === null) return 'null';
        if (object.axtoJSON) return object.axtoJSON(isqoute);
        if (isElement(object)) return;
        var results = [];
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var value = toJSONfn(object[property], isqoute);
                if (!isUndefined(value)) results.push(property.axtoJSON(isqoute) + ':' + value);
            }
        }
        return '{' + results.join(', ') + '}';
    }

    function toJSONforMobile(object) {
        var type = typeof object;
        switch (type) {
            case 'undefined':
            case 'function':
                return;
            case 'unknown':
                return;
            case 'boolean':
                return "\"" + object.toString() + "\"";
            case 'number':
                return "\"" + object.toString() + "\"";
            case 'string':
                return object.axtoJSON(true);
        }
        if (object === null) return 'null';
        if (object.toJSONforMobile) return object.toJSONforMobile(true);
        if (isElement(object)) return;
        var results = [];
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var value = axtoJSON(object[property]);
                if (!isUndefined(value)) results.push(property.axtoJSON(true) + ':' + value);
            }
        }
        return '{' + results.join(', ') + '}';
    }

    /**
     * 오브젝트의 key를 배열로 반환합니다.
     * @method Object.keys
     * @param {Object} object
     * @returns {Array}
     */
    function keys(obj) {
        var results = [];
        for (var property in obj) results.push(property);
        return results;
    }

    /**
     * 오브젝트의 value를 배열로 반환합니다.
     * @method Object.values
     * @param {Object} object
     * @returns {Array}
     */
    function values(obj) {
        var results = [];
        for (var property in obj) results.push(obj[property]);
        return results;
    }

    /**
     * 오브젝트의 새로운 참조를 생성합니다.
     * @method Object.clone
     * @param {Object} object
     * @returns {Object}
     */
    function clone(obj) {
        return extend({}, obj);
    }

    /**
     * 오브젝트가 HTML 엘리먼트여부인지 판단합니다.
     * @method Object.isElement
     * @param {Object} object
     * @returns {Boolean}
     */
    function isElement(obj) {
        return !!(obj && obj.nodeType == 1);
    }

    /**
     * 오브젝트가 Object인지 판단합니다.
     * @method Object.isObject
     * @param {Object} object
     * @returns {Boolean}
     */
    function isObject(obj) {
        return _toString.call(obj) == "[object Object]";
    }

    /**
     * 오브젝트가 Array인지 판단합니다.
     * @method Object.isArray
     * @param {Object} object
     * @returns {Boolean}
     */
    function isArray(obj) {
        return _toString.call(obj) == "[object Array]";
    }

    /**
     * 오브젝트가 Hash인지 판단합니다.
     * @method Object.isHash
     * @param {Object} object
     * @returns {Boolean}
     */
    function isHash(obj) {
        return obj instanceof Hash;
    }

    /**
     * 오브젝트가 Function인지 판단합니다.
     * @method Object.isFunction
     * @param {Object} object
     * @returns {Boolean}
     */
    function isFunction(obj) {
        return typeof obj === "function";
    }

    /**
     * 오브젝트가 String인지 판단합니다.
     * @method Object.isString
     * @param {Object} object
     * @returns {Boolean}
     */
    function isString(obj) {
        return _toString.call(obj) == "[object String]";
    }

    /**
     * 오브젝트가 Number인지 판단합니다.
     * @method Object.isNumber
     * @param {Object} object
     * @returns {Boolean}
     */
    function isNumber(obj) {
        return _toString.call(obj) == "[object Number]";
    }

    /**
     * 오브젝트가 undefined인지 판단합니다.
     * @method Object.isUndefined
     * @param {Object} object
     * @returns {Boolean}
     */
    function isUndefined(obj) {
        return typeof obj === "undefined";
    }

    extend(Object, {
        extend: extend,
        inspect: inspect,
        toJSON: toJSON,
        toJSONfn: toJSONfn,
        toJSONforMobile: toJSONforMobile,
        keys: keys,
        values: values,
        clone: clone,
        isElement: isElement,
        isObject: isObject,
        isArray: isArray,
        isHash: isHash,
        isFunction: isFunction,
        isString: isString,
        isNumber: isNumber,
        isUndefined: isUndefined
    });
})();

/**
 * Function.prototype
 * @namespace {Function} Function
 */
Object.extend(Function.prototype, (function () {
    var slice = Array.prototype.slice;

    function update(array, args) {
        var arrayLength = array.length, length = args.length;
        while (length--) array[arrayLength + length] = args[length];
        return array;
    }

    function merge(array, args) {
        array = slice.call(array, 0);
        return update(array, args);
    }

    /**
     * @method Function.argumentNames
     * @returns {Array} arguments
     * @description 함수의 아규먼트를 배열로 반환합니다.
     * @example
     * ```js
     * var myFn = function(a, b, c){
	 *     return a;
	 * };
     *
     * trace(myFn.argumentNames());
     * //  ["a", "b", "c"]
     * // prototypejs 를 참조하여 제작되었습니다.
     * ```
     */
    function argumentNames() {
        var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',');
        return names.length == 1 && !names[0] ? [] : names;
    }

    /**
     * @method Function.bind
     * @param {Object} bindTarget
     * @param {Object} [Argument]
     * @description 함수의 위치를 bind 대상에 연결하여 줍니다.
     * @example
     * ```js
     * var AlertClass = Class.create({
	 *     initialize: function(msg) {
	 *        this.msg = msg;
	 *    },
	 *    handleClick: function(event) {
	 *        alert(this.msg);
	 *    }
	 * });
     * var myalert = new AlertClass("AXJ Clicked");
     *
     * $("#link1").click(myalert.handleClick);
     * //undefined
     * $("#link2").click(myalert.handleClick.bind(myalert));
     * //AXJ Clicked
     *
     * // ---------------------
     * var AlertClass = Class.create({
	 *    initialize: function(msg) {
	 *        this.msg = msg;
	 *    },
	 *    handleClick: function(a, b, c, event) {
	 *        trace({a:a, b:b, c:c, event:event.type});
	 *        // {"a":"A", "b":"X", "c":"J", "event":"click"}
	 *        alert(this.msg);
	 *    }
	 * });
     * var myalert = new AlertClass("AXJ Clicked");
     *
     * $("#link1").click(myalert.handleClick);
     * $("#link2").click(myalert.handleClick.bind(myalert, "A", "X", "J"));
     * ```
     */
    function bind(context) {
        if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
        var __method = this, args = slice.call(arguments, 1);
        return function () {
            var a = merge(args, arguments);
            return __method.apply(context, a);
        }
    }

    function curry() {
        if (!arguments.length) return this;
        var __method = this, args = slice.call(arguments, 0);
        return function () {
            var a = merge(args, arguments);
            return __method.apply(this, a);
        }
    }

    /**
     * @method Function.delay
     * @param {Number} timeout - second
     * @description 함수의 실행을 지정된 시간 후에 실행되게 합니다.
     * @example
     * ```js
     * var showMsg = function(a, b){
	 *     alert(a+"/"+b);
	 * };
     * showMsg.delay(2, "AX", "ISJ");
     * // 2초 후에 alert 구문이 실행됩니다.
     * // 내부네서 this.apply 를 호출합니다. 간단한 함수 호출에는 사용을 권장하지만 복잡한 형태의 함수 구현에는 권장하지 않습니다.
     * ```
     */
    function delay(timeout) {
        var __method = this, args = slice.call(arguments, 1);
        timeout = timeout * 1000;
        return window.setTimeout(function () {
            return __method.apply(__method, args);
        }, timeout);
    }

    function defer() {
        var args = update([0.01], arguments);
        return this.delay.apply(this, args);
    }

    function wrap(wrapper) {
        var __method = this;
        return function () {
            var a = update([__method.bind(this)], arguments);
            return wrapper.apply(this, a);
        }
    }

    function methodize() {
        if (this._methodized) return this._methodized;
        var __method = this;
        return this._methodized = function () {
            var a = update([this], arguments);
            return __method.apply(null, a);
        };
    }

    function addPrototype(fns) {
        var name, i = 0, length = fns.length, isObj = length === undefined || Object.isFunction(fns);
        if (isObj) {
            for (name in fns) {
                this.prototype[name] = fns[name];
            }
        }
    }

    return {argumentNames: argumentNames, bind: bind, curry: curry, delay: delay, defer: defer, wrap: wrap, methodize: methodize, addPrototype: addPrototype}
})());

/**
 * String.prototype
 * @namespace {String} String
 */
Object.extend(String.prototype, (function () {
    function password() {
        return Math.tan(45).toString().substr(7)
    }

    /**
     * 문자열 시작부터 지정한 글자수 만큼 반환합니다.
     * @method String.left
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String".left(3); -> "AXJ"
     * toast.push('left(3) : ' + "AXJ_String".left(3));
     * ```
     */
    function left(strLen) {
        return this.toString().substr(0, strLen);
    }

    /**
     * 문자열 끝부터 지정한 글자수 만큼 반환합니다.
     * @method String.right
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String".right(3); -> "ing"
     * toast.push('right(3) : '+$('#AXJrightTest').val().left(3));
     * ```
     */
    function right(strLen) {
        return this.substring(this.length - strLen, this.length);
    }

    /**
     * URLencode된 문자열을 디코드 합니다.
     * @method String.dec
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String%2C%EC%97%91%EC%8B%9C%EC%8A%A4%EC%A0%9C%EC%9D%B4".dec(); -> "AXJ_String,엑시스제이"
     * ```
     */
    function dec() {
        try {
            return decodeURIComponent(this);
        }
        catch (e) {
            return unescape(this);
        }
    }

    /**
     * URLencode된 문자열로 인코드 합니다.
     * @method String.enc
     * @returns {String}
     * @example
     * ```js
     * "AXJ_String,엑시스제이".enc(); -> "AXJ_String%2C%EC%97%91%EC%8B%9C%EC%8A%A4%EC%A0%9C%EC%9D%B4"
     * ```
     */
    function enc() {
        return (this) ? encodeURIComponent(this).replace(/[!'()*]/g, function (c) {
            return '%' + c.charCodeAt(0).toString(16);
        }) : this;
    }

    /**
     * JSONString이면 Object로 변환합니다.
     * @method String.object
     * @returns {Object}
     * @example
     * ```js
     * var myObj = "{a:1, b:2, name:'AXJ'}".object();
     * trace(myObj);
     * // {"a":1, "b":2, "name":"AXJ"}
     *
     * var myObjError = "{1, b:2, name:'AXJ'}".object();
     * trace(myObjError);
     * // {"error":"syntaxerr", "result":"syntaxerr", "msg":"JSON syntax error.{1, b:2, name:'AXJ'}", "body":"{1, b:2, name:'AXJ'}"}
     * ```
     */
    function object() {
        try {
            var res = this.evalJSON();
        } catch (e) {
            res = {error: "syntaxerr", result: "syntaxerr", msg: "to object error, " + e.print() + ", " + this};
            try {
                mask.close();
            } catch (e) {
            }
        }
        return res;
    }

    /**
     * 콤마가 포함된 문자열을 Array로 변환합니다.
     * @method String.array
     * @returns {Array}
     * @example
     * ```js
     * var myObj = "a,b,c".array();
     * trace(myObj);
     * // ["a", "b", "c"]
     * ```
     */
    function array() {
        try {
            var res = this.split(/,/g);
        } catch (e) {
            res = {error: "syntaxerr", result: "syntaxerr", msg: "to object error, " + e.print() + ", " + this};
        }
        return res;
    }

    /**
     * 문자열을 date 형식에 맞추어 날짜 포멧으로 리턴합니다.
     * @method String.date
     * @param {String} [separator=-] 날짜구분자
     * @returns {Date}
     * @example
     * ```js
     * trace("20121119".date());
     * // "2012-11-19T03:00:00Z"
     *
     * trace("2012-11-19".date());
     * // "2012-11-19T03:00:00Z"
     *
     * trace("2012/11/19".date("/"));
     * // "2012-11-19T03:00:00Z"
     * ```
     */
    function toDate(separator, defaultDate) {
        function local_date(yy, mm, dd, hh, mi, ss) {
            var utc_d, local_d;
            local_d = new Date();
            if (typeof hh === "undefined") hh = 23;
            if (typeof mi === "undefined") mi = 59;
            utc_d = new Date(Date.UTC(yy, mm, dd || 1, hh, mi, ss || 0));

            if (mm == 0 && dd == 1 && utc_d.getUTCHours() + (utc_d.getTimezoneOffset() / 60) < 0) {
                utc_d.setUTCHours(0);
            }
            else {
                utc_d.setUTCHours(utc_d.getUTCHours() + (utc_d.getTimezoneOffset() / 60));
            }
            return utc_d;
        }

        if (this.length == 0) {
            return defaultDate || new Date();
        }
        else if (this.length > 15) {
            var yy, mm, dd, hh, mi,
                aDateTime = this.split(/ /g), aTimes, aTime,
                aDate = aDateTime[0].split(separator || "-"),
                utc_d, local_d;

            yy = aDate[0];
            mm = parseFloat(aDate[1]);
            dd = parseFloat(aDate[2]);
            aTime = aDateTime[1] || "09:00";
            aTimes = aTime.left(5).split(":");
            hh = parseFloat(aTimes[0]);
            mi = parseFloat(aTimes[1]);
            if (aTime.right(2) === "AM" || aTime.right(2) === "PM") hh += 12;
            return local_date(yy, mm - 1, dd, hh, mi);
        }
        else if (this.length == 14) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, va.substr(6, 2).number(), va.substr(8, 2).number(), va.substr(10, 2).number(), va.substr(12, 2).number());
        }
        else if (this.length > 7) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, va.substr(6, 2).number());
        }
        else if (this.length > 4) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, 1);
        }
        else if (this.length > 2) {
            var va = this.replace(/\D/g, "");
            return local_date(va.substr(0, 4), va.substr(4, 2).number() - 1, 1);
        }
        else {
            return defaultDate || new Date();
        }
    }

    /**
     * 문자열을 Number로 변환해 줍니다.
     * @method String.number
     * @returns {Number}
     * @example
     * ```js
     * var str = "1234";
     * trace(typeof str);
     * // string
     *
     * str = str.number();
     * trace(typeof str);
     * // number
     *
     * "1,234".number(); -> 1234
     * "1,234.1".number(); -> 1234.1
     * ```
     */
    function toNum() {
        var pair = this.replace(/,/g, "").split(".");
        var isMinus = false;
        if (parseFloat(pair[0]) < 0) isMinus = true;
        if (pair[0] == "-0") isMinus = true;
        var returnValue = 0.0;
        pair[0] = pair[0].replace(/[-|+]?[\D]/gi, "");
        if (pair[1]) {
            pair[1] = pair[1].replace(/\D/gi, "");
            returnValue = parseFloat(pair[0] + "." + pair[1]) || 0;
        }
        else {
            returnValue = parseFloat(pair[0]) || 0;
        }
        return (isMinus) ? -returnValue : returnValue;
    }

    function parseF() {
        return parseFloat(this);
    }

    /**
     * 문자열의 앞뒤 공백을 제거하여 줍니다.
     * @method String.trim
     * @returns {String}
     * @example
     * ```js
     * " AXJ ".trim(); ->  "AXJ"
     * ```
     */
    function strip() {
        return this.replace(/^\s+/, '').replace(/\s+$/, '');
    }

    /**
     * 문자열에서 HTML 태그를 제거하여 반환합니다.
     * @method String.delHtml
     * @returns {String}
     * @example
     * ```js
     * "<div>AXJ</div>".delHtml(); ->  "AXJ"
     * ```
     */
    function stripTags() {
        return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');
    }

    /**
     * 문자열에서 Script 태그를 제거하여 반환합니다.
     * @method String.delScript
     * @returns {String}
     * @example
     * ```js
     * "<script src="scriptname"></script>AXJ".delScript(); ->  "AXJ"
     * ```
     */
    function stripScript() {
        //스크립트 제거
        var cStr;
        var RegExpJS = new RegExp("<[ ]*script[^>]*>[^<]*</[ ]*script[^>]*>", "gi");
        cStr = this.replace(RegExpJS, "");

        cStr = cStr.replace(/[\s]*onclick[^=]*=/gi, " xonclick=");
        cStr = cStr.replace(/[\s]*onmouserover[^=]*=/gi, " xonmouseover=");
        cStr = cStr.replace(/[\s]*onmouseout[^=]*=/gi, " xonmouseout=");
        cStr = cStr.replace(/[\s]*onchange[^=]*=/gi, " xonchange=");
        cStr = cStr.replace(/[\s]*onblur[^=]*=/gi, " xonblur=");
        cStr = cStr.replace(/[\s]*onerror[^=]*=/gi, " xonerror=");
        cStr = cStr.replace(/[\s]*onload[^=]*=/gi, " xonload=");
        cStr = cStr.replace(/[\s]*href[^=]*=[\s]*["']?javascript/gi, " href=\"xjavascript");

        return cStr;
    }

    /**
     * 문자열을 반복하여 반환합니다.
     * @method String.times
     * @param {Number} count
     * @returns {String}
     * @example
     * ```js
     * "AXJ".times(3); ->  "AXJAXJAXJ"
     * ```
     */
    function times(count) {
        return count < 1 ? '' : new Array(count + 1).join(this);
    }

    function inspect(useDoubleQuotes) {
        var escapedString = this.replace(
            /[\x00-\x1f\\]/g,
            function (character) {
                try {
                    if (character in String.specialChar) return String.specialChar[character];
                } catch (e) {
                }
                if (character.charCodeAt() == 13) return "\\r";
                if (character.charCodeAt() == 10) return "\\n";
                return '\\u00' + character.charCodeAt()
            }
        );
        if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
        return "" + escapedString.replace(/'/g, '\\\'') + "";
    }

    function axtoJSON(TF) {
        return this.inspect(TF || false);
    }

    function blank() {
        return /^\s*$/.test(this);
    }

    function isJSON() {
        var str = this;
        if (str.isBlank()) return false;
        str = this.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, '');
        return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
    } //"
    function unfilterJSON(filter) {
        return this.replace(filter || AXUtil.JSONFilter, '$1');
    }

    function evalJSON(sanitize) {
        var json = this.unfilterJSON();
        try {
            var _evl = eval;
            if (!sanitize || json.isJSON()) return _evl("(" + json + ")");
            else return {error: "syntaxerr", result: "syntaxerr", msg: "JSON syntax error. fail to convert Object\n" + this};
            _evl = null;
        } catch (e) {
            return {
                error: e,
                result: "syntaxerr",
                msg: e,
                body: this
            };
        }
    }

    /**
     * queryString 형식의 문자열을 json object로 변환하여 줍니다.
     * @method String.queryToObject
     * @param {String} [separator=&]
     * @returns {Object}
     * @example
     * ```js
     * var myObject = "a=1&b=1".queryToObject();
     * trace(myObject);
     * // {"a":"1", "b":"1"}
     * ```
     */
    function queryToObject(separator) {
        var match = this.trim().match(/([^?#]*)(#.*)?$/);
        if (!match) return {};
        var rs = match[1].split(separator || '&');
        var returnObj = {};
        var i = 0;
        while (i < rs.length) {
            var pair = rs[i].split("=");
            var k = pair[0], v = pair[1];
            if (returnObj[k] != undefined) {
                if (!Object.isArray(returnObj[k])) returnObj[k] = [returnObj[k]];
                returnObj[k].push(v);
            }
            else {
                returnObj[k] = v;
            }
            i++;
        }
        return returnObj;
    }

    /**
     * queryString 형식의 문자열을 json object로 변환하여 줍니다. (파라미터 값은 URLDecode 합니다.)
     * @method String.queryToObjectDec
     * @param {String} [separator=&]
     * @returns {Object}
     * @example
     * ```js
     * var myObject = "a=1&b=1".queryToObject();
     * trace(myObject);
     * // {"a":"1", "b":"1"}
     * ```
     */
    function queryToObjectDec(separator) {
        var match = this.trim().match(/([^?#]*)(#.*)?$/);
        if (!match) return {};
        var rs = match[1].split(separator || '&');
        var returnObj = {};
        var i = 0;
        while (i < rs.length) {
            var pair = rs[i].split("=");
            var k = pair[0], v = pair[1];
            if (returnObj[k] != undefined) {
                if (!Object.isArray(returnObj[k])) returnObj[k] = [returnObj[k]];
                returnObj[k].push(v.dec());
            }
            else {
                returnObj[k] = v.dec();
            }
            i++;
        }
        return returnObj;
    }

    /**
     * 줄넘김 문자열 '\n'을 &gt;br/> 태그로 변환하여 줍니다.
     * @method String.crlf
     * @param {Regexp} [replaceTarget=/\n/g]
     * @param {String} [replacer=&gt;br/>]
     * @returns {String}
     * @example
     * ```js
     * "123
     * 123".crlf(); ->  "123<br/>123"
     * ```
     */
    function crlf(replaceTarget, replacer) {
        return this.replace((replaceTarget || /\n/g), (replacer || "<br/>"));
    }

    /**
     * 줄넘김 문자열 '%0A'을 &gt;br/> 태그로 변환하여 줍니다.
     * @method String.ecrlf
     * @param {Regexp} [replaceTarget=/%0A/g]
     * @param {String} [replacer=&gt;br/>]
     * @returns {String}
     * @example
     * ```js
     * "123%0A123".crlf(); ->  "123<br/>123"
     * ```
     */
    function ecrlf(replaceTarget, replacer) {
        return this.replace((replaceTarget || /%0A/g), (replacer || "<br/>"));
    }

    /**
     * 문자열 자리수를 맞추어 줍니다.
     * @method String.setDigit
     * @param {Number} length
     * @param {String} [padder=0]
     * @returns {String}
     * @example
     * ```js
     * "A".setDigit(3); ->  "00A"
     * "A".setDigit(3, '!'); ->  "!!A"
     * ```
     */
    function formatDigit(length, padder) {
        var string = this;
        return (padder || '0').times(length - string.length) + string;
    }

    /**
     * 파일경로에서 파일명을 반환합니다.
     * @method String.getFileName
     * @returns {String}
     * @example
     * ```js
     *"C://Works/AXISJ_project/css/myfile.zip".getFileName(); ->  "myfile.zip"
     * ```
     */
    function getFileName() {
        var sToMatch = this;
        var reAt = /[\/\\]?([^\/\\]?\.?[^\/\\]+)$/;
        var reArr = sToMatch.match(reAt);
        return RegExp.$1;
    }

    /**
     * Mozila 브라우저 등에서 사용하는 색상정보 값을 표준색상코드로 변환합니다. 표준색상코드를 입력하여도 표준색상코드 값을 얻을 수 있습니다.
     * @method String.toColor
     * @param {String} [prefix]
     * @returns {String}
     * @example
     * ```js
     * "rgb(243, 243, 243)".toColor(); ->  "f3f3f3"
     * "rgb(243, 243, 243)".toColor('#'); ->  "#f3f3f3"
     * "#f3f3f3".toColor(); ->  "f3f3f3"
     * "f3f3f3".toColor(); ->  "f3f3f3"
     * "f3f3f3".toColor('#'); ->  "#f3f3f3"
     * ```
     */
    function toColor(sharp) {
        var colorValue = "";
        if (this.left(3) == "rgb") {
            var val = this;
            var reAt = /rgb\((.+)\)/;
            val.match(reAt);
            var vals = RegExp.$1.split(", ");
            for (var a = 0; a < vals.length; a++) {
                vals[a] = vals[a].number().setDigit(2, '0', 16);
            }
            colorValue = vals.join("");
        }
        else {
            colorValue = this.replace("#", "");
        }
        var preFix = (sharp) ? "#" : "";
        return preFix + colorValue;
    }

    /**
     * 숫자형 문자열에 콤마를 삽입하여 통화단위로 반환합니다.
     * @method String.money
     * @returns {String}
     * @example
     * ```js
     * "1000000".money()
     * // "1,000,000"
     * ```
     */
    function toMoney() {
        return this.number().money();
    }

    function toByte() {
        return this.number().byte();
    }

    /**
     * 문자열을 소문자로 반환합니다.
     * @method String.lcase
     * @returns {String}
     * @example
     * ```js
     * "AXISJ".lcase() -> "axisj"
     * ```
     */
    function lcase() {
        return this.toLowerCase();
    }

    /**
     * 문자열을 대문자로 반환합니다.
     * @method String.ucase
     * @returns {String}
     * @example
     * ```
     * "axisj".ucase() -> "AXISJ"
     * ```
     */
    function ucase() {
        return this.toUpperCase();
    }

    /**
     * 문자열의 바이트 값을 계산하여 줍니다.
     * @method String.getByte
     * @returns {Number}
     * @example
     * ```
     * trace("장".getByte());
     * // 2
     * trace("a".getByte());
     * // 1
     * ```
     */
    function getByte() {
        var valueByte = this.length;
        for (i = 0, l = this.length; i < l; i++) if (this.charCodeAt(i) > 128) valueByte++;
        return valueByte;
    }

    /**
     * 문자열을 전화번호 형태로 반홥니다.
     * @method String.phone
     * @returns {String}
     * @example
     * ```js
     * trace("장".phone());
     * // 02
     * trace("a".phone());
     * // 02
     * trace("88819123".phone());
     * // 02-8881-9123
     * trace("01088819123".phone());
     * // 010-8881-9137
     * ```
     */
    function toPhoneString() {
        if (this == "") return this;
        var _this = this.replace(/\D+/g, "");
        var myLocalNums = "";
        var num1 = "", num2 = "";
        var localNum = "031/032/033/041/042/043/051/052/053/054/055/061/062/063/064/010/011/016/017/019/070/080/060";
        if (_this.left(2) == "02") {
            myLocalNums = "02";
        }
        else {
            var localNums = localNum.split(/\//g);
            var tempNum = _this.left(3);
            AXUtil.each(localNums, function () {
                if (this == tempNum) {
                    myLocalNums = this;
                    return false;
                }
            });
        }

        if (myLocalNums == "") {
            myLocalNums = "02";
            if (_this.length > 7) {
                num1 = _this.substr(0, 4);
                num2 = _this.substr(4);
            }
            else {
                num1 = _this.substr(0, 3);
                num2 = _this.substr(3);
            }
        }
        else {
            try {
                var snum = myLocalNums.length;
                if ((_this.length - snum) > 7) {
                    num1 = _this.substr(snum, 4);
                    num2 = _this.substr(snum + 4);
                }
                else {
                    num1 = _this.substr(snum, 3);
                    num2 = _this.substr(snum + 3);
                }
            } catch (e) {
                //trace(e);
            }
        }

        var returnString = myLocalNums;
        if (num1 != "") returnString += "-" + num1;
        if (num2 != "") returnString += "-" + num2;

        return returnString;

    }

    /**
     * anchor 데이터를 반환합니다.
     * @method String.getAnchorData
     * @returns {String}
     * @example
     * ```js
     * "http://jdoc.axisj.com/#{id:\"/API/Prototype/String/phone\"}".getAnchorData();
     * "{id:"/API/Prototype/String/phone"}"
     * ```
     */
    function getAnchorData() {
        var idx = this.indexOf("#", 0);
        if (idx < 0) return "";
        var cnt = this.length;
        var str = this.substring(idx + 1, cnt);
        return str;
    }

    function print() {
        return this;
    }

    return {
        ppassword: password,
        left: left,
        right: right,
        dec: dec,
        decode: dec,
        enc: enc,
        object: object,
        array: array,
        date: toDate,
        number: toNum,
        num: parseF,
        money: toMoney,
        byte: toByte,
        trim: strip,
        delHtml: stripTags,
        delScript: stripScript,
        removeScript: stripScript,
        times: times,
        inspect: inspect,
        axtoJSON: axtoJSON,
        isBlank: blank,
        isJSON: isJSON,
        unfilterJSON: unfilterJSON,
        evalJSON: evalJSON,
        queryToObject: queryToObject,
        queryToObjectDec: queryToObjectDec,
        crlf: crlf,
        ecrlf: ecrlf,
        setDigit: formatDigit,
        getFileName: getFileName,
        toColor: toColor,
        lcase: lcase,
        ucase: ucase,
        getByte: getByte,
        phone: toPhoneString,
        getAnchorData: getAnchorData,
        print: print
    }
})());

/**
 * Number.prototype
 * @namespace {Number} Number
 */
Object.extend(Number.prototype, (function () {
    /**
     * 숫자를 문자열로 변환하고 시작부터 지정한 글자수 만큼 반환합니다.
     * @method Number.left
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * (1234).left(3); -> "123"
     * ```
     */
    function left(strLen) {
        return this.toString().substr(0, strLen);
    }

    /**
     * 숫자를 문자열로 변환하고 마지막부터 지정한 글자수 만큼 반환합니다.
     * @method Number.right
     * @param {Number} strLen
     * @returns {String}
     * @example
     * ```js
     * 1234.right(3); -> 234
     * ```
     */
    function right(strLen) {
        return this.toString().substring(this.toString().length - strLen, this.toString().length);
    }

    /**
     * 통화표현 단위로 변환된 문자열을 반환합니다.
     * @method Number.money
     * @returns {String}
     * @example
     * ```js
     * trace((1234.9).money());
     * //1,234.9
     * trace((1234.1).money());
     * //1,234.1
     * trace((-1234.9).money());
     * //-1,234.9
     * trace((-1234.1).money());
     * //-1,234.1
     *
     * (12345678).money(); -> "12,345,678"
     * "12345678".money(); -> "12,345,678"
     * // String 에서도 money 메소드를 직접 사용 할 수 있습니다.
     * ```
     */
    function toMoney() {
        var txtNumber = '' + this;
        if (isNaN(txtNumber) || txtNumber == "") {
            return "";
        }
        else {
            var rxSplit = new RegExp('([0-9])([0-9][0-9][0-9][,.])');
            var arrNumber = txtNumber.split('.');
            arrNumber[0] += '.';
            do {
                arrNumber[0] = arrNumber[0].replace(rxSplit, '$1,$2');
            } while (rxSplit.test(arrNumber[0]));
            if (arrNumber.length > 1) {
                return arrNumber.join('');
            }
            else {
                return arrNumber[0].split('.')[0];
            }
        }
    }

    /**
     * 숫자값을 Byte로 인식하여 값에 크기에 따르 KB, MB, GB 의 형식으로 반환합니다.
     * @method Number.byte
     * @returns {String}
     * @example
     * ```js
     * trace((1234567890).byte());
     * // 1.1GB
     * trace((12345678).byte());
     * // 11.8MB
     * trace((123456).byte());
     * // 120.6KB
     * trace((123).byte());
     * // 0.1KB
     * ```
     */
    function toByte() {
        var n_unit = "KB";
        var myByte = this / 1024;
        if (myByte / 1024 > 1) {
            n_unit = "MB";
            myByte = myByte / 1024;
        }
        if (myByte / 1024 > 1) {
            n_unit = "GB";
            myByte = myByte / 1024;
        }
        return myByte.round(1) + n_unit;
    }

    /**
     * 자신을 반환합니다.
     * @method Number.number
     * @returns {Number}
     */
    function toNum() {
        return this;
    }

    /**
     * 원하는 횟수 만큼 자릿수 맞춤 문자열을 포함한 문자열을 반환합니다.
     * @method Number.setDigit
     * @param {Number} length - 자릿수
     * @param {String} padder - 자릿수 맞춤 문자열
     * @param {Number} radix - 진수
     * @returns {String}
     * @example
     * ```js
     * trace( (11).setDigit(3) );
     * //011
     * trace( (11).setDigit(3, '!') );
     * //!11
     * trace( (11).setDigit(3, 0, 16) );
     * //00b
     * trace( (25).setDigit(5, "X", 8) );
     * //XXX31
     * ```
     */
    function formatDigit(length, padder, radix) {
        var string = this.toString(radix || 10);
        return (padder || '0').times(length - string.length) + string;
    }

    /**
     * 인자값부터 원본까지 정수 단위로 이어진 배열을 리턴합니다.
     * @method Number.rangeFrom
     * @param {Number} start - 배열시작위치
     * @returns {Array}
     * @example
     * ```js
     * (3).rangeFrom(0);
     * [0, 1, 2, 3]
     * ```
     */
    function range(start) {
        var ra = [];
        for (var a = (start || 0); a < this + 1; a++) ra.push(a);
        return ra;
    }

    function axtoJSON() {
        return this;
    }

    /**
     * 절대값을 반환합니다.
     * @method Number.abs
     * @returns {Number}
     * @example
     * ```js
     * trace((1234).abs());
     * // 1234
     * trace((-1234).abs());
     * // 1234
     * trace((1234.123).abs());
     * // 1234.123
     * trace((-1234.123).abs());
     * // 1234.123
     * ```
     */
    function abs() {
        return Math.abs(this);
    }

    /**
     * 반올림 위치에서부터 반올림 한 값을 반환합니다.
     * @method Number.round
     * @param {Number} digit
     * @returns {Number}
     * @example
     * ```js
     * trace((1234.5678).round());
     * //1235
     * trace((1234.5678).round(1));
     * //1234.6
     * trace((1234.5678).round(2));
     * //1234.57
     * ```
     */
    function round(digit) {
        return (typeof digit == "undefined") ? Math.round(this) :
            (this.toString().search('e-')) ? this.toFixed(digit) : +(Math.round(this + "e+" + digit) + "e-" + digit);
    }

    /**
     * Math.ceil
     * @method Number.ceil
     * @returns {Number}
     */
    function ceil() {
        return Math.ceil(this);
    }

    /**
     * Math.floor
     * @method Number.floor
     * @returns {Number}
     */
    function floor() {
        return Math.floor(this);
    }

    /**
     * 숫자를 time값으로 이용하여 Date를 반환합니다.
     * @method Number.date
     * @returns {Date}
     * @example
     * ```js
     * var ndate = new Date();
     * ndate.getTime();
     * // 1417253161813
     * (1417253161813).date();
     * // Sat Nov 29 2014 18:26:01 GMT+0900 (KST)
     * ```
     */
    function date() {
        return new Date(this);
    }

    /**
     * 나누기 연산 결과를 반환합니다. divisor 가 0인 경우 연산 결과는 오류 없이 0을 반환합니다.
     * @method Number.div
     * @param {Number} divisor - 나눔수
     * @returns {Number}
     * @example
     * ```js
     * trace( (10).div(2); );
     * // 5
     * trace( (10).div(0); );
     * // 0
     * ```
     */
    function div(divisor) {
        if (divisor != 0) {
            return this / divisor;
        }
        else {
            return 0;
        }
    }

    function none() {
        return this;
    }

    function times(count) {
        return count < 1 ? '' : new Array(count + 1).join(this.toString());
    }

    /**
     * 숫자를 문자로 변환후 String.phone를 실행합니다.
     * @method Number.phone
     * @returns {String}
     */
    function phone() {
        var txtNumber = '' + this;
        return txtNumber.phone();
    }

    return {
        left: left,
        right: right,
        abs: abs,
        round: round,
        ceil: ceil,
        floor: floor,
        money: toMoney,
        byte: toByte,
        num: toNum,
        number: toNum,
        setDigit: formatDigit,
        date: date,
        div: div,
        dec: none,
        enc: none,
        rangeFrom: range,
        axtoJSON: axtoJSON,
        times: times,
        phone: phone
    }
})());

/**
 * Date.prototype
 * @namespace {Date} Date
 */
Object.extend(Date.prototype, (function () {
    /**
     * @method Data.add
     * @param {Number} daunum
     * @param {String} [interval=d] - y|m|d
     * @returns {Date}
     * @description 원본날짜에서 인자만큼 더해진 날짜 데이터를 반환합니다.
     * @example
     * ```js
     * var myDate = new Date();
     * trace(myDate.add(1));
     * // 내일값이 나옵니다.
     *
     * trace("2013-05-05".date().add(3));
     * // "2013-05-08T03:00:00Z"
     * trace("2013-05-05".date().add(2, 'm'));
     * //  "2013-07-05T03:00:00Z"
     * trace("2013-05-05".date().add(2, 'y'));
     * //  "2015-05-05T03:00:00Z"
     * ```
     */
    function dateAdd(daynum, interval) {
        interval = interval || "d";
        var interval = interval.toLowerCase();
        var DyMilli = ((1000 * 60) * 60) * 24;
        var aDate = new Date(this.getUTCFullYear(), this.getMonth(), this.getDate(), 12);

        if (interval == "d") {
            //trace(aDate.getTime(), (daynum) , (DyMilli));
            aDate.setTime(aDate.getTime() + (daynum * DyMilli));
        }
        else if (interval == "m") {
            var yy = aDate.getFullYear();
            var mm = aDate.getMonth();
            var dd = aDate.getDate();
            /*if (mm == 0 && dd == 1) yy += 1;*/
            yy = yy + parseInt(daynum / 12);
            mm += daynum % 12;
            var mxdd = AXUtil.dayLen(yy, mm);
            if (mxdd < dd) dd = mxdd;
            aDate = new Date(yy, mm, dd, 12);
        }
        else if (interval == "y") {
            aDate.setTime(aDate.getTime() + ((daynum * 365) * DyMilli));
        }
        else {
            aDate.setTime(aDate.getTime() + (daynum * DyMilli));
        }
        return aDate;
    }

    /**
     * @method Data.diff
     * @param {Date|String} edDate
     * @param {String} [type=d] - y|m|d
     * @returns {Number}
     * @description 날짜와 날짜 사이의 날짜 수를 반환합니다.
     * @example
     * ```js
     * trace( "2013-05-05".date().diff("2013-05-08") );
     * // 3
     * trace( "2013-05-05".date().diff("2013-05-08".date()) );
     * // 3
     * ```
     */
    function dayDiff(edDate, tp) {
        var DyMilli = ((1000 * 60) * 60) * 24;
        //trace(this.print() +"/"+ edDate.print() + "//" + ((edDate.date() - this) / DyMilli) + "//" + ((edDate.date() - this) / DyMilli).floor());
        var y1 = this.getFullYear();
        var m1 = this.getMonth();
        var d1 = this.getDate();
        var hh1 = this.getHours();
        var mm1 = this.getMinutes();
        var dd1 = new Date(y1, m1, d1, hh1, mm1, this.getSeconds());

        var day2 = edDate.date();
        var y2 = day2.getFullYear();
        var m2 = day2.getMonth();
        var d2 = day2.getDate();
        var hh2 = day2.getHours();
        var mm2 = day2.getMinutes();
        var dd2 = new Date(y2, m2, d2, hh2, mm2, this.getSeconds());

        if (tp != undefined) {
            if (tp == "D") {
                DyMilli = ((1000 * 60) * 60) * 24;
                dd2 = new Date(y2, m2, d2, hh1, mm1, this.getSeconds());
            }
            else if (tp == "H") {
                DyMilli = ((1000 * 60) * 60);
            }
            else if (tp == "mm") {
                DyMilli = (1000 * 60);
            }
            else {
                DyMilli = ((1000 * 60) * 60) * 24;
                dd2 = new Date(y2, m2, d2, hh1, mm1, this.getSeconds());
            }
        }

        return ((dd2.getTime() - dd1.getTime()) / DyMilli).floor();

    }

    /**
     * @method  Date.print
     * @param {String} [format=yyyy-mm-dd]
     * @returns {type} name
     * @description yyyy:년도, mm:월, dd:일, hh:시, mi:분, ss:초, dw:요일 을 조합하여 format으로 지정하면 그에 맞는 날짜형식 문자열이 반환됩니다.
     * @example
     * ```js
     * "2013-05-05".date().print(); -> "2013-05-05"
     * "2013-05-05".date().print('yyyy년 mm월 dd일'); -> "2013년 05월 05일"
     * "2013-05-05".date().print('yyyy년 mm월 dd일 (dw)'); -> "2013년 05월 05일 (일)"
     * ```
     */
    function toString(format) {
        if (format == undefined) {
            var sSeper = "-";
            return this.getUTCFullYear() + sSeper + (this.getMonth() + 1).setDigit(2) + sSeper + this.getDate().setDigit(2);
        }
        else {
            var fStr = format;
            var nY, nM, nD, nH, nMM, nS, nDW;
            nY = this.getUTCFullYear();
            nM = (this.getMonth() + 1).setDigit(2);
            nD = this.getDate().setDigit(2);
            nH = this.getHours().setDigit(2);
            nMM = this.getMinutes().setDigit(2);
            nS = this.getSeconds().setDigit(2);
            nDW = this.getDay();

            var yre = /[^y]*(yyyy)[^y]*/gi;
            yre.exec(fStr);
            var regY = RegExp.$1;
            var mre = /[^m]*(mm)[^m]*/gi;
            mre.exec(fStr);
            var regM = RegExp.$1;
            var dre = /[^d]*(dd)[^d]*/gi;
            dre.exec(fStr);
            var regD = RegExp.$1;
            var hre = /[^h]*(hh)[^h]*/gi;
            hre.exec(fStr);
            var regH = RegExp.$1;
            var mire = /[^m]*(mi)[^i]*/gi;
            mire.exec(fStr);
            var regMI = RegExp.$1;
            var sre = /[^s]*(ss)[^s]*/gi;
            sre.exec(fStr);
            var regS = RegExp.$1;
            var dwre = /[^d]*(dw)[^w]*/gi;
            dwre.exec(fStr);
            var regDW = RegExp.$1;

            if (regY === "yyyy") {
                fStr = fStr.replace(regY, nY.right(regY.length));
            }
            if (regM === "mm") {
                if (regM.length == 1) nM = (this.getMonth() + 1);
                fStr = fStr.replace(regM, nM);
            }
            if (regD === "dd") {
                if (regD.length == 1) nD = this.getDate();
                fStr = fStr.replace(regD, nD);
            }
            if (regH === "hh") {
                fStr = fStr.replace(regH, nH);
            }
            if (regMI === "mi") {
                fStr = fStr.replace(regMI, nMM);
            }
            if (regS === "ss") {
                fStr = fStr.replace(regS, nS);
            }
            if (regDW == "dw") {
                fStr = fStr.replace(regDW, AXConfig.weekDays[nDW].label);
            }
            return fStr;
        }
    }

    /**
     * @method  Date.getTimeAgo
     * @returns {String}
     * @description 현재와 날짜 데이터 간의 간격을 문자열로 반환합니다.
     * @example
     * ```js
     * var pDate = new Date();
     * pDate.setTime(pDate.getTime()-1000*60);
     * trace( pDate.getTimeAgo() );
     * // 1분 전
     *
     * pDate.setTime(pDate.getTime()-1000*60*5);
     * trace( pDate.getTimeAgo() );
     * //  6분 전
     *
     * pDate.setTime(pDate.getTime()-1000*60*60);
     * trace( pDate.getTimeAgo() );
     * //  1시간 6분 전
     *
     * pDate.setTime(pDate.getTime()-1000*60*60*24);
     * trace( pDate.getTimeAgo() );
     * //  2013년 11월 19일 화
     * ```
     */
    function getTimeAgo() {

        var rtnStr = "";
        var nMinute = Math.abs((new Date()).diff(this, "mm"));

        var wknames = [];
        wknames.push("일", "월", "화", "수", "목", "금", "토");

        if (isNaN(nMinute)) {
            rtnStr = "알수없음";
        }
        else {
            if (parseInt(nMinute / 60 / 24) >= 1) {
                rtnStr = this.print("yyyy년 mm월 dd일") + " " + wknames[this.getDay()];
            }
            else {
                rtnStr = nMinute;

                if ((nMinute / 60) > 1) {
                    rtnStr = parseInt(nMinute / 60) + "시간 " + (nMinute % 60) + "분 전";
                }
                else {
                    rtnStr = nMinute + "분 전";
                }
            }
        }
        return rtnStr;
    }

    function date() {
        return this;
    }

    function axtoJSON() {
        return '"' + this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).setDigit(2) + '-' + this.getUTCDate().setDigit(2) + 'T' + this.getUTCHours().setDigit(2) + ':' + this.getUTCMinutes().setDigit(2) + ':' + this.getUTCSeconds().setDigit(2) + 'Z"';
    }

    /**
     * @method  Date.axGetDay
     * @param {Number} [dayOfStart=0]
     * @returns {Number}
     * @description 요일의 시작인덱스를 변경한 요일인덱스를 반환합니다.
     */
    function axGetDay(dayOfStart) {
        if (dayOfStart == undefined) dayOfStart = 0;
        var myDay = this.getDay() - dayOfStart;
        if (myDay < 0) myDay = 7 + myDay;
        return myDay;
    }

    return {
        add: dateAdd,
        diff: dayDiff,
        print: toString,
        date: date,
        axtoJSON: axtoJSON,
        getTimeAgo: getTimeAgo,
        axGetDay: axGetDay
    }
})());

/**
 * Error.prototype
 * @namespace {Error} Error
 */
Object.extend(Error.prototype, (function () {
    /**
     * 에러넘버와 에러 객체를 리턴합니다.
     * @method Error.print
     * @returns {String}
     */
    function print() {
        return (this.number & 0xFFFF) + " : " + this;
    }

    return {
        print: print
    }
})());

/**
 * Array.prototype
 * @namespace {Array} Array
 */
Object.extend(Array.prototype, (function () {
    /**
     * @method Array.clear
     * @returns {Array}
     * @description Array를 빈 Array 로 변경합니다.
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a);
     * // [1, 2, 3]
     * trace(a.clear());
     * // []
     * trace(a);
     * // []
     * ```
     */
    function clear() {
        this.length = 0;
        return this;
    }

    /**
     * @method Array.first
     * @returns {Object}
     * @description Array의 첫번째 아이템을 반환합니다.
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a.first());
     * // 1
     *
     * var b = [{a:"액시스제이"}, 2, 3];
     * trace(b.first());
     * // {"a":"액시스제이"}
     *
     * var c = [[1,2,3], 2, 3];
     * trace(c.first());
     * // [1, 2, 3]
     * ```
     */
    function first() {
        return this[0];
    }

    /**
     * @method Array.last
     * @returns {Object}
     * @description Array의 마지막 아이템을 반환합니다.
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a.last());
     * // 1
     *
     * var b = [1, 2, {a:"액시스제이"}];
     * trace(b.last());
     * // {"a":"액시스제이"}
     *
     * var c = [1, 2, [1,2,3]];
     * trace(c.last());
     * // [1, 2, 3]
     * ```
     */
    function last() {
        return this[this.length - 1];
    }

    /**
     * 인자값에 해당하는 인덱스의 아이템을 반환합니다.
     * @method Array.getToSeq
     * @param {Number} seq
     * @returns {Object}
     * @example
     * ```js
     * var a = [1,2,3];
     * trace(a.getToSeq(1));
     * // 2
     *
     * var a = [1,{a:2},3];
     * trace(a.getToSeq(1));
     * // {"a":2}
     * ```
     */
    function getToSeq(seq) {
        if (seq > (this.length - 1)) {
            return null;
        }
        else {
            return this[seq];
        }
    }

    function axtoJSON(qoute) {
        var results = [];
        for (var i = 0; i < this.length; i++) results.push(Object.toJSON(this[i], qoute));
        return '[' + results.join(', ') + ']';
    }

    function toJSONforMobile() {
        var results = [];
        for (var i = 0; i < this.length; i++) results.push(Object.toJSONforMobile(this[i]));
        return '[' + results.join(', ') + ']';
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템을 제거한 Array 를 반환합니다.
     * @method Array.remove
     * @param {Function} callBack - remove 처리할 대상에 return true; 하면 true 인 대상이 제거 됩니다.
     * @returns {Array}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * a = a.remove(function(idx, item){
	 *     return (item == 3);
	 * });
     * trace(a);
     * // [1, 2, 4]
     *  * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * b = b.remove(function(){
	 *     return (this.item == 3 || this.index == 0);
	 * });
     * trace(b);
     * // [2, 4]
     * ```
     */
    function remove(callBack) {
        var _self = this;
        var collect = [];
        AXUtil.each(this, function (index, O) {
            if (!callBack.call({index: index, item: O}, index, O)) collect.push(O);
        });
        return collect;
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템 갯수를 반환합니다.
     * @method Array.search
     * @param {Function} callBack
     * @returns {Number}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * trace(a.search(function(idx, item){
	 *     return (item < 3);
	 * }));
     * // 2
     * ```
     */
    function search(callBack) {
        var _self = this;
        var collect = [];
        AXUtil.each(this, function (index, O) {
            if (callBack.call({index: index, item: O}, index, O)) collect.push(O);
        });
        return collect.length;
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템을 모두 반환합니다.
     * @method Array.searchObject
     * @param {Function} callBack
     * @returns {Array}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * trace(a.searchObject(function(idx, item){
	 *     return (item < 3);
	 * }));
     * // [1, 2]
     *
     * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * trace(b.searchObject(function(idx, item){
	 *     return (this.item < 3);
	 * }));
     * // [1, 2]
     * ```
     */
    function getObject(callBack) {
        var _self = this;
        var collect = [];
        AXUtil.each(this, function (index, O) {
            if (callBack.call({index: index, item: O}, index, O)) collect.push(O);
        });
        return collect;
    }

    /**
     * 사용자가 정의한 조건에 맞는 아이템을 한 개만 반환합니다.
     * @method Array.hasObject
     * @param {Function} callBack
     * @returns {Object}
     * @example
     * ```js
     * var a = [1,2,3,4];
     * trace(a);
     * // [1, 2, 3, 4]
     * trace(a.has(function(idx, item){
	 *     return (item == 3);
	 * }));
     * // 3
     *
     * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * trace(b.has(function(idx, item){
	 *     return (this.item == 3);
	 * }));
     * // 3
     * ```
     */
    function hasObject(callBack) {
        var _self = this;
        var collect = null;
        AXUtil.each(this, function (index, O) {
            if (callBack.call({index: index, item: O}, index, O)) {
                collect = O;
                return false;
            }
        });
        return collect;
    }

    /* 13-06-13 메소드 확장 */

    /**
     * Object Array의 키를 정렬한후 가장 작은 값을 반환합니다.
     * @method Array.getMinObject
     * @param {String} key
     * @returns {Object}
     * @example
     * ```js
     * var myArray = [{a:99},{a:2},{a:1}];
     * myArray.getMinObject("a");
     * // Object {a: 1}
     * ```
     */
    function getMinObject(key) {
        var tempArray = this.concat();
        tempArray = tempArray.sort(function (pItem, nItem) {
            var v1 = pItem[key];
            var v2 = nItem[key];
            if (v1 < v2) return -1;
            else if (v1 > v2) return 1;
            else if (v1 == v2) return 0;
        });
        return (tempArray.first() || {});
    }

    /**
     * Object Array의 키를 정렬한후 가장 큰 값을 반환합니다.
     * @method Array.getMaxObject
     * @param {String} key
     * @returns {Object}
     * @example
     * ```js
     * var myArray = [{a:2},{a:99},{a:1}];
     * myArray.getMaxObject("a");
     * // Object {a: 99}
     * ```
     */
    function getMaxObject(key) {
        var tempArray = this.concat();
        tempArray = tempArray.sort(function (pItem, nItem) {
            var v1 = pItem[key];
            var v2 = nItem[key];
            if (v1 < v2) return 1;
            else if (v1 > v2) return -1;
            else if (v1 == v2) return 0;
        });
        return (tempArray.first() || {});
    }

    function m_notall(context) {
        context = context || function (x) {
                return x;
            };
        var result = true;
        var i = 0;
        while (i < this.length) {
            result = !Boolean(context(this[i]));
            if (!result) break;
            i++;
        }
        return result;
    }

    function m_any(context) {
        context = context || function (x) {
                return x;
            };
        var result = false;
        var i = 0;
        while (i < this.length) {
            result = Boolean(context(this[i], i));
            if (result) break;
            i++;
        }
        return result;
    }

    function m_find(context) {
        context = context || function (x) {
                return false;
            };
        var myselect;
        var i = 0;
        while (i < this.length) {
            if (context(this[i], i)) {
                myselect = this[i];
                break;
            }
            i++;
        }
        return myselect;
    }

    function m_find2(context) {
        if (!Object.isFunction(context)) {
            findObj = context;
            context = function (x) {
                return (x == findObj);
            }
        }
        var myselect, myindex;
        var i = 0;
        while (i < this.length) {
            if (context(this[i], i)) {
                myselect = this[i];
                myindex = i;
                break;
            }
            i++;
        }
        return {obj: myselect, index: myindex};
    }

    function m_findAll(context) {
        context = context || function (x) {
                return false;
            };
        var myselect = [];
        ;
        var i = 0;
        while (i < this.length) {
            if (context(this[i], i)) myselect.push(this[i]);
            i++;
        }
        return myselect;
    }

    /**
     * 리스트형 데이터를 부모 참조키와 자식 참조키를 이용하여 트리형 데이터로 변환처리 합니다.
     * @method Array.convertTree
     * @param {String} parentKey
     * @param {String} childKey
     * @param {String} [hashDigit=3] - 트리의 주소값에 해당하는 hash 의 자릿수 단위 설정 (기본값 3)
     * @returns {Object}
     * @example
     * ```js
     * var a = [
     *     {pno:0, no:1, name:"장기영"},
     *     {pno:1, no:2, name:"장기영"},
     *     {pno:1, no:3, name:"장기영"},
     *     {pno:3, no:4, name:"장기영"},
     *     {pno:3, no:5, name:"장기영"},
     *     {pno:5, no:6, name:"장기영"},
     *     {pno:5, no:7, name:"장기영"}
     * ];
     *
     * var myTree = a.convertTree("pno", "no");
     * trace(myTree);
     * //[{"pno":0, "no":1, "name":"장기영", "subTree":[{"pno":1, "no":2, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000", "hash":"000_000_000"}, {"pno":1, "no":3, "name":"장기영", "__subTreeLength":2, "subTree":[{"pno":3, "no":4, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000_001", "hash":"000_000_001_000"}, {"pno":3, "no":5, "name":"장기영", "__subTreeLength":2, "subTree":[{"pno":5, "no":6, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000_001_001", "hash":"000_000_001_001_000"}, {"pno":5, "no":7, "name":"장기영", "__subTreeLength":0, "subTree":[], "pHash":"000_000_001_001", "hash":"000_000_001_001_001"}], "pHash":"000_000_001", "hash":"000_000_001_001"}], "pHash":"000_000", "hash":"000_000_001"}], "__subTreeLength":2, "pHash":"000", "hash":"000_000"}]
     * ```
     */
    function convertTree(parentKey, childKey, hashDigit) {
        var tree = [];
        var pointer = {};
        var seq = 0;
        var hashDigit = hashDigit || 3;
        for (var idx = 0; idx < this.length; idx++) {
            var L = this[idx];
            if (!L.isRoot) {
                pointer[L[childKey]] = idx;

                if (typeof L[parentKey] === "undefined" || L[parentKey] == "" || L[parentKey].number() == 0) {
                    L["subTree"] = [];
                    L.__subTreeLength = 0;
                    L["pHash"] = "0".setDigit(hashDigit);
                    L["hash"] = "0".setDigit(hashDigit) + "_" + seq.setDigit(hashDigit);
                    tree.push(AXUtil.copyObject(L));
                    seq++;
                }
                else {
                    L.__subTreeLength = 0;
                }
            }
        }

        for (var idx = 0; idx < this.length; idx++) {
            var L = this[idx];
            if (L["pHash"] == undefined && !L.isRoot) {
                var pItem = this[pointer[L[parentKey]]];
                var pHash = pItem["hash"];
                var pHashs = pHash.split(/_/g);
                var pTree = tree;
                var pTreeItem;
                axf.each(pHashs, function (idx, T) {
                    if (idx > 0) {
                        pTreeItem = pTree[T.number()];
                        pTree = pTree[T.number()].subTree;
                    }
                });
                L["subTree"] = [];
                var __subTreeLength = pItem.__subTreeLength;

                L["pHash"] = pHash;
                L["hash"] = pHash + "_" + __subTreeLength.setDigit(hashDigit);
                pTree.push(AXUtil.copyObject(L));
                pItem.__subTreeLength++;
                pTreeItem.__subTreeLength = pItem.__subTreeLength;
            }
        }
        return tree;
    }

    /**
     * 조건에 맞는 아이템을 index 값과 함께 반환합니다.
     * @method Array.getIndex
     * @param {Function} context
     * @returns {Object}
     * @example
     * ```js
     * var b = [1,2,3,4];
     * trace(b);
     * // [1, 2, 3, 4]
     * trace(b.getIndex(function(idx, item){
	 *     return (this.item >= 3);
	 * }));
     * //  {"item":3, "index":2}
     * ```
     */
    function getIndex(context) {
        if (!Object.isFunction(context)) {
            findObj = context;
            context = function (x) {
                return (x == findObj);
            }
        }
        var findObject, findIndex;
        var i = 0;
        while (i < this.length) {
            var sobj = {
                index: i,
                item: this[i]
            };
            if (context.call(sobj, sobj)) {
                findObject = this[i];
                findIndex = i;
                break;
            }
            i++;
        }
        return {item: findObject, index: findIndex};
    }

    return {
        clear: clear,
        first: first,
        last: last,
        getToSeq: getToSeq,
        axtoJSON: axtoJSON,
        toJSONforMobile: toJSONforMobile,
        remove: remove,
        search: search,
        has: hasObject,
        searchObject: getObject,
        getMinObject: getMinObject,
        getMaxObject: getMaxObject,

        not: m_notall,
        or: m_any,
        get: m_find,
        gets: m_findAll,
        getObj: m_find2,
        getIndex: getIndex,
        convertTree: convertTree
    }
})());

//JSON.stringify = Object.toJSON;
function AXgetId(id) {
    return document.getElementById(id);
}
function AX_A(iterable) {
    if (!iterable) return [];
    if ('toArray' in Object(iterable)) return iterable.toArray();
    var length = iterable.length || 0, results = new Array(length);
    while (length--) results[length] = iterable[length];
    return results;
}

var trace = axf.console;
var getUrlInfo = axf.getUrlInfo;
/* ---------------------------- */
/**
 * AXJ UI 클래스 기본형
 * @class AXJ
 */
var AXJ = Class.create({
    /**
     * @member AXJ.config
     * @description UI클래스 설정 변수
     */
    initialize: function () {
        this.config = {
            debugMode: false,
            hashSpliter: "_",
            href: ((typeof AXConfig.anchorHref === "undefined") ? "href=\"javascript:;\"" : AXConfig.anchorHref)
        };
    },
    init: function () {
        trace(Object.toJSON(this.config));
    },
    echo: function (msg, mtype) {
        if (mtype == undefined || mtype == "console")
            trace(msg);
        else if (mtype == "alert")
            AXUtil.alert(msg);
        else if (mtype == "toast")
            toast.push(msg);
        else if (mtype == "dialog")
            dialog.push(msg);
    },
    /**
     * @method AXJ.setConfig
     * @param {Object} configs - 속성오브젝트
     * @returns {AXJ}
     * @description UI 클래스의 속성을 정의 또는 재정의 하고 클래스내부에 init 메소드를 호출합니다.
     * @example
     ```js
     myClass.setConfig({
	a:1, b:2, c:function(){}
});
     ```
     */
    setConfig: function (configs) {
        // overwrite this.config
        if (configs) {
            for (k in configs) {
                if (configs.hasOwnProperty(k)) this.config[k] = configs[k];
            }
        }
        // configs에 targetID가 없고 target만 지정한 경우 targetID 자동생성
        if (this.config.target) if (this.config.target.id === undefined || this.config.target.id == "") axdom(this.config.target).attr("id", this.config.target.id = this.config.targetID = "AXJUnique_" + axf.getUniqueId());
        this.init();
        return this;
    },
    /**
     * @method AXJ.changeConfig
     * @param {Object} configs - 속성오브젝트
     * @returns {AXJ}
     * @description UI 클래스의 속성을 변경 합니다.
     * @example
     ```js
     myClass.changeConfig({
	a:1
});
     ```
     */
    changeConfig: function (configs) {
        if (configs) {
            for (k in configs) {
                if (configs.hasOwnProperty(k)) this.config[k] = configs[k];
            }
        }
        return this;
    },
    /**
     * @method AXJ.getEventTarget
     * @param {Object} args - 설명
     * @returns {Null}
     * @description 설명
     * @example
     ```js
     var myTarget = this.getEventTarget({
    evt : event.target,
	until:function(evt, evtIDs){
		// 선택 조건
		// event bubble 탐색 종료 시점 정의 함수 argument 로 받은 eventTarget 과 evtIDs 객체로 부터 다양한 조건으로 설정가능
		// return true; 하면 버블 탐색 종료 됨.
		// return ( axdom(evt.parentNode).hasClass("CTclassName") );
		return (evt.parentNode.tagName == "body");
	},
	find:function(evt, evtIDs){
		// return true; 하면 버블탐색 종료 후 현재 eventTarget 리턴
		//return ( axdom(evt).hasClass("colHeadTd") );
		return ( evt.id == objID || (evtIDs[0] == cfg.targetID && evtIDs[1] == objID) );
	}
});

     if(myTarget){
	//something
}
     ```
     */
    getEventTarget: function (args) {
        var eventTarget = args.evt;
        var eid = (eventTarget && eventTarget.id && eventTarget.id != "") ? eventTarget.id.split(/_AX_/g) : [];
        if (eventTarget) {
            while (!args.find(eventTarget, eid)) {
                if (!eventTarget.parentNode) {
                    eventTarget = null;
                    break;
                }
                if (args.until) {
                    if (args.until(eventTarget, eid)) {
                        eventTarget = null;
                        break;
                    }
                }
                if (eventTarget.parentNode) {
                    eventTarget = eventTarget.parentNode;
                    try {
                        eid = (eventTarget && eventTarget.id && eventTarget.id != "") ? eventTarget.id.split(/_AX_/g) : [];
                    } catch (e) {
                        eid = [];
                    }
                } else {
                    break;
                }
            }
        }
        return eventTarget;
    },
    /**
     * @method AXJ.getMousePositon
     * @param {eventObject} event
     * @returns {Object} css - pageX, pageY
     * @description 스크롤된 페이지에서 이벤트의 마우스 x,y 페이지포지션을 구해줍니다.
     */
    getMousePositon: function (event) {
        var eventDoc, doc, body;
        eventDoc = document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;
        var css = {};

        //trace({ cy: event.clientY, st: (doc && doc.scrollTop || body && body.scrollTop || 0), ct: (doc && doc.clientTop || body && body.clientTop || 0) });
        css.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        css.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        return css;
    },
    /**
     * @method AXJ.stopEvent
     * @param {eventObject} event - 이벤트
     * @description 이벤트 버블링을 중지 합니다.
     * @example
     ```js
     var _this = this;
     axdom("#" + elementID).on("mousedown", function(event){
	_this.stopEvent();
});
     ```
     */
    stopEvent: function (event) {
        try {
            if (event.preventDefault) event.preventDefault();
            if (event.stopPropagation) event.stopPropagation();
            event.cancelBubble = true;
        } catch (e) {

        }
        return false;
    },
    /**
     * @method AXJ.clearRange
     * @returns {AXJ}
     * @description 현재 페이지의 모든 사용자 선택을 취소 합니다.
     * @example
     ```js
     this.clearRange();
     ```
     */
    clearRange: function () {
        if (window.getSelection) {
            if (window.getSelection().empty) {  // Chrome
                window.getSelection().empty();
            } else if (window.getSelection().removeAllRanges) {  // Firefox
                window.getSelection().removeAllRanges();
            }
        } else if (document.selection) {  // IE?
            document.selection.empty();
        }
        return this;
    },
    /**
     * @method AXJ.windowResize
     * @description windowResizeApply메소드 호출을 연속으로 수행되지 않도록 하는 보호장치
     * @example
     ```js
     var _this = this;
     $(window).resize(function(){
   _this.windowResize();
 });
     // 결과적으로 windowResizeApply가 호출됩니다.
     ```
     */
    windowResize: function () {
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 1);
    },
    windowResizeApply: function () {

    }
});

/**
 * @namespace {jQueryObject} jQueryExtends
 */

// -- AXReq ----------------------------------------------
/**
 * @class AXReqQue
 * @version v1.4
 * @author tom@axisj.com
 * @logs
 * 2012-09-28 오후 2:58:32 - 시작
 * 2014-04-10 - tom : onbeforesend 옵션 추가 return false 하면 호출 제어됨.
 * 2014-10-06 - tom : dataSendMethod bug fix.
 * 2014-12-31 - tom : AXConfig.AXReq.pars 확장
 * 2015-03-19 - tom : AXConfig.AXReq.dataSendMethod = "json|query-json|parameter" 옵션을 수용하도록 변경 *
 */
var AXReqQue = Class.create({
    /**
     * AJAX호출 큐
     * @member {Array} AXReqQue.que
     */
    /**
     * AJAX호출 진행상태
     * @member {Boolean} AXReqQue.busy
     */
    initialize: function () {
        this.que = [];
        this.busy = false;
    },
    /**
     * @method AXReqQue.add
     * @param {Object} obj - ajax config
     * @returns {AXReqQue}
     * @description que.push
     */
    add: function (obj) {
        this.que.push(obj);
        try {
            this.start();
        } catch (e) {

        }
        return this;
    },
    /**
     * @method AXReqQue.start
     * @description que에 담긴 AJAX호출을 처리합니다.
     */
    start: function () {
        if (this.que.length == 0) return;
        if (this.busy) return;

        this.busy = true;
        var myQue = this.que.first();
        var _self = this;
        var config = {
            type: "post",
            onsucc: "",
            async: AXConfig.AXReq.async,
            responseType: AXConfig.AXReq.responseType,
            dataType: AXConfig.AXReq.dataType,
            contentType: AXConfig.AXReq.contentType,
            debug: false
        };
        axf.each(myQue.configs, function (k, v) { // update to {this.config}
            if (k == "pars") {

            }
            else {
                config[k] = v;
            }
        });

        var onerr = this.onerror.bind(this);
        var ontimeout = this.ontimeout.bind(this);
        var onsucc = this.onsucc.bind(this);
        var dataSendMethod = (myQue.configs.dataSendMethod || AXConfig.AXReq.dataSendMethod || "");
        if (dataSendMethod != "json") {

        } else {
            if (typeof myQue.configs.pars == "object") {
                myQue.configs.pars.dummy = AXUtil.timekey();
            } else if (typeof myQue.configs.pars == "string") {
                if (myQue.configs.pars == "") myQue.configs.pars += "dummy=" + AXUtil.timekey();
                else myQue.configs.pars += "&dummy=" + AXUtil.timekey();
            }
        }

        if (config.debug) trace({url: myQue.url, pars: myQue.configs.pars});

        var ajaxOption = {}, pars;
        axf.each(config, function (k, v) { // update to {this.config}
            ajaxOption[k] = v;
        });
        ajaxOption.url = myQue.url;
        pars = myQue.configs.pars;
        if (dataSendMethod != "DTO" && AXConfig.AXReq.pars) {
            if (typeof pars == "object") {
                if (typeof AXConfig.AXReq.pars == "object") {
                    pars = jQuery.extend(pars, AXConfig.AXReq.pars);
                } else if (typeof AXConfig.AXReq.pars == "string") {
                    pars = jQuery.extend(pars, AXConfig.AXReq.pars.queryToObject());
                }
            } else if (typeof pars == "string") {
                if (typeof AXConfig.AXReq.pars == "object") {
                    pars += "&" + jQuery.param(AXConfig.AXReq.pars);
                } else if (typeof AXConfig.AXReq.pars == "string") {
                    pars += "&" + AXConfig.AXReq.pars;
                }
            }
        }

        if (dataSendMethod == "json") {
            ajaxOption["data"] = Object.toJSON(((typeof pars == "string") ? pars.queryToObject() : pars ));
        } else if (dataSendMethod == "query-json") {
            ajaxOption["data"] = "{queryString:\"" + pars + "\"}";
        } else {
            ajaxOption["data"] = pars;
        }

        ajaxOption.success = onsucc;
        ajaxOption.error = onerr;
        ajaxOption.timeout = ontimeout;

        if (myQue.configs.onbeforesend) {
            if (!myQue.configs.onbeforesend.call(ajaxOption)) {
                return false;
            }
        }

        this.que[0]._jQueryAjax = axdom.ajax(ajaxOption);
    },
    onsucc: function (req) {
        if (req != undefined) {
            var myQue = this.que.first(), res;

            try {
                if (myQue.configs.debug) trace("onsucc" + req);

                if (myQue.configs.responseType == "text/html") {
                    res = req;
                } else {
                    if ((typeof req) == "string") {
                        res = req.object();
                    } else {
                        res = AXConfig.AXReq.resultFormatter.call(req);
                    }
                }

                if (res.result == "syntaxerr") {
                    if (myQue.configs.onerr) myQue.configs.onerr(res);
                } else {
                    if (myQue.configs.onsucc) myQue.configs.onsucc(res);
                }
            } catch (e) {
                if (myQue.configs.responseType == "text/html") {

                } else {
                    res.e = e;
                }
                if (myQue.configs.onerr) myQue.configs.onerr(res);
            }

            this.que.shift();
            this.busy = false;
            this.start();
        }
    },
    onerror: function (req) {
        var myQue = this.que.first();
        if (myQue.configs.onerr) myQue.configs.onerr(req);
        else trace("error : " + Object.toJSON(req));

        this.que.shift();
        this.busy = false;
        try {
            mask.close();
        } catch (e) {
        }
    },
    ontimeout: function (req) {
        trace("onTimeout:" + req.responseText);
        this.que.shift();
        this.busy = false;
        try {
            mask.close();
        } catch (e) {
        }
    },
    /**
     * @method AXReqQue.abort
     * @returns {AXReqQue} AXReqQue
     * @description 설명
     * @example
     ```js
     // AXCore.js파일 에서 미리선언된 AXReqQue의 인스턴스 myAXreqQue를 이용하여 abort 명령을 내릴수 있습니다.
     myAXreqQue.abort();
     // 또는
     AXReqAbort();
     // 현재 진행중인 AJAX호출을 취소시켜줍니다.
     ```
     */
    abort: function () {
        try {
            this.que[0]._jQueryAjax.abort();
        } catch (e) {

        }
        return this;
    }
});
var myAXreqQue = new AXReqQue();
var AXReqAbort = function () {
    myAXreqQue.abort();
};

/**
 * @class AXReq
 * @param {String} url - 비동기 호출 URL
 * @param {Object} config - 비동기 호출 설정
 * @description AJAX 호출구문을 AXReqQue 에 add 하여 비동기 호출합니다.
 * @example
 ```
 var url = "";
 var pars = "";
 new AXReq(url, {
	debug: [true|false] default false,
	type: ["GET"|"POST"|"PUT"|"DELETE"|String] default "POST",
	contentType: [AJAX content type] optional,
	responseType: [AJAX response type] optional,
	dataType: [Ajax data type] optional,
	headers: [AJAX headers] optional,
	pars: [parameter|Object],
	onsucc: [Function],
	onerr: [Function] optional
});
 ```
 */
var AXReq = Class.create({
    initialize: function (url, configs) {
        myAXreqQue.add({url: url, configs: configs});
    }
});
/* ---------------------------------------------- AXReq -- */

/* -- AXMask ---------------------------------------------- */
/**
 * @class AXMask
 * @version v1.4
 * @author tom@axisj.com
 * @logs
 * 2012-09-28 오후 2:58:32 - 시작
 * append 메소드 추가
 * 2014-09-17 hyunjun19 : 지정한 대상의 영역만 masking 하도록 style 추가
 * 2015-04-19 tom : body.data에 마스크상태값 저장
 * 2015-05-16 tom : mask.close(delay) 중 open 되면 예외처리, open상태에서 다시 open 도 예외처리
 * @description 웹페이지 전체에 사용자 입력을 막기위한 마스크를 추가하는데 사용
 * ```js
 mask.open();
 ```
 *
 */
var AXMask = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.selects = [];
        this.config.maskClassName = "AXMask";
        this.config.maskContentClassName = "AXMaskContent";
        this.config.content = "disable content";
        this.config.maskZindex = "5000";
        this.blinkTrack = [];
    },
    init: function () {
        this.mask = axdom("<div class=\"" + this.config.maskClassName + "\" style=\"z_index:" + this.config.maskZindex + "\"></div>");
    },
    open: function (configs) {
        if (this.maskDelay) clearTimeout(this.maskDelay);
        if (axdom(document.body).data("masked") != "true") {
            axdom(document.body).append(this.mask);
            axdom(document.body).data("masked", "true");
            var bodyHeight = 0;
            (AXUtil.docTD == "Q") ? bodyHeight = document.body.clientHeight : bodyHeight = document.documentElement.clientHeight;

            if (configs) {
                if (!configs.onclick) configs.onclick = configs.onClick;
                if (configs.onclick) {
                    this.mask.bind("click.AXMask", configs.onclick);
                }
            }
        }
    },
    append: function (targetID, configs) {
        var target = axdom("#" + targetID);
        if (target.css("position") == "static") {
            target.css("position", "relative")
        }
        target.append(this.mask.css({'position': 'absolute', 'top': 0, 'left': 0}));

        if (configs) {
            if (!configs.onclick) configs.onclick = configs.onClick;
            if (configs.onclick) {
                this.mask.bind("click.AXMask", configs.onclick);
            }
        }
    },
    close: function (delay) {
        if (!delay) {
            this.mask.unbind("click.AXMask");
            this.mask.remove();
            axdom(document.body).data("masked", null);
        } else {
            var maskHide = this.hide.bind(this);
            if (this.maskDelay) clearTimeout(this.maskDelay);
            this.maskDelay = setTimeout(maskHide, delay);
        }
        this.blinkTrack.clear();
    },
    hide: function () {
        this.mask.unbind("click.AXMask");
        this.mask.remove();
        axdom(document.body).data("masked", null);
        this.blinkTrack.clear();
    },
    setCSS: function (CSS) {
        this.mask.css(CSS);
    },
    addClass: function (className) {
        this.mask.addClass(className);
    },
    removeClass: function (className) {
        this.mask.removeClass(className);
    },
    blink: function (obj) {
        this.blinkTrack = [{css: {opacity: 0.1}, time: 1000}, {css: {opacity: 0.8}, time: 1000}];
        if (obj) this.blinkTrack = obj;
        this.blinking(0);
    },
    stopBlink: function (obj) {
        this.blinkTrack.clear();
    },
    blinking: function (blinkIndex) {
        if (this.blinkTrack.length > 0) {
            var blinkTrack = this.blinkTrack;
            var onblink = this.blinking.bind(this);
            this.mask.animate(blinkTrack[blinkIndex].css, blinkTrack[blinkIndex].time, 'circInOut', function () {
                onblink((blinkIndex + 1) % blinkTrack.length);
            });
        }
    },
    setContent: function (content) {
        var po = [];
        if (Object.isString(content)) {
            po.push(content);
        } else {
            var po = [];
            po.push("<div style='width: " + content.width + "px;height:" + content.height + "px;position: absolute;left:50%;top:50%;text-align: center;margin-left: -" + (content.width / 2) + "px;margin-top:-" + (content.height / 2) + "px;'>");
            po.push(content.html);
            po.push("</div>")
        }
        this.mask.html(po.join(''));
    }
});
var mask = new AXMask();
mask.setConfig();

/**
 * @method AXMask.open
 * @param {Object} config - 설명
 * @returns {Null}
 * @description 설명
 * @example
 ```
 mask.open({onclick:function(){
    // mask click event
 });
 mask.open();
```
 */


/**
 * @method jQueryExtends.mask
 * @param {Object} config - 설명
 * @returns {jQueryObject}
 * @description mask 삽입위치를 엘리먼트 다음의 위치로 합니다.
 * @example
 ```
 $("#target").mask();
 $("#target").mask({
    onclick: function(){
        // mask click event
    }
 });
 ```
 */
axdom.fn.mask = function (configs) {
    axf.each(this, function () {
        mask.append(this.id, configs);
    });
    return this;
};

/* ---------------------------------------------- AXMask -- */

/* -- AXNotification ---------------------------------------------- */
/**
 * AXNotification
 * @class AXNotification
 * @extends AXJ
 * @version v1.7
 * @author tom@axisj.com
 * @logs
 "2012-10-30 오후 12:01:10",
 "2013-01-09 오후 1:46:55 push type bug fix - tom"
 "2014-05-23 tom : dialog 에서 mask 제어 안하도록 변경"
 "2014-05-26 tom : dialog 에서 top 속성 설정 추가"
 "2014-08-16 tom : dialog body에서 \n -> <br/> auto replace "
 "2014-08-25 tom : dialog body에서 \n -> <br/> auto replace 예외처리 "
 "2015-01-12 tom : ie7,8 fadeOut error fix https://github.com/axisj-com/axisj/issues/386"
 "2015-01-19 tom : https://github.com/axisj-com/axisj/issues/392 dialog에 onConfirm 추가"
 "2015-04-14 tom : https://github.com/axisj-com/axisj/issues/532 dialog에 onclose 추가"
 */
var AXNotification = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.Observer = null;
        this.lasBreadSeq = 0;
        this.bread = [];
        this.config.easing = {open: {duration: 300, easing: "expoOut"}, close: {duration: 500, easing: "expoOut"}};
        this.config.eatUpTime = 2500;
        this.config.confirmStr = "확인";
        this.config.cancelStr = "취소";
    },
    init: function () {
        var config = this.config;
        if (config.type == "toast") {
            this.toastTray = axdom("<div class=\"AXNotificationTray\" id=\"" + config.targetID + "\"></div>");
        } else if (config.type == "dialog") {
            this.dialogTray = axdom("<div class=\"AXNotificationTrayDialog\" id=\"" + config.targetID + "\"></div>");
            //dialog type display center;
        }
    },
    push: function (obj) {
        var config = this.config;
        var breadID = config.targetID + "" + this.lasBreadSeq;
        this.lasBreadSeq++;

        var po = [];
        if ((typeof obj).toLowerCase() != "object") {
            po.push("<div class=\"AXNotification\" id=\"bread_AX_" + breadID + "\" style=\"display:none;\">");
            if (config.type == "dialog") {
                po.push("<div class=\"AXNotificationHead\">" + (obj.title || "Dialog Message") + "</div>");
            }
            po.push("<div class=\"AXNotificationCT\">");
            po.push("	<table cellpadding=\"0\" cellspacing=\"0\" class=\"AXNotificationTable\">");
            po.push("		<tbody>");
            po.push("			<tr>");
            po.push("				<td class=\"AXNotificationIcon\"></td>");
            po.push("				<td class=\"AXNotificationBody\">");
            if (Object.isString(obj)) {
                po.push(obj.crlf());
            } else {
                po.push(obj);
            }
            po.push("				</td>");
            po.push("			</tr>");
            po.push("		</tbody>");
            po.push("	</table>");

            if (config.type == "dialog") {
                po.push("	<div class=\"AXNotificationButtons\">");
                po.push("	<input type=\"button\" value=\"" + config.confirmStr + "\" class=\"AXButton Red\" data-bread-id=\"" + breadID + "\" id=\"bread_AX_" + breadID + "_AX_confirm\" />");
                po.push("	</div>");
            }

            po.push("</div>");
            po.push("</div>");

        } 
        else {
            po.push("<div class=\"AXNotification " + obj.type + "\" id=\"bread_AX_" + breadID + "\" style=\"display:none;\">");
            if (config.type == "dialog") {
                po.push("<div class=\"AXNotificationHead\">" + (obj.title || "Dialog Message") + "</div>");
            }
            po.push("<div class=\"AXNotificationCT\">");
            po.push("	<table cellpadding=\"0\" cellspacing=\"0\" class=\"AXNotificationTable\">");
            po.push("		<tbody>");
            po.push("			<tr>");
            po.push("				<td class=\"AXNotificationIcon\"></td>");
            po.push("				<td class=\"AXNotificationBody\">");
            if (Object.isString(obj.body)) {
                po.push(obj.body.crlf());
            } else {
                po.push(obj.body);
            }
            po.push("				</td>");
            if (obj.type == "Caution" && config.type != "dialog") {
                if (!obj.buttons) {
                    po.push("				<td class=\"AXNotificationButton\" align=\"right\">");
                    po.push("				<input type=\"button\" value=\"" + config.confirmStr + "\" class=\"AXButton Red\" data-bread-id=\"" + breadID + "\" id=\"bread_AX_" + breadID + "_AX_confirm\" />");
                    po.push("				</td>");
                }
            }
            po.push("			</tr>");
            po.push("		</tbody>");
            po.push("	</table>");
            if (obj.buttons) {
                po.push("	<div class=\"AXNotificationButtons\">");
                AXUtil.each(obj.buttons, function (index, B) {
                    po.push("	<input type=\"button\" value=\"" + this.buttonValue + "\" class=\"AXButton " + (this.buttonClass || "") + "\" data-bread-id=\"" + breadID + "\" id=\"bread_AX_" + breadID + "_AX_buttons_AX_" + index + "\" />");
                });
                po.push("	</div>");
            } else if (config.type == "dialog") {
                po.push("	<div class=\"AXNotificationButtons\">");
                po.push("	<input type=\"button\" value=\"" + config.confirmStr + "\" class=\"AXButton Red\" data-bread-id=\"" + breadID + "\" id=\"bread_AX_" + breadID + "_AX_confirm\" />");
                po.push("	</div>");
            }
            po.push("</div>");
            po.push("</div>");

        }

        if (config.type == "toast") {
            
            if (!AXgetId(config.targetID)) axdom(document.body).append(this.toastTray);
            this.bread.push({breadID: breadID, type: obj.type, html: po.join('').enc()});
            this.insertBread(obj);
            
        }
        else if (config.type == "dialog") {
            
            if (!AXgetId(config.targetID)) axdom(document.body).append(this.dialogTray);
            this.dialogTray.prepend(po.join(''));

            var bodyWidth = (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
            //var l = bodyWidth / 2 - this.dialogTray.width() / 2;
            if (obj.top != undefined) {
                this.dialogTray.css({paddingTop: obj.top});
            } else {
                this.dialogTray.css({paddingTop: 50});
            }

            var breadBox = axdom("#bread_AX_" + breadID);
            breadBox.fadeIn();

            var endCheck = this.endCheck.bind(this);

            //Confirm button
            axdom("#bread_AX_" + breadID + "_AX_confirm").bind("click", function () {
                if (obj.onConfirm) obj.onConfirm(obj.data);
                breadBox.find("button, input").hide();
                breadBox.fadeOut({
                    duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                        breadBox.remove();
                        endCheck();
                    }
                });
            });

            //AXBUTTON
            axdom(".AXNotificationButtons").find(".AXButton").bind("click", function (event) {
                var eid = event.target.id.split(/_AX_/g);
                var myBreadID = eid[1];
                var buttonSeq = eid.last(), breadBox = axdom("#bread_AX_" + myBreadID);
                if (obj.buttons) {
                    if (obj.buttons[buttonSeq]) {
                        if (obj.buttons[buttonSeq].onClick) obj.buttons[buttonSeq].onClick(obj.buttons[buttonSeq].data);
                    }
                }
                breadBox.find("button, input").hide();
                breadBox.fadeOut({
                    duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                        breadBox.remove();
                        endCheck();
                    }
                });
            });

            axdom(".AXNotificationButtons").find(".AXButton").get(0).focus();

            axdom(document.body).unbind("keyup." + breadID).bind("keyup." + breadID, function (event) {
                if (event.keyCode == AXUtil.Event.KEY_ESC) {
                    axdom("#bread_AX_" + breadID).fadeOut({
                        duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                            axdom("#bread_AX_" + breadID).remove();
                            endCheck(breadID, obj);
                        }
                    });
                }
            });
        }
    },
    insertBread: function (obj) {
        var _this = this;
        var config = this.config;
        if (this.bread.length == 0) {
            return;
        }
        if (this.busy) return;
        this.busy = true;

        var nextBread = this.nextBread.bind(this);
        var endCheck = this.endCheck.bind(this);

        var myQue = this.bread[0];
        axdom("#" + config.targetID).prepend(myQue.html.decode());

        axdom("#bread_AX_" + myQue.breadID + "_AX_confirm").bind("click", function (e) {
            if (obj.onConfirm) obj.onConfirm(obj.data);
            var breadBox = axdom("#bread_AX_" + myQue.breadID);
            breadBox.find("button, input").hide();
            breadBox.fadeOut({
                duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                    breadBox.remove();
                    endCheck();
                }
            });
        });

        var $bread = axdom("#bread_AX_" + myQue.breadID);
        $bread.slideDown({
            duration: config.easing.open.duration, easing: config.easing.open.easing, complete: function () {
                nextBread();
                if (myQue.type != "Caution") {
                    setTimeout(function () {
                        $bread.fadeOut({
                            duration: config.easing.close.duration, easing: config.easing.close.easing, complete: function () {
                                $bread.remove();
                                endCheck();
                            }
                        });
                    }, config.eatUpTime);
                }
            }
        });
    },
    nextBread: function () {
        this.bread.shift();
        this.busy = false;
        this.insertBread();
    },
    endCheck: function (breadID, obj) {
        if (axdom("#" + this.config.targetID).html() == "") {
            this.lasBreadSeq = 0;
            if (this.config.type == "dialog") {
                this.dialogTray.remove();
                if (breadID) {
                    axdom(document.body).unbind("keyup." + breadID);
                    if (obj && obj.onclose) obj.onclose.call(obj, obj);
                }
            }
        }
    }
});

/**
 * @method AXNotification.push
 * @param {Object|String} content - 대상물 문자열 혹은 오브젝트로 구성
 * @description notification은 dialog, toast 2가지 형태가 존재하고 각각 push 메소드를 이용하여 출력한다.
 * @example
 ```
 //toast
 toast.push('<b>Complete</b>\n Complete messange send !!');
 toast.push({body:'<b>Warning</b> Warning messange send !!', type:'Warning'});
 toast.push({body:'<b>Caution</b> Caution messange send !!', type:'Caution'});

 //dialog
 dialog.push('<b>Alert</b>\n Application Call dialog push');
 dialog.push({body:'<b>Warning</b> Application Call dialog push', type:'Warning'});
 dialog.push({body:'<b>Caution</b> Application Call dialog push', type:'Caution', onConfirm:fnObj.btnOnConfirm, data:'onConfirmData'});
 dialog.push({
	body:'<b>Caution</b> Application Call dialog push', top:0, type:'Caution', buttons:[
	    {buttonValue:'button1', buttonClass:'Red W100', onClick:fnObj.btnClick, data:'data1'},
	    {buttonValue:'button2', buttonClass:'Blue', onClick:fnObj.btnClick, data:'data2'},
	    {buttonValue:'button3', buttonClass:'Green', onClick:fnObj.btnClick, data:'data3'}
	]
 });
 ```
 */
var toast = new AXNotification();
toast.setConfig({targetID: "basicToast", type: "toast"});

var dialog = new AXNotification();
dialog.setConfig({targetID: "basicDialog", type: "dialog"});
/* ---------------------------------------------- AXNotification -- */

/**
 * AXScroll
 * @class AXScroll
 * @extends AXJ
 * @version v1.53.1
 * @author tom@axisj.com, axisj.com
 * @logs
 "2012-10-10 오전 11:17:34",
 "2013-01-08 오후 2:33:39 스크롤대상을 스크롤바에서 컨테이너 기준으로 변경 - root",
 "2013-01-09 오후 1:29:26 mobile 환경에서 클릭버그수정 - tom",
 "2013-01-11 오후 4:18:21 스크롤바 드래그시 컨테이너 top 계산 수정-root",
 "2013-01-11 오후 5:18:54 컨테이너와 스크롤타겟의 높이에 따른 스크롤바표시 관련 수정-root",
 "2013-01-31 오후 3:10:02 스크롤바가 최소일때 휠 및 드래그 계산수정-root ",
 "2013-02-08 오후 5:48:26 컨테이너가 스크롤타켓보다 길때 휠 함수 중단 처리 - tom",
 "2013-02-16 오후 4:13:16 unbind 후 다시 bind할때 생기는 이벤트 중첩현상 처리 - tom",
 "2013-08-01 오후 4:54:17 mobile touch 버그픽스 - tom ",
 "2013-10-16 오후 6:45:48 mobile 스크롤 속도문제 패치 - tom",
 "2013-11-28 오전 11:23:11 tom - AX scrollTop 메소드 추가",
 "2013-12-12 오전 10:25:28 tom - moveTo 메소드 추가",
 "2014-01-06 오후 12:55:20 tom - 관성 작용중 touchStart stop 버그픽스",
 "2014-03-31 오후 6:26:34 root - yscroll 이 없어지면 scroll top 을 0으로"
 "2014-06-13 tom scrollBar 와 content 싱크방식 변경 / 버그픽스"
 "2014-07-14 tom issue#221, issue#222 fix"
 "2014-08-20 tom focusElement 버그픽스"
 "2014-08-28 tom setSBPosition 예외사항 exeception"
 * @example
 *```js
 * var myUIScroll = new AXScroll(); // 스크롤 인스턴스 선언
 * myUIScroll.setConfig({
 *     targetID:"UIScrollContainer",
 *     scrollID:"UIScrollTarget"
 * });
 *```
 *
 */
var AXScroll = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.CT_className = "AXScroll";
        this.config.ST_className = "scrollTarget";
        this.scrollBarMove = false;
        this.scrollBarAttr = {};
        this.Observer = null;
        this.config.yscroll = true;
        this.config.xscroll = false;
        this.config.scrollBarMargin = 3;

        this.minHeightSB = {TF: false, h: 0};
        this.minWidthSB = {TF: false, w: 0};
    },
    /**
     * @method AXScroll.setConfig
     * @param {Object} configs - 스크롤 속성 오브젝트
     * @description 스크롤 대상과 스크롤 컨테이너를 지정하여 스크롤UI를 구현합니다.
     * @example
     *```js
     * myUIScroll.setConfig({
     *     targetID:"UIScrollContainer",
     *     scrollID:"UIScrollTarget",
     *     bounces:true
     * });
     *```
     */
    init: function () {
        var config = this.config;
        if (Object.isUndefined(config.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }
        if (Object.isUndefined(config.scrollID)) {
            trace("need scrollID - setConfig({scrollID:''})");
            return;
        }
        this.scrollTargetID = axdom("#" + config.targetID);
        this.scrollScrollID = axdom("#" + config.scrollID);
        this.scrollTargetID.addClass(this.config.CT_className);
        this.scrollScrollID.addClass(this.config.ST_className);
        this.initScroll();
        this.bindEvent();
    },
    /**
     * @method AXScroll.updateScroll
     * @returns {AXScroll}
     * @description 스크롤 처리 대상의 사이즈를 재정의 합니다. 스크롤 대상의 크기가 변경되었을 때 호출
     * @example
     * ```js
     * myUIScroll.updateScroll();
     * myUIScroll.resizeScroll(); // updateScroll과 동일한 기능
     * ```
     */
    updateScroll: function () {
        this.initScroll();
        return this;
    },
    resizeScroll: function () {
        this.initScroll();
        return this;
    },
    initScroll: function () {
        var cfg = this.config, _this = this;
        if (!this.scroll) {
            var po = [];
            if (cfg.yscroll) {
                po.push("<div class=\"scrollTrack\" id=\"" + cfg.targetID + "_AX_scrollTrack\"></div>");
                po.push("<div class=\"scrollBar\" id=\"" + cfg.targetID + "_AX_scrollBar\"></div>");
            } else {
                this.scrollTargetID.css({height: this.scrollScrollID.outerHeight()});
                /*
                 setTimeout(function(){

                 }, 10);
                 */
            }
            if (cfg.xscroll) {
                po.push("<div class=\"xscrollTrack\" id=\"" + cfg.targetID + "_AX_xscrollTrack\"></div>");
                po.push("<div class=\"xscrollBar\" id=\"" + cfg.targetID + "_AX_xscrollBar\"></div>");
            }

            this.scrollTargetID.append(po.join(''));
            this.scroll = true;

            if (cfg.yscroll) {
                this.scrollTrack = axdom("#" + cfg.targetID + "_AX_scrollTrack");
                this.scrollBar = axdom("#" + cfg.targetID + "_AX_scrollBar");
            }
            if (cfg.xscroll) {
                this.xscrollTrack = axdom("#" + cfg.targetID + "_AX_xscrollTrack");
                this.xscrollBar = axdom("#" + cfg.targetID + "_AX_xscrollBar");
            }
        } else {
            if (!cfg.yscroll) {
                this.scrollTargetID.css({height: this.scrollScrollID.outerHeight()});
            }
        }

        var CTheight = this.scrollTargetID.innerHeight();
        var CTwidth = this.scrollTargetID.innerWidth();

        if (cfg.yscroll) {
            this.scrollTrack.css({height: CTheight - (cfg.scrollBarMargin * 2)});
        }
        if (cfg.xscroll) {
            this.xscrollTrack.css({width: CTwidth - (cfg.scrollBarMargin * 2)});
        } else {
            this.scrollScrollID.css({width: CTwidth});
        }

        var Cheight = this.scrollScrollID.outerHeight();
        var Cwidth = this.scrollScrollID.outerWidth();

        if (cfg.yscroll) {
            var SBheight = CTheight * (CTheight - (cfg.scrollBarMargin * 2)) / Cheight;
            if (SBheight < 30) SBheight = 30;
            this.scrollBar.css({height: Math.ceil(SBheight)});
            /*
             if (SBheight < 30) {
             this.minHeightSB.TF = true;
             this.minHeightSB.h = SBheight;
             }
             */
            if (CTheight == Cheight || CTheight > Cheight) {
                this.scrollTrack.hide();
                this.scrollBar.hide();
                this.scrollScrollID.css({top: 0});
            } else {
                this.scrollTrack.show();
                this.scrollBar.show();
            }
        }
        if (cfg.xscroll) {
            var SBwidth = CTwidth * (CTwidth - (cfg.scrollBarMargin * 2)) / Cwidth;
            if (SBwidth < 30) SBwidth = 30;
            this.xscrollBar.css({width: Math.ceil(SBwidth)});
            /*
             if (SBwidth < 30) {
             this.minWidthSB.TF = true;
             this.minWidthSB.w = SBwidth;
             }
             */
            if (CTwidth == Cwidth || CTwidth > Cwidth) {
                this.xscrollTrack.hide();
                this.xscrollBar.hide();
            } else {
                this.xscrollTrack.show();
                this.xscrollBar.show();
            }
        }
    },

    bindEvent: function () {
        var cfg = this.config;

        var CTheight = this.scrollTargetID.innerHeight();
        var Cheight = this.scrollScrollID.outerHeight();

        if (cfg.xscroll) {
            var CTwidth = this.scrollTargetID.innerWidth();
            var Cwidth = this.scrollScrollID.outerWidth();
        }

        /* event 선언자 */
        var tractActive = this.tractActive.bind(this);
        this.tractActiveBind = function (event) {
            tractActive(event);
        }
        var tractInActive = this.tractInActive.bind(this);
        this.tractInActiveBind = function (event) {
            tractInActive(event);
        }
        var cancelEvent = this.cancelEvent.bind(this);
        this.cancelEventBind = function (event) {
            cancelEvent(event);
        }
        var SBonMouseDown = this.SBonMouseDown.bind(this);
        this.SBonMouseDownBind = function (event) {
            SBonMouseDown(event);
        }
        var SBonMouseMove = this.SBonMouseMove.bind(this);
        this.SBonMouseMoveBind = function (event) {
            SBonMouseMove(event);
        }
        var SBonMouseUp = this.SBonMouseUp.bind(this);
        this.SBonMouseUpBind = function (event) {
            SBonMouseUp(event);
        }
        this.SBonWheelBind = this.SBonWheel.bind(this);
        /* event 선언자 */

        this.scrollTargetID.bind("mouseover", this.tractActiveBind);
        this.scrollTargetID.bind("mouseout", this.tractInActiveBind);

        if (cfg.yscroll) {
            this.scrollBar.bind("dragstart", this.cancelEventBind);
            this.scrollBar.bind("mousedown", this.SBonMouseDownBind);
        }

        if (cfg.xscroll) {
            var SBonMouseDownX = this.SBonMouseDownX.bind(this);
            this.SBonMouseDownXBind = function (event) {
                SBonMouseDownX(event);
            }
            var SBonMouseMoveX = this.SBonMouseMoveX.bind(this);
            this.SBonMouseMoveXBind = function (event) {
                SBonMouseMoveX(event);
            }
            var SBonMouseUpX = this.SBonMouseUpX.bind(this);
            this.SBonMouseUpXBind = function (event) {
                SBonMouseUpX(event);
            }

            this.xscrollBar.bind("dragstart", this.cancelEventBind);
            this.xscrollBar.bind("mousedown", this.SBonMouseDownXBind);
        }

        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
        if (document.attachEvent) { //if IE (and Opera depending on user setting)
            if (AXgetId(cfg.targetID)) AXgetId(cfg.targetID).attachEvent("on" + mousewheelevt, this.SBonWheelBind);
        } else if (document.addEventListener) { //WC3 browsers
            if (AXgetId(cfg.targetID)) AXgetId(cfg.targetID).addEventListener(mousewheelevt, this.SBonWheelBind, false);
        }
        if (document.addEventListener) {
            var touchstart = this.touchstart.bind(this);
            this.touchstartBind = function () {
                touchstart();
            };
            if (AXgetId(cfg.targetID)) {
                AXgetId(cfg.targetID).addEventListener("touchstart", this.touchstartBind, false);
            }
        }
    },
    tractActive: function (event) {
        var cfg = this.config;

        if (cfg.yscroll) {
            this.scrollBar.addClass("scrollBar_hover");
            this.scrollTrack.addClass("scrollTrack_hover");
        }

        if (cfg.xscroll) {
            this.xscrollBar.addClass("xscrollBar_hover");
            this.xscrollTrack.addClass("xscrollTrack_hover");
        }

        if (this.Observer) clearTimeout(this.Observer); //닫기 명령 제거
        this.initScroll();
    },
    tractInActive: function (event) {
        var SBonWheelEnd = this.SBonWheelEnd.bind(this);
        this.Observer = setTimeout(function () {
            SBonWheelEnd();
        }, 500);
    },
    getMousePosition: function (event) {
        var config = this.config;
        var pos = (this.scrollTrack) ? this.scrollTrack.offset() : {left: 0, top: 0};
        var posx = (this.xscrollTrack) ? this.xscrollTrack.offset() : {left: 0, top: 0};

        var x = (event.pageX - posx.left);
        var y = (event.pageY - pos.top);
        return {x: x, y: y};
    },
    getTouchPosition: function (event) {
        /* 사용안함. 옵션 */
        var config = this.config;
        var touch = event.touches[0];
        var pos = this.scrollTrack.offset();
        if (this.config.touchDirection) {
            var x = (touch.pageX - pos.left);
            var y = (touch.pageY - pos.top);
        } else {
            var x = (-touch.pageX - pos.left);
            var y = (-touch.pageY - pos.top);
        }
        return {x: x, y: y};
    },


    /* touch event init --- s */
    touchstart: function (e) {
        if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
        if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);

        var cfg = this.config;
        var touch;
        var event = window.event;
        touch = event.touches[0];
        if (!touch.pageX) return;

        this.touchStartXY = {
            sTime: ((new Date()).getTime() / 1000),
            sTop: this.scrollScrollID.position().top,
            sLeft: this.scrollScrollID.position().left,
            scrollWidth: this.scrollScrollID.outerWidth(),
            scrollHeight: this.scrollScrollID.outerHeight(),
            targetWidth: this.scrollTargetID.outerWidth(),
            targetHeight: this.scrollTargetID.outerHeight(),
            x: touch.pageX,
            y: touch.pageY
        };

        var touchEnd = this.touchEnd.bind(this);
        this.touchEndBind = function () {
            touchEnd(event);
        };
        var touchMove = this.touchMove.bind(this);
        this.touchMoveBind = function () {
            touchMove(event);
        };

        if (document.removeEventListener) {
            document.removeEventListener("touchend", this.touchEndBind, false);
            document.removeEventListener("touchmove", this.touchMoveBind, false);
        }
        if (document.addEventListener) {
            document.addEventListener("touchend", this.touchEndBind, false);
            document.addEventListener("touchmove", this.touchMoveBind, false);
        }

        var minLeft = 0;
        var maxLeft = -(this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
        var minTop = 0;
        var maxTop = -(this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
        var scrollPosition = this.scrollScrollID.position();

        if ((scrollPosition.left < minLeft && scrollPosition.left > maxLeft) || (scrollPosition.top < minTop && scrollPosition.top > maxTop)) {
            this.scrollScrollID.stop();
            if (cfg.yscroll) this.scrollBar.stop();
            if (cfg.xscroll) this.xscrollBar.stop();
        }

        this.tractActive();
    },
    touchMove: function (e) {
        if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
        if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);
        var cfg = this.config;

        var touch;
        var event = window.event;
        touch = event.touches[0];
        if (!touch.pageX) return;

        if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
            if (cfg.yscroll && this.touchStartXY.scrollHeight > this.touchStartXY.targetHeight) {
                this.touchMode = "ns";
                var touchDirection = ((this.touchStartXY.y - touch.pageY) <= 0) ? "T" : "B";
                /* 위아래 이동 */

                if (touchDirection != this.touchDirection) {
                    this.touchMoveAfter(touch);
                }

                this.touchDirection = touchDirection;
                if (this.moveBlock({top: touch.pageY - this.touchStartXY.y})) {
                    if (event.preventDefault) event.preventDefault();
                    else return false;
                }
            }
        } else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
            if (cfg.xscroll && this.touchStartXY.scrollWidth > this.touchStartXY.targetWidth) {
                this.touchMode = "we";
                var touchDirection = ((this.touchStartXY.x - touch.pageX) <= 0) ? "L" : "R";
                /* 좌우 이동 */

                if (touchDirection != this.touchDirection) {
                    this.touchMoveAfter(touch);
                }

                this.touchDirection = touchDirection;
                if (this.moveBlock({left: touch.pageX - this.touchStartXY.x})) {
                    if (event.preventDefault) event.preventDefault();
                    else return false;
                }
            }
        }
        if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
            //this.touchSelecting = true;
        }
        var touchMoveAfter = this.touchMoveAfter.bind(this);
        this.touhMoveObserver = setTimeout(function () {
            touchMoveAfter(touch);
        }, 50);
    },
    touchMoveAfter: function (touch) {
        try {
            this.touchStartXY.sTime = ((new Date()).getTime() / 1000);
            this.touchStartXY.sTop = this.scrollScrollID.position().top;
            this.touchStartXY.sLeft = this.scrollScrollID.position().left;
            this.touchStartXY.x = touch.pageX;
            this.touchStartXY.y = touch.pageY;
        } catch (e) {
            //trace(e);
        }
    },
    touchEnd: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        //this.moveSens = 0;
        //this.touchMode = false;

        if (document.removeEventListener) {
            document.removeEventListener("touchend", this.touchEndBind, false);
            document.removeEventListener("touchmove", this.touchMoveBind, false);
        }

        var moveEndBlock = this.moveEndBlock.bind(this);
        if (this.touchStartXY) {
            this.touhEndObserver = setTimeout(function () {
                moveEndBlock();
            }, 10);
        }
    },
    moveBlock: function (moveXY) {
        var cfg = this.config;
        var returnTF = true;
        if (moveXY.left != undefined) {
            var newLeft = (this.touchStartXY.sLeft + (moveXY.left));
            var minLeft = 0;
            var maxLeft = -(this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
            if (cfg.bounces) {
                minLeft = this.touchStartXY.targetWidth * 0.4;
                maxLeft = -((this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth) * 1.2);
            }
            if (newLeft > minLeft) {
                newLeft = minLeft;
                returnTF = false;
            } else if (newLeft < maxLeft) {
                newLeft = maxLeft;
                returnTF = false;
            }
            this.scrollScrollID.css({left: newLeft});
            this.setScrollbarPositionForWheel("left");
        } else if (moveXY.top != undefined) {
            var newTop = (this.touchStartXY.sTop + (moveXY.top));
            var minTop = 0;
            var maxTop = -(this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
            if (cfg.bounces) {
                minTop = this.touchStartXY.targetHeight * 0.4;
                maxTop = -((this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight) * 1.2);
            }
            if (newTop > minTop) {
                newTop = minTop;
                returnTF = false;
            } else if (newTop < maxTop) {
                newTop = maxTop;
                returnTF = false;
            }
            this.scrollScrollID.css({top: newTop});
            this.setScrollbarPositionForWheel("top");
        }
        /*trace(moveXY);*/
        return returnTF;
        //return true;
    },
    moveEndBlock: function () {
        var cfg = this.config;
        /* 관성발동여부 체크 */
        if (!this.touchStartXY) return;
        var sTime = this.touchStartXY.sTime;
        var eTime = ((new Date()).getTime() / 1000);
        var dTime = eTime - sTime;
        //var setScrollbarPositionForWheel = this.setScrollbarPositionForWheel.bind(this);
        var tractInActive = this.tractInActive.bind(this);

        if (this.touchMode == "we") { /* 좌우 */
            if (this.touchStartXY.scrollWidth <= this.touchStartXY.targetWidth) return;
            var eLeft = this.scrollScrollID.position().left;
            var dLeft = eLeft - this.touchStartXY.sLeft;
            var velocityLeft = Math.ceil((dLeft / dTime) / 1); // 속력= 거리/시간
            var endLeft = Math.ceil(eLeft + velocityLeft); //스크롤할때 목적지
            if (endLeft > 0) endLeft = 0;
            else if (endLeft < -(this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth)) {
                endLeft = -(this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
            }
            var newLeft = endLeft.abs();
            this.touchStartXY.sLeft = -newLeft;
            this.scrollScrollID.animate({left: -newLeft}, (eLeft + newLeft).abs(), "circOut", function () {
                tractInActive();
            });
            this.setScrollbarPositionForWheel("left", (eLeft + newLeft).abs(), "circOut", {left: -newLeft});

            if (cfg.yscroll) {
                var eTop = this.scrollScrollID.position().top;
                var topChange = false;
                if (eTop > 0) {
                    eTop = 0;
                    topChange = true;
                } else if (eTop < -(this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight)) {
                    eTop = (this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
                    topChange = true;
                }
                if (topChange) this.scrollScrollID.css({top: -eTop});
            }

        } else { /* 위아래 */
            if (this.touchStartXY.scrollHeight <= this.touchStartXY.targetHeight) return;
            var eTop = this.scrollScrollID.position().top;
            var dTop = eTop - this.touchStartXY.sTop;
            var velocityTop = Math.ceil((dTop / dTime) / 1); // 속력= 거리/시간
            var endTop = Math.ceil(eTop + velocityTop); //스크롤할때 목적지
            if (endTop > 0) endTop = 0;
            else if (endTop < -(this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight)) {
                endTop = -(this.touchStartXY.scrollHeight - this.touchStartXY.targetHeight);
            }

            var newTop = endTop.abs();
            this.touchStartXY.sTop = -newTop;
            this.scrollScrollID.animate({top: -newTop}, (eTop + newTop).abs(), "circOut", function () {
                tractInActive();
            });
            this.setScrollbarPositionForWheel("top", (eTop + newTop).abs(), "circOut", {top: -newTop});

            if (cfg.xscroll) {
                var eLeft = this.scrollScrollID.position().left;
                var leftChange = false;
                if (eLeft > 0) {
                    eLeft = 0;
                    leftChange = true;
                } else if (eLeft < -(this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth)) {
                    eLeft = (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
                    leftChange = true;
                }
                if (leftChange) this.scrollScrollID.css({left: -eLeft});
            }
        }
        this.touchStartXY = null;

    },
    /* touch event init --- e */


    /* scrollBar event */
    SBonMouseDown: function (event) {
        var config = this.config;
        this.scrollBarMove = true;
        var pos = this.getMousePosition(event);
        var SBpos = this.scrollBar.position();
        var SBh = this.scrollBar.height();
        var STh = this.scrollTrack.height();
        var Ch = this.scrollScrollID.outerHeight();

        this.Ch = Ch;
        this.STh = STh;

        this.scrollBarAttr = {x: (SBpos.left - pos.x).number(), y: (SBpos.top - pos.y).number(), h: SBh.number(), sth: STh};
        //trace("y:"+SBpos.top +" - "+ pos.y +", h:"+ SBh +", sth:"+STh+", calc y : "+(SBpos.top - pos.y).number());

        axdom(document.body).bind("mousemove.AXScroll", this.SBonMouseMoveBind);
        axdom(document.body).bind("mouseup.AXScroll", this.SBonMouseUpBind);
        axdom(document.body).bind("mouseleave.AXScroll", this.SBonMouseUpBind);
    },
    SBonMouseMove: function (event) {
        var config = this.config;
        if (this.scrollBarMove) {
            axdom(document.body).attr("onselectstart", "return false");
            //axdom(document.body).addClass("AXUserSelectNone");
            var pos = this.getMousePosition(event);

            var SBy = pos.y + this.scrollBarAttr.y;
            //trace(SBy +" = "+ pos.y +"+"+ this.scrollBarAttr.y);

            if (SBy < config.scrollBarMargin) SBy = config.scrollBarMargin;
            if ((SBy + this.scrollBarAttr.h) > this.scrollBarAttr.sth) {
                SBy = this.scrollBarAttr.sth - this.scrollBarAttr.h + config.scrollBarMargin;
                //trace(SBy)
            }
            this.scrollBar.css({top: SBy});
            this.setContentPosition();
        }
    },
    SBonMouseUp: function (event) {
        if (this.scrollBarMove) {
            var config = this.config;
            this.scrollBarMove = false;
            axdom(document.body).removeAttr("onselectstart");
            //axdom(document.body).removeClass("AXUserSelectNone");
        }
        axdom(document.body).unbind("mousemove.AXScroll");
        axdom(document.body).unbind("mouseup.AXScroll");
        axdom(document.body).unbind("mouseleave.AXScroll");
    },

    SBonMouseDownX: function (event) {
        var config = this.config;
        this.scrollBarMove = true;
        var pos = this.getMousePosition(event);
        var SBpos = this.xscrollBar.position();
        var SBw = this.xscrollBar.width();
        var STw = this.xscrollTrack.width();
        var Cw = this.scrollScrollID.outerWidth();

        this.Cw = Cw;
        this.STw = STw;

        this.scrollBarAttr = {x: (SBpos.left - pos.x).number(), w: SBw.number(), stw: STw};

        axdom(document.body).bind("mousemove.AXScroll", this.SBonMouseMoveXBind);
        axdom(document.body).bind("mouseup.AXScroll", this.SBonMouseUpXBind);
        axdom(document.body).bind("mouseleave.AXScroll", this.SBonMouseUpXBind);
    },
    SBonMouseMoveX: function (event) {
        var config = this.config;
        if (this.scrollBarMove) {

            axdom(document.body).attr("onselectstart", "return false");
            //axdom(document.body).addClass("AXUserSelectNone");
            var pos = this.getMousePosition(event);

            var SBx = pos.x + this.scrollBarAttr.x;
            //trace(SBy +" = "+ pos.y +"+"+ this.scrollBarAttr.y);

            if (SBx < config.scrollBarMargin) SBx = config.scrollBarMargin;
            if ((SBx + this.scrollBarAttr.w) > this.scrollBarAttr.stw) {
                SBx = this.scrollBarAttr.stw - this.scrollBarAttr.w + config.scrollBarMargin;
            }

            this.xscrollBar.css({left: SBx});
            this.setContentPosition("xscroll");
        }
    },
    SBonMouseUpX: function (event) {
        if (this.scrollBarMove) {
            var config = this.config;
            this.scrollBarMove = false;
            axdom(document.body).removeAttr("onselectstart");
            //axdom(document.body).removeClass("AXUserSelectNone");
        }
        axdom(document.body).unbind("mousemove.AXScroll");
        axdom(document.body).unbind("mouseup.AXScroll");
        axdom(document.body).unbind("mouseleave.AXScroll");
    },

    SBonWheel: function (e) {
        //content top handle
        var config = this.config;

        var event = (window.event || e);
        var delta = event.detail ? event.detail * (-10) : event.wheelDelta; //check for detail first so Opera uses that instead of wheelDelta

        var Sy = this.scrollScrollID.position().top;
        var Sh = this.scrollScrollID.outerHeight();
        var TGh = this.scrollTargetID.height();

        //trace(Sh+" + "+Sy+" < "+TGh );
        if (Sh < TGh) return; //스크롤 할 대상이 없음 2013-02-08 오후 5:48:07 tom@axmods.com

        var eventCancle = false;
        Sy += delta;
        if (Sy > 0) {
            Sy = 0;
            eventCancle = true;
        }

        //trace(Sh+" + "+Sy+" < "+TGh );

        if ((Sh + Sy) < TGh) {
            Sy = (TGh - Sh);
            eventCancle = true;
        }
        this.scrollScrollID.css({top: Sy});

        //this.setContentPosition();
        this.setScrollbarPositionForWheel("top");

        if (!eventCancle) {
            if (event.preventDefault) event.preventDefault();
            if (event.stopPropagation) event.stopPropagation();
            event.cancelBubble = true;
            return false;
        }

    },
    SBonWheelEnd: function () {
        if (this.scrollBarMove) return;
        var config = this.config;

        if (config.yscroll) {
            this.scrollBar.removeClass("scrollBar_hover");
            this.scrollTrack.removeClass("scrollTrack_hover");
        }

        if (config.xscroll) {
            this.xscrollBar.removeClass("xscrollBar_hover");
            this.xscrollTrack.removeClass("xscrollTrack_hover");
        }

    },
    cancelEvent: function (event) {
        event.stopPropagation(); // disable  event
        return false;
    },
    setContentPosition: function (xscroll) {
        var config = this.config;

        if (xscroll == "xscroll") {

            if (!this.contentScrollXAttr) {
                this.contentScrollXAttr = {
                    bodyWidth: this.scrollTargetID.width(),
                    scrollWidth: this.scrollScrollID.width(),
                    scrollTrackXWidth: this.xscrollTrack.width(),
                    scrollXHandleWidth: this.xscrollBar.width()
                };
            } else {
                // scrollContent height update
                this.contentScrollXAttr.scrollWidth = this.scrollScrollID.width();
                this.contentScrollXAttr.scrollTrackXWidth = this.xscrollTrack.width();
                this.contentScrollXAttr.scrollXHandleWidth = this.xscrollBar.width();
            }

            var SBx = this.xscrollBar.position().left - config.scrollBarMargin;
            var L = (this.contentScrollXAttr.scrollWidth * (SBx) / this.contentScrollXAttr.scrollTrackXWidth).round(0);
            this.scrollScrollID.css({left: -L});

        } else {

            if (!this.contentScrollYAttr) {
                this.contentScrollYAttr = {
                    bodyHeight: this.scrollTargetID.height(),
                    scrollHeight: this.scrollScrollID.height(),
                    scrollTrackYHeight: this.scrollTrack.height(),
                    scrollYHandleHeight: this.scrollBar.height()
                };
            } else {
                // scrollContent height update
                this.contentScrollYAttr.scrollHeight = this.scrollScrollID.height();
                this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrack.height();
                this.contentScrollYAttr.scrollYHandleHeight = this.scrollBar.height();
            }

            var SBy = this.scrollBar.position().top - config.scrollBarMargin;
            var T = (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight) * ( (SBy) / (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) ).number();
            this.scrollScrollID.css({top: -T});
        }

    },

    setScrollbarPositionForWheel: function (direction, duration, easing, position) {
        //scrollbar top position handle for wheel
        var config = this.config;

        if (direction == "left") {

            if (!this.contentScrollXAttr) {
                this.contentScrollXAttr = {
                    bodyWidth: this.scrollTargetID.width(),
                    scrollWidth: this.scrollScrollID.width(),
                    scrollTrackXWidth: this.xscrollTrack.width(),
                    scrollXHandleWidth: this.scrollBar.outerWidth()
                };
            } else {
                // scrollContent height update
                this.contentScrollXAttr.scrollWidth = this.scrollScrollID.width();
                this.contentScrollXAttr.scrollTrackXWidth = this.xscrollTrack.width();
                this.contentScrollXAttr.scrollXHandleWidth = this.xscrollBar.outerWidth();
            }

            var Sy = (position) ? position.left : this.scrollScrollID.position().left;
            var L = (this.contentScrollXAttr.scrollTrackXWidth - this.contentScrollXAttr.scrollXHandleWidth) * ((Sy) / (this.contentScrollXAttr.scrollWidth - this.contentScrollXAttr.bodyWidth));
            L -= config.scrollBarMargin;
            if (easing) {
                this.xscrollBar.animate({
                    left: -L
                    //,width: Math.ceil(this.scrollTargetID.outerWidth() * (this.scrollTargetID.outerWidth() - 4) / (this.scrollScrollID.outerWidth() + addY))
                }, duration, easing, function () {
                });
            } else {
                this.xscrollBar.css({
                    left: -L
                    //,width: Math.ceil(this.scrollTargetID.outerWidth() * (this.scrollTargetID.outerWidth() - 4) / (this.scrollScrollID.outerWidth() + addY))
                });
            }
        } else {

            if (!config.yscroll) return false;
            //wheel control event is not jquery event !

            if (!this.contentScrollYAttr) {
                this.contentScrollYAttr = {
                    bodyHeight: this.scrollTargetID.height(),
                    scrollHeight: this.scrollScrollID.height(),
                    scrollTrackYHeight: this.scrollTrack.height(),
                    scrollYHandleHeight: this.scrollBar.outerHeight()
                };
            } else {
                // scrollContent height update
                this.contentScrollYAttr.scrollHeight = this.scrollScrollID.height();
                this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrack.height();
                this.contentScrollYAttr.scrollYHandleHeight = this.scrollBar.outerHeight();
            }

            var Sy = (position) ? position.top : this.scrollScrollID.position().top;
            var T = (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) * ((Sy) / (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight));
            T -= config.scrollBarMargin;
            if (easing) {
                //trace({ top: SBy }, duration, easing);

                this.scrollBar.animate({
                    top: -T
                    //,height: Math.ceil(this.scrollTargetID.outerHeight() * (this.scrollTargetID.outerHeight() - 4) / (this.scrollScrollID.outerHeight() + addY))
                }, duration, easing, function () {
                });
            } else {
                this.scrollBar.css({
                    top: -T
                    //,height: Math.ceil(this.scrollTargetID.outerHeight() * (this.scrollTargetID.outerHeight() - 4) / (this.scrollScrollID.outerHeight() + addY))
                });
            }

        }
    },


    setSBPosition: function () {
        var config = this.config;
        try {

            var Ctop = this.scrollScrollID.position().top;
            var CTheight = this.scrollTargetID.innerHeight();
            var STh = this.scrollTrack.height();
            var Ch = this.scrollScrollID.outerHeight();

            var SBh = this.scrollBar.height();

            //trace({Ctop:Ctop, CTheight:CTheight, Ch:Ch, STh:STh, SBh:SBh, x:(STh*Ctop)/Ch});
            var SBtop = -(STh * Ctop) / Ch;
            if (SBtop < config.scrollBarMargin) SBtop = config.scrollBarMargin;
            if ((SBtop + SBh) > STh) {
                SBtop = STh - SBh + config.scrollBarMargin;
            }
            this.scrollBar.css({top: SBtop});
        } catch (e) {

        }
    },
    /**
     * @method AXScroll.focusElement
     * @param {String} id - 포커스 할 대상 엘리먼트 아이디
     * @returns {AXScroll}
     * @description 스크롤 오브젝트 안에 엘리먼트를 포커스 합니다.
     * @example
     *```js
     * myUIScroll.focusElement("resizer01");
     *```
     */
    focusElement: function (id) {
        var config = this.config;
        if (AXgetId(id)) {
            //trace(axdom("#"+id).position());
            var ppos = this.scrollScrollID.offset();
            var pos = axdom("#" + id).offset();

            var myNewTop = pos.top - ppos.top;
            var CTheight = this.scrollTargetID.innerHeight();
            var Cheight = this.scrollScrollID.outerHeight();
            if ((Cheight - myNewTop) < CTheight) {
                myNewTop = Cheight - CTheight;
            }
            if (myNewTop < 0) myNewTop = 0;
            this.scrollScrollID.css({top: -myNewTop});
            this.setSBPosition();
        }
        return this;
    },
    /**
     * @method AXScroll.scrollTop
     * @param {Number} top - scrollTop position
     * @returns {AXScroll}
     * @description 스크롤 포지션을 원하는 포지션으로 이동합니다.
     * @example
     *```js
     * myUIScroll.scrollTop(0);
     *```
     */
    scrollTop: function (top) {
        var myNewTop = top;
        var CTheight = this.scrollTargetID.innerHeight();
        var Cheight = this.scrollScrollID.outerHeight();
        if ((Cheight - myNewTop) < CTheight) {
            myNewTop = Cheight - CTheight;
        }
        if (myNewTop < 0) myNewTop = 0;
        this.scrollScrollID.css({top: -myNewTop});
        this.setSBPosition();
        return this;
    },
    /**
     * @method AXScroll.moveTo
     * @param {Number} x - scrollTop position (optional)
     * @param {Number} y - scrollLeft position (optional)
     * @returns {AXScroll}
     * @description 스크롤위치를 이동시킵니다.
     * @example
     *```js
     * myUIScroll.moveTo();
     *```
     */
    moveTo: function (x, y) {
        var cfg = this.config;
        var css = {};
        if (!AXUtil.isEmpty(x)) {
            css.left = -x;
        }
        if (!AXUtil.isEmpty(y)) {
            css.top = -y;
        }

        this.scrollScrollID.css(css);
        if (cfg.yscroll && !AXUtil.isEmpty(css.top)) {
            this.scrollBar.css({top: css.top});
        }
        if (cfg.xscroll && !AXUtil.isEmpty(css.left)) {
            this.xscrollBar.css({left: css.left});
        }
        return this;
    },
    /**
     * @method AXScroll.unbind
     * @returns {AXScroll}
     * @description 스크롤을 UI를 제거합니다.
     * @example
     * ```js
     * myUIScroll.unbind();
     * ```
     */
    unbind: function () {
        var config = this.config;
        this.scroll = false;

        this.scrollTrack.remove();
        this.scrollBar.remove();

        this.scrollTargetID.unbind("mouseover", this.tractActiveBind);
        this.scrollTargetID.unbind("mouseout", this.tractInActiveBind);

        //axdom("#"+config.targetID+"_AX_scrollBar").unbind("dragstart", this.cancelEventBind);
        //axdom("#"+config.targetID+"_AX_scrollBar").unbind("mousedown", this.SBonMouseDownBind);
        axdom(document.body).unbind("mousemove.AXScroll", this.SBonMouseMoveBind);
        axdom(document.body).unbind("mouseup.AXScroll", this.SBonMouseUpBind);

        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
        if (document.attachEvent) { //if IE (and Opera depending on user setting)
            if (AXgetId(config.targetID)) AXgetId(config.targetID).detachEvent("on" + mousewheelevt, this.SBonWheelBind);
        } else if (document.addEventListener) { //WC3 browsers
            if (AXgetId(config.targetID)) AXgetId(config.targetID).removeEventListener(mousewheelevt, this.SBonWheelBind, false);
        }

        if (document.addEventListener) {
            if (AXgetId(config.targetID)) AXgetId(config.targetID).removeEventListener("touchstart", this.SBtouchstartBind, false)
        }
        return this;
    }
});
/* ---------------------------------------------- AXScroll -- */

/* -- AXCalendar ---------------------------------------------- */
/**
 * @class AXCalendar
 * @extends AXJ
 * @version v1.2
 * @author tom@axisj.com
 * @logs
 * "2012-12-05 오후 11:54:27"
 * "2014-03-31 오후 4:53:02 - tom : timePage PM 이면 12시 선택 못하도록 기능 변경"
 * "2015-03-17 tom : 0시 0분 입력 가능 하도록 수정"
 *
 */
var AXCalendar = Class.create(AXJ, {
    /**
     * AXCalendar 기본속성
     * @member {Object} AXCalendar.config
     * @example
     *```js
     * {
     *     CT_className : {String},
     *     weeks : {
     *        { name: "SUN" },
     *        { name: "MON" },
     *        { name: "TUE" },
     *        { name: "WED" },
     *        { name: "THU" },
     *        { name: "FRI" },
     *        { name: "SAT" }
     *     },
     *     printFormat : "dd",
     *     titleFormat : "yyyy/mm/dd",
     *     valueFormat : "yyyy-mm-dd"
     * }
     *```
     */
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.CT_className = "AXCalendar";
        this.Observer = null;
        this.config.weeks = [
            {name: "SUN"},
            {name: "MON"},
            {name: "TUE"},
            {name: "WED"},
            {name: "THU"},
            {name: "FRI"},
            {name: "SAT"}
        ];
        this.config.printFormat = "dd";
        this.config.titleFormat = "yyyy/mm/dd";
        this.config.valueFormat = "yyyy-mm-dd";
    },
    /**
     * @method AXCalendar.setConfig
     * @param {Object} config
     * @description 선언된 스크롤 클래스를 사용하기 위해 속성을 정의합니다.
     * @example
     *```js
     * mycalendar.setConfig(config);
     *
     * var config = {
     *     CT_className : {String},
     *     weeks : {Object} [{ { name: "SUN" }, { name: "MON" }, { name: "TUE" }, { name: "WED" }, { name: "THU" }, { name: "FRI" }, { name: "SAT" } }],
     *     printFormat : {String} [dd],
     *     titleFormat : {String} [yyyy/mm/dd],
     *     valueFormat : {String} [yyyy-mm-dd]
     * };
     *```
     */
    init: function () {

    },
    getBasicDate: function () {
        var cfg = this.config;
        if (cfg.basicDate != undefined) {
            return cfg.basicDate.date();
        } else {
            return new Date();
        }
    },
    getCalendarStartDate: function (date) {
        var cfg = this.config;
        var calendarStartDate, monthStartDate, basicDate;
        basicDate = (date) ? date.date() : this.getBasicDate();
        monthStartDate = new Date(basicDate.getFullYear(), basicDate.getMonth(), 1, 12);
        var calendarStartDateDay = monthStartDate.getDay();
        if (calendarStartDateDay == 0) calendarStartDateDay = 7;
        calendarStartDate = monthStartDate.add(-calendarStartDateDay);
        return {calendarStartDate: calendarStartDate, monthStartDate: monthStartDate};
    },
    /**
     * @method AXCalendar.printDayPage
     * @param {String} [toDay]
     * @returns {AXCalendar}
     * @description 일자 캘린더를 targetID 안에 출력합니다
     * @example
     *```js
     * mycalendar.printDayPage("2014-11-01");
     *```
     */
    printDayPage: function (date) {
        var cfg = this.config;

        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }

        var calendarDate = this.getCalendarStartDate(date);
        var calendarStartDate = calendarDate.calendarStartDate;
        var monthStartDate = calendarDate.monthStartDate;
        var basicDate = this.getBasicDate();
        var setDate = (date) ? date.date() : new Date();
        //
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\">");
        po.push("<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarPage\">");
        po.push("<thead>");
        po.push("<tr>");
        axf.each(cfg.weeks, function (wi, ww) {
            po.push("<td class=\"head_" + wi + " dayofweek_" + wi + "\">" + ww.name + "</td>");
        });
        po.push("</tr>");
        po.push("</thead>");
        po.push("<tbody>");

        var minTime = -1;
        var maxTime = -1;
        var onBeforeShowDay;
        var roopDate = calendarStartDate;
        if (cfg.minDate) {
            minTime = cfg.minDate.date().getTime();
        }
        if (cfg.maxDate) {
            maxTime = cfg.maxDate.date().getTime();
        }
        if (cfg.onBeforeShowDay) {
            onBeforeShowDay = cfg.onBeforeShowDay.bind(this);
        }
        var i = 0;
        while (i < 6) {
            po.push("<tr>");
            var k = 0;
            while (k < 7) {
                var roopTime = roopDate.getTime();
                var dayValue = roopDate.print(this.config.printFormat);
                var addClass = [];
                var addStyle = "";
                var tdClass = [];
                var printTitle = roopDate.print(this.config.titleFormat);
                var isEnable = true;
                if (onBeforeShowDay) {
                    var addData = onBeforeShowDay(roopDate); // addData -> { isEnable: true|false, title:'성탄절', className: 'holyday', style: 'color:red' }
                    if (addData) {
                        if (addData.className) {
                            addClass.push(addData.className);
                        } // ie7 이하에서 class 예약어라 사용안됨
                        if (addData.style) {
                            addStyle = addData.style;
                        }
                        if (addData.title) {
                            printTitle = addData.title;
                        }
                        if (addData.isEnable === false) {
                            isEnable = false;
                        }
                    }
                }
                if (isEnable && minTime > -1) {
                    isEnable = !(roopTime < minTime);
                }
                if (isEnable && maxTime > -1) {
                    isEnable = !(roopTime > maxTime);
                }
                if (roopDate.getMonth() != monthStartDate.getMonth()) addClass.push("notThisMonth");
                if (setDate.diff(roopDate, "D") == 0) tdClass.push("setDate");
                if (!isEnable) {
                    addClass.push("disabled");
                }
                po.push("<td class=\"bodyCol_" + k + " bodyRow_" + i + " " + tdClass.join(" ") + "\"><a " + cfg.href + " class=\"calendarDate " + addClass.join(" ") + "\" id=\"" + cfg.targetID + "_AX_" + roopDate.print(this.config.valueFormat) + "_AX_date\" title=\"" + printTitle + "\">" + dayValue.number() + "</a></td>");
                k++;
                roopDate = roopDate.add(1);
            }
            po.push("</tr>");
            i++;
        }
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));
        return this;
    },
    /**
     * @method AXCalendar.dayPageSetDay
     * @param {Date} - 날짜
     * @returns {AXCalendar}
     * @description 일자달력의 표시 날짜를 변경합니다.
     * @example
     *```js
     * var myDate = new Date();
     * // var myDate = "2014-11-01".date();
     * mycalendar.dayPageSetDay(myDate);
     *```
     */
    dayPageSetDay: function (date) {
        var cfg = this.config;
        axdom("#" + cfg.targetID).find(".calendarDate").removeClass("selected");
        axdom("#" + cfg.targetID + "_AX_" + date.print(this.config.valueFormat) + "_AX_date").addClass("selected");
        return this;
    },
    /**
     * @method AXCalendar.printMonthPage
     * @param {String} [toDay]
     * @returns {AXCalendar}
     * @description 월 선택 캘린더를 targetID 안에 출력합니다.
     * @example
     *```js
     * mycalendar.printMonthPage("2014-11-01");
     *```
     */
    printMonthPage: function (date) {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }
        var setDate = (date) ? date.date() : new Date();
        //alert(setDate);
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\">");
        po.push("<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarPageMonth\">");
        po.push("<tbody>");

        var m = 1;
        var i = 0;
        while (i < 4) {
            po.push("<tr>");
            var k = 0;
            while (k < 3) {
                var tdClass = [];
                if (m == (setDate.getMonth() + 1)) tdClass.push("setDate");
                po.push("<td class=\"bodyCol_" + k + " bodyRow_" + i + " " + tdClass.join(" ") + "\"><a " + cfg.href + " class=\"calendarMonth\" id=\"" + cfg.targetID + "_AX_" + m + "_AX_month\" title=\"\">" + m + "월</a></td>");
                k++;
                m++;
            }
            po.push("</tr>");
            i++;
        }
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));
        return this;
    },
    /**
     * @method AXCalendar.monthPageSetMonth
     * @param {Date} - 날짜
     * @returns {AXCalendar}
     * @description 월달력의 표시 날짜를 변경합니다.
     * @example
     *```js
     * var myDate = new Date();
     * // var myDate = "2014-11-01".date();
     * mycalendar.monthPageSetMonth(myDate);
     *```
     */
    monthPageSetMonth: function (date) {
        var cfg = this.config;
        axdom("#" + cfg.targetID).find(".calendarMonth").removeClass("selected");
        axdom("#" + cfg.targetID + "_AX_" + (date.getMonth() + 1) + "_AX_month").addClass("selected");
    },
    /**
     * @method AXCalendar.printYearPage
     * @param {(String|Number)}
     * @returns {AXCalendar}
     * @description 년도 선택 캘린더를 targetID 안에 출력합니다.
     * @example
     *```js
     * mycalendar.printYearPage("2014");
     * mycalendar.printYearPage(2014);
     *```
     */
    printYearPage: function (year) {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\">");
        po.push("<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarPageMonth\">");
        po.push("<tbody>");

        var m = year - 4;
        var i = 0;
        while (i < 4) {
            po.push("<tr>");
            var k = 0;
            while (k < 3) {
                var tdClass = [];
                if (m == year) tdClass.push("setDate");
                po.push("<td class=\"bodyCol_" + k + " bodyRow_" + i + " " + tdClass.join(" ") + "\"><a " + cfg.href + " class=\"calendarMonth\" id=\"" + cfg.targetID + "_AX_" + m + "_AX_year\" title=\"\">" + m + "년</a></td>");
                k++;
                m++;
            }
            po.push("</tr>");
            i++;
        }
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));
    },
    /**
     * @method AXCalendar.yearPageSetYear
     * @param {Date} - 날짜
     * @returns {AXCalendar}
     * @description 년도달력의 표시 날짜를 변경합니다.
     * @example
     *```js
     * var myDate = new Date();
     * // var myDate = "2014-11-01".date();
     * mycalendar.yearPageSetYear(myDate);
     *```
     */
    yearPageSetYear: function (date) {
        var cfg = this.config;
        axdom("#" + cfg.targetID).find(".calendarMonth").removeClass("selected");
        axdom("#" + cfg.targetID + "_AX_" + date.print("yyyy") + "_AX_year").addClass("selected");
    },
    /**
     * @method AXCalendar.printTimePage
     * @param {String}
     * @returns {AXCalendar}
     * @description 시간 선택 캘린더를 targetID 안에 출력합니다.
     * @example
     *```js
     * mycalendar.printTimePage("06:36 AM");
     *```
     */
    printTimePage: function (displayTime) {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetID)) {
            trace("need targetID - setConfig({targetID:''})");
            return;
        }

        if (displayTime) {
            var now = displayTime.split(":");
            var hh = now[0].setDigit(2);
            var mm = now[1].left(2).setDigit(2);
            var apm = now[1].right(2);
            if (hh == "00" && mm == "00") {
                //hh = "12";
                apm = "AM";
            }
            if (apm == "00") apm = "AM";
        } else {
            var now = new Date();
            var hh = now.getHours();
            var mm = now.getMinutes();
            var apm = "AM";
            if (hh == 0 && mm == 0) {
                //hh = 24;
            }
            if (hh > 12) {
                apm = "PM";
                hh -= 12;
            }
            hh = hh.setDigit(2);
            mm = mm.setDigit(2);
        }

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_box\" class=\"" + cfg.CT_className + "\" style=\"padding:0px;\">");
        po.push("<div class='timeBox'>");
        po.push("<div class='hourTitle'>Hour</div>");
        po.push("<div class='hourSlider'><input type='text' value='" + hh + "' id='" + cfg.targetID + "_AX_hour' class='AXInput' /></div>");
        po.push("<div class='minuteTitle'>Minute</div>");
        po.push("<div class='minuteSlider'><input type='text' value='" + mm + "' id='" + cfg.targetID + "_AX_minute' class='AXInput' /></div>");
        po.push("<div class='timeDisplay'>" + hh + ":" + mm + " " + apm + "</div>");
        po.push("<div class='AMPM'><input type='text' id='" + cfg.targetID + "_AX_AMPM' value='" + apm + "' style='width:50px;height:21px;border:0px none;' /></div>");
        po.push("</div>");
        po.push("</div>");
        axdom("#" + cfg.targetID).html(po.join(''));

        var timePageChange = this.timePageChange.bind(this);
        axdom("#" + cfg.targetID + "_AX_hour").unbindInput();
        axdom("#" + cfg.targetID + "_AX_minute").unbindInput();
        axdom("#" + cfg.targetID + "_AX_AMPM").unbindInput();
        axdom("#" + cfg.targetID + "_AX_hour").bindSlider({
            min: 0, max: 12, onChange: function (objID, objVal) {
                timePageChange(objID, objVal);
            }
        });
        axdom("#" + cfg.targetID + "_AX_minute").bindSlider({
            min: 0, max: 59, onChange: function (objID, objVal) {
                timePageChange(objID, objVal);
            }
        });
        axdom("#" + cfg.targetID + "_AX_AMPM").bindSwitch({
            off: "AM", on: "PM", onChange: function (objID, objVal) {
                timePageChange(objID, objVal);
            }
        });
    },
    // 내부 함수
    timePageChange: function () {
        var cfg = this.config, hh, mi, apm, mytime;
        hh = axdom("#" + cfg.targetID + "_AX_hour").val().number();
        mi = axdom("#" + cfg.targetID + "_AX_minute").val().number();
        apm = axdom("#" + cfg.targetID + "_AX_AMPM").val();
        if (apm == "PM") {
            //hh += 12;
            if (hh > 12) {
                axdom("#" + cfg.targetID + "_AX_hour").val(12);
                axdom("#" + cfg.targetID + "_AX_hour").setValueInput(12);
            }
        }
        mytime = hh.setDigit(2) + ":" + mi.setDigit(2) + " " + apm;
        axdom("#" + cfg.targetID + "_AX_box").find(".timeDisplay").html(mytime);
        if (cfg.onChange) {
            cfg.onChange(hh.setDigit(2) + ":" + mi.setDigit(2));
        }
    },
    /**
     * @method AXCalendar.getTime
     * @returns {String} hh:mm
     * @description 현재 시간과 분을 리턴합니다.
     * @example
     *```js
     * myCalendar.getTime();
     * // 09:20
     *```
     */
    getTime: function () {
        var cfg = this.config;
        var hh = (axdom("#" + cfg.targetID + "_AX_hour").val() || 0).number();
        var mi = (axdom("#" + cfg.targetID + "_AX_minute").val() || 0).number();
        var apm = axdom("#" + cfg.targetID + "_AX_AMPM").val();
        if (apm == "PM" && hh < 12) hh += 12;
        return hh.setDigit(2) + ":" + mi.setDigit(2);
    }
});
/* ---------------------------------------------- AXCalendar -- */

/* -- AXMultiSelect ---------------------------------------------- */
/**
 * @class AXMultiSelect
 * @classdesc 박스안에 아이템들중에 약속된 Class를 가진 아이템에 대해 다중선택를 할 수 있도록 지원합니다.
 * @extends AXJ
 * @version v1.9
 * @author tom@axisj.com
 * @logs
 "2013-01-31 오후 5:01:12",
 "2013-11-12 오전 9:19:09 - tom : 버그픽스",
 "2013-11-12 오전 11:59:38 - tom : body relative 버그 픽스, 스크롤바 마우스 선택 문제 해결",
 "2013-11-13 오후 3:01:15 - tom : 모바일 터치 기능 지원"
 "2015-04-01 tom : 드래그 셀렉트 버그 픽스"
 * @example
 *```js
 * var multiSelector = new AXMultiSelect();
 * multiSelector.setConfig({
 *     selectStage       : "selectStageBox", // 컨테이너 타겟 아이디
 *     selectClassName   : "readyselect", // 셀렉트 대상
 *     beselectClassName : "beSelected", // 셀렉트 되었을 때.
 *     selectingClassName: "AX_selecting" // 셀렉트중일 때
 * });
 *```
 */
var AXMultiSelect = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();

        /**
         * 선택된 아이템 <en>Array of selected Item.</en>
         * @member {Array} AXMultiSelect.selects
         */
        this.selects = [];
        this.moveSens = 0;
        this.touchMode;

        this.config.selectClassName = "readySelect";
        this.config.beselectClassName = "beSelected";
        this.config.selectingClassName = "AX_selecting";
        this.config.moveSens = 5;
        this.config.useHelper = true;
    },
    /**
     * @method AXMultiSelect.setConfig
     * @param {Object} config
     * @description 멀티셀렉트
     * @example
     *```js
     * var config = {
     *     selectStage: {String} - Element ID of select item container,
     *     selectClassName: {String} [readySelect] - CSS Class Name of select item,
     *     beselectClassName: {String} [beSelected] - CSS Class Name of selected item,
     *     selectingClassName: {String} [AX_selecting] - CSS Class Name of selecting item,
     *     moveSens: {Number} [5] - mouse position move of detect select,
     *     useHelper: {Boolean} [true] - use mouse select box
     * }
     * multiSelector.setConfig(config);
     *```
     */
    init: function () {

        var mouseClick = this.onmouseClick.bind(this);
        this._selectStage = axdom("#" + this.config.selectStage);
        this._selectStage.css({"position": "relative"});

        /*
         if(AXUtil.browser.mobile){
         this._selectStage.css({"overflow":"visible", "min-height":this._selectStage.innerHeight(), "height":"auto"});
         }
         */

        this._selectStage.bind("mousedown", this.mousedown.bind(this));

        this._selectStage.bind("click", function (event) {
            mouseClick(this, event);
        });

        this.helper = axdom("<div class='AXMultiselectorHelper'></div>");
        this.collect();

        axdom(window).bind("resize.AXMultiSelect", this.collect.bind(this));
        axdom(window).bind("keydown.AXMultiSelect", this.onKeydown.bind(this));
        this._selectStage.bind("scroll", this.onScrollStage.bind(this));

        this._selectStage.bind("touchstart", this.touchstart.bind(this));
    },
    onKeydown: function (event) {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            this.clearSelects();
        }
    },
    onScrollStage: function (event) {
        var cfg = this.config;
        if (!AXUtil.browser.mobile) {
            if (this.helperAppened || this.helperAppenedReady) {
                this.moveSens = 0;
                axdom(document.body).unbind("mousemove.AXMultiSelect");
                axdom(document.body).unbind("mouseup.AXMultiSelect");
                axdom(document.body).unbind("mouseleave.AXMultiSelect");
                axdom(document.body).removeAttr("onselectstart");
                //axdom(document.body).removeClass("AXUserSelectNone");
                this.helperAppenedReady = false;
                this.helperAppened = false;
                this.helper.remove();
            }
        }

    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* observe method ~~~~~~ */
    onmouseClick: function (element, event) {
        if (this.helperAppened) {
            return this;
        }
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (AXgetId(evt.parentNode) == AXgetId(cfg.selectStage)) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass(cfg.selectClassName)) ? true : false;
            }
        });

        if (myTarget) {
            var selectElement = myTarget;
            if (selectElement) {
                if (event.shiftKey) {
                    this.shiftSelects(selectElement);
                } else if (event.metaKey || event.ctrlKey) {
                    this.toggleSelects(selectElement);
                } else {
                    this.clickSelects(selectElement);
                }
            }
        } else {
            if (event.target.id == cfg.selectStage && AXUtil.browser.name != "ie") this.clearSelects();
        }
        return this;
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* class method ~~~~~~ */
    /**
     * @method AXMultiSelect.collect
     * @returns {AXMultiSelect}
     * @description 컨테이너안에 셀렉트 아이템을 재정의 합니다.
     * @example
     *```js
     * multiSelector.collect();
     * // 컨테이너안에 아이템의 변화가 생긴 경우 호출합니다.
     *```
     */
    collect: function () {
        var cfg = this.config;
        this._selectTargets = axdom("#" + cfg.selectStage + " ." + cfg.selectClassName);
        this.selectTargets = this._selectTargets.get();
        var scrollLeft = this._selectStage.scrollLeft().number();
        var scrollTop = this._selectStage.scrollTop().number();
        this._selectTargets.each(function () {
            var jQuerythis = axdom(this), pos = jQuerythis.position();
            axdom.data(this, "selectableItem", {
                element: this,
                jQueryelement: jQuerythis,
                left: pos.left + scrollLeft,
                top: pos.top + scrollTop,
                right: pos.left + scrollLeft + jQuerythis.outerWidth(),
                bottom: pos.top + scrollTop + jQuerythis.outerHeight(),
                selected: jQuerythis.hasClass(cfg.beselectClassName),
                selecting: jQuerythis.hasClass(cfg.selectingClassName)
            });
        });
        return this;
    },
    clearSelects: function () {
        var cfg = this.config;
        this._selectTargets.each(function () {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selecting) {
                    selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                    selectTarget.selecting = false;
                }
                if (selectTarget.selected) {
                    selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                    selectTarget.selected = false;
                }
            }
        });
    },
    pushSelects: function (Obj) {
        var hasSelect = this.selects.has(function () {
            return this.item == Obj;
        });
        if (!hasSelect) this.selects.push(Obj);
    },
    clickSelects: function (Obj) {
        var cfg = this.config;

        this.clearSelects();

        var selectTarget = axdom.data(Obj, "selectableItem");
        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
        selectTarget.selected = true;
    },
    toggleSelects: function (Obj) {
        var cfg = this.config;

        var selectTarget = axdom.data(Obj, "selectableItem");
        if (selectTarget.selected) {
            selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
            selectTarget.selected = false;
        } else {
            selectTarget.jQueryelement.addClass(cfg.beselectClassName);
            selectTarget.selected = true;
        }
    },
    shiftSelects: function (Obj) {
        var cfg = this.config;

        var selectedLength = 0;
        var li, si;
        this._selectTargets.each(function (stIndex, ST) {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selected) {
                    selectedLength++;
                    li = stIndex;
                }
            }
            if (this === Obj) si = stIndex;
        });

        if (selectedLength == 0) {
            this.clickSelects(Obj);
        } else {
            //마지막 selects 개체를 찾는다.
            if (si == li) return;
            this.clearSelects();
            var temp;
            if (si > li) {
                temp = si;
                si = li;
                li = temp;
            }
            this._selectTargets.each(function (stIndex, ST) {
                var selectTarget = axdom.data(this, "selectableItem");
                if (selectTarget) {
                    if (si <= stIndex && li >= stIndex) {
                        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
                        selectTarget.selected = true;
                    }
                }
            });
        }
    },

    /* mouser helper */
    mousedown: function (event) {
        var cfg = this.config;

        axdom(document.body).bind("mousemove.AXMultiSelect", this.mousemove.bind(this));
        axdom(document.body).bind("mouseup.AXMultiSelect", this.mouseup.bind(this));
        axdom(document.body).bind("mouseleave.AXMultiSelect", this.mouseup.bind(this));
        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");

        this.helperAppenedReady = true;
    },
    mousemove: function (event) {
        var cfg = this.config;
        if (!event.pageX) return;

        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.selectorHelperMove(event);
    },
    mouseup: function (event) {
        var cfg = this.config, _this = this;

        this.helperAppenedReady = false;
        this.moveSens = 0;

        axdom(document.body).unbind("mousemove.AXMultiSelect");
        axdom(document.body).unbind("mouseup.AXMultiSelect");
        axdom(document.body).unbind("mouseleave.AXMultiSelect");

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");

        if (this.helperAppened) {
            setTimeout(function () {
                _this.helperAppened = false;
                _this.helper.remove();
            }, 100);


            /* selected change */
            this._selectTargets.each(function () {
                var selectTarget = axdom.data(this, "selectableItem");
                if (selectTarget) {
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
                        selectTarget.selected = true;
                    }
                    /*
                     else if (selectTarget.selected) {

                     }
                     */
                }
            });
        }

    },
    selectorHelperMove: function (event) {
        var cfg = this.config;

        if (!cfg.useHelper) {
            return;
        }

        if (this.helperAppened) {

            var _helperPos = this.helperPos;
            var tmp,
                x1 = this.helperPos.x,
                y1 = this.helperPos.y,
                x2 = event.pageX - _helperPos.bodyLeft,
                y2 = event.pageY - _helperPos.bodyTop;
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({left: x1, top: y1, width: x2 - x1, height: y2 - y1});

            this._selectTargets.each(function () {

                var selectTarget = axdom.data(this, "selectableItem"), hit = false;
                /*trace({sl:selectTarget.left, sr:selectTarget.right, st:selectTarget.top, sb:selectTarget.bottom, x1:x1, x2:x2, y1:y1, y2:y2}); */
                if (!selectTarget) return;

                var stL = selectTarget.left.number(), stR = selectTarget.right.number(), stT = selectTarget.top.number(), stB = selectTarget.bottom.number();
                stL = stL + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stR = stR + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stT = stT + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;
                stB = stB + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;

                hit = (!(stL > x2 || stR < x1 || stT > y2 || stB < y1));
                /* touch */
                /* hit = (selectTarget.left > x1 && selectTarget.right < x2 && selectTarget.top > y1 && selectTarget.bottom < y2); fit */
                if (hit) {
                    /* SELECT */
                    if (selectTarget.selected) {
                        selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                        selectTarget.selected = false;
                    }
                    if (!selectTarget.selecting) {
                        selectTarget.jQueryelement.addClass(cfg.selectingClassName);
                        selectTarget.selecting = true;
                    }
                } else {
                    /* UNSELECT */
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                    }
                    if (selectTarget.selected) {
                        if (!event.metaKey && !event.shiftKey && !event.ctrlKey) {
                            selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                            selectTarget.selected = false;
                        }
                    }
                }
            });

        } else {
            this.helperAppened = true;
            axdom(document.body).append(this.helper);

            var css = {left: (event.pageX - axdom(document.body).offset().left), top: (event.pageY - axdom(document.body).offset().top), width: 0, height: 0};
            this.helper.css(css);
            var stagePos = this._selectStage.offset();
            this.helperPos = {
                stageX: stagePos.left.number(),
                stageY: stagePos.top.number(),
                x: css.left.number(),
                y: css.top.number(),
                scrollLeft: this._selectStage.scrollLeft().number(),
                scrollTop: this._selectStage.scrollTop().number(),
                bodyLeft: axdom(document.body).offset().left,
                bodyTop: axdom(document.body).offset().top
            };
        }
    },

    /* touch helper */
    touchstart: function (event) {
        var cfg = this.config;

        var touchEnd = this.touchEnd.bind(this);
        this.touchEndBind = function () {
            touchEnd(event);
        };

        var touchMove = this.touchMove.bind(this);
        this.touchMoveBind = function () {
            touchMove(event);
        };

        if (document.addEventListener) {
            document.addEventListener("touchend", this.touchEndBind, false);
            document.addEventListener("touchmove", this.touchMoveBind, false);
        }

        this.helperAppenedReady = true;
    },
    touchMove: function (event) {
        var cfg = this.config;
        var event = window.event || e;
        var touch = event.touches[0];
        if (!touch.pageX) return;
        var offset = this._selectStage.offset();
        var right = offset.left + this._selectStage.width();
        var bottom = offset.top + this._selectStage.height();

        if (this.moveSens == 0) {
            this.touchStartXY = {x: touch.pageX, y: touch.pageY, scrollTop: this._selectStage.scrollTop()};
        }

        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) {
            if (this.touchMode == "drag") {
                if (bottom < touch.pageY) this._selectStage.scrollTop(this.touchStartXY.scrollTop - (bottom - touch.pageY));
                else if (offset.top > touch.pageY) this._selectStage.scrollTop(this.touchStartXY.scrollTop - (offset.top - touch.pageY));
                if (right < touch.pageX) this._selectStage.scrollLeft(this.touchStartXY.scrollLeft - (right - touch.pageX));
                else if (offset.left > touch.pageX) this._selectStage.scrollLeft(this.touchStartXY.scrollLeft - (offset.left - touch.pageX));
                this.selectorHelperMoveByTouch(event);
            } else if (this.touchMode == "scrollTop") {
                this._selectStage.scrollTop(this.touchStartXY.scrollTop + (this.touchStartXY.y - touch.pageY));
            } else if (this.touchMode == "scrollLeft") {
                this._selectStage.scrollLeft(this.touchStartXY.scrollLeft + (this.touchStartXY.x - touch.pageX));
            } else {
                if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
                    this.touchMode = "drag"
                    this.selectorHelperMoveByTouch(event);
                } else if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
                    this.touchMode = "scrollTop";
                    this._selectStage.scrollTop(this.touchStartXY.scrollTop + (this.touchStartXY.y - touch.pageY));
                } else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
                    this.touchMode = "scrollLeft";
                    this._selectStage.scrollLeft(this.touchStartXY.scrollLeft + (this.touchStartXY.x - touch.pageX));
                }
            }
        }

        if (event.preventDefault) event.preventDefault();
        else return false;
    },
    selectorHelperMoveByTouch: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        var touch = event.touches[0];

        if (this.helperAppened) {

            var _helperPos = this.helperPos;
            var tmp,
                x1 = this.helperPos.x,
                y1 = this.helperPos.y,
                x2 = touch.pageX - _helperPos.bodyLeft,
                y2 = touch.pageY - _helperPos.bodyTop;
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({left: x1, top: y1, width: x2 - x1, height: y2 - y1});

            this._selectTargets.each(function () {

                var selectTarget = axdom.data(this, "selectableItem"), hit = false;
                /*trace({sl:selectTarget.left, sr:selectTarget.right, st:selectTarget.top, sb:selectTarget.bottom, x1:x1, x2:x2, y1:y1, y2:y2}); */
                if (!selectTarget) return;

                var stL = selectTarget.left.number(), stR = selectTarget.right.number(), stT = selectTarget.top.number(), stB = selectTarget.bottom.number();
                stL = stL + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stR = stR + _helperPos.stageX - _helperPos.scrollLeft - _helperPos.bodyLeft;
                stT = stT + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;
                stB = stB + _helperPos.stageY - _helperPos.scrollTop - _helperPos.bodyTop;

                hit = (!(stL > x2 || stR < x1 || stT > y2 || stB < y1));
                /* touch */
                /* hit = (selectTarget.left > x1 && selectTarget.right < x2 && selectTarget.top > y1 && selectTarget.bottom < y2); fit */
                if (hit) {
                    /* SELECT */
                    if (selectTarget.selected) {
                        selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                        selectTarget.selected = false;
                    }
                    if (!selectTarget.selecting) {
                        selectTarget.jQueryelement.addClass(cfg.selectingClassName);
                        selectTarget.selecting = true;
                    }
                } else {
                    /* UNSELECT */
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                    }
                    if (selectTarget.selected) {
                        if (!event.metaKey && !event.shiftKey && !event.ctrlKey) {
                            selectTarget.jQueryelement.removeClass(cfg.beselectClassName);
                            selectTarget.selected = false;
                        }
                    }
                }
            });

        } else {
            this.helperAppened = true;
            axdom(document.body).append(this.helper);

            var css = {left: (touch.pageX - axdom(document.body).offset().left), top: (touch.pageY - axdom(document.body).offset().top), width: 0, height: 0};
            this.helper.css(css);
            var stagePos = this._selectStage.offset();
            this.helperPos = {
                stageX: stagePos.left.number(),
                stageY: stagePos.top.number(),
                x: css.left.number(),
                y: css.top.number(),
                scrollLeft: this._selectStage.scrollLeft().number(),
                scrollTop: this._selectStage.scrollTop().number(),
                bodyLeft: axdom(document.body).offset().left,
                bodyTop: axdom(document.body).offset().top
            };
        }
    },
    touchEnd: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        this.helperAppenedReady = false;
        this.moveSens = 0;

        this.touchMode = false;

        if (document.removeEventListener) {
            document.removeEventListener("touchend", this.touchEndBind, false);
            document.removeEventListener("touchmove", this.touchMoveBind, false);
        }

        if (this.helperAppened) {
            this.helperAppened = false;
            this.helper.remove();

            /* selected change */
            this._selectTargets.each(function () {
                var selectTarget = axdom.data(this, "selectableItem");
                if (selectTarget) {
                    if (selectTarget.selecting) {
                        selectTarget.jQueryelement.removeClass(cfg.selectingClassName);
                        selectTarget.selecting = false;
                        selectTarget.jQueryelement.addClass(cfg.beselectClassName);
                        selectTarget.selected = true;
                    } else if (selectTarget.selected) {

                    }
                }
            });
        }
    },
    /**
     * @method AXMultiSelect.getSelects
     * @returns {Array} selects
     * @description 셀렉트된 아이템 엘리먼트 배열을 반환합니다. Return Array of selected item element
     * @example
     *```js
     * multiSelector.getSelects();
     *```
     */
    getSelects: function () {
        var cfg = this.config;
        var selects = [];
        this._selectTargets.each(function () {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selected) {
                    selects.push(selectTarget.element);
                }
            }
        });
        return selects;
    },
    size: function () {
        var cfg = this.config;
        var selects = [];
        this._selectTargets.each(function () {
            var selectTarget = axdom.data(this, "selectableItem");
            if (selectTarget) {
                if (selectTarget.selected) {
                    selects.push(selectTarget.element);
                }
            }
        });
        return selects.length;
    }
});
/* ---------------------------------------------- AXMultiSelect -- */

/* -- AXResizable ---------------------------------------------- */
/**
 * 아이템을 주어진 조건에 맞게 리사이즈 할 수 있는 클래스
 * @class AXResizable
 * @classdesc
 * @extends AXJ
 * @version v0.9
 * @author tom@axisj.com
 * @logs
 "2013-11-12 오전 10:22:06"
 */
var AXResizable = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.moveSens = 0;
        this.objects = [];

        this.config.moveSens = 2;
        this.config.bindResiableContainer = "AXResizable";
        this.config.bindResiableHandle = "AXResizableHandle";
    },
    /**
     * @method AXResizable.setConfig
     * @param {Object} config
     * @description targetID를 지정합니다. 인스턴스간에 구분을 할 수 있게 해줍니다.
     * @example
     ```js
     var AXResizableBinder = new AXResizable();
     AXResizableBinder.setConfig({ targetID: "defaultResiable" });
     ```
     */
    init: function () {
        this.helper = axdom("<div class='AXResizableHelper'></div>");
    },
    /**
     * @method AXResizable.bind
     * @param {Object} obj
     * @returns {AXResizable}
     * @example
     ```js
     var config = {
    id: {String} - Element ID,
    minWidth: {Number} [0],
    minHeight: {Number} [0],
	maxWidth: {Number} [0],
	maxHeight: {Number} [0],
	animate: {easing:"bounceOut", duration:500},
	aspectRatio: {Number} - 2/1,
	snap: {Number} - 10,
	onChange: function(){
		// this.id, this.element, this.jQueryElement, this.config
		toast.push(this.id);
	}
 };
     myResizer.bind(config);
     ```
     */
    bind: function (obj) {
        var cfg = this.config;
        if (!obj.id) {
            trace("bind 대상 ID가 없어 bind 처리할 수 없습니다.");
            return;
        }
        if (!AXgetId(obj.id)) {
            trace("bind 대상이 없어 bind 처리할 수 없습니다.");
            return;
        }
        var objID = obj.id;
        var objSeq = null;

        AXUtil.each(this.objects, function (idx, O) {
            /*if (this.id == objID && this.isDel == true) objSeq = idx;*/
            if (this.id == objID) {
                objSeq = idx;
            }
        });
        if (objSeq == null) {
            objSeq = this.objects.length;
            this.objects.push({
                id: objID,
                element: AXgetId(objID),
                jQueryElement: axdom("#" + objID),
                config: obj
            });
        } else {
            this.objects[objSeq].isDel = undefined;
            this.objects[objSeq].config = obj;
        }
        this.bindResizer(objID, objSeq);
        return this;
    },
    /**
     * @method AXResizable.unbind
     * @param {Object} obj
     * @returns {AXResizable}
     * @description 바인드 해제 합니다.
     * @example
     ```js
     myResizer.unbind({id:"ElementID"});
     ```
     */
    unbind: function (obj) {
        var cfg = this.config;
        var removeIdx;
        AXUtil.each(this.objects, function (idx, O) {
            if (O.id != obj.id) {
            } else {
                if (O.isDel != true) {
                    removeIdx = idx;
                }
            }
        });
        if (removeIdx != undefined) {
            this.objects[removeIdx].isDel = true;
            /* unbind 구문 */
        }
        return this;
    },
    bindResizer: function (objID, objSeq) {
        var _this = this;
        var cfg = this.config;

        var obj = this.objects[objSeq];

        var po = [];
        po.push("<div class=\"" + cfg.bindResiableHandle + "\"></div>");
        obj.jQueryElement.addClass(cfg.bindResiableContainer);
        obj.jQueryElement.append(po.join(''));

        //obj.jQueryElement.bind("mousedown.AXResizable", function(){_this.mousedown(objID, objSeq, event)});
        obj.jQueryElement.bind("mousedown.AXResizable", this.mousedown.bind(this, objID, objSeq));
    },
    mousedown: function (objID, objSeq, event) {
        var _this = this;
        var cfg = this.config;

        axdom(window).bind("mousemove.AXResizable", this.mousemove.bind(this, objID, objSeq));
        axdom(window).bind("mouseup.AXResizable", this.mouseup.bind(this, objID, objSeq));
        /*axdom(document.body).bind("mouseleave.AXResizable", this.mouseup.bind(this, objID, objSeq));*/

        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");

        this.helperAppenedReady = true;
    },
    mousemove: function (objID, objSeq, event) {
        var cfg = this.config;
        if (!event.pageX) return;

        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.selectorHelperMove(objID, objSeq, event);
    },
    mouseup: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        this.helperAppenedReady = false;
        this.moveSens = 0;

        axdom(window).unbind("mousemove.AXResizable");
        axdom(window).unbind("mouseup.AXResizable");
        /*axdom(document.body).unbind("mouseleave.AXResizable");*/

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");

        if (this.helperAppened) {
            this.helperAppened = false;

            var newWidth = this.helper.width();
            var newHeight = this.helper.height();

            var paddingLeft = obj.jQueryElement.css("padding-left");
            var paddingRight = obj.jQueryElement.css("padding-right");
            var paddingTop = obj.jQueryElement.css("padding-top");
            var paddingBottom = obj.jQueryElement.css("padding-bottom");
            var paddingW = paddingLeft.number() + paddingRight.number();
            var paddingH = paddingTop.number() + paddingBottom.number();

            if (obj.config.animate) {
                obj.jQueryElement.animate(
                    {width: newWidth - paddingW, height: newHeight - paddingH},
                    (obj.config.animate.duration || 300), (obj.config.animate.easing || "liner"),
                    function () {
                        if (obj.config.onChange) {
                            obj.config.onChange.call(obj, obj);
                        }
                    }
                );
            } else {
                obj.jQueryElement.css({width: newWidth - paddingW, height: newHeight - paddingH});
                if (obj.config.onChange) {
                    obj.config.onChange.call(obj, obj);
                }
            }

            this.helper.remove();
        }
    },
    selectorHelperMove: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (this.helperAppened) {

            var _helperPos = this.helperPos;
            var tmp,
                x1 = this.helperPos.x,
                y1 = this.helperPos.y,
                x2 = event.pageX - _helperPos.bodyLeft,
                y2 = event.pageY - _helperPos.bodyTop;

            var minWidth = (obj.config.minWidth || 0),
                minHeight = (obj.config.minHeight || 0),
                maxWidth = (obj.config.maxWidth || 0),
                maxHeight = (obj.config.maxHeight || 0);

            var myWidth = x2 - x1, myHeight = y2 - y1;

            if (minWidth != 0 && myWidth < minWidth) myWidth = minWidth;
            if (minHeight != 0 && myHeight < minHeight) myHeight = minHeight;
            if (maxWidth != 0 && myWidth > maxWidth) myWidth = maxWidth;
            if (maxHeight != 0 && myHeight > maxHeight) myHeight = maxHeight;

            if (obj.config.aspectRatio) {
                myWidth = myHeight * obj.config.aspectRatio;
            }

            if (obj.config.snap) {
                myWidth = obj.config.snap * (myWidth / obj.config.snap).ceil();
                myHeight = obj.config.snap * (myHeight / obj.config.snap).ceil();
            }
            //trace({width: myWidth, height: myHeight});
            this.helper.css({width: myWidth, height: myHeight});

        } else {
            this.helperAppened = true;
            axdom(document.body).append(this.helper);

            var bodyLeft = axdom(document.body).offset().left;
            var bodyTop = axdom(document.body).offset().top;

            var pos = obj.jQueryElement.offset();
            var css = {
                left: pos.left + bodyLeft,
                top: pos.top + bodyLeft,
                width: obj.jQueryElement.outerWidth(),
                height: obj.jQueryElement.outerHeight()
            };
            this.helper.css(css);

            this.helperPos = {
                x: css.left,
                y: css.top,
                bodyLeft: axdom(document.body).offset().left,
                bodyTop: axdom(document.body).offset().top
            };
        }
    }
});
var AXResizableBinder = new AXResizable();
AXResizableBinder.setConfig({targetID: "defaultResizable"});

/**
 * @method jQueryExtends.bindAXResizable
 * @param {Object} config
 * @returns {jQueryObject}
 * @description box 엘리먼트 크기를 조정할 수 있게 해줍니다.
 * @example
 ```js
 $("#mytarget").bindAXResizable({
	minWidth:50, minHeight:50,
	maxWidth:200, maxHeight:200,
	animate: {easing:"bounceOut", duration:500},
	aspectRatio: 2/1,
	snap:10,
	onChange: function(){
		toast.push(this.id);
	}
 });

 // 옵션 스펙
 var config = {
    minWidth: {Number} [0],
    minHeight: {Number} [0],
	maxWidth: {Number} [0],
	maxHeight: {Number} [0],
	animate: {easing:"bounceOut", duration:500},
	aspectRatio: {Number} - 2/1,
	snap: {Number} - 10,
	onChange: function(){
		// this.id, this.element, this.jQueryElement, this.config
		toast.push(this.id);
	}
 };

 ```
 */
axdom.fn.bindAXResizable = function (config) {
    AXUtil.each(this, function () {
        config = config || {};
        config.id = this.id;
        AXResizableBinder.bind(config);
        return this;
    });
    return this;
};

/**
 * @method jQueryExtends.unbindAXResizable
 * @param {Object} [config]
 * @returns {jQueryObject}
 * @description box 엘리먼트 크기를 조정자를 제거합니다.
 * @example
 ```js
 $("#mytarget").unbindAXResizable();
 ```
 */
axdom.fn.unbindAXResizable = function (config) {
    AXUtil.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXResizableBinder.unbind(config);
        return this;
    });
    return this;
};
/* ---------------------------------------------- AXResizable -- */

/* -- AXContextMenu ---------------------------------------------- */
/**
 * AXContextMenuClass
 * @class AXContextMenuClass
 * @extends AXJ
 * @version v1.28
 * @author tom@axisj.com, axisj.com
 * @logs
 "2013-03-22 오후 6:08:57",
 "2013-09-03 오후 7:10:14 메뉴확장 위치 제어 버그 픽스",
 "2013-12-16 href=javascript 설정했을 때 onbeforeunload 이벤트 충돌문제 해결",
 "2013-12-26 오후 4:27:00 tom, left, top position ",
 "2014-02-11 오전 11:06:13 root, subMenu underLine, upperLine add",
 "2014-04-07 오전 9:55:57 tom, extent checkbox, sortbox"
 "2014-06-24 tom : reserveKeys.subMenu 설정할 수 있도록 기능 보강, 콜백함수 개선"
 "2014-12-18 tom : onclose 속성을 추가 할 수 있도록 속성 추가
 "2014-12-22 tom : filter를 통과한 메뉴 아이템이 없을 경우 표시 안하도록 변경"
 "2015-01-22 tom : item false 이면 표시 안하도록 변경"
 "2015-02-26 tom : bind를 다시 할때 reserveKeys 초기화 버그 픽스"
 */

var AXContextMenuClass = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.showedItem = {};
        this.objects = [];
        this.config.theme = "AXContextMenu";
        this.config.width = "140";
        this.config.responsiveMobile = 0;
        /* 모바일 반응 너비 */
        this.config.reserveKeys = {
            subMenu: "subMenu"
        };
    },
    /**
     * @method AXContextMenuClass.setConfig
     * @param {Object} configs
     * @description 선언된 클래스를 사용하기 위해 속성을 정의합니다.
     * @example
     ```js
     var AXContextMenu = new AXContextMenuClass();
     AXContextMenu.setConfig({});
     ```
     */
    init: function () {

    },
    /**
     * @method AXContextMenuClass.bindSetConfig
     * @param {String} objID - object ID
     * @param {Object} configs - contentMenu config
     * @description contextmenu 오브젝트에 속성을 변경합니다.
     * @example
     ```js
     AXContextMenu.bindSetConfig("contenxt01", {});
     ```
     */
    bindSetConfig: function (objID, configs) {
        var findIndex = null;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == objID) {
                findIndex = index;
                return false;
            }
        });
        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        } else {
            var _self = this.objects[findIndex];
            axf.each(configs, function (k, v) {
                _self.config[k] = v;
            });
        }
    },
    /**
     * @method AXContextMenuClass.bind
     * @param {Object} obj - 컨텍스트메뉴 속성
     * @returns {AXContextMenuClass}
     * @description 컨텍스트메뉴를 선언하여 컨텍스트메뉴를 사용준비합니다. bind한 컨텍스트메뉴는 id로 open 할 수 있습니다.
     * @example
     ```js
     AXContextMenu.bind({
		id:"myContextMenu",
		theme:"AXContextMenu", // 선택항목
		width:"150", // 선택항목
		checkbox:"checkbox", // [checkbox|radio]
		sortbox:true,
		menu:[
			{
				label:'선택 1',
				checked:true,
				className: 'doc | docline | plus | minus | group | edit | copy | cut | paste | up | down | left | right | link | unlink | openall | closeall'
				onclick:function(){
					return false;
				}
			},
			{label:'선택 2', checked:true,
				subMenu:[
					{label:"하위메뉴1"},
					{label:"하위메뉴2",
						subMenu:[
							{label:"하위메뉴21"},
							{label:"하위메뉴22"}
						]
					},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"}
				]
			},
			{label:'선택 3', checked:true},
			{label:'선택 4', checked:false, sort:"asc"} // config 에 checkbox 가 있는데. menu에 onclick 가 없으면 체크박스 액션이 작동합니다.
		],
		onchange: function(){ // 체크박스 선택값이 변경 된 경우 호출 됩니다.
			trace(this.menu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		},
		onsort: function(){ // 정렬이 변경 된 경우 호출 됩니다.
			trace(this.sortMenu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		}
	});
     ```
     */
    bind: function (obj) {
        var cfg = this.config;
        if (!obj.id) {
            trace("ID가 없어 bind 처리할 수 없습니다. AXContentMenu.bind({id:'idValue'});");
            return;
        }
        var objSeq = null;
        axf.each(this.objects, function (idx, O) {
            if (this.id == obj.id) {
                objSeq = idx;
                return false;
            }
        });

        if (!obj.reserveKeys) {
            obj.reserveKeys = cfg.reserveKeys;
        }
        if (objSeq != null) {
            this.objects[objSeq] = obj;
            return this;
        }
        objSeq = this.objects.length;

        this.objects.push(obj);
        return this;
    },
    filter: function (objSeq, objID, myobj, menu) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (myobj.filter) {
            var sendObj = {
                menu: menu,
                sendObj: obj.sendObj
            };
            return myobj.filter.call(sendObj, objID);
        } else {
            return true;
        }
    },
    getSubMenu: function (parentID, objSeq, objID, myobj, subMenu, depth) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        var filter = this.filter.bind(this);
        var getSubMenu = this.getSubMenu.bind(this);
        var subMenuID = parentID + "_AX_subMenu";

        var href = (obj.href == undefined) ? cfg.href : obj.href;
        var po = [];
        po.push("<div id=\"" + subMenuID + "\" class=\"" + theme + "\" style=\"width:" + width + "px;left:" + (width.number() - 15) + "px;display:none;\">");
        AXUtil.each(subMenu, function (idx, menu) {
            if (filter(objSeq, objID, myobj, menu)) {
                if (menu.upperLine) po.push("<div class=\"hline\"></div>");
                var className = (menu.className) ? menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem " + className + hasSubMenu + "\" id=\"" + subMenuID + "_AX_" + depth + "_AX_" + idx + "\">");
                var checked = "";
                if (obj.checkbox) {
                    if (menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox" + checked + "' id=\"" + subMenuID + "_tool_AX_" + depth + "_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</span>");

                if (menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                po.push("</div>");
                po.push("</a>");
                menu.__axdomId = subMenuID + "_AX_" + depth + "_AX_" + idx;

                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push(getSubMenu(subMenuID + "_AX_" + depth + "_AX_" + idx, objSeq, objID, myobj, menu[obj.reserveKeys.subMenu], (depth + 1)));
                if (menu.underLine) po.push("<div class=\"hline\"></div>");
            }
        });
        po.push("</div>");
        return po.join('');
    },
    /**
     * @method AXContextMenuClass.open
     * @param {Object} myobj
     * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
     * @returns {AXContextMenuClass}
     * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
     * @example
     ```js
     AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

     AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
     ```
     */
    open: function (myobj, position) {
        var cfg = this.config;
        if (axf.clientWidth() < cfg.responsiveMobile) {
            this.mobileOpen(myobj, position);
        } else {
            this.deskTopOpen(myobj, position);
        }
        return this;
    },
    mobileOpen: function (myobj, position) {
        var cfg = this.config;
        var objSeq = null;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        var obj = this.objects[objSeq];
        var objID = obj.id;

        this.modal = new AXMobileModal();
        this.modal.setConfig({
            addClass: "",
            height: 388,
            width: 300,
            head: {
                //title:(myobj.title||AXConfig.AXContextMenu.title),
                close: {
                    onclick: function () {
                    }
                }
            },
            onclose: function () {
            }
        });

        var initMobileModalBind = this.initMobileModal.bind(this);
        var onLoad = function (modalObj) {
            initMobileModalBind(objID, objSeq, myobj, modalObj);
        };
        this.modal.open(null, onLoad);
        this.mobileMode = true;
    },
    initMobileModal: function (objID, objSeq, myobj, modalObj) { // 현재 선택된 모바일 메뉴를 오픈합니다.
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];
        this.mobileModalObj = {
            myobj: myobj,
            modalObj: modalObj
        }; // memo mobileModal
        if (myobj.sendObj) {
            obj.sendObj = myobj.sendObj;
        }
        var href = (obj.href == undefined) ? cfg.href : obj.href;
        var filter = this.filter.bind(this);

        var headPo = [];
        /* 현재 선택된 메뉴 선택 하는 기능구현 필요 */
        headPo.push('<a ' + href + ' class="AXContextMenuHome">home</a>');
        headPo.push('<span id="' + objID + '_AX_mobileMenuPrevBox"></span>');
        modalObj.modalHead.empty();
        modalObj.modalHead.append(headPo.join(''));

        modalObj.modalHead.find(".AXContextMenuHome").bind("click", function () {
            _this.initMobileModal(objID, objSeq, myobj, modalObj);
        });

        var styles = [];
        styles.push("height:339px;");
        var menuList = obj.menu;
        var po = [];
        po.push("<div id=\"" + objID + "_AX_containerBox\" class=\"AXContextMenuContainer\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + objID + "_AX_scroll\" class=\"AXContextMenuScroll\">");

        if (typeof obj.reserveKeys == "undefined") {
            obj.reserveKeys = cfg.reserveKeys;
        }

        axf.each(menuList, function (idx, menu) {
            if (menu && filter(objSeq, objID, myobj, menu)) {
                //if (menu.upperLine) po.push("<div class=\"hline\"></div>");
                var className = (menu.className) ? " " + menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + objID + "_AX_contextMenu_AX_" + 0 + "_AX_" + idx + "\">");

                var checked = "";
                if (obj.checkbox) {
                    if (menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox" + checked + "' id=\"" + objID + "_AX_contextMenuToolCheck_AX_" + 0 + "_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</label>");

                if (menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                if (obj.sortbox) {
                    var sortdirect = "";
                    if (menu.sort) {
                        sortdirect = " " + menu.sort.toString().lcase();
                    }
                    po.push("<div class=\"tool-sort" + sortdirect + "\" id=\"" + objID + "_AX_contextMenuToolSort_AX_" + 0 + "_AX_" + idx + "\"></div>");
                }
                po.push("</div>");
                po.push("</a>");

                menu.__axdomId = objID + "_AX_contextMenu_AX_0_AX_" + idx;
                //if (menu.underLine) po.push("<div class=\"hline\"></div>");
            }
        });
        po.push("</div>");
        po.push("</div>");

        modalObj.modalBody.empty();
        modalObj.modalBody.append(po.join(''));

        this.myUIScroll = new AXScroll();
        this.myUIScroll.setConfig({
            targetID: objID + "_AX_containerBox",
            scrollID: objID + "_AX_scroll"
        });

        var contextMenuItemClick = this.contextMenuItemClick.bind(this);
        var closeMobileModal = this.closeMobileModal.bind(this);
        this.contextMenuItemClickBind = function (event) {
            contextMenuItemClick(event, objSeq, objID);
            //closeMobileModal();
        };
        modalObj.modalBody.find(".contextMenuItem").bind("click", this.contextMenuItemClickBind);
    },

    mobileModalSubMenu: function (parentID, objSeq, objID, myobj, modalObj, pMenu, depth) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];
        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        var filter = this.filter.bind(this);
        var mobileModalSubMenu = this.mobileModalSubMenu.bind(this);
        var subMenuID = parentID + "_AX_subMenu";

        var href = (obj.href == undefined) ? cfg.href : obj.href;

        var poi = parentID.split(/_AX_/g);
        var pdepth = poi[poi.length - 2].number();
        /*
         if(pdepth == 0) {
         this.mobileModalObj.previousMenu = "root";
         this.mobileModalObj.nowMenu = pMenu.__axdomId;
         }else{
         this.mobileModalObj.previousMenu = this.mobileModalObj.nowMenu;
         this.mobileModalObj.nowMenu = pMenu.__axdomId;
         }
         */
        //trace(axdom("#" + objID + "_AX_mobileMenuPrevBox").get(0));
        axdom("#" + objID + "_AX_mobileMenuPrevBox").html('<a class="AXContextMenuPrev" id="' + objID + '_AX_prev_AX_' + poi.join("_") + '">' + pMenu.label + '</a>');

        axdom("#" + objID + '_AX_prev_AX_' + poi.join("_")).bind("click", function () {
            if (pdepth == 0) {
                _this.initMobileModal(objID, objSeq, myobj, modalObj);
            } else {
                var poi = pMenu.__axdomId.split(/_AX_/g);
                var _depth = poi[poi.length - 2].number();
                var hashs = [];

                var mystrPosition = poi.length - 1;
                for (var r = 0; r < depth + 1; r++) {
                    if (!isNaN(poi[mystrPosition])) hashs.push(poi[mystrPosition]);
                    mystrPosition -= 3;
                }
                hashs = hashs.reverse();
                hashs.pop();
                var menu = obj.menu;
                for (var hash, idx = 0, __arr = hashs; (idx < __arr.length && (hash = __arr[idx])); idx++) {
                    if (idx == 0) menu = menu[hash];
                    else menu = menu[obj.reserveKeys.subMenu][hash];
                }
                _this.mobileModalSubMenu(menu.__axdomId, objSeq, objID, _this.mobileModalObj.myobj, _this.mobileModalObj.modalObj, menu, (depth - 1));
            }
        });

        var styles = [];
        styles.push("height:339px;");
        var menuList = pMenu[obj.reserveKeys.subMenu];
        var po = [];
        po.push("<div id=\"" + objID + "_AX_containerBox\" class=\"AXContextMenuContainer\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + objID + "_AX_scroll\" class=\"AXContextMenuScroll\">");
        axf.each(menuList, function (idx, menu) {
            if (menu && filter(objSeq, objID, myobj, menu)) {
                var className = (menu.className) ? " " + menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + subMenuID + "_AX_" + depth + "_AX_" + idx + "\">");

                var checked = "";
                if (obj.checkbox) {
                    if (menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox" + checked + "' id=\"" + subMenuID + "_AX_contextMenuToolCheck_AX_" + depth + "_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</label>");

                if (menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                if (obj.sortbox) {
                    var sortdirect = "";
                    if (menu.sort) {
                        sortdirect = " " + menu.sort.toString().lcase();
                    }
                    po.push("<div class=\"tool-sort" + sortdirect + "\" id=\"" + subMenuID + "_AX_contextMenuToolSort_AX_" + depth + "_AX_" + idx + "\"></div>");
                }
                po.push("</div>");

                po.push("</a>");

                menu.__axdomId = subMenuID + "_AX_" + depth + "_AX_" + idx;
            }
        });
        po.push("</div>");
        po.push("</div>");

        modalObj.modalBody.empty();
        modalObj.modalBody.append(po.join(''));

        this.myUIScroll = new AXScroll();
        this.myUIScroll.setConfig({
            targetID: objID + "_AX_containerBox",
            scrollID: objID + "_AX_scroll"
        });

        var contextMenuItemClick = this.contextMenuItemClick.bind(this);
        var closeMobileModal = this.closeMobileModal.bind(this);
        this.contextMenuItemClickBind = function (event) {
            contextMenuItemClick(event, objSeq, objID);
            //closeMobileModal();
        };
        modalObj.modalBody.find(".contextMenuItem").bind("click", this.contextMenuItemClickBind);
    },

    closeMobileModal: function () {
        var cfg = this.config;
        this.modal.close();
    },
    deskTopOpen: function (myobj, position) {
        var cfg = this.config;
        var objSeq = null;
        this.mobileMode = false;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        var obj = this.objects[objSeq];
        var objID = obj.id;

        if (myobj.sendObj) {
            obj.sendObj = myobj.sendObj;
        }

        if (AXgetId(objID)) return;

        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        axdom("#" + objID).remove();

        var href = (obj.href == undefined) ? cfg.href : obj.href;

        var filter = this.filter.bind(this);
        var getSubMenu = this.getSubMenu.bind(this);

        var displayMenuCount = 0;
        var po = [];
        po.push("<div id=\"" + objID + "\" class=\"" + theme + "\" style=\"width:" + width + "px;\">");
        AXUtil.each(obj.menu, function (idx, menu) {
            if (menu && filter(objSeq, objID, myobj, menu)) {

                if (menu.upperLine) {
                    po.push("<div class=\"hline\"></div>");
                }
                var className = (menu.className) ? " " + menu.className : "";
                var hasSubMenu = (menu[obj.reserveKeys.subMenu]) ? " hasSubMenu" : "";
                po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + objID + "_AX_contextMenu_AX_0_AX_" + idx + "\">");
                var checked = "";
                if (obj.checkbox) {
                    if (menu.checked) checked = " on";
                    po.push("<div class='tool-checkbox" + checked + "' id=\"" + objID + "_AX_contextMenuTool_AX_0_AX_" + idx + "\"></div>");
                }

                po.push("<span class='label'>" + menu.label + "</span>");

                if (menu.shotCut) po.push("<span class='shot-cut'>" + menu.shotCut + "</span>");

                po.push("<div class='tool-rightGroup'>");
                if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0) po.push("<div class=\"contextSubMenuIcon\"></div>");
                if (obj.sortbox)  po.push("<div class=\"tool_sort desc\"></div>");
                po.push("</div>");
                po.push("</a>");

                menu.__axdomId = objID + "_AX_contextMenu_AX_0_AX_" + idx;

                if (menu[obj.reserveKeys.subMenu]) {
                    if (menu[obj.reserveKeys.subMenu].length > 0) {
                        po.push(getSubMenu(objID + "_AX_contextMenu_AX_0_AX_" + idx, objSeq, objID, myobj, menu[obj.reserveKeys.subMenu], 1));
                    }
                }
                if (menu.underLine) {
                    po.push("<div class=\"hline\"></div>");
                }
                displayMenuCount++;
            }
        });
        po.push("</div>");

        if (displayMenuCount == 0) {
            // 표시할 메뉴가 없음.
            return false;
        }
        axdom(document.body).append(po.join(''));

        axdom("#" + objID + " .contextMenuItem:first-child").addClass("first");
        axdom("#" + objID + " .contextMenuItem:last-child").addClass("last");

        var contextMenuItemMouseOver = this.contextMenuItemMouseOver.bind(this);
        this.contextMenuItemMouseOverBind = function (event) {
            contextMenuItemMouseOver(event, objSeq, objID);
        };
        axdom("#" + objID + " .contextMenuItem").bind("mouseover", this.contextMenuItemMouseOverBind);

        //컨텍스트 메뉴의 위치 지정
        var css = {};
        if (!position.clientX) {
            if (position.left != undefined) css.left = position.left;
            else css.right = position.right;
            css.top = position.top;
        } else {
            var mouse = this.getMousePositon(position);
            css.left = mouse.pageX;
            css.top = mouse.pageY;
        }

        // -- 부모박스 정보와 박스 정보
        var pElement = axdom("#" + objID).offsetParent();
        var pBox = {width: pElement.width(), height: pElement.height()};
        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = {width: axdom("#" + objID).outerWidth(), height: axdom("#" + objID).outerHeight()};
        // -- 부모박스 정보와 박스 정보

        if ((_box.height.number() + css.top.number()) > pBox.height) {
            css.top -= ((_box.height.number() + css.top.number()) - pBox.height) + 25;
            this.openTB = "up";
            if (css.top < 0) css.top = 0;
        }

        if (css.left != undefined) {

            if ((_box.width.number() + css.left.number()) > pBox.width) {
                var moveLeft = ((_box.width.number() + css.left.number()) - pBox.width) + 25;
                css.left -= moveLeft;
                this.openLR = "left";
            } else {
                if ((_box.width.number() * 2 + css.left.number()) > pBox.width) {
                    this.openLR = "left";
                }
            }

            /*
             if((_box.width.number() + css.left.number()) > pBox.width){
             css.left -= ((_box.width.number() + css.left.number()) - pBox.width) + 5;
             this.openLR = "left";
             }
             */
        } else {
            css.left = "auto";
            this.openLR = "right";
        }
        axdom("#" + objID).css(css);

        this.eventBind(objSeq, objID);
    },
    eventBind: function (objSeq, objID) {
        var cfg = this.config;
        /* closeEvent bind */
        var contextMenuItemDown = this.contextMenuItemDown.bind(this);
        var contextMenuItemDownBind = function (event) {
            contextMenuItemDown(event, objSeq, objID);
        };

        axdom(document).bind("mousedown.AXContenxtMenu", contextMenuItemDownBind);
        axdom(document).bind("keydown.AXContenxtMenu", contextMenuItemDownBind);

        axdom(document).find("iframe").each(function () {
            try {
                axdom(window[this.name].document).bind("mousedown.AXContenxtMenu", contextMenuItemDownBind);
                axdom(window[this.name].document).bind("keydown.AXContenxtMenu", contextMenuItemDownBind);
            } catch (e) {

            }
        });

        /* closeEvent bind ~~~~~~~~~~~~~~~~~~~ */
        //click
        var contextMenuItemClick = this.contextMenuItemClick.bind(this);
        this.contextMenuItemClickBind = function (event) {
            contextMenuItemClick(event, objSeq, objID);
        };
        axdom("#" + objID).find(".contextMenuItem").bind("click", this.contextMenuItemClickBind);
    },
    // 이벤트로 인한 닫기
    _close: function (objSeq, objID) {
        var cfg = this.config,
            obj = this.objects[objSeq],
            that = {id: obj.id, event_type: "event"};

        if (this.mobileMode) {
            this.closeMobileModal();
        } else {
            axdom("#" + objID).fadeOut("fast", function () {
                axdom("#" + objID).remove();
            });
        }

        axdom(document).unbind("keydown.AXContenxtMenu");
        axdom(document).unbind("mousedown.AXContenxtMenu");

        axdom(document).find("iframe").each(function () {
            if (window[this.name]) {
                axdom(window[this.name].document).unbind("mousedown.AXContenxtMenu");
                axdom(window[this.name].document).unbind("keydown.AXContenxtMenu");
            }
        });

        this.showedItem = {}; // 초기화
        this.openTB = "";
        this.openLR = "";

        if (obj.onclose) {
            obj.onclose.call(that);
        }
    },
    /**
     * @method AXContextMenuClass.close
     * @param {Object} obj
     * @returns {AXContextMenuClass}
     * @description 열린 컨텍스트메뉴 개체를 닫습니다.
     * @example
     ```js
     AXContextMenu.close({
	id:"myContextMenuTree"
});
     ```
     */
    close: function (myobj) {
        var cfg = this.config,
            objSeq = null;

        axf.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }

        var obj = this.objects[objSeq], objID = obj.id,
            that = {id: obj.id, event_type: "script"};

        if (this.mobileMode) {
            this.closeMobileModal();
        } else {
            axdom("#" + objID).fadeOut("fast", function () {
                axdom("#" + objID).remove();
            });
        }

        axdom(document).unbind("keydown", this.contextMenuItemDownBind);
        axdom(document).unbind("mousedown", this.contextMenuItemDownBind);

        this.showedItem = {}; // 초기화
        this.openTB = "";
        this.openLR = "";

        if (obj.onclose) {

        }

        return this;
    },
    contextMenuItemMouseOver: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var menuWidth = obj.width || cfg.width;
        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("contextMenuItem")) ? true : false;
            }
        });
        // event target search ------------------------
        if (myTarget) {
            var poi = myTarget.id.split(/_AX_/g);
            var depth = poi[poi.length - 2];
            if (this.showedItem[depth]) {
                axdom("#" + this.showedItem[depth]).hide();
            }
            if (axdom(myTarget).hasClass("hasSubMenu")) {

                // -- 부모박스 정보와 박스 정보
                var pElement = axdom("#" + myTarget.id + "_AX_subMenu").offsetParent();
                var pBox = {width: pElement.width(), height: pElement.height()};
                var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
                var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
                if (clienWidth > pBox.width) pBox.width = clienWidth;
                if (clientHeight > pBox.height) pBox.height = clientHeight;
                var _box = {width: axdom("#" + myTarget.id + "_AX_subMenu").outerWidth(), height: axdom("#" + myTarget.id + "_AX_subMenu").outerHeight()};
                // -- 부모박스 정보와 박스 정보

                var subMenuTop = axdom("#" + myTarget.id).position().top;

                var css;
                if (this.openTB == "up") {
                    var ph = axdom("#" + myTarget.id).offsetParent().height();
                    var h = axdom("#" + myTarget.id).height();
                    var bottom = ph - subMenuTop - h;
                    css = {top: "auto", bottom: bottom};
                } else {
                    css = {top: subMenuTop};
                }
                if (this.openLR == "left") {
                    //css.left = -(menuWidth - 15);
                    css.left = -(20);
                }

                axdom("#" + myTarget.id + "_AX_subMenu").css(css);
                axdom("#" + myTarget.id + "_AX_subMenu").show();

                this.showedItem[depth] = myTarget.id + "_AX_subMenu";
            }
        }
    },
    contextMenuItemDown: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            this._close(objSeq, objID, event);
            return;
        }

        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("contextMenuItem")) ? true : false;
            }
        });
        // event target search ------------------------

        if (myTarget) {

        } else {
            this._close(objSeq, objID, event);
        }
    },
    contextMenuItemClick: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("contextMenuItem") || axdom(evt).hasClass("tool-checkbox") || axdom(evt).hasClass("tool-sort")) ? true : false;
            }
        });
        // event target search ------------------------

        if (myTarget) {

            var poi = myTarget.id.split(/_AX_/g);
            var depth = poi[poi.length - 2].number();
            var hashs = [];

            var mystrPosition = poi.length - 1;
            for (var r = 0; r < depth + 1; r++) {
                hashs.push(poi[mystrPosition]);
                mystrPosition -= 3;
            }
            hashs = hashs.reverse();

            var menu = obj.menu;
            for (var hash, idx = 0, __arr = hashs; (idx < __arr.length && (hash = __arr[idx])); idx++) {
                if (idx == 0) menu = menu[hash];
                else menu = menu[obj.reserveKeys.subMenu][hash];
            }

            if (menu[obj.reserveKeys.subMenu] && menu[obj.reserveKeys.subMenu].length > 0 && this.mobileMode) {
                //this.initMobileModal(objID, objSeq, this.mobileModalObj.myobj, this.mobileModalObj.modalObj, (depth+1), menu.subMenu);
                this.mobileModalSubMenu(myTarget.id, objSeq, objID, this.mobileModalObj.myobj, this.mobileModalObj.modalObj, menu, (depth + 1));
                return false;
            }

            if (axdom(myTarget).hasClass("tool-checkbox")) {
                menu.checked = !menu.checked;
                axdom("#" + menu.__axdomId).find(".tool-checkbox").toggleClass("on");

                if (obj.onchange) {
                    obj.onchange.call({menu: obj.menu, clickMenu: menu, sendObj: obj.sendObj}, objID);
                }
                return true;
            }

            if (axdom(myTarget).hasClass("tool-sort")) {

                // 다른 메뉴들은 모두 정렬 헤제
                for (var M, midx = 0, __arr = obj.menu; (midx < __arr.length && (M = __arr[midx])); midx++) {
                    if (menu != M) {
                        M.sort = undefined;
                        axdom("#" + M.__axdomId).find(".tool-sort").removeClass("asc").removeClass("desc");
                    }
                }


                if (menu.sort == undefined) menu.sort = "";
                if (menu.sort.toString().lcase() == "asc") {
                    axdom("#" + menu.__axdomId).find(".tool-sort").removeClass("asc").addClass("desc");
                    menu.sort = "desc";
                } else if (menu.sort.toString().lcase() == "desc") {
                    axdom("#" + menu.__axdomId).find(".tool-sort").removeClass("desc").addClass("asc");
                    menu.sort = "asc";
                } else {
                    axdom("#" + menu.__axdomId).find(".tool-sort").addClass("desc");
                    menu.sort = "desc";
                }

                if (obj.onsort) {
                    if (obj.onsort.call({menu: obj.menu, sortMenu: menu, sendObj: obj.sendObj}, objID) != true) {
                        this._close(objSeq, objID, event);
                    }
                }
                return true;
            }

            if (menu.onclick) {
                if (menu.onclick.call({menu: menu, sendObj: obj.sendObj}, objID) != true) {
                    this._close(objSeq, objID, event);
                }
                return true;
            } else if (obj.onchange) { // 라벨 선택 할 때. 정렬항목도 없는 경우만 체크 모드로 연결
                menu.checked = !menu.checked;
                axdom("#" + menu.__axdomId).find(".tool-checkbox").toggleClass("on");

                if (obj.onchange) {
                    if (obj.onchange.call({menu: obj.menu, clickMenu: menu, sendObj: obj.sendObj}, objID) != true) {
                        this._close(objSeq, objID, event);
                    }
                }
                return true;
            }
        }
    }
});

var AXContextMenu = new AXContextMenuClass();
AXContextMenu.setConfig({});

/**
 * @namespace AXContextMenu
 * @description AXContextMenu 오브젝트는 AXContextMenuClass 를 이용하여 AXJ에서 미리 선언한 인스턴스입니다.
 * AXContentMenu와 같이 사용할 때마다 new를 하지 않고 사용되는 UI들은 AXJ에서 미리 선언해두고 있습니다.
 */
/**
 * @method AXContextMenu.bindSetConfig
 * @param {String} objID - object ID
 * @param {Object} configs - contentMenu config
 * @description contextmenu 오브젝트에 속성을 변경합니다.
 * @example
 ```js
 AXContextMenu.bindSetConfig("contenxt01", {});
 ```
 */
/**
 * @method AXContextMenu.bind
 * @param {Object} obj - 컨텍스트메뉴 속성
 * @returns {AXContextMenu}
 * @description 컨텍스트메뉴를 선언하여 컨텍스트를 메뉴를 사용준비합니다. bind한 컨텍스트 메뉴는 id로 open 할 수 있습니다.
 * @example
 ```js
 AXContextMenu.bind({
		id:"myContextMenu",
		theme:"AXContextMenu", // 선택항목
		width:"150", // 선택항목
		checkbox:"checkbox", // [checkbox|radio]
		sortbox:true,
		menu:[
			{label:'선택 1', checked:true, onclick:function(){
				return false;
			}},
			{label:'선택 2', checked:true,
				subMenu:[
					{label:"하위메뉴1"},
					{label:"하위메뉴2",
						subMenu:[
							{label:"하위메뉴21"},
							{label:"하위메뉴22"}
						]
					},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"},
					{label:"하위메뉴3"}
				]
			},
			{label:'선택 3', checked:true},
			{label:'선택 4', checked:false, sort:"asc"} // config 에 checkbox 가 있는데. menu에 onclick 가 없으면 체크박스 액션이 작동합니다.
		],
		onchange: function(){ // 체크박스 선택값이 변경 된 경우 호출 됩니다.
			trace(this.menu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		},
		onsort: function(){ // 정렬이 변경 된 경우 호출 됩니다.
			trace(this.sortMenu);

			// return true; 메뉴 창이 닫히지 않게 합니다.
		}
	});
 ```
 */
/**
 * @method AXContextMenu.open
 * @param {Object} myobj
 * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
 * @returns {AXContextMenu}
 * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
 * @example
 ```js
 AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

 AXContextMenu.open({
	id:"myContextMenuTree", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
 ```
 */
/**
 * @method AXContextMenu.close
 * @param {Object} obj
 * @returns {AXContextMenu}
 * @description 열린 컨텍스트메뉴 개체를 닫습니다.
 * @example
 ```js
 AXContextMenu.close({
	id:"myContextMenuTree"
});
 ```
 */


/**
 * @class AXPopOverClass
 * @extends AXContextMenuClass
 * @version v1.0
 * @author tom@axisj.com, axisj.com
 * @description AXContextMenuClass를 상속하여 만들어진 클래스로 마우스 오버이벤트에 최적화 됨
 * @example
 ```js
 var AXPopOver = new AXPopOverClass();
 AXPopOver.setConfig({ theme: "AXPopOver" });
 ```
 */
var AXPopOverClass = Class.create(AXContextMenuClass, {
    /**
     * @method AXPopOverClass.bind
     * @param {Object} obj 팝오버메뉴 속성
     * @returns AXPopOverClass
     * @description 팝오버메뉴를 선언하여 팝오버 메뉴를 사용준비합니다. bind한 팝오버메뉴는 id로 open 할 수 있습니다.
     * @example
     ```js
     AXPopOver.bind({
	id:"myPopOver",
	theme:"AXPopOver", // 선택항목
	width:"200", // 선택항목
	menu:[
		{userType:0, label:"Friends", className:"groupName"},
		{userType:0, label:"Invite friends", className:"", onclick:function(){}},
		{userType:0, label:"Find friends", className:"", onclick:function(){}},
		{userType:0, label:"Photo", className:"groupName"},
		{userType:0, label:"Cut", className:"", onclick:function(){}},
		{userType:0, label:"Roll", className:"", onclick:function(){}},
		{userType:0, label:"Equipment", className:"groupName"},
		{userType:0, label:"Setting", className:""},
		{userType:0, label:"Screen", className:"", onclick:function(){}},
		{userType:0, label:"Securities", className:"groupName"},
		{userType:0, label:"Account", className:"", onclick:function(){}},
		{userType:0, label:"Logout", className:"", onclick:function(){}},
	]
});

     $("#popoverBtn1").bind("mouseover", function(){
	var pos = $(this).offset();
	AXPopOver.open({
		id:"myPopOver", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}},
		{left:pos.left-60, top:pos.top+30}
	);
});
     ```
     */

    /**
     * @method AXPopOverClass.open
     * @param {Object} myobj
     * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
     * @returns {AXPopOverClass}
     * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
     * @example
     ```js
     AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

     AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
     ```
     */

    /**
     * @method AXPopOverClass.close
     * @param {Object} obj
     * @returns {AXPopOverClass}
     * @description 열린 팝오버메뉴 개체를 닫습니다.
     * @example
     ```js
     AXPopOver.close({
	id:"myPopOver"
});
     ```
     */
    open: function (myobj, position) {
        var cfg = this.config;
        var objSeq = null;
        AXUtil.each(this.objects, function (index, O) {
            if (O.id == myobj.id) {
                objSeq = index;
                //return false;
            } else {
                axdom("#" + O.id).remove();
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }

        var obj = this.objects[objSeq];
        var objID = obj.id;

        if (myobj.sendObj) {
            obj.sendObj = myobj.sendObj;
        }

        if (this.observer) clearTimeout(this.observer); //닫기 명령 제거
        var direction = obj.direction || "top";

        if (AXgetId(objID)) {
            if (position.clientX) {
                this.contentMenuSetCss(event, position, objSeq, objID);
            }
            return;
        }

        var theme = obj.theme || cfg.theme;
        var width = obj.width || cfg.width;

        //컨텍스트 메뉴의 위치 지정

        var arrowStyle = "";
        if (position.clientX) {
            arrowStyle = "background-position:10px 0px;"
        } else {
            if (position.arrowLeft) arrowStyle = "background-position:" + position.arrowLeft + "px 0px;"
        }

        axdom("#" + objID).remove();

        var href = (obj.href == undefined) ? cfg.href : obj.href;

        var filter = this.filter.bind(this);
        var getSubMenu = this.getSubMenu.bind(this);
        var po = [];
        po.push("<div id=\"" + objID + "\" class=\"" + theme + "\" style=\"width:" + width + "px;\">");
        po.push("<div class=\"arrowTop\" style=\"" + arrowStyle + "\"></div>");
        po.push("<div class=\"arrowBottom\" style=\"" + arrowStyle + "\"></div>");
        po.push("<div class=\"blockContainer\">");
        if (obj.menu) {
            AXUtil.each(obj.menu, function (idx, menu) {
                if (!menu) return false;
                if (filter(objSeq, objID, myobj, menu)) {
                    if (menu.upperLine) {
                        po.push("<div class=\"hline\"></div>");
                    }
                    var className = (menu.className) ? " " + menu.className : "";
                    var hasSubMenu = (menu.subMenu) ? " hasSubMenu" : "";
                    po.push("<a " + href + " class=\"contextMenuItem" + className + hasSubMenu + "\" id=\"" + objID + "_AX_contextMenu_AX_0_AX_" + idx + "\">");
                    po.push(menu.label);
                    if (menu.subMenu) {
                        if (menu.subMenu.length > 0) {
                            po.push("<div class=\"contextSubMenuIcon\"></div>");
                        }
                    }
                    po.push("</a>");
                    if (menu.subMenu) {
                        if (menu.subMenu.length > 0) {
                            po.push(getSubMenu(objID + "_AX_contextMenu_AX_0_AX_" + idx, objSeq, objID, myobj, menu.subMenu, 1));
                        }
                    }
                    if (menu.underLine) {
                        po.push("<div class=\"hline\"></div>");
                    }
                }
            });
        } else if (obj.body) {
            po.push("<div class=\"contextMenuBody\">");
            po.push(obj.body);
            po.push("</div>");
        }
        po.push("</div>");
        po.push("</div>");
        axdom(document.body).append(po.join(''));

        if (direction == "top") {
            axdom("#" + objID).find(".arrowTop").show();
            axdom("#" + objID).find(".arrowBottom").hide();
        } else if (direction == "bottom") {
            axdom("#" + objID).find(".arrowTop").hide();
            axdom("#" + objID).find(".arrowBottom").show();
        } else {
            axdom("#" + objID).find(".arrowTop").show();
            axdom("#" + objID).find(".arrowBottom").hide();
        }

        axdom("#" + objID + " .contextMenuItem:first-child").addClass("first");
        axdom("#" + objID + " .contextMenuItem:last-child").addClass("last");

        var contextMenuItemMouseOver = this.contextMenuItemMouseOver.bind(this);
        this.contextMenuItemMouseOverBind = function (event) {
            contextMenuItemMouseOver(event, objSeq, objID);
        };
        var contextMenuMouseOut = this.contextMenuMouseOut.bind(this);
        this.contextMenuMouseOutBind = function (event) {
            contextMenuMouseOut(event, objSeq, objID);
        };

        var eventClear = function () {
            if (this.observer) clearTimeout(this.observer); //닫기 명령 제거
        }
        axdom("#" + objID + " .contextMenuItem").bind("mouseover", this.contextMenuItemMouseOverBind);
        axdom("#" + objID).bind("mouseover", eventClear.bind(this));
        axdom("#" + objID).bind("mouseout", this.contextMenuMouseOutBind);

        this.contentMenuSetCss(null, position, objSeq, objID);

        //var eventBind = this.eventBind.bind(this);
        this.eventBind(objSeq, objID);
        //setTimeout(function(){}, 1);

        return this;
    },
    contentMenuSetCss: function (event, position, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var direction = obj.direction || "top";
        var css = {};

        if (!position.clientX) {
            if (position.left != undefined) {
                css.left = position.left;
            } else {
                css.left = "auto";
                css.right = position.right;
            }
            css.top = position.top;
        } else {
            var mouse = this.getMousePositon(position);
            obj.eventPosition = true;
            css.left = mouse.pageX;
            css.left -= 20;
            css.top = mouse.pageY;
        }
        // -- 부모박스 정보와 박스 정보
        var pElement = axdom("#" + objID).offsetParent();
        var pBox = {width: pElement.width(), height: pElement.height()};
        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = {width: axdom("#" + objID).outerWidth(), height: axdom("#" + objID).outerHeight()};
        // -- 부모박스 정보와 박스 정보
        var openTB = "";
        if (direction == "top") {
            openTB = "top";
        } else if (direction == "bottom") {
            css.top -= axdom("#" + objID).outerHeight();
            openTB = "bottom";
        } else {
            if ((_box.height.number() + css.top.number()) > pBox.height) {
                css.top = css.top - _box.height.number() - position.handleHeight - 3;
                axdom("#" + objID).find(".arrowTop").hide();
                axdom("#" + objID).find(".arrowBottom").show();
                //css.top -= ((_box.height.number() + css.top.number()) - pBox.height) + 5;
                openTB = "bottom";
            } else {
                axdom("#" + objID).find(".arrowTop").show();
                axdom("#" + objID).find(".arrowBottom").hide();
                openTB = "top";
            }
        }

        if (css.left != undefined) {
            if ((_box.width.number() + css.left.number()) > pBox.width) {
                var moveLeft = ((_box.width.number() + css.left.number()) - pBox.width) + 5;
                css.left -= moveLeft;
                if (openTB == "top") {
                    axdom("#" + objID).find(".arrowTop").css({"background-position": (moveLeft + 5) + "px 0px;"});
                } else {
                    axdom("#" + objID).find(".arrowBottom").css({"background-position": (moveLeft + 5) + "px 0px;"});
                }
            } else {

            }
        } else {

        }
        axdom("#" + objID).css(css);
    },
    contextMenuItemMouseOver: function (event, objSeq, objID) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (this.observer) clearTimeout(this.observer); //닫기 명령 제거

        var menuWidth = obj.width || cfg.width;
        // event target search -
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("contextMenuItem")) ? true : false;
            }
        });
        // event target search ------------------------
        if (myTarget) {
            var poi = myTarget.id.split(/_AX_/g);
            var depth = poi[poi.length - 2];
            if (this.showedItem[depth]) {
                axdom("#" + this.showedItem[depth]).hide();
            }
            if (axdom(myTarget).hasClass("hasSubMenu")) {
                var subMenuTop = axdom("#" + myTarget.id).position().top;
                var css;
                if (this.openTB == "up") {
                    var ph = axdom("#" + myTarget.id).offsetParent().height();
                    var h = axdom("#" + myTarget.id).height();
                    var bottom = ph - subMenuTop - h;
                    css = {top: "auto", bottom: bottom};
                } else {
                    css = {top: subMenuTop};
                }
                if (this.openLR == "left") {
                    //css.left = -(menuWidth - 15);
                    css.left = -(20);
                }
                axdom("#" + myTarget.id + "_AX_subMenu").css(css);
                axdom("#" + myTarget.id + "_AX_subMenu").show();

                this.showedItem[depth] = myTarget.id + "_AX_subMenu";
            }
        }
    },
    contextMenuMouseOut: function (event, objSeq, objID) {
        var close = this._close.bind(this);
        this.observer = setTimeout(function () {
            close(objSeq, objID);
        }, 200);
    }
});
var AXPopOver = new AXPopOverClass();
AXPopOver.setConfig({theme: "AXPopOver"});

/**
 * @namespace AXPopOver
 * @description AXPopOver 오브젝트는 AXPopOverClass 를 이용하여 AXJ에서 미리 선언한 인스턴스입니다.
 * AXPopOver 같이 사용할 때마다 new를 하지 않고 사용되는 UI들은 AXJ에서 미리 선언해두고 있습니다.
 */
/**
 * @method AXPopOver.bindSetConfig
 * @param {String} objID - object ID
 * @param {Object} configs contentMenu config
 * @description contextmenu 오브젝트에 속성을 변경합니다.
 * @example
 ```js
 AXPopOver.bindSetConfig("popover01", {});
 ```
 */
/**
 * @method AXPopOver.bind
 * @param {Object} obj - 컨텍스트메뉴 속성
 * @returns {AXPopOver}
 * @description 컨텍스트메뉴를 선언하여 컨텍스트를 메뉴를 사용준비합니다. bind한 컨텍스트 메뉴는 id로 open 할 수 있습니다.
 * @example
 ```js
 AXPopOver.bind({
	id:"myPopOver",
	theme:"AXPopOver", // 선택항목
	width:"200", // 선택항목
	menu:[
		{userType:0, label:"Friends", className:"groupName"},
		{userType:0, label:"Invite friends", className:"", onclick:function(){}},
		{userType:0, label:"Find friends", className:"", onclick:function(){}},
		{userType:0, label:"Photo", className:"groupName"},
		{userType:0, label:"Cut", className:"", onclick:function(){}},
		{userType:0, label:"Roll", className:"", onclick:function(){}},
		{userType:0, label:"Equipment", className:"groupName"},
		{userType:0, label:"Setting", className:""},
		{userType:0, label:"Screen", className:"", onclick:function(){}},
		{userType:0, label:"Securities", className:"groupName"},
		{userType:0, label:"Account", className:"", onclick:function(){}},
		{userType:0, label:"Logout", className:"", onclick:function(){}},
	]
});

 $("#popoverBtn1").bind("mouseover", function(){
	var pos = $(this).offset();
	AXPopOver.open({
		id:"myPopOver", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}},
		{left:pos.left-60, top:pos.top+30}
	);
});
 ```
 */
/**
 * @method AXPopOver.open
 * @param {Object} myobj
 * @param {Event|Object} position - 이벤트 객체를 전달하거나 {left:[Number], top:[Number]} 를 전달합니다.
 * @returns {AXPopOver}
 * @description bind된 컨텍스트메뉴 개체를 오픈합니다. (이벤트속성에 정해진 마우스 포지션또는 사용자가 정한 left, top 포지션에)
 * @example
 ```js
 AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, event); // event 직접 연결 방식

 AXPopOver.open({
	id:"myPopover", sendObj:{id:"전달하고싶은 오브젝트", name:"형식은 자유"}
}, {left:0, top:0}); // position 직접 결정 방식
 ```
 */
/**
 * @method AXPopOver.close
 * @param {Object} obj
 * @returns {AXPopOver}
 * @description 열린 팝오버 개체를 닫습니다.
 * @example
 ```js
 AXPopOver.close({
	id:"myPopover"
});
 ```
 */


/**
 * @method jQueryExtends.bindTooltip
 * @param {Object} configs - 툴팁설정
 * @returns {jQueryObject}
 * @description 툴팁을 바인드 하는 대상의 '아이디+"_AX_tooltip"'를 아이디로 하는 엘리먼트를 대상이 마우스 오버 이벤트 발생 할때 툴팁으로 표시 합니다.
 * @example
 ```js

 <div style="position:relative;">
 <button class="AXButton" onclick="" id="tooltip4"><div class="black_help">Bottom</div></button>
 <div id="tooltip4_AX_tooltip" class="AXTooltipContent">
 AXCore 에서는 자바스크립트 자료형에 대한 prototype 확장 메소드,
 AXJ 클래스 원형, AXUtil 개체, AXReq(AJAX통신용) 클래스, AXCalendar 클래스, AXContext 클래스, AXPopOver 클래스, AXMask 클래스, AXNotification 클래스,
 AXScroll 클래스, AXMultiSelect 클래스, jQuery extend(eventType, easing) 구문 등을 포함하고 있습니다.
 </div>

 <button class="AXButton" onclick="" id="tooltip5"><div class="black_help">Top</div></button>
 <div id="tooltip5_AX_tooltip" class="AXTooltipContent">
 AXCore 에서는 자바스크립트 자료형에 대한 prototype 확장 메소드,
 AXJ 클래스 원형, AXUtil 개체, AXReq(AJAX통신용) 클래스, AXCalendar 클래스, AXContext 클래스, AXPopOver 클래스, AXMask 클래스, AXNotification 클래스,
 AXScroll 클래스, AXMultiSelect 클래스, jQuery extend(eventType, easing) 구문 등을 포함하고 있습니다.
 </div>

 <button class="AXButton" onclick="" id="tooltip6"><div class="black_help">Auto</div></button>
 <div id="tooltip6_AX_tooltip" class="AXTooltipContent">
 AXCore 에서는 자바스크립트 자료형에 대한 prototype 확장 메소드,
 AXJ 클래스 원형, AXUtil 개체, AXReq(AJAX통신용) 클래스, AXCalendar 클래스, AXContext 클래스, AXPopOver 클래스, AXMask 클래스, AXNotification 클래스,
 AXScroll 클래스, AXMultiSelect 클래스, jQuery extend(eventType, easing) 구문 등을 포함하고 있습니다.
 </div>
 </div>
 <script>
 // configs:{
	//	theme: (config.theme || "AXPopOverTooltip"), // (optional)
	//	width: (config.width || ""), // (optional)
	//	direction: (config.direction || "top"), // (optional)
	// }

 // class 가 tooltipbind인 모든 엘리먼트에 툴팁설정
 $(".tooltipbind").bindTooltip({width:300});

 //AXPopOverTooltip (bindTooltip) 방향설정 방식
 $("#tooltip4").bindTooltip({direction:"bottom", width:300}); //{direction:"[auto|top|bottom]"}
 $("#tooltip5").bindTooltip({direction:"top", width:300}); //{direction:"[auto|top|bottom]"}
 $("#tooltip6").bindTooltip({direction:"auto", width:300}); //{direction:"[auto|top|bottom]"}
 </script>
 ```
 */
axdom.fn.bindTooltip = function (config) {
    if (config == undefined) config = {};
    AXUtil.each(this, function () {
        var tooltipContent = axdom("#" + this.id + "_AX_tooltip").html();
        AXPopOver.bind({
            id: this.id + "_AX_tooltipobj",
            theme: (config.theme || "AXPopOverTooltip"), // 선택항목
            width: (config.width || ""), // 선택항목
            direction: (config.direction || "top"), // 선택항목
            body: tooltipContent
        });

        axdom(this).bind((config.event || "mouseover"), function () {
            var pos = axdom(this).offset();
            var direction = (config.direction || "top");
            var posTop = pos.top;
            if (direction == "bottom") {
                posTop -= 3;
            } else {
                posTop += axdom(this).outerHeight() + 3;
            }
            AXPopOver.open({id: this.id + "_AX_tooltipobj", sendObj: {}}, {left: pos.left, top: posTop, handleHeight: (axdom(this).outerHeight().number() + 3)}); // event 직접 연결 방식
        });
    });
    return this;
};
/* ---------------------------------------------- AXContextMenu -- */

/* -- AXMobileModal ---------------------------------------------- */
/**
 * @class AXMobileModal
 * @extends AXJ
 * @version v1.0
 * @author tom@axisj.com, axisj.com
 * @logs
 "2013-12-11 오후 5:48:28"
 "2014-04-14 : tom - modalOpen위치 scrollTop 적용"
 * @example
 ```js
 var myMobileModal = new AXMobileModal();
 // default config
 myMobileModal.config.theme = "AXMobileModal";
 myMobileModal.config.width = "auto";
 myMobileModal.config.height = "auto";
 myMobileModal.config.margin = "10px";
 myMobileModal.config.align = "center";
 myMobileModal.config.valign = "center";
 ```
 */
var AXMobileModal = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.theme = "AXMobileModal";
        this.config.width = "auto";
        this.config.height = "auto";
        this.config.margin = "10px";
        this.config.align = "center";
        this.config.valign = "center";
    },
    /**
     * @method AXMobileModal.setConfig
     * @param {Object} configs
     * @description 모바일모달 개체 초기화
     * @example
     ```js
     myMobileModal.setConfig({
	//theme, margin, align, valign
	width:300,
	height:300,
	head:{
		close:{
			onclick:function(){

			}
		}
	},
	onclose: function(){
		trace("close bind");
	}
});
     ```
     */
    init: function () {
        var cfg = this.config;

        if (!cfg.head) {
            cfg.head = {};
        }
    },
    /**
     * @method AXMobileModal.open
     * @returns {Object} modalObject - 열린 모달의 오브젝트
     * @description 모바일 모달창을 열고 열린 모달의 엘리먼트 정보를 리턴합니다.
     * @example
     ```js
     var obj = myMobileModal.open();
     // 다음의 정보를 리턴합니다.
     // obj: {
//    jQueryModal: 모달,
//    modalPanel: 모달의 패널,
//    modalHead: 모달패널의 헤드,
//    modalBody: 모달패널의 바디,
//    modalFoot: 모달패널의 풋
// }

     obj.modalHead.html("자유Head 설정테스트");
     obj.modalBody.html("<div style='height:250px;background:#fff;text-align: center;line-height:30px;'>자유body 테스트</div>");
     //obj.modalFoot.html("자유footer 테스트");
     ```
     */
    open: function (configs, onLoad) {
        var cfg = this.config;
        if (!configs) configs = {};
        var theme = (configs.theme || cfg.theme);
        if (cfg.addClass) {
            theme += " " + cfg.addClass;
        }
        this.modalId = "AXMobileModal" + AXUtil.timekey();
        var modalId = this.modalId;
        var clientWidth = (configs.clientWidth || AXUtil.clientWidth());

        var po = [];
        po.push('<div id="', modalId, '" class="', theme, '" style="left:0px;top:0px;width:100%;height:100%;">');
        po.push('	<div  id="', modalId, '_AX_modal" class="AXMobileModalPanel" style="height:50px;width:50px;left:', (AXUtil.clientWidth() - 50) / 2, 'px;top:', (AXUtil.clientHeight() - 50) / 2, 'px;">');
        po.push('		<div  id="', modalId, '_AX_head" class="mobileModalHead">');
        po.push('			<div class="modalTitle">' + (cfg.head.title || "") + '</div>');
        po.push('		</div>');
        if (cfg.head.close) {
            po.push('		<a ' + cfg.href + ' class="mobileModelClose">Close</a>');
        }
        po.push('		<div  id="', modalId, '_AX_body" class="mobileModalBody"></div>');
        po.push('		<div  id="', modalId, '_AX_foot" class="mobileModalFoot"></div>');
        po.push('	</div>');
        po.push('</div>');
        this.jQueryModal = axdom(po.join(''));
        axdom(document.body).append(this.jQueryModal);

        this.modalPanel = this.jQueryModal.find(".AXMobileModalPanel");
        this.modalHead = this.modalPanel.find(".mobileModalHead");
        this.modalBody = this.modalPanel.find(".mobileModalBody");
        this.modalFoot = this.modalPanel.find(".mobileModalFoot");

        this.openConfigs = configs;
        this.setSizeModal(this.openConfigs, onLoad);
        this.modalPanel.find(".mobileModelClose").bind("click", this.close.bind(this));
        this.jQueryModal.bind("click", this.modalClick.bind(this));

        axdom(window).unbind("resize.AXMobileModal").bind("resize.AXMobileModal", this.reposition.bind(this));

        this.opened = true;

        return {
            jQueryModal: this.jQueryModal,
            modalPanel: this.modalPanel,
            modalHead: this.modalHead,
            modalBody: this.modalBody,
            modalFoot: this.modalFoot
        };
    },
    setSizeModal: function (configs, onLoad) {
        var cfg = this.config;
        var cssStyles = {};
        var clientWidth, width, height, left, top, margin, align, valign;
        var modalWidth, modalHeight;
        var clientWidth = this.jQueryModal.innerWidth();
        var clientHeight = AXUtil.clientHeight();
        var width = (configs.width || cfg.width);
        var height = (configs.height || cfg.height);
        var margin = (configs.margin || cfg.margin);
        var align = (configs.align || cfg.align);
        var valign = (configs.valign || cfg.valign);

        this.openModalAttr = {
            width: width, height: height, margin: margin, align: align, valign: valign
        };

        if (width == "auto") {
            if (margin.right(1) == "%") {
                modalWidth = clientWidth * (100 - margin.number() * 2) / 100;
            } else {
                modalWidth = clientWidth - margin.number() * 2;
            }
        } else {
            modalWidth = width;
        }
        left = (clientWidth - modalWidth) / 2;

        if (height == "auto") {
            if (margin.right(1) == "%") {
                modalHeight = clientHeight * (100 - margin.number() * 2) / 100;
            } else {
                modalHeight = clientHeight - margin.number() * 2;
            }
        } else {
            modalHeight = height;
        }
        top = (clientHeight - modalHeight) / 2;

        if (left < 0) left = margin;
        if (top < -5) top = -5;

        var cssStylesStart = {
            left: (axf.clientWidth() - (modalWidth * 0.8)) / 2,
            top: (axf.clientHeight() - (modalHeight * 0.8)) / 2,
            width: (modalWidth * 0.8),
            height: (modalHeight * 0.8)
        };
        //cssStylesStart.top += jQuery(window).scrollTop();
        this.modalPanel.css(cssStylesStart);

        cssStyles.left = left;
        cssStyles.top = top;
        cssStyles.width = modalWidth;
        cssStyles.height = modalHeight;
        mask.open();

        var returnObj = {
            jQueryModal: this.jQueryModal,
            modalPanel: this.modalPanel,
            modalHead: this.modalHead,
            modalBody: this.modalBody,
            modalFoot: this.modalFoot
        };

        if (AXUtil.browser.name == "android") {
            //alert(AXUtil.browser.version);
            this.modalPanel.css(cssStyles);
            if (onLoad) {
                onLoad.call(returnObj, returnObj);
            }
        } else {
            this.modalPanel.animate(cssStyles, 300, "expoOut", function () {
                if (onLoad) {
                    onLoad.call(returnObj, returnObj);
                }
            });
        }
    },
    modalClick: function (event) {
        var cfg = this.config;
        if (event.target.id == this.modalId) {
            this.close();
        }
    },

    /**
     * @method AXMobileModal.close
     * @returns {AXMobileModal}
     * @description 모바일모달창을 닫습니다.
     * @example
     ```js
     myMobileModal.close();
     ```
     */
    close: function () {
        var cfg = this.config;
        mask.close();

        var modalWidth, modalHeight;
        modalWidth = this.modalPanel.width();
        modalHeight = this.modalPanel.height();

        var cssStylesStart = {
            left: (AXUtil.clientWidth() - (modalWidth * 0.8)) / 2,
            top: (AXUtil.clientHeight() - (modalHeight * 0.8)) / 2,
            width: (modalWidth * 0.8),
            height: (modalHeight * 0.8),
            opacity: 0
        };
        var remove = this.remove.bind(this);
        this.modalPanel.animate(cssStylesStart, 300, "expoOut", function () {
            remove();
            if (cfg.onclose) {
                cfg.onclose();
            }
        });
        this.modalPanel.empty();
        //this.jQueryModal.fadeOut();
        //this.remove();
        /*

         remove.delay(0.01);
         */
        this.opened = false;
        axdom(window).unbind("resize.AXMobileModal");

        return this;
    },
    remove: function () {
        var cfg = this.config;
        this.jQueryModal.remove();
    },
    reposition: function () {
        var cfg = this.config;

        var clientWidth = AXUtil.clientWidth();
        var clientHeight = AXUtil.clientHeight();
        this.jQueryModal.css({width: clientWidth, height: clientHeight});

        var modalWidth, modalHeight, left, top;
        var width = this.openModalAttr.width;
        var height = this.openModalAttr.height;
        var margin = this.openModalAttr.margin;
        var align = this.openModalAttr.align;
        var valign = this.openModalAttr.valign;
        var cssStyles = {};

        if (width == "auto") {
            if (margin.right(1) == "%") {
                modalWidth = clientWidth * (100 - margin.number() * 2) / 100;
            } else {
                modalWidth = clientWidth - margin.number() * 2;
            }
        } else {
            modalWidth = width;
        }
        left = (clientWidth - modalWidth) / 2;

        if (height == "auto") {
            if (margin.right(1) == "%") {
                modalHeight = clientHeight * (100 - margin.number() * 2) / 100;
            } else {
                modalHeight = clientHeight - margin.number() * 2;
            }
        } else {
            modalHeight = height;
        }
        top = (clientHeight - modalHeight) / 2;

        if (left < 0) left = margin;
        if (top < -5) top = -5;

        cssStyles.left = left;
        cssStyles.top = top;
        cssStyles.width = modalWidth;
        cssStyles.height = modalHeight;

        this.modalPanel.css(cssStyles);
    }
});
/* ---------------------------------------------- AXMobileModal -- */

/* -- jQuery easing plugin ---------------------------------------------- */
axdom.extend(true, {
    easing: {
        backIn: function (p, n, f, d) {
            var c = f + d;
            var s = 1.70158;
            return c * (p /= 1) * p * ((s + 1) * p - s) + f;
        },
        backOut: function (p, n, f, d) {
            var c = f + d;
            var s = 1.70158;
            return c * ((p = p / 1 - 1) * p * ((s + 1) * p + s) + 1) + f;
        },
        backInOut: function (p, n, f, d) {
            var c = f + d;
            var s = 1.70158;
            if ((p /= 0.5) < 1) return c / 2 * (p * p * (((s *= (1.525)) + 1) * p - s)) + f; else return c / 2 * ((p -= 2) * p * (((s *= (1.525)) + 1) * p + s) + 2) + f;
        },
        bounceIn: function (p, n, f, d) {
            var c = f + d;
            var inv = this.bounceOut(1 - p, 1, 0, d);
            return c - inv + f;
        },
        bounceOut: function (p, n, f, d) {
            var c = f + d;
            if (p < (1 / 2.75)) return c * (7.5625 * p * p) + f; else if (p < (2 / 2.75)) return c * (7.5625 * (p -= (1.5 / 2.75)) * p + .75) + f; else if (p < (2.5 / 2.75)) return c * (7.5625 * (p -= (2.25 / 2.75)) * p + .9375) + f; else return c * (7.5625 * (p -= (2.625 / 2.75)) * p + .984375) + f;
        },
        circIn: function (p, n, f, d) {
            var c = f + d;
            return -c * (Math.sqrt(1 - (p /= 1) * p) - 1) + f;
        },
        circOut: function (p, n, f, d) {
            var c = f + d;
            return c * Math.sqrt(1 - (p = p / 1 - 1) * p) + f;
        },
        circInOut: function (p, n, f, d) {
            var c = f + d;
            if ((p /= 0.5) < 1) return -c / 2 * (Math.sqrt(1 - p * p) - 1) + f; else return c / 2 * (Math.sqrt(1 - (p -= 2) * p) + 1) + f;
        },
        cubicIn: function (p, n, f, d) {
            var c = f + d;
            return c * (p /= 1) * p * p + f;
        },
        cubicOut: function (p, n, f, d) {
            var c = f + d;
            return c * ((p = p / 1 - 1) * p * p + 1) + f;
        },
        cubicInOut: function (p, n, f, d) {
            var c = f + d;
            if ((p /= 0.5) < 1) return c / 2 * p * p * p + f; else return c / 2 * ((p -= 2) * p * p + 2) + f;
        },
        elasticIn: function (p, n, f, d) {
            var c = f + d;
            if (p == 0) return f;
            if (p == 1) return c;
            var peroid = 0.25;
            var s;
            var amplitude = c;
            if (amplitude < Math.abs(c)) {
                amplitude = c;
                s = peroid / 4;
            } else {
                s = peroid / (2 * Math.PI) * Math.asin(c / amplitude);
            }
            return -(amplitude * Math.pow(2, 10 * (p -= 1)) * Math.sin((p * 1 - s) * (2 * Math.PI) / peroid)) + f;
        },
        elasticOut: function (p, n, f, d) {
            var c = f + d;
            if (p == 0) return f;
            if (p == 1) return c;
            var peroid = 0.25;
            var s;
            var amplitude = c;
            if (amplitude < Math.abs(c)) {
                amplitude = c;
                s = peroid / 4;
            } else {
                s = peroid / (2 * Math.PI) * Math.asin(c / amplitude);
            }
            return -(amplitude * Math.pow(2, -10 * p) * Math.sin((p * 1 - s) * (2 * Math.PI) / peroid)) + c;
        },
        expoIn: function (p, n, f, d) {
            var c = f + d;
            return (p == 0) ? f : c * Math.pow(2, 10 * (p - 1)) + f - c * 0.001;
        },
        expoOut: function (p, n, f, d) {
            var c = f + d;
            return (p == 1) ? c : d * 1.001 * (-Math.pow(2, -10 * p) + 1) + f;
        },
        expoInOut: function (p, n, f, d) {
            var c = f + d;
            if (p == 0) return f;
            if (p == 1) return c;
            if ((p /= 0.5) < 1) return c / 2 * Math.pow(2, 10 * (p - 1)) + f - c * 0.0005; else return c / 2 * 1.0005 * (-Math.pow(2, -10 * --p) + 2) + f;
        },
        quadIn: function (p, n, f, d) {
            var c = f + d;
            return c * (p /= 1) * p + f;
        },
        quadOut: function (p, n, f, d) {
            var c = f + d;
            return -c * (p /= 1) * (p - 2) + f;
        },
        quadInOut: function (p, n, f, d) {
            var c = f + d;
            if ((p /= 0.5) < 1) return c / 2 * p * p + f; else return -c / 2 * ((--p) * (p - 2) - 1) + f;
        },
        quartIn: function (p, n, f, d) {
            var c = f + d;
            return c * (p /= 1) * p * p * p + f;
        },
        quartOut: function (p, n, f, d) {
            var c = f + d;
            return -c * ((p = p / 1 - 1) * p * p * p - 1) + f;
        },
        quartInOut: function (p, n, f, d) {
            var c = f + d;
            if ((p /= 0.5) < 1) return c / 2 * p * p * p * p + f; else return -c / 2 * ((p -= 2) * p * p * p - 2) + f;
        },
        quintIn: function (p, n, f, d) {
            var c = f + d;
            return c * (p /= 1) * p * p * p * p + f;
        },
        quintOut: function (p, n, f, d) {
            var c = f + d;
            return c * ((p = p / 1 - 1) * p * p * p * p + 1) + f;
        },
        quintInOut: function (p, n, f, d) {
            var c = f + d;
            if ((p /= 0.5) < 1) return c / 2 * p * p * p * p * p + f; else return c / 2 * ((p -= 2) * p * p * p * p + 2) + f;
        },
        sineIn: function (p, n, f, d) {
            var c = f + d;
            return -c * Math.cos(p * (Math.PI / 2)) + c + f;
        },
        sineOut: function (p, n, f, d) {
            var c = f + d;
            return c * Math.sin(p * (Math.PI / 2)) + f;
        },
        sineInOut: function (p, n, f, d) {
            var c = f + d;
            return -c / 2 * (Math.cos(Math.PI * p) - 1) + f;
        }
    }
});
/* ---------------------------------------------- jQuery easing plugin -- */

// jQuery misc plugin
// 2014-08-08 tom : select option 이 없으면 엘리먼트를 찾지 않는 버그 픽스
var __r20 = /%20/g,
    __rbracket = /\[\]$/,
    __rCRLF = /\r?\n/g,
    __rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    __rselectTextarea = /^(?:select|textarea)/i;

// jquery event extend for mobile
var rkeyEvent = /^key/;
var rmouseEvent = /^(?:mouse|contextmenu)|click/;
axf.each(("touchstart touchmove touchend").split(" "), function (i, name) {
    axdom.fn[name] = function (data, fn) {
        if (fn == null) {
            fn = data;
            data = null;
        }
        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
    if (rkeyEvent.test(name)) {
        axdom.event.fixHooks[name] = axdom.event.keyHooks;
    }
    if (rmouseEvent.test(name)) {
        axdom.event.fixHooks[name] = axdom.event.mouseHooks;
    }
});

/**
 * 설명
 * @member {type} AXJ.name
 */
/**
 * @method jQueryExtends.serializeObject
 * @returns {Array}
 * @description 엘리먼트 안에 폼아이템 요소들을 수집합니다. <en>Collect 'form item' inside target element</en>
 * @example
 ```js
 var myItems = $("#mytarget").serializeObject();
 ```
 */
axdom.fn.serializeObject = function () {
    var myArray = this.map(function () {
        return this.elements ? axdom.makeArray(this.elements) : this;
    })
        .filter(function () {
            return this.name && !this.disabled &&
                (this.checked || __rselectTextarea.test(this.nodeName) ||
                __rinput.test(this.type));
        })
        .map(function (i, elem) {
            var val = axdom(this).val();
            var label = (axdom(elem).attr("title") || axdom(elem).attr("placeholder") || "");

            if (val == null) {
                if (this.nodeName.lcase() == "select") val = "";
            }

            return val == null ?
                null :
                axdom.isArray(val) ?
                    axdom.map(val, function (val, i) {
                        return {id: elem.id, name: elem.name, type: elem.type, value: val.replace(__rCRLF, "\r\n"), label: label};
                    }) :
                {id: elem.id, name: elem.name, type: elem.type, value: val.replace(__rCRLF, "\r\n"), label: label};

        }).get();
    return myArray;
};

/**
 * @method jQueryExtends.endFocus
 * @returns {jQueryObject}
 * @description input 엘리먼트 맨끝에 포커스되도록 합니다.
 * @example
 ```js
 $("#mytarget").endFocus();
 ```
 */
axdom.fn.endFocus = function () {
    var elem = this;
    var elemLen = elem.val().length;
    if (elemLen == 0) {
        elem.focus();
        return;
    }
    // For IE Only
    if (document.selection) {
        // Set focus
        elem.focus();
        elem.val(elem.val());
    }
    else if (document.selection == undefined || elem.selectionStart || elem.selectionStart == '0') {
        // Firefox/Chrome
        elem.focus().val(elem.val());
    } // if
    return this;
};

/**
 * @method jQueryExtends.setCaret
 * @param {Number} [pos=valueLength] - 포커스 포지션 넘버
 * @returns {jQueryObject}
 * @description input 엘리먼트 특정위치에 커서를 위치시켜 줍니다.
 * @example
 ```js
 $("#mytarget").setCaret(2);
 ```
 */
axdom.fn.setCaret = function (pos) {
    var input = this[0];
    if (typeof pos == "undefined") {
        pos = input.value.length;
    }
    if (input.setSelectionRange) {
        input.focus();
        input.setSelectionRange(pos, pos);
    } else if (input.createTextRange) {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveEnd('character', pos);
        range.moveStart('character', pos);
        range.select();
    } else if (input.selectionStart) {
        input.focus();
        input.selectionStart = pos;
        input.selectionEnd = pos;
    }
    return this;
};

/**
 * @method jQueryExtends.onwheel
 * @param {String} handler - 이벤트 키 네임
 * @param {Function} callBackFn - 이벤트 콜백 함수
 * @returns {jQueryObject}
 * @description 엘리먼트에 휠이벤트를 바인드 합니다. (단 엘리먼트에 id속성이 없는 경우 제대로 작동하지 않을 수 있습니다.)
 * @example
 ```
 $("#mytarget").onwheel("mywheel", function(event){
	var delta = event.detail ? event.detail * (-20) : event.wheelDelta / 2;
	trace(delta);
});
 ```
 */
axdom.fn.onwheel = function (handler, callBackFn) {
    axf.each(this, function () {
        if (typeof axf._customerEvents == "undefined") axf._customerEvents = {};
        axf._customerEvents[this.id + "_AX_" + handler] = callBackFn;
        if (document.attachEvent) {
            this.attachEvent("on" + axf.mousewheelevt, axf._customerEvents[this.id + "_AX_" + handler]);
        } else if (document.addEventListener) {
            this.addEventListener(axf.mousewheelevt, axf._customerEvents[this.id + "_AX_" + handler], false);
        }
    });
    return this;
};

/**
 * @method jQueryExtends.offwheel
 * @param {String} handler - 이벤트 키 네임
 * @returns {jQueryObject}
 * @description 엘리먼트에 휠이벤트를 언바인드 합니다. (단 엘리먼트에 id속성이 없는 경우 제대로 작동하지 않을 수 있습니다.)
 * @example
 ```
 $("#mytarget").offwheel("mywheel");
 ```
 */
axdom.fn.offwheel = function (handler) {
    axf.each(this, function () {
        if (document.attachEvent) {
            this.detachEvent("on" + axf.mousewheelevt, axf._customerEvents[this.id + "_AX_" + handler]);
        } else if (document.addEventListener) {
            this.removeEventListener(axf.mousewheelevt, axf._customerEvents[this.id + "_AX_" + handler], false);
        }
    });
    return this;
};

/*
 input type=text, textarea가 일부 브라우저에서 포커스 되지 않는 현상해결 해주는 구문
 */
axdom(document.body).ready(function () {
    axdom("input[type=text]").bind("mousedown", function () {
        this.focus();
    });
    axdom("textarea").bind("mousedown", function () {
        this.focus();
    });
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 
 /*
 아래 코드는 husky_framework 의 HuskyRange.js 코드를 참조하여 개발 되었습니다.
 */
 
var DOMfix = {
	DF_parentNode: function(node){
		if(AXUtil.browser.name == "ie" || AXUtil.browser.name == "op"){
			if(!node) return node;
			while(node.previousSibling){node = node.previousSibling;}
			return node.parentNode;			
		}else{
			return node.parentNode;
		}
	},
	DF_childNode: function(node){
		if(AXUtil.browser.name == "ie" || AXUtil.browser.name == "op"){
			var result = null;
			var ni = 0;	
			if(node){
				var result = [];
				node = node.firstChild;
				while(node){
					result[ni++] = node;
					node = node.nextSibling;
				}
			}			
			return result;		
		}else{
			return node.childNodes;
		}
	}
}

var AXDOMRange = Class.create({
	START_TO_START	:0,
	START_TO_END	:1,
	END_TO_END		:2,
	END_TO_START	:3,	
	initialize		: function(_document){
		this._doc = _document || document;
		this.collapsed = true;
		this.commonAncestorContainer = this._doc.body;
		this.endContainer = this._doc.body;
		this.endOffset = 0;
		this.startContainer = this._doc.body;
		this.startOffset = 0;
	},
	cloneContents : function(){
		var oClonedContents = this._doc.createDocumentFragment();
		var oTmpContainer 	= this._doc.createDocumentFragment();
		var aNodes 			= this._getNodesInRange();
		if(aNodes.length < 1) return oClonedContents;
		var oClonedContainers = this.DF_constructClonedTree(aNodes, oTmpContainer);
		var oTopContainer = oTmpContainer.firstChild;
		if(oTopContainer){
			var elCurNode = oTopContainer.firstChild;
			var elNextNode;
			while(elCurNode){
				elNextNode = elCurNode.nextSibling;
				oClonedContents.appendChild(elCurNode);
				elCurNode = elNextNode;
			}
		}
		oClonedContainers = this._splitTextEndNodes({oStartContainer: oClonedContainers.oStartContainer, iStartOffset: this.startOffset, 
													oEndContainer: oClonedContainers.oEndContainer, iEndOffset: this.endOffset});
		if(oClonedContainers.oStartContainer && oClonedContainers.oStartContainer.previousSibling)
			DOMfix.DF_parentNode(oClonedContainers.oStartContainer).removeChild(oClonedContainers.oStartContainer.previousSibling);

		if(oClonedContainers.oEndContainer && oClonedContainers.oEndContainer.nextSibling)
			DOMfix.DF_parentNode(oClonedContainers.oEndContainer).removeChild(oClonedContainers.oEndContainer.nextSibling);

		return oClonedContents;
	},
	DF_constructClonedTree : function(aNodes, oClonedParentNode){
		var oClonedStartContainer = null;
		var oClonedEndContainer = null;

		var oStartContainer = this.startContainer;
		var oEndContainer = this.endContainer;

		recurConstructClonedTree = function(aAllNodes, iCurIdx, oParentNode, oClonedParentNode){
			if(iCurIdx < 0) return iCurIdx;
			var iChildIdx = iCurIdx-1;
			var oCurNodeCloneWithChildren = aAllNodes[iCurIdx].cloneNode(false);
			if(aAllNodes[iCurIdx] == oStartContainer) oClonedStartContainer = oCurNodeCloneWithChildren;
			if(aAllNodes[iCurIdx] == oEndContainer) oClonedEndContainer = oCurNodeCloneWithChildren;
			while(iChildIdx >= 0 && DOMfix.DF_parentNode(aAllNodes[iChildIdx]) == aAllNodes[iCurIdx]){
				iChildIdx = this.recurConstructClonedTree(aAllNodes, iChildIdx, aAllNodes[iCurIdx], oCurNodeCloneWithChildren, oClonedStartContainer, oClonedEndContainer);
			}
			oClonedParentNode.insertBefore(oCurNodeCloneWithChildren, oClonedParentNode.firstChild);
			return iChildIdx;
		};

		aNodes[aNodes.length] = DOMfix.DF_parentNode(aNodes[aNodes.length-1]);
		recurConstructClonedTree(aNodes, aNodes.length-1, aNodes[aNodes.length-1], oClonedParentNode);

		return {oStartContainer: oClonedStartContainer, oEndContainer: oClonedEndContainer};
	},
	cloneRange : function(){
		return this.DF_copyRange(new AXDOMRange(this._doc));
	},
	DF_copyRange : function(oClonedRange){
		oClonedRange.collapsed = this.collapsed;
		oClonedRange.commonAncestorContainer = this.commonAncestorContainer;
		oClonedRange.endContainer = this.endContainer;
		oClonedRange.endOffset = this.endOffset;
		oClonedRange.startContainer = this.startContainer;
		oClonedRange.startOffset = this.startOffset;
		oClonedRange._document = this._doc;
		
		return oClonedRange;
	},
	collapse : function(toStart){
		if(toStart){
			this.endContainer = this.startContainer;
			this.endOffset = this.startOffset;
		}else{
			this.startContainer = this.endContainer;
			this.startOffset = this.endOffset;
		}
		this._updateRangeInfo();
	},
	compareBoundaryPoints : function(how, sourceRange){
		switch(how){
			case this.START_TO_START:
				return this._compareEndPoint(this.startContainer, this.startOffset, sourceRange.startContainer, sourceRange.startOffset);
			case this.START_TO_END:
				return this._compareEndPoint(this.endContainer, this.endOffset, sourceRange.startContainer, sourceRange.startOffset);
			case this.END_TO_END:
				return this._compareEndPoint(this.endContainer, this.endOffset, sourceRange.endContainer, sourceRange.endOffset);
			case this.END_TO_START:
				return this._compareEndPoint(this.startContainer, this.startOffset, sourceRange.endContainer, sourceRange.endOffset);
		}
	},
	DF_getBody : function(node){
		if(!node) return null;
		while(node){
			if(node.tagName == "BODY") return node;
			node = DOMfix.DF_parentNode(node);
		}
		return null;
	},
	_compareEndPoint : function(oContainerA, iOffsetA, oContainerB, iOffsetB){
		var iIdxA, iIdxB;

		if(!oContainerA || this.DF_getBody(oContainerA) != this._doc.body){
			oContainerA = this._doc.body;
			iOffsetA = 0;
		}

		if(!oContainerB || this.DF_getBody(oContainerB) != this._doc.body){
			oContainerB = this._doc.body;
			iOffsetB = 0;
		}

		var compareIdx = function(iIdxA, iIdxB){
			if(iIdxB == -1) iIdxB = iIdxA+1;
			if(iIdxA < iIdxB) return -1;
			if(iIdxA == iIdxB) return 0;
			return 1;
		};

		var oCommonAncestor = this._getCommonAncestorContainer(oContainerA, oContainerB);

		var nodeA = oContainerA;
		if(nodeA != oCommonAncestor){
			while((oTmpNode = DOMfix.DF_parentNode(nodeA)) != oCommonAncestor){nodeA = oTmpNode;}
			iIdxA = this._getPosIdx(nodeA)+0.5;
		}else iIdxA = iOffsetA;
		
		var nodeB = oContainerB;
		if(nodeB != oCommonAncestor){
			while((oTmpNode = DOMfix.DF_parentNode(nodeB)) != oCommonAncestor){nodeB = oTmpNode;}
			iIdxB = this._getPosIdx(nodeB)+0.5;
		}else iIdxB = iOffsetB;

		return compareIdx(iIdxA, iIdxB);
	},
	_getCommonAncestorContainer : function(node1, node2){
		var oComparingNode = node2;

		while(node1){
			while(oComparingNode){
				if(node1 == oComparingNode) return node1;
				oComparingNode = DOMfix.DF_parentNode(oComparingNode);
			}
			oComparingNode = node2;
			node1 = DOMfix.DF_parentNode(node1);
		}

		return this._doc.body;
	},

	deleteContents : function(){
		if(this.collapsed) return;

		this._splitTextEndNodesOfTheRange();

		var aNodes = this._getNodesInRange();

		if(aNodes.length < 1) return;

		var oPrevNode = aNodes[0].previousSibling;
		while(oPrevNode && this._isBlankTextNode(oPrevNode)) oPrevNode = oPrevNode.previousSibling;
		
		var oNewStartContainer, iNewOffset;
		if(!oPrevNode){
			oNewStartContainer = DOMfix.DF_parentNode(aNodes[0]);
			iNewOffset = 0;
		}

		for(var i=0; i<aNodes.length; i++){
			var node = aNodes[i];
			if(!node.firstChild){
				if(oNewStartContainer == node){
					iNewOffset = this._getPosIdx(oNewStartContainer);
					oNewStartContainer = DOMfix.DF_parentNode(node);
				}
				DOMfix.DF_parentNode(node).removeChild(node);
			}
		}

		if(!oPrevNode){
			this.setStart(oNewStartContainer, iNewOffset);
		}else{
			if(oPrevNode.tagName == "BODY")
				this.setStartBefore(oPrevNode);
			else
				this.setStartAfter(oPrevNode);
		}

		this.collapse(true);
	},

	extractContents : function(){
		var oClonedContents = this.cloneContents();
		this.deleteContents();
		return oClonedContents;
	},

	insertNode : function(newNode){
		var oFirstNode = null;
		var oParentContainer;
		if(this.startContainer.nodeType == "3"){
			oParentContainer = DOMfix.DF_parentNode(this.startContainer);
			if(this.startContainer.nodeValue.length <= this.startOffset)
				oFirstNode = this.startContainer.nextSibling;
			else
				oFirstNode = this.startContainer.splitText(this.startOffset);
		}else{
			oParentContainer = this.startContainer;
			oFirstNode = DOMfix.DF_childNode(this.startContainer)[this.startOffset];
		}
		if(!oFirstNode || !DOMfix.DF_parentNode(oFirstNode)) oFirstNode = null;
		oParentContainer.insertBefore(newNode, oFirstNode);
		this.setStartBefore(newNode);
	},
	selectNode : function(refNode){
		this.setStartBefore(refNode);
		this.setEndAfter(refNode);
	},
	selectNodeContents : function(refNode){
		this.setStart(refNode, 0);
		this.setEnd(refNode, DOMfix.DF_childNode(refNode).length);
	},
	_endsNodeValidation : function(node, iOffset){
		if(!node || this.DF_getBody(node) != this._doc.body) throw new Error("node error");
		if(node.nodeType == 3){
			if(iOffset > node.nodeValue.length) iOffset = node.nodeValue.length;
		}else{
			if(iOffset > DOMfix.DF_childNode(node).length) iOffset = DOMfix.DF_childNode(node).length;
		}
		return iOffset;
	},
	setEnd : function(refNode, offset){
		offset = this._endsNodeValidation(refNode, offset);
		this.endContainer = refNode;
		this.endOffset = offset;
		if(!this.startContainer || this._compareEndPoint(this.startContainer, this.startOffset, this.endContainer, this.endOffset) != -1) this.collapse(false);
		this._updateRangeInfo();
	},
	setEndAfter : function(refNode){
		if(!refNode) throw new Error("setEndAfter");
		if(refNode.tagName == "BODY"){
			this.setEnd(refNode, DOMfix.DF_childNode(refNode).length);
			return;
		}
		this.setEnd(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode)+1);
	},
	setEndBefore : function(refNode){
		if(!refNode) throw new Error("setEndBefore");
		if(refNode.tagName == "BODY"){
			this.setEnd(refNode, 0);
			return;
		}
		this.setEnd(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode));
	},
	setStart : function(refNode, offset){
		offset = this._endsNodeValidation(refNode, offset);
		this.startContainer = refNode;
		this.startOffset = offset;
		if(!this.endContainer || this._compareEndPoint(this.startContainer, this.startOffset, this.endContainer, this.endOffset) != -1) this.collapse(true);
		this._updateRangeInfo();
	},
	setStartAfter : function(refNode){
		if(!refNode) throw new Error("setStartAfter");
		if(refNode.tagName == "BODY"){
			this.setStart(refNode, DOMfix.DF_childNode(refNode).length);
			return;
		}
		this.setStart(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode)+1);
	},

	setStartBefore : function(refNode){
		if(!refNode) throw new Error("setStartBefore");
		if(refNode.tagName == "BODY"){
			this.setStart(refNode, 0);
			return;
		}
		this.setStart(DOMfix.DF_parentNode(refNode), this._getPosIdx(refNode));
	},
	surroundContents : function(newParent){
		newParent.appendChild(this.extractContents());
		this.insertNode(newParent);
		this.selectNode(newParent);
	},
	toString : function(){
		var oTmpContainer = this._doc.createElement("DIV");
		oTmpContainer.appendChild(this.cloneContents());
		return oTmpContainer.textContent || oTmpContainer.innerText || "";
	},
	_isBlankTextNode : function(node){
		if(node.nodeType == 3 && node.nodeValue == "") return true;
		return false;
	},
	_getPosIdx : function(refNode){
		var idx = 0;
		for(var node = refNode.previousSibling; node; node = node.previousSibling) idx++;

		return idx;
	},
	_updateRangeInfo : function(){
		if(!this.startContainer){
			this.init(this._doc);
			return;
		}
		this.collapsed = this._isCollapsed(this.startContainer, this.startOffset, this.endContainer, this.endOffset);
		this.commonAncestorContainer = this._getCommonAncestorContainer(this.startContainer, this.endContainer);
	},
	_isCollapsed : function(oStartContainer, iStartOffset, oEndContainer, iEndOffset){
		var bCollapsed = false;
		if(oStartContainer == oEndContainer && iStartOffset == iEndOffset){
			bCollapsed = true;
		}else{
			var oActualStartNode = this._getActualStartNode(oStartContainer, iStartOffset);
			var oActualEndNode = this._getActualEndNode(oEndContainer, iEndOffset);
			oActualStartNode = this._getNextNode(this._getPrevNode(oActualStartNode));
			oActualEndNode = this._getPrevNode(this._getNextNode(oActualEndNode));
			if(oActualStartNode && oActualEndNode && oActualEndNode.tagName != "BODY" && 
				(this._getNextNode(oActualEndNode) == oActualStartNode || (oActualEndNode == oActualStartNode && this._isBlankTextNode(oActualEndNode)))
			)
				bCollapsed = true;
		}
		return bCollapsed;
	},

	_splitTextEndNodesOfTheRange : function(){
		var oEndPoints = this._splitTextEndNodes({oStartContainer: this.startContainer, iStartOffset: this.startOffset, 
													oEndContainer: this.endContainer, iEndOffset: this.endOffset});

		this.startContainer = oEndPoints.oStartContainer;
		this.startOffset = oEndPoints.iStartOffset;

		this.endContainer = oEndPoints.oEndContainer;
		this.endOffset = oEndPoints.iEndOffset;
	},

	_splitTextEndNodes : function(oEndPoints){
		oEndPoints = this._splitStartTextNode(oEndPoints);
		oEndPoints = this._splitEndTextNode(oEndPoints);

		return oEndPoints;
	},

	_splitStartTextNode : function(oEndPoints){
		var oStartContainer = oEndPoints.oStartContainer;
		var iStartOffset = oEndPoints.iStartOffset;

		var oEndContainer = oEndPoints.oEndContainer;
		var iEndOffset = oEndPoints.iEndOffset;

		if(!oStartContainer) return oEndPoints;
		if(oStartContainer.nodeType != 3) return oEndPoints;
		if(iStartOffset == 0) return oEndPoints;

		if(oStartContainer.nodeValue.length <= iStartOffset) return oEndPoints;

		var oLastPart = oStartContainer.splitText(iStartOffset);

		if(oStartContainer == oEndContainer){
			iEndOffset -= iStartOffset;
			oEndContainer = oLastPart;
		}
		oStartContainer = oLastPart;
		iStartOffset = 0;

		return {oStartContainer: oStartContainer, iStartOffset: iStartOffset, oEndContainer: oEndContainer, iEndOffset: iEndOffset};
	},

	_splitEndTextNode : function(oEndPoints){
		var oStartContainer = oEndPoints.oStartContainer;
		var iStartOffset = oEndPoints.iStartOffset;

		var oEndContainer = oEndPoints.oEndContainer;
		var iEndOffset = oEndPoints.iEndOffset;

		if(!oEndContainer) return oEndPoints;
		if(oEndContainer.nodeType != 3) return oEndPoints;

		if(iEndOffset >= oEndContainer.nodeValue.length) return oEndPoints;
		if(iEndOffset == 0) return oEndPoints;

		oEndContainer.splitText(iEndOffset);

		return {oStartContainer: oStartContainer, iStartOffset: iStartOffset, oEndContainer: oEndContainer, iEndOffset: iEndOffset};
	},
	
	_getNodesInRange : function(){
		if(this.collapsed) return [];

		var oStartNode = this._getActualStartNode(this.startContainer, this.startOffset);
		var oEndNode = this._getActualEndNode(this.endContainer, this.endOffset);

		return this._getNodesBetween(oStartNode, oEndNode);
	},

	_getActualStartNode : function(oStartContainer, iStartOffset){
		var oStartNode = oStartContainer;;

		if(oStartContainer.nodeType == 3){
			if(iStartOffset >= oStartContainer.nodeValue.length){
				oStartNode = this._getNextNode(oStartContainer);
				if(oStartNode.tagName == "BODY") oStartNode = null;
			}else{
				oStartNode = oStartContainer;
			}
		}else{
			if(iStartOffset < DOMfix.DF_childNode(oStartContainer).length){
				oStartNode = DOMfix.DF_childNode(oStartContainer)[iStartOffset];
			}else{
				oStartNode = this._getNextNode(oStartContainer);
				if(oStartNode.tagName == "BODY") oStartNode = null;
			}
		}

		return oStartNode;
	},

	_getActualEndNode : function(oEndContainer, iEndOffset){
		var oEndNode = oEndContainer;

		if(iEndOffset == 0){
			oEndNode = this._getPrevNode(oEndContainer);
			if(oEndNode.tagName == "BODY") oEndNode = null;
		}else if(oEndContainer.nodeType == 3){
			oEndNode = oEndContainer;
		}else{
			oEndNode = DOMfix.DF_childNode(oEndContainer)[iEndOffset-1];
		}

		return oEndNode;
	},

	_getNextNode : function(node){
		if(!node || node.tagName == "BODY") return this._doc.body;

		if(node.nextSibling) return node.nextSibling;
		
		return this._getNextNode(DOMfix.DF_parentNode(node));
	},

	_getPrevNode : function(node){
		if(!node || node.tagName == "BODY") return this._doc.body;

		if(node.previousSibling) return node.previousSibling;
		
		return this._getPrevNode(DOMfix.DF_parentNode(node));
	},

	// includes partially selected
	// for <div id="a"><div id="b"></div></div><div id="c"></div>, _getNodesBetween(b, c) will yield to b, "a" and c
	_getNodesBetween : function(oStartNode, oEndNode){
		var aNodesBetween = [];

		if(!oStartNode || !oEndNode) return aNodesBetween;

		this._recurGetNextNodesUntil(oStartNode, oEndNode, aNodesBetween);
		return aNodesBetween;
	},

	_recurGetNextNodesUntil : function(node, oEndNode, aNodesBetween){
		if(!node) return false;

		if(!this._recurGetChildNodesUntil(node, oEndNode, aNodesBetween)) return false;

		var oNextToChk = node.nextSibling;
		
		while(!oNextToChk){
			if(!DOMfix.DF_parentNode(node)) return false;
			node = DOMfix.DF_parentNode(node);

			aNodesBetween[aNodesBetween.length] = node;

			if(node == oEndNode) return false;

			oNextToChk = node.nextSibling;
		}

		return this._recurGetNextNodesUntil(oNextToChk, oEndNode, aNodesBetween);
	},

	_recurGetChildNodesUntil : function(node, oEndNode, aNodesBetween){
		if(!node) return false;

		var bEndFound = false;
		var oCurNode = node;
		if(oCurNode.firstChild){
			oCurNode = oCurNode.firstChild;
			while(oCurNode){
				if(!this._recurGetChildNodesUntil(oCurNode, oEndNode, aNodesBetween)){
					bEndFound = true;
					break;
				}
				oCurNode = oCurNode.nextSibling;
			}
		}

		aNodesBetween[aNodesBetween.length] = node;

		if(bEndFound) return false;
		if(node == oEndNode) return false;

		return true;
	},
	getNodes : function(bSplitTextEndNodes, fnFilter){
		if(bSplitTextEndNodes) this._splitTextEndNodesOfTheRange();

		var aAllNodes = this._getNodesInRange();
		var aFilteredNodes = [];

		if(!fnFilter) return aAllNodes;

		for(var i=0; i<aAllNodes.length; i++)
			if(fnFilter(aAllNodes[i])) aFilteredNodes[aFilteredNodes.length] = aAllNodes[i];

		return aFilteredNodes;
	},

	getTextNodes : function(bSplitTextEndNodes){
		var txtFilter = function(oNode){
			if (oNode.nodeType == 3 && oNode.nodeValue != "\n" && oNode.nodeValue != "")
				return true;
			else
				return false;
		}

		return this.getNodes(bSplitTextEndNodes, txtFilter);
	},
	surroundContentsWithNewNode : function(sTagName){
		var oNewParent = this._doc.createElement(sTagName);
		this.surroundContents(oNewParent);
		return oNewParent;
	},
	pasteHTML : function(sHTML){
		var oTmpDiv = this._doc.createElement("DIV");
		oTmpDiv.innerHTML = sHTML;

		var oFirstNode = oTmpDiv.firstChild;
		var oLastNode = oTmpDiv.lastChild;

		var clone = this.cloneRange();
		var sBM = clone.placeStringBookmark();

		while(oTmpDiv.lastChild) this.insertNode(oTmpDiv.lastChild);

		this.setEndNodes(oFirstNode, oLastNode);

		// delete the content later as deleting it first may mass up the insertion point
		// eg) <p>[A]BCD</p> ---paste O---> O<p>BCD</p>
		clone.moveToBookmark(sBM);
		clone.deleteContents();
		clone.removeStringBookmark(sBM);
	}
});

SSelection = function(win){
	this.init = function(win){
		this._window = win || window;
		this._document = this._window.document;
	};
	this.init(win);

	if('getSelection' in win){
		SSelectionImpl_FF.apply(this);
	}else{
		SSelectionImpl_IE.apply(this);
	}

	this.selectRange = function(oRng){
		this.selectNone();
		this.addRange(oRng);
	};

	this.selectionLoaded = true;
	if(!this._oSelection) this.selectionLoaded = false;
};

SSelectionImpl_FF = function(){
	this._oSelection = this._window.getSelection();

	this.getRangeAt = function(iNum){
		iNum = iNum || 0;

		try{
			var oFFRange = this._oSelection.getRangeAt(iNum);
		}catch(e){return new AXDOMRange(this._document);}
		return this._FFRange2W3CRange(oFFRange);
	};

	this.addRange = function(oW3CRange){
		var oFFRange = this._W3CRange2FFRange(oW3CRange);
		this._oSelection.addRange(oFFRange);
	};

	this.selectNone = function(){
		this._oSelection.removeAllRanges();
	};

	this._FFRange2W3CRange = function(oFFRange){
		var oW3CRange = new AXDOMRange(this._document);
		oW3CRange.setStart(oFFRange.startContainer, oFFRange.startOffset);
		oW3CRange.setEnd(oFFRange.endContainer, oFFRange.endOffset);
		return oW3CRange;
	};

	this._W3CRange2FFRange = function(oW3CRange){
		var oFFRange = this._document.createRange();
		oFFRange.setStart(oW3CRange.startContainer, oW3CRange.startOffset);
		oFFRange.setEnd(oW3CRange.endContainer, oW3CRange.endOffset);

		return oFFRange;
	};
};

SSelectionImpl_IE = function(){
	this._oSelection = this._document.selection;

	this.getRangeAt = function(iNum){
		iNum = iNum || 0;

		if(this._oSelection.type == "Control"){
			var oW3CRange = new AXDOMRange(this._document);

			var oSelectedNode = this._oSelection.createRange().item(iNum);

			// if the selction occurs in a different document, ignore
			if(!oSelectedNode || oSelectedNode.ownerDocument != this._document) return oW3CRange;

			oW3CRange.selectNode(oSelectedNode);

			return oW3CRange;
		}else{
			this._document.body.focus();

			var oSelectedNode = this._oSelection.createRangeCollection().item(iNum).parentElement();

			// if the selction occurs in a different document, ignore
			if(!oSelectedNode || oSelectedNode.ownerDocument != this._document){
				var oW3CRange = new AXDOMRange(this._document);
				return oW3CRange;
			}
			return this._IERange2W3CRange(this._oSelection.createRangeCollection().item(iNum));
		}
	};

	this.addRange = function(oW3CRange){
		var oIERange = this._W3CRange2IERange(oW3CRange);
		oIERange.select();
	};

	this.selectNone = function(){
		this._oSelection.empty();
	};

	this._W3CRange2IERange = function(oW3CRange){
		var oStartIERange = this._getIERangeAt(oW3CRange.startContainer, oW3CRange.startOffset);
		var oEndIERange = this._getIERangeAt(oW3CRange.endContainer, oW3CRange.endOffset);
		oStartIERange.setEndPoint("EndToEnd", oEndIERange);

		return oStartIERange;
	};

	this._getIERangeAt = function(oW3CContainer, iW3COffset){
		var oIERange = this._document.body.createTextRange();

		var oEndPointInfoForIERange = this._getSelectableNodeAndOffsetForIE(oW3CContainer, iW3COffset);

		var oSelectableNode = oEndPointInfoForIERange.oSelectableNodeForIE;
		var iIEOffset = oEndPointInfoForIERange.iOffsetForIE;

		oIERange.moveToElementText(oSelectableNode);
		oIERange.collapse(oEndPointInfoForIERange.bCollapseToStart);
		oIERange.moveStart("character", iIEOffset);

		return oIERange;
	};

	this._getSelectableNodeAndOffsetForIE = function(oW3CContainer, iW3COffset){
		var oIERange = this._document.body.createTextRange();

		var oNonTextNode = null;
		var aChildNodes =  null;
		var iNumOfLeftNodesToCount = 0;

		if(oW3CContainer.nodeType == 3){
			oNonTextNode = DOMfix.DF_parentNode(oW3CContainer);
			aChildNodes = DOMfix.DF_childNode(oNonTextNode);
			iNumOfLeftNodesToCount = aChildNodes.length;
		}else{
			oNonTextNode = oW3CContainer;
			aChildNodes = DOMfix.DF_childNode(oNonTextNode);
			iNumOfLeftNodesToCount = iW3COffset;
		}

		var oNodeTester = null;

		var iResultOffset = 0;

		var bCollapseToStart = true;

		for(var i=0; i<iNumOfLeftNodesToCount; i++){
			oNodeTester = aChildNodes[i];

			if(oNodeTester.nodeType == 3){
				if(oNodeTester == oW3CContainer) break;

				iResultOffset += oNodeTester.nodeValue.length;
			}else{
				oIERange.moveToElementText(oNodeTester);
				oNonTextNode = oNodeTester;
				iResultOffset = 0;

				bCollapseToStart = false;
			}
		}

		if(oW3CContainer.nodeType == 3) iResultOffset += iW3COffset;

		return {oSelectableNodeForIE:oNonTextNode, iOffsetForIE: iResultOffset, bCollapseToStart: bCollapseToStart};
	};

	this._IERange2W3CRange = function(oIERange){
		var oW3CRange = new AXDOMRange(this._document);

		var oIEPointRange = null;
		var oPosition = null;

		oIEPointRange = oIERange.duplicate();
		oIEPointRange.collapse(true);

		oPosition = this._getW3CContainerAndOffset(oIEPointRange, true);

		oW3CRange.setStart(oPosition.oContainer, oPosition.iOffset);

		var oCollapsedChecker = oIERange.duplicate();
		oCollapsedChecker.collapse(true);
		if(oCollapsedChecker.isEqual(oIERange)){
			oW3CRange.collapse(true);
		}else{
			oIEPointRange = oIERange.duplicate();
			oIEPointRange.collapse(false);
			oPosition = this._getW3CContainerAndOffset(oIEPointRange);
			oW3CRange.setEnd(oPosition.oContainer, oPosition.iOffset);
		}

		return oW3CRange;
	};

	this._getW3CContainerAndOffset = function(oIEPointRange, bStartPt){
		var oRgOrigPoint = oIEPointRange;

		var oContainer = oRgOrigPoint.parentElement();
		var offset = -1;

		var oRgTester = this._document.body.createTextRange();
		var aChildNodes = DOMfix.DF_childNode(oContainer);
		var oPrevNonTextNode = null;
		var pointRangeIdx = 0;

		for(var i=0;i<aChildNodes.length;i++){
			if(aChildNodes[i].nodeType == 3) continue;

			oRgTester.moveToElementText(aChildNodes[i]);

			if(oRgTester.compareEndPoints("StartToStart", oIEPointRange)>=0) break;

			oPrevNonTextNode = aChildNodes[i];
		}

		var pointRangeIdx = i;

		if(pointRangeIdx != 0 && aChildNodes[pointRangeIdx-1].nodeType == 3){
			var oRgTextStart = this._document.body.createTextRange();
			var oCurTextNode = null;
			if(oPrevNonTextNode){
				oRgTextStart.moveToElementText(oPrevNonTextNode);
				oRgTextStart.collapse(false);
				oCurTextNode = oPrevNonTextNode.nextSibling;
			}else{
				oRgTextStart.moveToElementText(oContainer);
				oRgTextStart.collapse(true);
				oCurTextNode = oContainer.firstChild;
			}

			var oRgTextsUpToThePoint = oRgOrigPoint.duplicate();
			oRgTextsUpToThePoint.setEndPoint("StartToStart", oRgTextStart);

			var textCount = oRgTextsUpToThePoint.text.length

			while(textCount > oCurTextNode.nodeValue.length && oCurTextNode.nextSibling){
				textCount -= oCurTextNode.nodeValue.length;
				oCurTextNode = oCurTextNode.nextSibling;
			}

			// this will enforce IE to re-reference oCurTextNode
			var oTmp = oCurTextNode.nodeValue;

			if(bStartPt && oCurTextNode.nextSibling && oCurTextNode.nextSibling.nodeType == 3 && textCount == oCurTextNode.nodeValue.length){
				textCount -= oCurTextNode.nodeValue.length;
				oCurTextNode = oCurTextNode.nextSibling;
			}

			oContainer = oCurTextNode;
			offset = textCount;
		}else{
			oContainer = oRgOrigPoint.parentElement();
			offset = pointRangeIdx;
		}

		return {"oContainer" : oContainer, "iOffset" : offset};
	};
}
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXDrag = Class.create(AXJ, {
    version: "AXJDrag V1.2",
	author: "tom@axisj.com",
	logs: [
		"2013-08-21 오후 11:47:11 - modsAX 변환",
		"2013-12-17 오후 4:56:13 - multiselect 와 호환성 작업"
	],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.dragBoxClassName = "AXJDragBox";
        this.config.bedragClassName = "bedraged";
        this.config.bedropClassName = "bedroped";
        this.config.dragClassName = "readyDrag";
        this.config.dropClassName = "readyDrop";
        this.config.sort = false;
        this.sortOn = false;
        this.config.moveSens = 5;
        this.moveSens = 0;
        this.config.scrollPos = true;
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* init ~~~~~~ */
    init: function() {
        this.draged = false;
        //this.dragBox = new Element('div', { 'class':this.config.dragBoxClassName});
        this.dragBox = jQuery("<div class='" + this.config.dragBoxClassName + "'></div>");
        this.dragBox.html("<div class=\"boxshadow\"></div><div class=\"boxicon\"></div><div class=\"boxcounter\">0</div>");

        if (this.config.sort) {
            this.sorter = jQuery(this.config.sort.sorter);
        }

        var mouseMove = this.onmouseMove.bind(this);
        this.dragBox.bind("mousemove", function(event) {
            mouseMove(this, event);
        });
        this.dragCount = this.dragBox.find("div.boxcounter");
        this.dragBoxDim = {};
        this.dragItem = [];
        //ready dragBox

        if (this.config.multiSelector) { //AXJMselect init
        	this.mselector = new AXMultiSelect();
        	this.config.multiSelector.useHelper = false;
            this.mselector.setConfig(this.config.multiSelector);
        }
    },
    active: function() {
        this.mouseDown = this.onmouseDown.bind(this);
        this.dragStart = this.ondragStart.bind(this);

        jQuery("#" + this.config.dragStage).bind("mousedown", this.mouseDown);
        jQuery("#" + this.config.dragStage).bind("dragstart", this.dragStart);
    },
    draging: function(power) {
        if (power) {
            this.draging(false);
            this.mouseMove = this.onmouseMove.bind(this);
            this.mouseOver = this.onmouseOver.bind(this);
            this.mouseOut = this.onmouseOut.bind(this);
            this.mouseUp = this.onmouseUp.bind(this);
            this.selectstart = this.onselectStart.bind(this);
            this.keyUp = this.onkeyUp.bind(this);
            jQuery("#" + this.config.dragStage).bind("mousemove", this.mouseMove);
            jQuery("#" + this.config.dragStage).bind("mouseover", this.mouseOver);
            jQuery("#" + this.config.dragStage).bind("mouseout", this.mouseOut);
            jQuery(document).bind("mouseup", this.mouseUp);
            jQuery(document).bind("selectstart", this.selectstart);
            jQuery(document).bind("keyup", this.keyUp);
            //jQuery("#" + this.config.dragStage).addClass("AXJSelectNone");
            //alert("x");
        } else {
            if (this.mouseMove) jQuery("#" + this.config.dragStage).unbind('mousemove', this.mouseMove);
            if (this.mouseOver) jQuery("#" + this.config.dragStage).unbind('mouseover', this.mouseOver);
            if (this.mouseUp) jQuery(document).unbind("mouseup", this.mouseup);
            if (this.selectstart) jQuery(document).unbind("selectstart", this.selectstart);
            if (this.keyUp) jQuery(document).unbind("keyup", this.keyup);
            //jQuery("#" + this.config.dragStage).removeClass("AXJSelectNone");
            //alert("y");
        }
    },
    inactive: function() {
        if (this.mouseDown) jQuery("#" + this.config.dragStage).unbind('mousedown', this.mouseDown);
        if (this.dragStart) jQuery("#" + this.config.dragStage).unbind('dragstart', this.dragStart);
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* on observe method ~~~~~~ */
    onmouseDown: function(event) {

        if (event.button == 2) return;
        var eventTarget = event.target;

        if (eventTarget) {
            while (!axdom(eventTarget).hasClass(this.config.dragClassName)) {
                if (eventTarget.parentNode) eventTarget = eventTarget.parentNode;
                else break;
            }
        }
        if (!jQuery(eventTarget).hasClass(this.config.dragClassName)) return;

        var dragElement = eventTarget;
        if (dragElement) {
            if (AXUtil.browser.name == "moz") {
                this.dragParent = jQuery(dragElement).parent();
                if (this.dragParent.css("overflow") == "visible") {
                    this.dragParent = null;
                }
            }

            if (this.config.multiSelector) {
            	if (event.shiftKey || event.metaKey || event.ctrlKey) {
            		
            	}else{
            		this.mselector.clickSelects(dragElement);
            	}
            	this.dragReady();
            } else {
            	this.dragReady([dragElement]);
            }
        }
    },
    ondragStart: function(event) {
        event.stopPropagation(); // disable  event
        return false;
    },
    onselectStart: function(event) {
        event.stopPropagation();
        return false;
    },
    onmouseUp: function(event) {
        var dropElement;
        var eventTarget;

        if (this.config.sort) {
            eventTarget = event.target;
            if (eventTarget) {
                while (!axdom(eventTarget).hasClass(this.config.dragClassName)) {

                    if (eventTarget.parentNode) eventTarget = eventTarget.parentNode;
                    else break;
                }
            }
            var isSort = jQuery(eventTarget).hasClass(this.config.dragClassName);
        }

        if (!isSort) { //소트타입이 아니라면
            eventTarget = event.target;
            var isDrop = jQuery(eventTarget).hasClass(this.config.dropClassName);
        }

        if (isSort) {
            if (eventTarget && this.draged) {
                if (this.config.onSort) this.config.onSort({ dragItem: this.dragItem, sortItem: eventTarget });
                this.endSort();
            }
        } else if (isDrop) {
            if (eventTarget && this.draged) {
                jQuery(eventTarget).removeClass(this.config.bedropClassName);
                if (this.config.onDrop) this.config.onDrop({ dragItem: this.dragItem, dropItem: eventTarget });
            }
        }

        this.draging(false);
        this.endDrag();
    },
    onkeyUp: function(event) {

    },
    onmouseMove: function(event) {
        if (!event.pageX) return;

        if (this.config.scrollPos) {
            if (document.body.scrollTop == 0) {
                var st = document.documentElement.scrollTop;
                var sl = document.documentElement.scrollLeft;
            } else {
                var st = document.body.scrollTop;
                var sl = document.body.scrollLeft;
            }
            this.mouse = { x: (event.pageX - sl) || 0, y: (event.pageY - st) || 0 }; //Event.pointer(event);
        } else {
            this.mouse = { x: event.pageX || 0, y: event.pageY || 0 }; //Event.pointer(event);
        }
        //드래그 감도 적용
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.dragboxMove();
    },
    onmouseOver: function(event) {
        var eventTarget;

        if (this.config.sort) {
            eventTarget = event.target;
            if (eventTarget) {
                while (!axdom(eventTarget).hasClass(this.config.dragClassName)) {

                    if (eventTarget.parentNode) eventTarget = eventTarget.parentNode;
                    else break;
                }
            }
            var isSort = jQuery(eventTarget).hasClass(this.config.dragClassName);
        }

        if (!isSort) { //소트타입이 아니라면
            eventTarget = event.target;
            var isDrop = jQuery(eventTarget).hasClass(this.config.dropClassName);
        }

        if (isDrop) {
            if (eventTarget) jQuery(eventTarget).addClass(this.config.bedropClassName);
            this.endSort();
        } else if (isSort) {
            if (eventTarget) this.startSort(eventTarget);
        } else {
            if (this.sortOn) this.endSort();
        }
    },
    onmouseOut: function(event) {
        if (!jQuery(event.target).hasClass(this.config.dropClassName)) return;
        var dropElement = event.target;
        if (dropElement) {
            jQuery(dropElement).removeClass(this.config.bedropClassName);
        }
    },
    startSort: function(target) {
        jQuery(target).before(this.sorter);
        this.sortOn = true;
    },
    endSort: function() {
        if (this.sortOn) {
            jQuery(this.sorter).detach();
        }
        if (this.config.onStopDrag) this.config.onStopDrag({ dragItem: this.dragItem });
    },
    dragboxMove: function() {
        if (!this.draged) {
            this.draged = true;
            if (this.dragParent) this.dragParent.css({ "overflow": "hidden" });
            var bedragClassName = this.config.bedragClassName;
            if (this.config.appendTarget)
                jQuery("#" + this.config.appendTarget).append(this.dragBox);
            else
                jQuery("#" + this.config.dragStage).after(this.dragBox);

            this.dragBoxDim = { width: this.dragBox.width(), height: this.dragBox.height() }; //.getDimensions();
            this.dragCount.html(this.dragItem.length);
            this.dragTrigger();
            //draged dragItem
            jQuery(this.dragItem).addClass(bedragClassName);
        }

        this.dragBox.css({ left: this.mouse.x + (20) + "px", top: this.mouse.y + (20) + "px" });
    },
    endDrag: function() {
        if (this.draged) {
            if (this.dragParent) this.dragParent.css({ "overflow": "auto" });

            var bedragClassName = this.config.bedragClassName;
            this.draged = false;
            this.dragBox.detach();
            this.endSort();
            //undraged dragItem
            jQuery(this.dragItem).removeClass(bedragClassName);
            if (this.config.multiSelector) this.mselector.clearSelects();
            else this.dragItem.clear();
            this.moveSens = 0;
        }
    },
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* class method ~~~~~~ */
    dragReady: function(dragItems) {
        if (this.config.multiSelector) this.dragItem = this.mselector.getSelects();
        else this.dragItem = dragItems;
        this.draging(true);
    },
    dragTrigger: function() {
        if (this.config.onDrag) this.config.onDrag({ dragItem: this.dragItem });
    },
    collectItem: function() {
        if (this.config.multiSelector) {
            if (this.observer) clearTimeout(this.observer);
            this.observer = setTimeout(this.collectItemAct.bind(this), 100);
        }
    },
    collectItemAct: function() {
        this.mselector.collect();
    },
    nothing: function() {

    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */

var AXEditorLang = {
    en: {
        home: "HOME",
        attch: "Attachment",
        table: "Table",
        layout: "Layouts",
        option: "Options",
        external: "External",
        editor: "Editor",
        HTML: "HTML",
        textColor: "TEXT COLOR",
        textBgColor: "TEXT BGCOLOR",
        fontFamily: "Font Family",
        fontSize: "Font Size",
        fontSample: "가나Ab",
        lineHeight: "Line Height(em)",
        url: "Link",
        upload: "Upload",
        insertDoc: "Insert",
        delSelected: "Delete",
        selectAll: "SelectAll",
        invalidUrlMsg: "invalid url make fail",
        volumeOverMsg: "upload Maxium size over",
        noSelectedFileMsg: "No selected target file",
        fileDeleteConfirm: "Do you want to delete it?",
        externalTitle: "Custom AX Pannel",
        imoticon: "Imoticon"
    },
    kr: {
        home: "홈",
        attch: "파일첨부",
        table: "테이블",
        layout: "레이아웃",
        option: "옵션",
        external: "추가기능",
        editor: "Editor",
        HTML: "HTML",
        textColor: "텍스트 컬러",
        textBgColor: "텍스트 배경컬러",
        fontFamily: "글꼴",
        fontSize: "글자크기",
        fontSample: "가나Ab",
        lineHeight: "줄간격(em)",
        url: "링크걸기",
        upload: "업로드",
        insertDoc: "본문삽입",
        delSelected: "선택삭제",
        selectAll: "전체선택",
        invalidUrlMsg: "url 형식이 잘못되어 url연결에 실패 하였습니다.",
        volumeOverMsg: "업로드 용량이 초과 되어 업로드 하실 수 없습니다.",
        noSelectedFileMsg: "선택된 파일이 없습니다.",
        fileDeleteConfirm: "정말 삭제 하시겠습니까?",
        externalTitle: "Custom AX Pannel",
        imoticon: "이모티콘"
    },
    jp: {
        home: "HOME",
        attch: "Attachment",
        table: "Table",
        layout: "Layouts",
        option: "Options",
        external: "External",
        editor: "Editor",
        HTML: "HTML",
        textColor: "TEXT COLOR",
        textBgColor: "TEXT BGCOLOR",
        fontFamily: "Font Family",
        fontSize: "Font Size",
        fontSample: "가나Ab",
        lineHeight: "Line Height(em)",
        url: "Link",
        upload: "Upload",
        insertDoc: "Insert",
        delSelected: "Delete",
        selectAll: "Select",
        invalidUrlMsg: "invalid url make fail",
        volumeOverMsg: "upload Maxium size over",
        noSelectedFileMsg: "No selected target file",
        fileDeleteConfirm: "Do you want to delete it?",
        externalTitle: "Custom AX Pannel",
        imoticon: "Imoticon"
    },
    cn: {
        home: "HOME",
        attch: "Attachment",
        table: "Table",
        layout: "Layouts",
        option: "Options",
        external: "External",
        editor: "Editor",
        HTML: "HTML",
        textColor: "TEXT COLOR",
        textBgColor: "TEXT BGCOLOR",
        fontFamily: "Font Family",
        fontSize: "Font Size",
        fontSample: "가나Ab",
        lineHeight: "Line Height(em)",
        url: "Link",
        upload: "Upload",
        insertDoc: "Insert",
        delSelected: "Delete",
        selectAll: "Select",
        invalidUrlMsg: "invalid url make fail",
        volumeOverMsg: "upload Maxium size over",
        noSelectedFileMsg: "No selected target file",
        fileDeleteConfirm: "Do you want to delete it?",
        externalTitle: "Custom AX Pannel",
        imoticon: "Imoticon"
    }
};

/*
2014-04-17 : tom - insert image & remove image 아이디 문제 해결
*/

/**
 * AXEditor
 * @class AXEditor
 * @extends AXJ
 * @version v1.4
 * @author tom@axisj.com
 * @logs
 * "2014-06-04 tom : method [insertImg] Insert prevent duplicate images
 * "2014-08-05 tom : add event onresize"
 * "2014-08-08 tom : AXConfig.AXEditor 설정 추가"
 * "2014-09-01 tom : toolbar config 추
 *
 */

var AXEditor = Class.create(AXJ, {
    _GID: function (ids) {
        var myid = [];
        for (var a = 0; a < ids.length; a++) {
            myid.push(ids[a]);
        }
        return myid.join("_");
    },
    _GPT: function (myid, idx) {
        var ids = myid.split(/_/g);
        if (idx == undefined) {
            return ids.last();
        }
        else {
            return ids[idx];
        }
    },
    initialize: function (AXJ_super) {
        AXJ_super();
        this.moveSens = 0;
        this.contentMode = "editor";
        this.panelNum = 0;
        this.attchFiles = [];
        this.readyFiles = [];

        this.config.containerCss = "AXEditor";
        this.config.headCss = "editorHead";
        this.config.bodyCss = "editorBody";
        this.config.footCss = "editorFoot";
        this.config.height = 300;
        this.config.lang = "en";
        this.config.moveSens = 5;
        this.config.ie67adj = -2;
        this.config.selectMenuIndex = 0;
        this.config.tabFileUsed = false;
        this.config.tabTableUsed = false;
        this.config.tabLayoutUsed = false;
        this.config.tabOptionUsed = false;
        this.config.tabExternalUsed = false;
        this.config.frameSrc = (AXConfig.AXEditor.editor_frameSrc || "/_AXJ/lib/AXEditor.html");
        this.config.editorFontSize = "12px";
        this.config.editorFontFamily = "Malgun Gothic";
        this.config.colors = ["ffffff", "faedd4", "fff3b4", "ffffbe", "ffeaea", "ffeaf8", "e6ecfe", "d6f3f9", "e0f0e9", "eaf4cf", "e8e8e8", "e7c991", "f3d756", "ffe409", "f9b4cb", "dfb7ee", "b1c4fc", "96ddf3", "b1dab7", "b8d63d", "c2c2c2", "d18e0a", "ec9c2c", "ff8b16", "f3709b", "af65dd", "7293fa", "49b5d5", "6abb9a", "5fb636", "8e8e8e", "9d6c08", "c84205", "e31600", "c8056a", "801fbf", "3058d2", "0686a8", "318561", "2b8400", "474747", "654505", "8c3c04", "840000", "8c044b", "57048c", "193da9", "004c5f", "105738", "174600", "000000", "463003", "612a03", "5b0000", "610334", "320251"];
        this.config.fonts = ["Malgun Gothic", "Gulim", "Dotum", "궁서"];
        this.config.fontsizes = [8, 9, 10, 11, 12, 14, 16, 18, 20];
        this.config.lineHeights = [1.0, 1.2, 1.5, 1.8, 2.0, 2.5];
        this.config.swfUploader = "";
        this.config.uploadUrl = "";
        this.config.uploadPars = ["p1=1", "p2=2"];
        this.config.deleteUrl = "";
        this.config.deletePars = [];
        this.config.uploadVolume = (5 * 1024 * 1024);
        this.config.uploadFilterName = "All,Image";
        this.config.uploadFilterValue = "*.*,*.jpg; *.gif; *.png";
        this.config.uploadCallBack = "mmuCall";
        this.config.tabExternals = [];
        this.config.readyTofocus = true;
        this.config.msg = {
            alreadyInsertImg: "이미 추가된 이미지 입니다."
        }

        this.config.toolbar = {
            fontFamily: true,
            fontSize: true,
            fontDecoration: true,
            color: true,
            textAlign: true,
            orderList: true,
            lineHeight: true,
            url: true,
            imoticon: true,
            pageBreak: true
        };

        this.config.AXEditorIcons = [
            {
                categoryNM: "Grimi",
                copyRights: "<a href='http://jowrney.com/xe/grimi/' target='_blank'>Copyright © Jowrney.com. All rights reserved.</a>",
                imageFolder: (AXConfig.AXEditor.iconDirectory || "/ui/icons/") + "grimi/",
                icons: ["grimi_big_smile16.png", "grimi_cry16.png", "grimi_doze16.png", "grimi_happy16.png", "grimi_love16.png", "grimi_smile16.png", "grimi_so_what16.png", "grimi_vomit16.png"]
            },
            {
                categoryNM: "Fugue Icons",
                copyRights: "<a href='http://p.yusukekamiyamane.com/' target='_blank'>Copyright © Yusuke Kamiyamane. All rights reserved.</a>",
                imageFolder: (AXConfig.AXEditor.iconDirectory || "/ui/icons/"),
                icons: ["address-book.png", "alarm-clock.png", "arrow-000-medium.png", "arrow-045-medium.png", "arrow-045.png", "arrow-090-medium.png", "arrow-090.png",
                    "arrow-135-medium.png", "arrow-135.png", "arrow-180-medium.png", "arrow-180.png", "arrow-225-medium.png", "arrow-225.png", "arrow-270-medium.png", "arrow-270.png",
                    "arrow-315-medium.png", "arrow-315.png", "arrow.png", "asterisk.png", "auction-hammer.png", "balance.png", "balloon-ellipsis.png", "balloon-quotation.png", "balloon.png",
                    "bandaid.png", "bell.png", "bin.png", "binocular.png", "block.png", "bomb.png", "bookmark.png", "box.png", "briefcase.png", "broom.png", "building.png", "burn.png",
                    "calculator.png", "camcorder.png", "camera.png", "car--exclamation.png", "car-red.png", "clapperboard.png", "compass.png", "credit-card.png", "crown-bronze.png",
                    "crown-silver.png", "crown.png", "currency-euro.png", "currency-pound.png", "currency-yen.png", "currency.png", "cursor-small.png", "cursor.png", "direction.png",
                    "drill.png", "eraser.png", "eye.png", "hammer.png", "hand.png", "heart-break.png", "heart.png", "inbox.png", "keyboard.png", "leaf.png", "lifebuoy.png", "light-bulb.png",
                    "mail-open.png", "mail.png", "marker.png", "megaphone.png", "microphone.png", "mobile-phone.png", "money.png", "mouse.png", "music.png", "paint-can.png", "pipette-color.png",
                    "plug.png", "printer.png", "safe.png", "smiley-confuse.png", "smiley-cool.png", "smiley-cry.png", "smiley-eek.png", "smiley-evil.png", "smiley-fat.png", "smiley-grin.png",
                    "smiley-lol.png", "smiley-mad.png", "smiley-mr-green.png", "smiley-neutral.png", "smiley-paint-brush.png", "smiley-razz.png", "smiley-red.png", "smiley-roll.png", "smiley-sad.png",
                    "smiley-slim.png", "smiley-surprise.png", "smiley-twist.png", "smiley-wink.png", "smiley-yell.png", "smiley.png"]
            }
        ];

    },

    /**
     * 선언된 스크롤 클래스를 사용하기 위해 속성을 정의합니다.
     * @method AXEditor.setConfig
     * @param {Object}
     * @example
     ```js
     var myEditor = new AXEditor();

     myEditor.setConfig({
	targetID: "AXEditorTarget", // 에디터 표시 타겟
	lang: "kr",
	height: 300,
	frameSrc: "lib/AXEditor.html", // 에디터 컨텐츠 기본 HTML 위치
	editorFontFamily: "Malgun Gothic",
	fonts: ["Malgun Gothic","Gulim","Dotum","궁서"],
	onReady: function(){ // 에디터 준비완료
		myEditor.setContent($("#editContent"));
	},
    onresize: function(){ // 에디터 높이 변경 이벤트
        trace(this);
    }
});
     ```
     */
    init: function () {
        this._self = jQuery("#" + this.config.targetID);
        var config = this.config;
        // po
        var po = [];
        po.push("<div id=\"" + config.targetID + "_container\" class=\"" + config.containerCss + "\">");
        po.push("	<div id=\"" + config.targetID + "_head\"   class=\"" + config.headCss + "\"></div>");
        po.push("	<div id=\"" + config.targetID + "_body\"   class=\"" + config.bodyCss + "\"></div>");
        po.push("	<div id=\"" + config.targetID + "_foot\"   class=\"" + config.footCss + "\"></div>");
        po.push("</div>");
        this._self.append(po.join(''));

        // define element
        this.container = jQuery("#" + config.targetID + "_container");
        this.head = jQuery("#" + config.targetID + "_head");
        this.body = jQuery("#" + config.targetID + "_body");
        this.foot = jQuery("#" + config.targetID + "_foot");

        //init head
        this.initHead();

        //init foot
        this.initFoot();

        //init body
        this.initBody();
    },
    initHead: function () {
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var po = [];
        /*메뉴탭과 패널*/
        /*po.push("<div id=\""+re+"_headTab\" class='me___tabContainer'></div>");*/
        po.push("<div id=\"" + re + "_headPanel\" class='me___headPanel'></div>");
        this.head.append(po.join(''));
        /*메뉴 내용 구성*/

        this.initPanel();
    },
    initPanel: function () {
        var config = this.config;
        var re = config.targetID;
        var po = [];
        if (config.toolbar.fontFamily)
        {
            po.push("<div class='me___selectW'>");
            po.push("	<a href='#axExecption' class='me___value selectCommand me_ffs' style='font-family:" + config.editorFontFamily + "' id='" + this._GID([re, "fontname"]) + "'>" + config.editorFontFamily + "</a>");
            po.push("</div>");
        }
        if (config.toolbar.fontSize)
        {
            po.push("<div class='me___selectS'>");
            po.push("	<a href='#axExecption' class='me___value selectCommand me_fss' id='" + this._GID([re, "fontsize"]) + "'>" + config.editorFontSize + "</a>");
            po.push("</div>");
        }

        if (config.toolbar.fontDecoration)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnL'>");
            po.push("	<span class='me_icon me___bold simpleCommand' id='" + this._GID([re, "bold"]) + "'>Bold</span>");
            po.push("</a>");

            po.push("<a href='#axExecption' class='me___btnM'>");
            po.push("	<span class='me_icon me___italic simpleCommand' id='" + this._GID([re, "italic"]) + "'>Italic</span>");
            po.push("</a>");
            po.push("<a href='#axExecption' class='me___btnM'>");
            po.push("	<span class='me_icon me___underLine simpleCommand' id='" + this._GID([re, "underline"]) + "'>UnderLine</span>");
            po.push("</a>");
            po.push("<a href='#axExecption' class='me___btnR'>");
            po.push("	<span class='me_icon me___strike simpleCommand' id='" + this._GID([re, "strikethrough"]) + "'>strike</span>");
            po.push("</a>");
        }

        if (config.toolbar.color)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<div class='me___selectTL'>");
            po.push("	<div class='me___fontColor_disp' style='background:#444444;' id='" + this._GID([re, "foreColorVal"]) + "'></div>");
            po.push("	<a href='#axExecption' class='me___value colorCommand' id='" + this._GID([re, "foreColor"]) + "'>foreColor</a>");
            po.push("	<a href='#axExecption' class='me___arrow selectCommand me_picker' id='" + this._GID([re, "foreColorExt"]) + "'>+</a>");
            po.push("</div>");
            po.push("<div class='me___selectTR'>");
            po.push("	<div class='me___fontBgColor_disp' style='background:#ffffff;' id='" + this._GID([re, "backColorVal"]) + "'></div>");
            po.push("	<a href='#axExecption' class='me___value colorCommand' id='" + this._GID([re, "backColor"]) + "'>backColor</a>");
            po.push("	<a href='#axExecption' class='me___arrow selectCommand me_picker' id='" + this._GID([re, "backColorExt"]) + "'>+</a>");
            po.push("</div>");
        }
        if (config.toolbar.textAlign)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnL'>");
            po.push("	<span class='me_icon me___alignLeft simpleCommand' id='" + this._GID([re, "JustifyLeft"]) + "'>alignLeft</span>");
            po.push("</a>");
            po.push("<a href='#axExecption' class='me___btnM'>");
            po.push("	<span class='me_icon me___alignCenter simpleCommand' id='" + this._GID([re, "JustifyCenter"]) + "'>alignCenter</span>");
            po.push("</a>");
            po.push("<a href='#axExecption' class='me___btnM'>");
            po.push("	<span class='me_icon me___alignRight simpleCommand' id='" + this._GID([re, "JustifyRight"]) + "'>alignRight</span>");
            po.push("</a>");
            po.push("<a href='#axExecption' class='me___btnR'>");
            po.push("	<span class='me_icon me___alignJustify simpleCommand' id='" + this._GID([re, "JustifyFull"]) + "'>alignJustify</span>");
            po.push("</a>");
        }
        if (config.toolbar.orderList)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnL'>");
            po.push("	<span class='me_icon me___li simpleCommand' id='" + this._GID([re, "InsertUnorderedList"]) + "'>li</span>");
            po.push("</a>");

            po.push("<a href='#axExecption' class='me___btnR'>");
            po.push("	<span class='me_icon me___ol simpleCommand' id='" + this._GID([re, "InsertOrderedList"]) + "'>ol</span>");
            po.push("</a>");
        }

        if (config.toolbar.lineHeight)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnSa'>");
            po.push("	<span class='me_icon me___lineHeight selectCommand me_lhs' id='" + this._GID([re, "lineHeight"]) + "'>lineHeight</span>");
            po.push("</a>");
        }
        if (config.toolbar.url)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnSa'>");
            po.push("	<span class='me_icon me___url selectCommand me_url' id='" + this._GID([re, "url"]) + "'>url</span>");
            po.push("</a>");
        }
        if (config.toolbar.imoticon)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnSa'>");
            po.push("	<span class='me_icon me___imoticon selectCommand me_ico' id='" + this._GID([re, "imoticon"]) + "'>imoticon</span>");
            po.push("</a>");
        }
        if (config.toolbar.pageBreak)
        {
            po.push("<div class='me___vline'></div>");
            po.push("<a href='#axExecption' class='me___btnSa'>");
            po.push("	<span class='me_icon me___pageBreak pbCommand' id='" + this._GID([re, "pageBreak"]) + "'>pageBreak</span>");
            po.push("</a>");
        }
        jQuery("#" + re + "_headPanel").append(po.join(''));
        jQuery("#" + re + "_headPanel").find(".simpleCommand").bind("click", this.onSimpleCommandClick.bind(this));
        jQuery("#" + re + "_headPanel").find(".colorCommand").bind("click", this.onColorCommandClick.bind(this));
        jQuery("#" + re + "_headPanel").find(".selectCommand").bind("click", this.onSelectCommandClick.bind(this));
        jQuery("#" + re + "_headPanel").find(".pbCommand").bind("click", this.onInsertCommand.bind(this));
    },
    closePanel: function () {
        var config = this.config;
        var re = config.targetID;
        var items = ["home_btn", "attch_btn", "table_btn", "layout_btn", "option_btn", "external_btn"];
        jQuery("#" + re + "_" + items[this.panelNum]).parent().removeClass("me___itemOn");
        if (this.panelNum == 0) return;
        if (this.panelNum == 1) this.initFlashButtonMoveTo(jQuery("#" + re + "_" + items[this.panelNum]).parent());

        /*this.closeFileStatus();*/
        this.divPanel.remove();
        jQuery("#" + config.targetID + "_head").removeClass("editorHeadExt");
    },
    openPanel: function () {
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var items = ["home_btn", "attch_btn", "table_btn", "layout_btn", "option_btn", "external_btn"];
        jQuery("#" + re + "_" + items[this.panelNum]).parent().addClass("me___itemOn");

        if (this.panelNum == 0) return;
        if (this.panelNum == 1) {
            this.divPanel = jQuery("<div id='" + this._GID([re, "divPanel", "attch"]) + "' class='me___headDivPanel_attch'></div>");
            var po = [];
            po.push("<div class='me___headDivPanel_attch_btns' id='" + re + "_divPanel_attchBtns'>");
            po.push("	<span class='me___span' style='margin-left:33px;'>&nbsp;</span>");
            po.push("	<a href='#axExecption' class='me___btnS1' id='" + this._GID([re, "attbtns", "insertDoc"]) + "'>" + lg.insertDoc + "</a>");
            po.push("	<a href='#axExecption' class='me___btnS1' id='" + this._GID([re, "attbtns", "delete"]) + "'>" + lg.delSelected + "</a>");
            po.push("	<span class='me___span'>&nbsp;</span>");
            po.push("	<a href='#axExecption' class='me___btnS1' id='" + this._GID([re, "attbtns", "selectAll"]) + "'>" + lg.selectAll + "</a>");
            po.push("</div>");
            po.push("<div class='me___headDivPanel_attch_CT' nowrap='nowrap' align='left'>");

            jQuery.each(this.attchFiles, function (si, fo) {
                if (fo.checked) {
                    po.push("<div class='attchItem attchItemON' id='" + re + "_attchItem_" + si + "' title='" + fo.ti.dec() + "'>");
                }
                else {
                    po.push("<div class='attchItem' id='" + re + "_attchItem_" + si + "' title='" + fo.ti.dec() + "'>");
                }
                po.push("<div class='attchItemName'>" + fo.ti.dec() + "</div>");
                po.push("<div class='attchItemPreview'>");
                var ty = fo.ty.dec().toLowerCase();
                if (ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp") {
                    po.push("<img src='" + fo.path.dec() + fo.nm.dec() + "' width='100%' height='100%' alt='' />")
                }
                po.push("</div>");
                po.push("</div>");
            });

            po.push("	<div class='attchItemEnd' id='" + re + "_divPanel_attchItemEnd'>&nbsp;</div>");
            po.push("</div>");
            this.divPanel.html(po.join(''));

            this.openFileStatus();
        }
        if (this.panelNum == 5) {
            this.divPanel = jQuery("<div id='" + this._GID([re, "divPanel", "external"]) + "' class='me___headDivPanel_attch'></div>");
            var po = [];
            po.push("<div class='me___headDivPanel_attch_btns' id='" + re + "_divPanel_attchBtns'>");
            po.push("<div class='headTitle'>" + lg.externalTitle + "</div>");
            po.push("</div>");
            po.push("<div class='me___headDivPanel_attch_CT' nowrap='nowrap' align='left'>");

            jQuery.each(config.tabExternals, function (idx, n) {
                po.push("<div class='componentItem' id='" + n.component + "' title='" + n.title + "'>");
                po.push("<div class='componentItemName'>" + n.title + "</div>");
                po.push("<div class='componentItemPreview'>");
                if (n.ico != "") {
                    po.push("<img src='" + n.ico + "' alt='' />")
                }
                po.push("</div>");
                po.push("</div>");
            });

            po.push("	<div class='attchItemEnd' id='" + re + "_divPanel_attchItemEnd'>&nbsp;</div>");
            po.push("</div>");
            this.divPanel.html(po.join(''));
        }

        jQuery("#" + re + "_headPanel").append(this.divPanel);
        jQuery("#" + config.targetID + "_head").addClass("editorHeadExt");
        if (this.panelNum == 1) {
            this.initFlashButtonMoveTo(jQuery("#" + re + "_divPanel_attchBtns"));
            jQuery("#" + re + "_divPanel_attch").find(".me___btnS1").bind("click", this.onAttbtnsClick.bind(this));
            jQuery("#" + re + "_divPanel_attch").find(".attchItem").bind("click", this.onAttchItemClick.bind(this));
        }
        if (this.panelNum == 5) {
            jQuery("#" + re + "_divPanel_external").find(".componentItem").bind("click", this.onClickComponent.bind(this));
        }
    },
    setAttchItem: function (arg) {
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        if (!arg) return;

        /*file size check*/
        var useByte = 0;
        var volumeByte = config.uploadVolume;
        jQuery.each(this.attchFiles, function () {
            useByte += this.size.number();
        });
        jQuery.each(arg, function (index) {
            useByte += this.size.number();
        });
        if (useByte > volumeByte) {
            /*alert(	lg.volumeOverMsg + "\n\n(" + useByte.byte() + "/" + volumeByte.byte() +")" );*/
            /*AXFlash.requestFn(re+"_attched_swf","uploadCancel");*/
            /*return;*/
        }
        this.readyFiles = arg;
        this.readyUpload();
        /*업로드 시작*/
        /*AXFlash.requestFn(re+"_attched_swf", "uploadStart");*/
    },
    readyUpload: function () {
        if (this.readyFiles.length == 0) return;
        var config = this.config;
        var re = config.targetID;
        /*ready file*/
        var startIndex = this.attchFiles.length;
        var po = [];
        po.push("<div class='attchItem' id='" + re + "_attchItem_" + startIndex + "'>");
        po.push("	<div class='attchItemName'>.....</div>");
        po.push("	<div class='attchItemPreviewLoad'></div>");
        po.push("</div>");
        jQuery("#" + re + "_divPanel_attchItemEnd").before(po.join(''));
    },
    uploadedFile: function (arg) {
        var config = this.config;
        var re = config.targetID;
        var startIndex = this.attchFiles.length;
        jQuery("#" + re + "_attchItem_" + startIndex).attr('title', arg.ti.dec());
        jQuery("#" + re + "_attchItem_" + startIndex).find(".attchItemName").html(arg.ti.dec());
        jQuery("#" + re + "_attchItem_" + startIndex).find(".attchItemPreviewLoad").addClass("attchItemPreview");
        jQuery("#" + re + "_attchItem_" + startIndex).bind("click", this.onAttchItemClick.bind(this));
        var ty = arg.ty.dec().toLowerCase();
        if (ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp") {
            jQuery("#" + re + "_attchItem_" + startIndex).find(".attchItemPreviewLoad").html("<img src='" + arg.path.dec() + arg.nm.dec() + "' width='100%' height='100%' alt='' />")
            /*본문삽입*/
            var imgObj = new Image();
            imgObj.src = arg.path.dec() + arg.nm.dec();
            imgObj.id = "MF_" + arg.nm.replace(arg.ty, "").dec();
            var pasteHTML = this.__pasteHTML.bind(this);
            var canvasWidth = this.canvas.width() - 40;
            imgObj.onload = function () {
                var ow = imgObj.width;
                var oh = imgObj.height;
                if (imgObj.width > canvasWidth) {
                    imgObj.width = canvasWidth;
                    imgObj.height = oh * (imgObj.width / ow);
                }
                try {
                    pasteHTML(imgObj);
                } catch (e) {
                    alert(e.print());
                }
            }
        }
        this.attchFiles.push(arg);
        this.readyFiles.pop();
        this.readyUpload();
        this.updateFileStatus();
    },
    /**
     * 에디터 바디에 이미지를 추가합니다.
     * @method AXEditor.insertIMG
     * @param {Object} img
     * @returns {AXEditor}
     * @example
     ```js
     var file = {
	id:"식별자", nm:"저장된파일이름", ty:"파일타입"
};
     myEditor.insertIMG(file);
     ```
     */
    insertIMG: function (file) {

        /*trace(file);*/

        /*{id:"", ti:"", nm:"", ty:"", sz:"", path:"", thumb:""}*/
        var config = this.config;
        var re = config.targetID;
        var ty = file.ty.dec().toLowerCase();
        var tyReg = /(bmp|jpg|jpeg|gif|png)$/;
        if (tyReg.test(ty)) {
            var imgTagId = "MF_" + file.nm.replace(new RegExp("[\.]" + file.ty, "i"), "").dec();
            if (axdom(this.myEDT.document).find("#" + imgTagId).get(0)) {
                alert(config.msg.alreadyInsertImg);
                return;
            }
            var imgObj = new Image();
            imgObj.src = file.path.dec() + file.nm.dec();
            imgObj.id = imgTagId;

            var pasteHTML = this.__pasteHTML.bind(this);
            var canvasWidth = this.canvas.width() - 40;
            imgObj.onload = function () {
                var ow = imgObj.width;
                var oh = imgObj.height;
                if (imgObj.width > canvasWidth) {
                    imgObj.width = canvasWidth;
                    imgObj.height = oh * (imgObj.width / ow);
                }
                try {
                    pasteHTML(imgObj);
                } catch (e) {
                    alert(e.print());
                }
            }
        }
        return this;
    },
    /**
     * 에디터 바디에서 이미지를 제거합니다.
     * @method AXEditor.removeIMG
     * @param {String} fileID
     * @returns {AXEditor}
     * @example
     ```js
     myEditor.removeIMG("IMG_00110011");
     ```
     */
    removeIMG: function (fileID) {
        this.onFeilDeleteInFrame("#" + fileID);
        return this;
    },
    initFoot: function () {
        var config = this.config;
        var po = [];
        po.push("<a class='me___handle'>resizer</a>");
        po.push("<div class='me___container'>");
        po.push("	<a href='#axExecption' id='" + config.targetID + "_contentMode_0' class='me____tab me____tabOn'>Editor</a>");
        po.push("	<a href='#axExecption' id='" + config.targetID + "_contentMode_1' class='me____tab'>HTML</a>");
        po.push("</div>");
        this.foot.append(po.join(''));
        this.foot.find("a.me___handle").bind("mousedown", this.footOnDrag.bind(this));
        this.foot.find("a.me____tab").bind("click", this.onContentMode.bind(this));
    },
    /* initFoot sub functions */
    footOnDrag: function () {
        this.footOnMover = this.footOnMove.bind(this);
        jQuery(document).bind("mousemove", this.footOnMover);
        this.footOnDroper = this.footOnDrop.bind(this);
        jQuery(document).bind("mouseup", this.footOnDroper);
        this.selectstart = this.onselectStart.bind(this);
        jQuery(document).bind("selectstart", this.selectstart);
        this.canvasMask.show();
    },
    footOnMove: function (event) {
        if (!event.pageX) return;
        this.mouse = {x: event.pageX || 0, y: event.pageY || 0};
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.footMove();
    },
    footMove: function () {
        if (!this.draged) {
            this.draged = true;
            this.canvasTop = (this.contentMode == "html") ? this.htmlArea.offset().top : this.canvas.offset().top;
        }
        if ((this.mouse.y - this.canvasTop) > 100) this.config.height = (this.mouse.y - this.canvasTop - 2);
        if (this.observer) clearTimeout(this.observer);
        this.observer = setTimeout(this.footSetCanvasHeight.bind(this), 10);
    },
    footOnDrop: function () {
        this.moveSens = 0;
        jQuery(document).unbind("mousemove", this.footOnMover);
        jQuery(document).unbind("mouseup", this.footOnDroper);
        jQuery(document).unbind("selectstart", this.selectstart);
        clearTimeout(this.observer);
        this.canvasMask.hide();
        this.draged = false;
    },
    footSetCanvasHeight: function () {
        this.canvas.css({height: this.config.height + "px"});
        if (this.contentMode == "html") {
            this.htmlArea.css({height: this.canvas.height() + "px"});
        }
        if (Object.isFunction(this.config.onresize)) {
            this.config.onresize.call({canvas: this.canvas, height: this.canvas.height()});
        }
    },
    /* initFoot sub functions */
    initBody: function () {
        var config = this.config;
        this.canvas = jQuery("<iframe src='" + config.frameSrc + "' id='" + config.targetID + "_canvas' name='" + config.targetID + "_canvas' frameBorder='0' allowTransparency='true'></iframe>");
        this.canvasMask = jQuery("<div id='" + config.targetID + "_canvasMask' class='me___AXMask' style='display:none;z-index:10;'></div>");
        this.body.append(this.canvas);
        this.body.append(this.canvasMask);
        this.canvas.css({"width": "100%", height: config.height + "px"});
        this.canvas.bind("load", this.readyFrame.bind(this));
    },
    setHtmlMode: function (power) {
        if (power == "on") {
            var config = this.config;
            var canvasHeight = this.canvas.height();
            this.canvas.hide();
            this.htmlArea = jQuery("<textarea id='" + config.targetID + "_html' name='" + config.targetID + "_html' class='me__htmlArea'></textarea>");
            this.body.append(this.htmlArea);
            this.htmlArea.css({"width": "100%", height: canvasHeight + "px"});
            this.htmlArea.val(this.__getContent());
        }
        else {
            this.setContent(this.htmlArea.val());
            this.canvas.show();
            this.htmlArea.remove();
        }
    },
    readyFrame: function () {
        var config = this.config;
        this.myEDT = window[config.targetID + "_canvas"];

        var editorBody = this.myEDT.document;
        if (AXUtil.browser.name == "ie")    editorBody.body.contentEditable = true;
        else if (AXUtil.browser.name == "webkit") {
            editorBody.body.contentEditable = true;
            editorBody.designMode = "On";
        }
        else if (AXUtil.browser.name == "mozilla")    editorBody.designMode = "On";
        else    editorBody.designMode = "On";
        try {
            jQuery(editorBody.body).css({"font-size": config.editorFontSize});
            jQuery(editorBody.body).css({"font-family": config.editorFontFamily});
        } catch (e) {
        }

        this.bindFocusFrame();
        if (this.config.onReady) this.config.onReady();
    },
    focusFrame: function () {
        /* close all menu*/
        this.closeColorPicker();
        this.closeffPicker();
        this.closefsPicker();
        this.closelhPicker();

        this.closeicPicker();
    },
    unbindFocusFrame: function () {
        var editorBody = this.myEDT.document;
        if (AXUtil.browser.name == "mozilla") jQuery(editorBody).unbind("focus", this.focusFrame.bind(this));
        else    jQuery(editorBody.body).unbind("focus", this.focusFrame.bind(this));
    },
    bindFocusFrame: function () {
        var editorBody = this.myEDT.document;
        if (AXUtil.browser.name == "mozilla") jQuery(editorBody).bind("focus", this.focusFrame.bind(this));
        else    jQuery(editorBody.body).bind("focus", this.focusFrame.bind(this));
    },
    onselectStart: function (event) {
        event.stopPropagation();
        return false;
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    __command: function (sCommand, bUserInterface, vValue) {
        var myEDT = this.myEDT.document;
        myEDT.execCommand(sCommand, bUserInterface, vValue);
    },
    __pasteHTML: function (sHTML) {
        var myEDT = this.myEDT.document;
        var oTmpDiv = myEDT.createElement("DIV");
        var oTmpP = myEDT.createElement("P");
        oTmpDiv.appendChild(oTmpP);
        if (typeof(sHTML) == "string") oTmpDiv.innerHTML = sHTML;
        else  oTmpP.appendChild(sHTML);

        if (this.contentMode == "editor") {
            var myRange = new SSelection(this.myEDT);
            var rng = myRange.getRangeAt(0);
            rng.insertNode(oTmpDiv.lastChild);
        }
        else {
            jQuery("#" + this.config.targetID + "_html").val(jQuery("#" + this.config.targetID + "_html").val() + oTmpDiv.innerHTML);
        }
    },
    /* click event */
    onHeadClick: function (event) {
        if (typeof(event) == "object") {
            var myID = event.target.id;
            if (!myID) return;
            var ids = myID.split(/_/g);
            var headNM = ids[1];
            var headCMD = ids[2];
        }
        else {
            var headNM = event;
            var headCMD = "";
        }
        if (headNM == "home") {
            this.closePanel();
            this.panelNum = 0;
            this.openPanel();
        }
        else if (headNM == "attch") {
            if (this.panelNum == 1) return;
            this.closePanel();
            this.panelNum = 1;
            this.openPanel();
        }
        else if (headNM == "external") {
            if (this.panelNum == 5) return;
            this.closePanel();
            this.panelNum = 5;
            this.openPanel();
        }
    },
    onAttchPanelOpen: function (arg) {
        if (this.panelNum == 1) {
            if (arg)    this.setAttchItem(arg);
            return;
        }
        this.closePanel();
        this.panelNum = 1;
        this.openPanel();
        if (arg)    this.setAttchItem(arg);
    },
    onSimpleCommandClick: function (event) {
        var myID = event.target.id;
        if (!myID) return;
        var command = this._GPT(myID);
        this.__command(command);
    },
    onColorCommandClick: function (event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;
        var myID = event.target.id;
        if (!myID) return;
        var myCommand = this._GPT(myID);
        var myColor = jQuery("#" + myID + "Val").css("background-color").toColor();
        this.__command(myCommand, false, myColor);

        var myRange = new SSelection(this.myEDT);
        var rng = myRange.getRangeAt(0);
        var nodes = rng.getNodes();
        if (nodes.length) {
            for (var a = 0; a < nodes.length; a++) {
                var myNode = nodes[a];
                var pnode = DOMfix.DF_parentNode(myNode);
                try {
                    while (pnode.tagName != "FONT" && pnode.tagName != "SPAN") {
                        pnode = DOMfix.DF_parentNode(pnode);
                    }
                    if (myCommand == "foreColor") {
                        pnode.style.color = myColor;
                        pnode.removeAttribute("color");
                    }
                    else {
                        pnode.style.backgroundColor = myColor;
                        pnode.removeAttribute("bgcolor");
                    }
                } catch (e) {
                }
            }
        }
        else {
            if (myCommand == "foreColor") myEDT.body.style.color = myColor;
            else myEDT.body.style.backgroundColor = myColor;
        }

    },
    onInsertCommand: function (event) {
        var myID = event.target.id;
        if (!myID) return;
        var command = this._GPT(myID);
        if (command == "pageBreak") {
            this.__pasteHTML("<hr style='page-break-before:always;border:1px dashed #444;' />");
        }
    },
    onSelectCommandClick: function (event) {
        var myEDT = this.myEDT.document;
        var myID = event.target.id;
        if (!myID) return;
        var command = this._GPT(myID);
        /*alert("select Command : " + command);*/
        if (command == "foreColorExt" || command == "backColorExt") this.openColorPicker(command);
        if (command == "fontname") this.fontFamilyPicker(command);
        if (command == "fontsize") this.fontSizePicker(command);
        if (command == "lineHeight") this.lineHeightPicker(command);
        if (command == "url") this.urlPicker(command);
        if (command == "imoticon") this.icoPicker(command);
    },
    onAttbtnsClick: function (event) {
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var myID = event.target.id;
        if (!myID) return;
        var cmd = myID.split(/_/g).last();
        if (cmd == "selectAll") {
            jQuery.each(this.attchFiles, function (idx, f) {
                f.checked = true;
                jQuery("#" + re + "_attchItem_" + idx).addClass("attchItemON");
            });
        }
        if (cmd == "delete") {
            var delFiles = [];
            jQuery.each(this.attchFiles, function (idx, f) {
                if (f.checked) {
                    delFiles.push("file=" + f.nm + "&path=" + f.path)
                }
            });
            if (delFiles.length == 0) {
                alert(lg.noSelectedFileMsg);
                return;
            }
            if (!confirm(lg.fileDeleteConfirm)) return;
            var url = config.deleteUrl;
            var pars = config.deletePars.join("&");
            if (pars != "") pars += "&";
            pars += delFiles.join("&") + "&dummy=" + AXUtil.timekey();
            /*new AXreq(url, {pars:pars, onsucc:this.onFileDelete.bind(this)});*/
        }
        if (cmd == "insertDoc") {
            var insertFiles = jQuery.map(this.attchFiles, function (f) {
                if (f.checked) return f;
            });
            if (insertFiles.length == 0) {
                alert(lg.noSelectedFileMsg);
                return;
            }

            try {
                this.myEDT.document.body.focus();
            } catch (e) {
            }

            for (var si = 0; si < insertFiles.length; si++) {
                var fo = insertFiles[si];
                var ty = fo.ty.dec().toLowerCase();
                if (ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp") {
                    var imgObj = new Image();
                    imgObj.src = fo.path.dec() + fo.nm.dec();
                    imgObj.id = "MF_" + fo.nm.replace(fo.ty, "").dec();

                    var pasteHTML = this.__pasteHTML.bind(this);
                    var canvasWidth = this.canvas.width() - 40;
                    imgObj.onload = function () {
                        var ow = imgObj.width;
                        var oh = imgObj.height;
                        if (imgObj.width > canvasWidth) {
                            imgObj.width = canvasWidth;
                            imgObj.height = oh * (imgObj.width / ow);
                        }
                        try {
                            pasteHTML(imgObj);
                        } catch (e) {
                            alert(e.print());
                        }
                    }

                }
                else {
                    this.__pasteHTML("<a href='" + fo.path.dec() + fo.nm.dec() + "' id='MF_" + fo.nm.replace(fo.ty, "").dec() + "' target='_blank'>" + fo.ti.dec() + "</a>");
                }
            }
            /*img resize*/
        }
    },
    onFeilDeleteInFrame: function (rid) {
        var editorBody = this.myEDT.document;
        if (AXUtil.browser.name == "mozilla") {
            jQuery(editorBody).find(rid).remove();
        }
        else {
            jQuery(editorBody.body).find(rid).remove();
        }
    },
    onFileDelete: function (res) {
        if (res.result == "ok") {
            var config = this.config;
            var re = config.targetID;

            var removeInFrame = this.onFeilDeleteInFrame.bind(this);
            this.attchFiles = jQuery.map(this.attchFiles, function (f, i) {
                jQuery("#" + re + "_attchItem_" + i).remove();
                if (f.checked) {
                    removeInFrame("#MF_" + f.nm.replace(f.ty, "").dec());
                }
                else {
                    return f;
                }
            });

            this.updateFileStatus();

            if (this.attchFiles.length == 0) return;
            jQuery.each(this.attchFiles, function (si, fo) {
                var po = [];
                po.push("<div class='attchItem' id='" + re + "_attchItem_" + si + "' title='" + fo.ti.dec() + "'>");
                po.push("<div class='attchItemName'>" + fo.ti.dec() + "</div>");
                po.push("<div class='attchItemPreview'>");
                var ty = fo.ty.dec().toLowerCase();
                if (ty == ".gif" | ty == ".jpg" | ty == ".png" | ty == ".bmp")
                    po.push("<img src='" + fo.path.dec() + fo.nm.dec() + "' width='100%' height='100%' alt='' />")
                po.push("</div>");
                po.push("</div>");
                jQuery("#" + re + "_divPanel_attchItemEnd").before(po.join(''));
            });

            jQuery("#" + re + "_divPanel_attch").find(".attchItem").bind("click", this.onAttchItemClick.bind(this));

        }
        else {
            alert(res.msg.dec());
        }
    },
    onAttchItemClick: function (event) {
        var config = this.config;
        var re = config.targetID;
        var myID = event.target.id;
        if (!myID) {
            try {
                myID = jQuery(event.target).parents(".attchItem")[0].id;
            } catch (e) {
            }
            if (!myID) return;
        }
        ;
        var fidx = myID.split(/_/g).last().number();
        this.attchFiles[fidx].checked = (!this.attchFiles[fidx].checked);
        if (this.attchFiles[fidx].checked) {
            jQuery("#" + re + "_attchItem_" + fidx).addClass("attchItemON");
        }
        else {
            jQuery("#" + re + "_attchItem_" + fidx).removeClass("attchItemON");
        }
    },
    onClickComponent: function (event) {
        var myID = event.target.id;
        if (!myID) {
            try {
                myID = jQuery(event.target).parents(".componentItem")[0].id;
            } catch (e) {
            }
            if (!myID) return;
        }
        ;
        if (this.config.onTabExternals) this.config.onTabExternals(myID);
    },
    /* ~~ colorPicker ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    openColorPicker: function (command) {
        if (this.colorPicker) this.colorPicker.remove();
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var po = [];
        po.push("<div class='me___selecterBox me_picker' id='" + this._GID([re, command, "picker"]) + "'>");
        po.push("	<div class='me___selecterArrow me_picker'></div>");
        if (command == "foreColorExt") po.push("	<div class='me___selecterTitle me_picker'>" + lg.textColor + "</div>");
        if (command == "backColorExt") po.push("	<div class='me___selecterTitle me_picker'>" + lg.textBgColor + "</div>");
        jQuery.each(config.colors, function (index, n) {
            po.push("<a href='#AXExex' class='colorItem me_picker' style='background:#" + n + "'>" + n + "</a>");
        });
        po.push("</div>");
        this.colorPicker = jQuery(po.join(''));
        var myHeight = (config.colors.length / 7).ceil() * 21 + 28;
        if (command == "foreColorExt") this.colorPicker.css({width: 150, height: myHeight, left: 249, top: 25});
        if (command == "backColorExt") this.colorPicker.css({width: 150, height: myHeight, left: 287, top: 25});
        jQuery("#" + re + "_headPanel").append(this.colorPicker);

        /*other click observer init*/
        this.clickToClose = this.closeColorPicker.bind(this);
        jQuery(document).bind("click", this.clickToClose);
        this.keyDownToClose = this.closeColorPickerKey.bind(this);
        jQuery(document).bind("keydown", this.keyDownToClose);
        /*color select*/
        this.colorPicker.find(".colorItem").bind("click", this.clickColor.bind(this, command));
    },
    closeColorPicker: function (event) {
        if (event) {
            if (!jQuery(event.target).hasClass("me_picker")) {
                if (this.clickToClose) jQuery(document).unbind('click', this.clickToClose);
                if (this.keyDownToClose) jQuery(document).unbind('keydown', this.keyDownToClose);
                if (this.colorPicker) this.colorPicker.remove();
            }
        }
        else {
            if (this.clickToClose) jQuery(document).unbind('click', this.clickToClose);
            if (this.keyDownToClose) jQuery(document).unbind('keydown', this.keyDownToClose);
            if (this.colorPicker) this.colorPicker.remove();
        }
    },
    closeColorPickerKey: function () {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            if (this.clickToClose) jQuery(document).unbind('click', this.clickToClose);
            if (this.keyDownToClose) jQuery(document).unbind('keydown', this.keyDownToClose);
            if (this.colorPicker) this.colorPicker.remove();
        }
    },
    clickColor: function (command, event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;

        var myColor = jQuery(event.target).css("background-color").toColor();
        var myCommand = command.replace("Ext", "");
        this.__command(myCommand, false, myColor);

        var myRange = new SSelection(this.myEDT);
        var rng = myRange.getRangeAt(0);
        var nodes = rng.getNodes();
        if (nodes.length) {
            for (var a = 0; a < nodes.length; a++) {
                var myNode = nodes[a];
                var pnode = DOMfix.DF_parentNode(myNode);
                try {
                    while (pnode.tagName != "FONT" && pnode.tagName != "SPAN") {
                        pnode = DOMfix.DF_parentNode(pnode);
                    }
                    if (myCommand == "foreColor") {
                        pnode.style.color = myColor;
                        pnode.removeAttribute("color");
                    }
                    else {
                        pnode.style.backgroundColor = myColor;
                        pnode.removeAttribute("bgcolor");
                    }
                } catch (e) {
                }
            }
        }
        else {
            if (myCommand == "foreColor") myEDT.body.style.color = myColor;
            else myEDT.body.style.backgroundColor = myColor;
        }

        jQuery("#" + this._GID([re, myCommand + "Val"])).css({background: "#" + myColor});
        this.closeColorPicker();
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    /* ~~ font family ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    fontFamilyPicker: function (command) {
        if (this.ffPicker) this.ffPicker.remove();
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var po = [];
        po.push("<div class='me___selecterBox me_ffs' id='" + this._GID([re, command, "picker"]) + "'>");
        po.push("	<div class='me___selecterArrow me_ffs'></div>");
        po.push("	<div class='me___selecterTitle me_ffs'>" + lg.fontFamily + "</div>");
        jQuery.each(config.fonts, function (index, n) {
            po.push("<a href='#AXExex' class='ffItem me_ffs' style='font-family:" + n + "'>" + lg.fontSample + "(" + n + ")</a>");
        });
        po.push("</div>");
        this.ffPicker = jQuery(po.join(''));
        var myHeight = config.fonts.length * 25 + 30;
        this.ffPicker.css({width: 150, height: myHeight, left: 3, top: 25});
        jQuery("#" + re + "_headPanel").append(this.ffPicker);

        /*other click observer init*/
        this.clickToCloseFF = this.closeffPicker.bind(this);
        jQuery(document).bind("click", this.clickToCloseFF);
        this.keyDownToCloseFF = this.closeffPickerKey.bind(this);
        jQuery(document).bind("keydown", this.keyDownToCloseFF);
        /*color select*/
        this.ffPicker.find(".ffItem").bind("click", this.clickff.bind(this, command));
    },
    closeffPicker: function (event) {
        if (event) {
            if (!jQuery(event.target).hasClass("me_ffs")) {
                if (this.clickToCloseFF) jQuery(document).unbind('click', this.clickToCloseFF);
                if (this.keyDownToCloseFF) jQuery(document).unbind('keydown', this.keyDownToCloseFF);
                if (this.ffPicker) this.ffPicker.remove();
            }
        }
        else {
            if (this.clickToCloseFF) jQuery(document).unbind('click', this.clickToCloseFF);
            if (this.keyDownToCloseFF) jQuery(document).unbind('keydown', this.keyDownToCloseFF);
            if (this.ffPicker) this.ffPicker.remove();
        }
    },
    closeffPickerKey: function () {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            if (this.clickToCloseFF) jQuery(document).unbind('click', this.clickToCloseFF);
            if (this.keyDownToCloseFF) jQuery(document).unbind('keydown', this.keyDownToCloseFF);
            if (this.ffPicker) this.ffPicker.remove();
        }
    },
    clickff: function (command, event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;
        var myfont = jQuery(event.target).css("font-family");

        this.__command(command, false, myfont);

        var myRange = new SSelection(this.myEDT);
        var rng = myRange.getRangeAt(0);
        var nodes = rng.getTextNodes();
        if (nodes.length) {
            for (var a = 0; a < nodes.length; a++) {
                var myNode = nodes[a];
                var pnode = DOMfix.DF_parentNode(myNode);
                try {
                    while (pnode.tagName != "FONT" && pnode.tagName != "SPAN") {
                        pnode = DOMfix.DF_parentNode(pnode);
                    }
                    pnode.style.fontFamily = myfont;
                    pnode.removeAttribute("face");
                } catch (e) {
                }
            }
        }
        else {
            myEDT.body.style.fontFamily = myfont;
        }
        /*일단 현재 선택된 노드에 대한 합의의 형태로 일단락 추후 추가 개발토록 하자.*/

        jQuery("#" + this._GID([re, "fontname"])).html(myfont);
        jQuery("#" + this._GID([re, "fontname"])).css({"font-family": myfont});

        this.closeffPicker();
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    /* ~~ font size ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    fontSizePicker: function (command) {
        if (this.fsPicker) this.fsPicker.remove();
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var po = [];
        po.push("<div class='me___selecterBox me_fss' id='" + this._GID([re, command, "picker"]) + "'>");
        po.push("	<div class='me___selecterArrow me_fss'></div>");
        po.push("	<div class='me___selecterTitle me_fss'>" + lg.fontSize + "</div>");
        jQuery.each(config.fontsizes, function (index, n) {
            po.push("<a href='#AXExex' class='ffItem me_fss' style='font-size:" + n + "px'>" + lg.fontSample + "(" + n + "px)</a>");
        });
        po.push("</div>");
        this.fsPicker = jQuery(po.join(''));
        var myHeight = config.fontsizes.length * 25 + 30;
        this.fsPicker.css({width: 150, height: myHeight, left: 95, top: 25});
        jQuery("#" + re + "_headPanel").append(this.fsPicker);

        /*other click observer init*/
        this.clickToCloseFS = this.closefsPicker.bind(this);
        jQuery(document).bind("click", this.clickToCloseFS);
        this.keyDownToCloseFS = this.closefsPickerKey.bind(this);
        jQuery(document).bind("keydown", this.keyDownToCloseFS);
        /*color select*/
        this.fsPicker.find(".ffItem").bind("click", this.clickfs.bind(this, command));
    },
    closefsPicker: function (event) {
        if (event) {
            if (!jQuery(event.target).hasClass("me_fss")) {
                if (this.clickToCloseFS) jQuery(document).unbind('click', this.clickToCloseFS);
                if (this.keyDownToCloseFS) jQuery(document).unbind('keydown', this.keyDownToCloseFS);
                if (this.fsPicker) this.fsPicker.remove();
            }
        }
        else {
            if (this.clickToCloseFS) jQuery(document).unbind('click', this.clickToCloseFS);
            if (this.keyDownToCloseFS) jQuery(document).unbind('keydown', this.keyDownToCloseFS);
            if (this.fsPicker) this.fsPicker.remove();
        }
    },
    closefsPickerKey: function () {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            if (this.clickToCloseFS) jQuery(document).unbind('click', this.clickToCloseFS);
            if (this.keyDownToCloseFS) jQuery(document).unbind('keydown', this.keyDownToCloseFS);
            if (this.fsPicker) this.fsPicker.remove();
        }
    },
    clickfs: function (command, event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;
        var mysize = jQuery(event.target).css("font-size");
        this.__command(command, false, 1);
        var myRange = new SSelection(this.myEDT);
        var rng = myRange.getRangeAt(0);
        var nodes = rng.getTextNodes();
        if (nodes.length) {
            for (var a = 0; a < nodes.length; a++) {
                var myNode = nodes[a];
                var pnode = DOMfix.DF_parentNode(myNode);
                try {
                    while (pnode.tagName != "FONT" && pnode.tagName != "SPAN") {
                        pnode = DOMfix.DF_parentNode(pnode);
                    }
                    pnode.style.fontSize = mysize;
                    pnode.removeAttribute("size");
                } catch (e) {
                }
            }
        }
        else {
            myEDT.body.style.fontSize = mysize;
        }
        /*일단 현재 선택된 노드에 대한 합의의 형태로 일단락 추후 추가 개발토록 하자.*/
        jQuery("#" + this._GID([re, "fontsize"])).html(mysize);
        this.closefsPicker();
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    /* ~~ lineheight ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    lineHeightPicker: function (command) {
        if (this.lhPicker) this.lhPicker.remove();
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var po = [];
        po.push("<div class='me___selecterBox me_lhs' id='" + this._GID([re, command, "picker"]) + "'>");
        po.push("	<div class='me___selecterArrow me_lhs'></div>");
        po.push("	<div class='me___selecterTitle me_lhs'>" + lg.lineHeight + "</div>");
        jQuery.each(config.lineHeights, function (index, n) {
            po.push("<a href='#AXExex' class='ffItem me_lhs' style='text-align:center;'>" + n + "</a>");
        });
        po.push("</div>");
        this.lhPicker = jQuery(po.join(''));
        var myHeight = config.lineHeights.length * 25 + 30;
        this.lhPicker.css({width: 100, height: myHeight, left: 491, top: 25});
        jQuery("#" + re + "_headPanel").append(this.lhPicker);

        /*other click observer init*/
        this.clickToCloseLH = this.closelhPicker.bind(this);
        jQuery(document).bind("click", this.clickToCloseLH);
        this.keyDownToCloseLH = this.closelhPickerKey.bind(this);
        jQuery(document).bind("keydown", this.keyDownToCloseLH);
        /*color select*/
        this.lhPicker.find(".ffItem").bind("click", this.clicklh.bind(this, command));
    },
    closelhPicker: function (event) {
        if (event) {
            if (!jQuery(event.target).hasClass("me_lhs")) {
                if (this.clickToCloseLH) jQuery(document).unbind('click', this.clickToCloseLH);
                if (this.keyDownToCloseLH) jQuery(document).unbind('keydown', this.keyDownToCloseLH);
                if (this.lhPicker) this.lhPicker.remove();
            }
        }
        else {
            if (this.clickToCloseLH) jQuery(document).unbind('click', this.clickToCloseLH);
            if (this.keyDownToCloseLH) jQuery(document).unbind('keydown', this.keyDownToCloseLH);
            if (this.lhPicker) this.lhPicker.remove();
        }
    },
    closelhPickerKey: function () {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            if (this.clickToCloseLH) jQuery(document).unbind('click', this.clickToCloseLH);
            if (this.keyDownToCloseLH) jQuery(document).unbind('keydown', this.keyDownToCloseLH);
            if (this.lhPicker) this.lhPicker.remove();
        }
    },
    clicklh: function (command, event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;
        var mylh = jQuery(event.target).text();
        var myRange = new SSelection(this.myEDT);
        var rng = myRange.getRangeAt(0);
        var nodes = rng.getTextNodes();
        if (nodes.length) {
            for (var a = 0; a < nodes.length; a++) {
                var myNode = nodes[a];
                var pnode = DOMfix.DF_parentNode(myNode);
                if (pnode.tagName == "BODY") {
                    pnode.style.lineHeight = mylh + "em";
                }
                else {
                    while (pnode.tagName != "P" && pnode.tagName != "DIV") {
                        pnode = DOMfix.DF_parentNode(pnode);
                    }
                    pnode.style.lineHeight = mylh + "em";
                }
            }
        }
        else {
            myEDT.body.style.lineHeight = mylh + "em";
        }
        /*jQuery("#"+this._GID([re, "lineHeight"])).html(mylh);*/
        this.closelhPicker();
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    /* ~~ url ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    urlPicker: function (command) {
        /*this.unbindFocusFrame();*/

        if (this.ulPicker) this.ulPicker.remove();
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        var inpID = this._GID([re, command, "input"]);
        var target_blank = this._GID([re, command, "target_blank"]);
        var target_self = this._GID([re, command, "target_self"]);

        var po = [];
        po.push("<div class='me___selecterBox me_url' id='" + this._GID([re, command, "picker"]) + "'>");
        po.push("	<div class='me___selecterArrow me_url' style='left:240px;'></div>");
        po.push("	<div class='me___selecterTitle me_url'>" + lg.url + "</div>");
        po.push("	<div class='me___inputUrl me_url'><input type='text' id='" + inpID + "' class='me_url' style='width:280px;'></div>");
        po.push("	<div class='me___inputBtn me_url'>");
        po.push("	<input type='radio' name='" + this._GID([re, command, "target"]) + "' id='" + target_blank + "' class='me_url' value='_blank' checked='checked'> _blank");
        po.push("	<input type='radio' name='" + this._GID([re, command, "target"]) + "' id='" + target_self + "' class='me_url' value='_self'> _self");
        po.push("	<input type='button' value='OK' class='AXButtonSmall me_url me___inputBtnOK' />");
        po.push("	</div>");
        po.push("</div>");
        this.ulPicker = jQuery(po.join(''));
        var myHeight = 90;
        this.ulPicker.css({width: 300, height: myHeight, left: 324, top: 25});
        jQuery("#" + re + "_headPanel").append(this.ulPicker);

        /* url find */
        this.myRange = new SSelection(this.myEDT);
        this.oSelection = this.myRange.getRangeAt(0);
        var oNode = this.oSelection.commonAncestorContainer;
        while (oNode && oNode.tagName != "A") oNode = DOMfix.DF_parentNode(oNode);
        if (oNode) {
            var sTarget = oNode.target;
            if (sTarget && sTarget == "_blank") jQuery("#" + target_blank)[0].checked = true;
            jQuery("#" + inpID).val(oNode.href ? oNode.href : "http://");
        }
        else {
            jQuery("#" + inpID).val("http://");
        }
        jQuery("#" + inpID).select();

        /*other click observer init*/
        this.clickToCloseUL = this.closeulPicker.bind(this);
        jQuery(document).bind("click", this.clickToCloseUL);
        this.keyDownToCloseUL = this.closeulPickerKey.bind(this);
        jQuery(document).bind("keydown", this.keyDownToCloseUL);
        /*color select*/
        this.ulPicker.find(".me___inputBtnOK").bind("click", this.clickul.bind(this, command));
        /*this.bindFocusFrame();*/
    },
    closeulPicker: function (event) {
        if (event) {
            if (!jQuery(event.target).hasClass("me_url")) {
                if (this.clickToCloseUL) jQuery(document).unbind('click', this.clickToCloseUL);
                if (this.keyDownToCloseUL) jQuery(document).unbind('keydown', this.keyDownToCloseUL);
                if (this.ulPicker) this.ulPicker.remove();
            }
        }
        else {
            if (this.clickToCloseUL) jQuery(document).unbind('click', this.clickToCloseUL);
            if (this.keyDownToCloseUL) jQuery(document).unbind('keydown', this.keyDownToCloseUL);
            if (this.ulPicker) this.ulPicker.remove();
        }
    },
    closeulPickerKey: function () {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            if (this.clickToCloseUL) jQuery(document).unbind('click', this.clickToCloseUL);
            if (this.keyDownToCloseUL) jQuery(document).unbind('keydown', this.keyDownToCloseUL);
            if (this.ulPicker) this.ulPicker.remove();
        }
    },
    clickul: function (command, event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;
        var lg = AXEditorLang[config.lang];
        var inpID = this._GID([re, command, "input"]);
        var target_blank = this._GID([re, command, "target_blank"]);
        var target_self = this._GID([re, command, "target_self"]);

        var sURL = jQuery("#" + inpID).val();
        this.myRange.selectRange(this.oSelection);

        if (this._validateURL(sURL)) {
            var sTarget = (jQuery("#" + target_blank)[0].checked) ? "_blank" : "_self";
            if (this.oSelection.collapsed) {
                this.__pasteHTML("<a href='" + sURL + "' target='" + sTarget + "'>" + sURL + "</a>");
            }
            else {
                this.__command("CreateLink", false, sURL);
                this.myRange = new SSelection(this.myEDT);
                this.oSelection = this.myRange.getRangeAt(0);
                var oNode = this.oSelection.commonAncestorContainer;
                while (oNode && oNode.tagName != "A") oNode = DOMfix.DF_parentNode(oNode);
                if (oNode) oNode.target = sTarget;
            }
        }
        else {
            alert(lg.invalidUrlMsg);
        }
        this.closeulPicker();
    },
    _validateURL: function (sURL) {
        return /^(http|https|ftp|mailto):(?:\/\/)?((\w|-)+(?:[\.:@](\w|-))+)(?:\/|@)?([^"\?]*?)(?:\?([^\?"]*?))?$/.test(sURL);
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    /* ~~ imoticon ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    icoPicker: function (command) {
        if (this.icPicker) this.icPicker.remove();
        var config = this.config;
        var re = config.targetID;
        var lg = AXEditorLang[config.lang];
        if (this.icoCategoryIndex == undefined) this.icoCategoryIndex = 0;
        var icoCategoryIndex = this.icoCategoryIndex;
        var po = [];
        po.push("<div class='me___selecterBox me_ico' id='" + this._GID([re, command, "picker"]) + "'>");
        po.push("	<div class='me___selecterArrow me_ico' style='left:372px;'></div>");
        po.push("	<div class='me___selecterTitleTab me_ico'>");
        po.push("		<div class='me___selecterTitleTabTray me_ico'>");
        jQuery.each(config.AXEditorIcons, function (idx, ca) {
            if (icoCategoryIndex == idx)
                po.push("<a href='#AXExec' class='categoryItem me_ico on' id='" + re + "_icoCategory_" + idx + "'>" + ca.categoryNM + "</a>");
            else
                po.push("<a href='#AXExec' class='categoryItem me_ico' id='" + re + "_icoCategory_" + idx + "'>" + ca.categoryNM + "</a>");
        });
        po.push("		</div>");
        po.push("	</div>");
        po.push("	<div class='me___selecterTray me_ico' style='height:120px;' id='" + re + "_icoTray'>");
        var icoFolder = config.AXEditorIcons[icoCategoryIndex].imageFolder;
        jQuery.each(config.AXEditorIcons[icoCategoryIndex].icons, function (index, n) {
            po.push("<a href='#AXExex' class='icoItem me_ico'><img src='" + icoFolder + n + "' align='middle' alt='' /></a>");
        });
        po.push("	</div>");
        po.push("	<div class='me___selecterBot me_ico' id='" + re + "_icoBot'>");
        po.push("	" + config.AXEditorIcons[icoCategoryIndex].copyRights);
        po.push("	</div>");
        po.push("</div>");
        this.icPicker = jQuery(po.join(''));

        var myWidth = 396;
        var myHeight = 180;
        this.icPicker.css({width: myWidth, height: myHeight, left: 214, top: 25});
        jQuery("#" + re + "_headPanel").append(this.icPicker);

        /*other click observer init*/
        this.clickToCloseIC = this.closeicPicker.bind(this);
        jQuery(document).bind("click", this.clickToCloseIC);
        this.keyDownToCloseIC = this.closeicPickerKey.bind(this);
        jQuery(document).bind("keydown", this.keyDownToCloseIC);

        /*select*/
        this.icPicker.find(".icoItem img").bind("click", this.clickic.bind(this, command));
        this.icPicker.find(".me___selecterTitleTabTray .categoryItem").bind("click", this.changeCategory.bind(this));
    },
    closeicPicker: function (event) {
        if (event) {
            if (!jQuery(event.target).hasClass("me_ico")) {
                if (this.clickToCloseIC) jQuery(document).unbind('click', this.clickToCloseIC);
                if (this.keyDownToCloseIC) jQuery(document).unbind('keydown', this.keyDownToCloseIC);
                if (this.icPicker) this.icPicker.remove();
            }
        }
        else {
            if (this.clickToCloseIC) jQuery(document).unbind('click', this.clickToCloseIC);
            if (this.keyDownToCloseIC) jQuery(document).unbind('keydown', this.keyDownToCloseIC);
            if (this.icPicker) this.icPicker.remove();
        }
    },
    closeicPickerKey: function () {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            if (this.clickToCloseIC) jQuery(document).unbind('click', this.clickToCloseIC);
            if (this.keyDownToCloseIC) jQuery(document).unbind('keydown', this.keyDownToCloseIC);
            if (this.icPicker) this.icPicker.remove();
        }
    },
    clickic: function (command, event) {
        var config = this.config;
        var re = config.targetID;
        var myEDT = this.myEDT.document;
        var sHTML = "<img src='" + event.target.src + "' align='middle' alt='' style='vertical-align:middle;' />"
        var oTmpDiv = myEDT.createElement("DIV");
        oTmpDiv.innerHTML = sHTML;
        var myRange = new SSelection(this.myEDT);
        var rng = myRange.getRangeAt(0);
        rng.insertNode(oTmpDiv.lastChild);
        this.closeicPicker();
    },
    changeCategory: function (event) {
        var config = this.config;
        var re = config.targetID;
        var idx = event.target.id.split("_").last();
        if (this.icoCategoryIndex != undefined) {
            jQuery("#" + re + "_icoCategory_" + this.icoCategoryIndex).removeClass("on");
        }
        this.icoCategoryIndex = idx;
        icoCategoryIndex = idx;
        jQuery("#" + re + "_icoCategory_" + idx).addClass("on");

        var po = [];
        var icoFolder = config.AXEditorIcons[icoCategoryIndex].imageFolder;
        jQuery.each(config.AXEditorIcons[icoCategoryIndex].icons, function (index, n) {
            po.push("<a href='#AXExex' class='icoItem me_ico'><img src='" + icoFolder + n + "' align='middle' alt='' /></a>");
        });
        jQuery("#" + re + "_icoTray").html(po.join(''));
        this.icPicker.find(".icoItem img").bind("click", this.clickic.bind(this, "imoticon"));
        jQuery("#" + re + "_icoBot").html(config.AXEditorIcons[icoCategoryIndex].copyRights);
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    onContentMode: function (event) {
        var config = this.config;
        if (event.target.id == config.targetID + "_contentMode_0") {
            if (this.contentMode != "editor") {
                this.contentMode = "editor";
                jQuery("#" + config.targetID + "_contentMode_0").addClass("me____tabOn");
                jQuery("#" + config.targetID + "_contentMode_1").removeClass("me____tabOn");
                this.setHtmlMode("off");
            }
        }
        else {
            if (this.contentMode != "html") {
                this.contentMode = "html";
                jQuery("#" + config.targetID + "_contentMode_0").removeClass("me____tabOn");
                jQuery("#" + config.targetID + "_contentMode_1").addClass("me____tabOn");
                this.setHtmlMode("on");
            }
        }
        /*goto home*/
        /*this.onHeadClick("home");*/
    },
    /* ~~ get&set content ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    __getContent: function () {
        var myEDT = this.myEDT.document;
        return myEDT.body.innerHTML;
    },
    getContentCheck: function () {
        var myEDT = this.myEDT.document;
        var editorContent = "";
        if (this.contentMode == "editor") {
            editorContent = myEDT.body.innerHTML;
        }
        else {
            editorContent = this.htmlArea.val();
        }

        if (editorContent.trim() != "") {
            return true;
        }
        else {
            return false;
        }

    },
    /**
     * 에디터의 내용을 반환합니다.
     * @method AXEditor.getContent
     * @returns {String}
     * @example
     ```js
     var myContent = myEditor.getContent();
     var content = [];
     while(myContent.length > 0){
	content.push("content="+myContent.substr(0, 102399).enc());
	myContent = myContent.substr(102399);
 }
     alert(content);
     // post전송할 때 짤림현상 방지를 위해서는 content를 잘라서 보내야 합니다.
     ```
     */
    getContent: function () {
        var myEDT = this.myEDT.document;
        var ff = myEDT.body.style.fontFamily;
        var fs = myEDT.body.style.fontSize;
        var cl = myEDT.body.style.color;
        var bc = myEDT.body.style.backgroundColor;
        var lh = myEDT.body.style.lineHeight;

        if (lh == "") {
            lh = "1.5em";
        }

        var sts = [];
        if (ff) sts.push("font-family:" + ff);
        if (fs) sts.push("font-size:" + fs);
        if (cl) sts.push("color:" + cl);
        if (bc) sts.push("background-color:" + bc);
        if (lh) sts.push("line-height:" + lh);

        if (this.contentMode == "editor") {
            return "<div class='AXEditorContentBody' style='" + sts.join(";") + ";'>" + myEDT.body.innerHTML + "</div>";
        }
        else {
            return "<div class='AXEditorContentBody' style='" + sts.join(";") + ";'>" + this.htmlArea.val() + "</div>";
        }
    },
    /**
     * 에디터의 내용을 정의합니다.
     * @method AXEditor.setContent
     * @param {String|jQueryObject} content
     * @returns {AXEditor} name
     * @example
     ```js
     myEditor.setContent($("#editContent"));
     myEditor.setContent("액시스제이");
     ```
     */
    setContent: function (content) {
        var myEDT = this.myEDT.document;
        if (typeof content == "string") {
            if (content == "") content = "<p></p>";
            myEDT.body.innerHTML = content;
        }
        else {
            var myBody = content.find(".AXEditorContentBody");
            if (myBody.html() == null) {
                jQuery(myEDT.body).html(content.html());
            }
            else {
                content.children().each(function () {
                    if (!jQuery(this).hasClass("AXEditorContentBody")) {
                        myBody.prepend(this);
                    }
                });
                jQuery(myEDT.body).html(myBody.html());
                jQuery(myEDT.body).css({"font-family": myBody.css("fontFamily")});
                jQuery(myEDT.body).css({"font-size": myBody.css("fontSize")});
                jQuery(myEDT.body).css({"color": myBody.css("color")});
                jQuery(myEDT.body).css({"background-color": myBody.css("backgroundColor")});
                jQuery(myEDT.body).css({"line-height": myBody.css("lineHeight")});
            }
        }
        return this;
    },
    getFileList: function () {
        return this.attchFiles;
    },
    setFileList: function (files) {
        this.attchFiles = files;
        this.updateFileStatus();
    },
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    nothing: function () {}
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXExcelConvert = Class.create(AXJ, {
    version: "AXExcelConvert V1",
	author: "tom@axisj.com",
	logs: [
		"2013-08-21 오후 11:47:11 - modsAX 변환"
	],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.ds = [];
    },
    init: function() {
		
    },
	readyData: function(){
		this.ds = []; //엑셀 데이터 초기화
		var re = this.config.targetID;
		var po = [];
		po.push("<div id='"+re+"_CT'>");
		po.push("<div style='padding:5px;'>엑셀데이터 붙여넣기 <span>- 변환하실 엑셀 데이터를 선택하여 아래에 붙여넣기 해주세요.</span></div>");
		po.push("<textarea id='"+re+"_TEXT' style='width:"+this.config.ctWidth+"px;height:"+this.config.ctHeight+"px;' class='AXTextarea'></textarea>");
		po.push("<div style='padding:10px;' align='right'><input type='button' value='변환하기' class='AXButton' id='"+re+"_convert' /> <input type='button' value='창 닫기' class='AXButton' id='"+re+"_close' /></div>");
		po.push("</div>");
		
		jQuery("#"+re).html(po.join(''));
		setTimeout(function(){
			jQuery("#"+re+"_TEXT").focus();
		}, 500);
		
		jQuery("#"+re+"_convert").bind("click", this.onConvert.bind(this));
		jQuery("#"+re+"_close").bind("click", this.onClose.bind(this));
	},
	onConvert: function(){
		var re = this.config.targetID;
		var tStr = jQuery("#"+re+"_TEXT").val().trim();
		if(tStr == ""){
			alert("변환할 내용이 없습니다. 내용을 입력하세요.");
			return;	
		}

		var iePattern2 = /["]/gi;   //"문자제거
		var iePattern3 = / (?:\r\n|\r|\n)/g; //개행문자 바로 이전에 있는 공백 한개를 모두 제거
		var sStr  = tStr.replace(iePattern3, "").replace(iePattern2, "");
		var codeR = sStr.split(/\n/g);

		for(var a=0;a<codeR.length;a++){
			if(codeR[a].trim() != ""){
				codeR[a] = codeR[a].replace(/\t\t/gi, "\t \t");
				var codeC = codeR[a].trim().split(/[\t]/gi);
				this.ds.push(codeC);
			}
		}
		this.gridPrint();
	},
	onClose: function(){
		if(this.config.onClose){
			this.config.onClose();
		}
	},
	gridPrint: function(){
		var re = this.config.targetID;
		var colnames = this.config.colnames;
		
		function getCOPT(nm){
			var copt = [];
			copt.push("<select name='colNames' class='colNamesSelect'>");
			copt.push("	<option value=''></option>");
			jQuery.each(colnames, function(){
				if(nm == this.nm){
			copt.push("	<option value='"+this.nm+"' selected='selected'>"+this.val+"</option>");
				}else{
			copt.push("	<option value='"+this.nm+"'>"+this.val+"</option>");
				}
			});
			copt.push("</select>");
			return copt.join('');
		}
		
		var po = [];
		po.push("<div id='"+re+"_CT'>");
		po.push("<div style='padding:5px;'>엑셀데이터 확인</div>");
		po.push("<div style='width:"+this.config.ctWidth+"px;height:"+this.config.ctHeight+"px;overflow:auto;border:1px solid #ccc;'>");
		po.push("<form name='"+re+"_frm'>");
		po.push("	<table cellspacing='0' cellpadding='0'>");
		po.push("		<thead>");
		po.push("			<tr>");
		jQuery.each(colnames, function(){
		po.push("				<td>"+getCOPT(this.nm)+"</td>");
		});
		po.push("			</tr>");
		po.push("		</thead>");
		po.push("		<tbody>");
		jQuery.each(this.ds, function(idx, R){
		po.push("			<tr>");
			jQuery.each(colnames, function(icx, C){
		po.push("				<td class='nowrap' title='"+R[icx]+"'>"+R[icx]+"</td>");
			});
		po.push("			</tr>");
		});
		po.push("		</tbody>");
		po.push("	</table>");
		po.push("</form>");
		po.push("</div>");
		po.push("<div style='padding:10px;' align='right'><input type='button' value='변환완료' class='AXButton' id='"+re+"_convert' /> <input type='button' value='창 닫기' class='AXButton' id='"+re+"_close' /></div>");
		po.push("</div>");
		jQuery("#"+re).html(po.join(''));
		
		jQuery("#"+re+"_convert").bind("click", this.onInsert.bind(this));
		jQuery("#"+re+"_close").bind("click", this.onClose.bind(this));
		
		jQuery(".colNamesSelect").bind("change", this.onColNameSelect.bind(this));
	},
	onInsert: function(){
		var re = this.config.targetID;
		var frm = document[re+"_frm"];
		var cols = [];
		for(var a=0;a<frm.colNames.length;a++){
			cols.push(
				{
					nm:frm.colNames[a][frm.colNames[a].selectedIndex].value,
					val:frm.colNames[a][frm.colNames[a].selectedIndex].text
				}
			);
		}
		
		if(this.config.onConvert){
			this.config.onConvert({
				cols:cols,
				ds:this.ds
			});
		}
	},
	onColNameSelect: function(event){
		var selVal = event.target.value;
		jQuery(".colNamesSelect").each(function(){
			if(event.target != this)
				if(this.value == selVal) this.value = "";
		});
	}
});
/* ---------------------------- */
var AXSplit = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();

	},
	init: function() {
		var cfg = this.config;

		if(!cfg.onwindowresize) cfg.onwindowresize = cfg.onWindowResize;
		if(!cfg.onready) cfg.onready = cfg.onReady;
		if(!cfg.onsplitresize) cfg.onsplitresize = cfg.onSplitResize;
		if(!cfg.onsplitresizeend) cfg.onsplitresizeend = cfg.onSplitResizeEnd;

        $("html, body").css("overflow", "hidden"); // resize 이벤트 발생시 스크롤이 순간적으로 발생하는 현상을 막기위해 필수!


		this.target = axdom("#"+cfg.targetID);
		this.target.attr("ondragstart", "return false");

        if (typeof cfg.setTargetHeight === "function") {
            var targetHeight = cfg.setTargetHeight.call(this);
            this.target.height(targetHeight);
        }

		this.initChild(this.target);
		this.initEvent();
		axdom(window).resize(this.windowResize.bind(this));

		if(cfg.onready){
			cfg.onready.call({});
		}

        this.resizeInstances();
	},
	windowResize: function () {
		this.windowResizeApply();

		/*
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function () {
			windowResizeApply();
		}, 1);
		*/
	},
	windowResizeApply: function(){
		var cfg = this.config;
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.initChild(this.target);
		//axdom(window).resize();
		if(cfg.onwindowresize){
			cfg.onwindowresize.call({});
		}
	},
	initChild: function(parent){
		var cfg = this.config;
		var parentWidth = parent.innerWidth();
		var parentHeight = parent.innerHeight();

		var calcWidth = 0, calcHeight = 0, uncolCount = 0, unrowCount = 0, colindex = 1, rowindex = 1;
		var moreFindTarget = [];
        var getPixelValueBind = this.getPixelValue.bind(this);

        // data-width, data-height 속성이 선언된 element 길이 설정
		parent.children().each(function(){
			var dom_this = axdom(this);
			if(dom_this.hasClass("AXSplit-cols")){
				if(dom_this.attr("data-width")) {
                    var width = getPixelValueBind(dom_this.attr("data-width"), parentWidth);
					calcWidth += width;
                    dom_this.css("width", width);
				}else{
					uncolCount++;
				}
				if(!dom_this.attr("data-axsplit-colindex")) dom_this.attr("data-axsplit-colindex", colindex);
				colindex++;
			}else if(dom_this.hasClass("AXSplit-col-handle")){
				calcWidth += dom_this.width().number();
				if(!dom_this.attr("data-axsplit-colindex")) dom_this.attr("data-axsplit-colindex", colindex);
				colindex++;
			}else if(dom_this.hasClass("AXSplit-rows")){
				if(dom_this.attr("data-height")){
                    var height = getPixelValueBind(dom_this.attr("data-height"), parentHeight);
					calcHeight += height;
                    dom_this.css("height", height);
				}else{
					unrowCount++;
				}
				if(!dom_this.attr("data-axsplit-rowindex")) dom_this.attr("data-axsplit-rowindex", rowindex);
				rowindex++;
			}else if(dom_this.hasClass("AXSplit-row-handle")) {
				calcHeight += dom_this.height().number();
				if(!dom_this.attr("data-axsplit-rowindex")) dom_this.attr("data-axsplit-rowindex", rowindex);
				rowindex++;
			}
		});

        /**
         * min/max, width/height 설정
         * @param dom
         * @param type "width"|"height"
         */
        function setMinMaxLength(dom, type) {
            var min = dom.attr("data-min-" + type);
            var max = dom.attr("data-max-" + type);
            var parentLength = (type == "height" ? parentHeight : parentWidth);
            if(min) {
                var minValue = getPixelValueBind(min, parentLength);
                dom.css("min-" + type, minValue);
            }
            if (max) {
                var maxValue = getPixelValueBind(max, parentLength);
                dom.css("max-" + type, maxValue);
            }
        }

        // data-width, data-height 속성이 없는 element 길이 설정
        parent.children().each(function(){
			var dom_this = axdom(this);
			if(dom_this.hasClass("AXSplit-cols")){
				if(!dom_this.attr("data-width")){
					dom_this.css({width: (parentWidth - calcWidth) / uncolCount});
				}
                setMinMaxLength(dom_this, "width");
			}else if(dom_this.hasClass("AXSplit-rows")){
                if(!dom_this.attr("data-height")){
                    dom_this.css({height: (parentHeight - calcHeight) / unrowCount});
                }
                setMinMaxLength(dom_this, "height");
            }

			if( dom_this.find(".AXSplit-rows, .AXSplit-cols").length > 0 ){
				moreFindTarget.push(dom_this);
			}
		});

        // inner split을 처리하기 위한 재귀호출
		for(var i=0;i<moreFindTarget.length;i++){
			this.initChild(moreFindTarget[i]);
		}
    },
	initEvent: function(){
		var cfg = this.config, _this = this;
		this.target.find(".AXSplit-col-handle, .AXSplit-row-handle").bind("mousedown", function(event){
			_this.readyResize(axdom(this), event);
		});
	},
	readyResize: function(handleDom, event){
		var cfg = this.config, _this = this;
		this.resizeHandle_data = {
			parentDom: handleDom.parent(),
			dom: handleDom,
			isRowHandle: handleDom.hasClass("AXSplit-row-handle")
		};
		this.resizeHandle_data.dom.addClass("on");

		if(this.resizeHandle_data.isRowHandle){
			//rows
			this.resizeHandle_data.top = event.pageY;
			this.resizeHandle_data.hindex = this.resizeHandle_data.dom.attr("data-axsplit-rowindex").number();
			this.resizeHandle_data.pitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-rows[data-axsplit-rowindex="+ (this.resizeHandle_data.hindex-1) +"]");
			this.resizeHandle_data.nitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-rows[data-axsplit-rowindex="+ (this.resizeHandle_data.hindex+1) +"]");
			this.resizeHandle_data.pitem_dom_height = this.resizeHandle_data.pitem_dom.height().number();
			this.resizeHandle_data.pitem_dom_min_height = this.resizeHandle_data.pitem_dom.css("min-height").number();
			this.resizeHandle_data.pitem_dom_max_height = this.resizeHandle_data.pitem_dom.css("max-height").number();
			this.resizeHandle_data.nitem_dom_height = this.resizeHandle_data.nitem_dom.height().number();
			this.resizeHandle_data.nitem_dom_min_height = this.resizeHandle_data.nitem_dom.css("min-height").number();
			this.resizeHandle_data.nitem_dom_max_height = this.resizeHandle_data.nitem_dom.css("max-height").number();
		}else{
			//cols
			this.resizeHandle_data.left = event.pageX;
			this.resizeHandle_data.hindex = this.resizeHandle_data.dom.attr("data-axsplit-colindex").number();
			this.resizeHandle_data.pitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-cols[data-axsplit-colindex="+ (this.resizeHandle_data.hindex-1) +"]");
			this.resizeHandle_data.nitem_dom = this.resizeHandle_data.parentDom.find(".AXSplit-cols[data-axsplit-colindex="+ (this.resizeHandle_data.hindex+1) +"]");
			this.resizeHandle_data.pitem_dom_width = this.resizeHandle_data.pitem_dom.width().number();
			this.resizeHandle_data.pitem_dom_min_width = this.resizeHandle_data.pitem_dom.css("min-width").number();
			this.resizeHandle_data.pitem_dom_max_width = this.resizeHandle_data.pitem_dom.css("max-width").number();
			this.resizeHandle_data.nitem_dom_width = this.resizeHandle_data.nitem_dom.width().number();
			this.resizeHandle_data.nitem_dom_min_width = this.resizeHandle_data.nitem_dom.css("min-width").number();
			this.resizeHandle_data.nitem_dom_max_width = this.resizeHandle_data.nitem_dom.css("max-width").number();
		}

		axdom(document.body).bind("mousemove.axsplit", this.splitResize.bind(this));
		axdom(document.body).bind("mouseup.axsplit", this.splitResizeEnd.bind(this));
	},
	splitResize: function(event){
		var cfg = this.config, _this = this;
		var rdata = this.resizeHandle_data;

		if(rdata.isRowHandle){
			var dy = event.pageY - rdata.top;

			var pitem_dom_height = rdata.pitem_dom_height + dy;

            if (rdata.pitem_dom_min_height > 0 && rdata.pitem_dom_min_height > pitem_dom_height) { return; }
            if (rdata.pitem_dom_max_height > 0 && rdata.pitem_dom_max_height < pitem_dom_height) { return; }

			rdata.pitem_dom.css({height:pitem_dom_height});
			if(rdata.pitem_dom.attr("data-height")){
				rdata.pitem_dom.attr("data-height", pitem_dom_height);
			}

			var nitem_dom_height = rdata.nitem_dom_height - dy;

            if (rdata.nitem_dom_min_height > 0 && rdata.nitem_dom_min_height > nitem_dom_height) { return; }
            if (rdata.nitem_dom_max_height > 0 && rdata.nitem_dom_max_height < nitem_dom_height) { return; }

            rdata.nitem_dom.css({height:nitem_dom_height});
			if(rdata.nitem_dom.attr("data-height")){
				rdata.nitem_dom.attr("data-height", nitem_dom_height);
			}
		}else{
			var dx = event.pageX - rdata.left;

			var pitem_dom_width = rdata.pitem_dom_width + dx;

            if (rdata.pitem_dom_min_width > 0 && rdata.pitem_dom_min_width > pitem_dom_width) { return; }
            if (rdata.pitem_dom_max_width > 0 && rdata.pitem_dom_max_width < pitem_dom_width) { return; }

			rdata.pitem_dom.css({width:pitem_dom_width});
			if(rdata.pitem_dom.attr("data-width")){
				rdata.pitem_dom.attr("data-width", pitem_dom_width);
			}

			var nitem_dom_width = rdata.nitem_dom_width - dx;

            if (rdata.nitem_dom_min_width > 0 && rdata.nitem_dom_min_width > nitem_dom_width) { return; }
            if (rdata.nitem_dom_max_width > 0 && rdata.nitem_dom_max_width < nitem_dom_width) { return; }

			rdata.nitem_dom.css({width:nitem_dom_width});
			if(rdata.nitem_dom.attr("data-width")){
				rdata.nitem_dom.attr("data-width", nitem_dom_width);
			}
		}

        // 브라우저 부하로 인해 리사이즈 액션이 끊기는 문제가 있어서 일단 주석 처리함
        //this.resizeInstances();

        if(cfg.onsplitresize){
            cfg.onsplitresize.call(this.resizeHandle_data);
        }
	},
	splitResizeEnd: function(){
		var cfg = this.config, _this = this;
		this.resizeHandle_data.dom.removeClass("on");
		axdom(document.body).unbind("mousemove.axsplit");
		axdom(document.body).unbind("mouseup.axsplit");

		if(cfg.onsplitresizeend){
			cfg.onsplitresizeend.call({});
		}

        this.resizeInstances();
	},
    /**
     * '10%', '20px', '30' 등의 길이 표현을 픽셀단위의 number 값으로 변환한다.
     * @param value {String} - '10%', '20px', '30' 등의 길이 표현
     */
    getPixelValue: function(value, parentLength){
        if (typeof value !== "string" || value === "") { return 0; }

        if (value.indexOf("%") > -1) {
            var percent = value.number();
            var pixelValue = parentLength * (percent / 100);

            return pixelValue;
        } else {
            return value.number();
        }
    },
    /**
     * AXGrid_instances, AXTree_instances 중에 fill: true 설정된 인스턴스를 컨테이너에 꽉차게 만든다.
     */
    resizeInstances: function(){
        var axGrids = window.AXGrid_instances;
        if (axGrids && typeof axGrids.length === "number") {
            axf.each(axGrids, function(gi, grid) {
                if (grid.config.fill === true) {
                    grid.scrollBody.css("border", "none");

                    var ph = grid.target.parent().innerHeight();
                    var siblingsHeight = 0;
                    grid.target.siblings().each(function(si, sibling){
                        var s = $(sibling);
                        if (s.height() === 0) { return; }

                        siblingsHeight += s.outerHeight(true);
                    });

                    grid.setHeight(ph - siblingsHeight + 2/*border none size*/);
                }
            });
        }

        var axTree = window.AXTree_instances;
        if (axTree && typeof axTree.length === "number") {
            axf.each(axTree, function(ti, tree){
                if (tree.config.fill === true) {
                    tree.scrollBody.css("border", "none");

                    var ph = tree.target.parent().innerHeight();
                    var siblingsHeight = 0;
                    tree.target.siblings().each(function(si, sibling){
                        var s = $(sibling);
                        if (s.height() === 0) { return; }

                        siblingsHeight += s.outerHeight(true);
                    });

                    tree.target.height(ph - siblingsHeight);
                    tree.resetHeight();
                }
            });
        }
    }
});
/* ---------------------------- */
var AXGrid = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();

        this.Observer = null;
        this.list = [];
        this.removedList = [];
        this.pageActive = false;
        this.page = {pageNo: 0, pageSize: 100, pageCount: "", listCount: 0};

        this.moveSens = 0;
        this.config.viewMode = "grid"; // icon, mobile
        this.config.moveSens = 1;
        this.config.formPaddingRight = "11px";
        this.config.sort = true;
        this.config.colHeadTool = true;
        this.config.xscroll = true;
        this.config.fitToWidth = (AXConfig.AXGrid.fitToWidth || false);
        this.config.fitToWidthRightMargin = (AXConfig.AXGrid.fitToWidthRightMargin || 15);
        this.config.passiveMode = AXConfig.AXGrid.passiveMode;
        this.config.passiveRemoveHide = AXConfig.AXGrid.passiveRemoveHide;
        this.config.scrollContentBottomMargin = "10";
        this.config.listCountMargin = 12;
        this.config.headTdHeight = (AXConfig.AXGrid.headTdHeight || 30);

        this.config.mergeCells = false; // cells merge option
        this.config.control_lock_status = 0; // 0 : 모든 기능 사용가능, 1: 컨트롤(데이터는 변경가능하지만 내부 속성변경 금지), 2: 컨트롤+update(데이터와 속성 모두 변경 금지)
        this.selectedCells = [];
        this.selectedRow = [];
        this.copiedRow = [];
        this.clipBoard = {
            type: "copy", list: []
        };

        this.isMobile = AXUtil.browser.mobile;
        this.cachedDom = {};
        this.virtualScroll = {
            startIndex: 0,
            endIndex: 0,
            itemTrHeight: 0,
            printListCount: 0,
            scrollTop: 0
        };
        this.reserveKeys = {
            // 시스템 설정 키들 -- s
            parent_hash: "phash",
            child_hash: "hash",
            sub_list: "list",
            hidden: "_hidden"
        };

        this.config.resizeable = true; // 2016-06-12 reisze 안되는 옵션 추가.

        this.mobileContextMenu = new AXContextMenuClass();

        this.windowEvents = []; // removeGrid(); 메서드에서 window에 걸린 이벤트를 제거하기 위한 프로퍼티

        window.AXGrid_instances = window.AXGrid_instances || [];
        window.AXGrid_instances.push(this);
    },
    /* 공통 영역 */
    defineConfig: function (rewrite, _test) {
        var cfg = this.config;
        if (!cfg.colGroup) return;
        if (cfg.colGroup.length == 0) {
            console.log("colGrpup is empty)");
            return;
        }

        /* col너비 합계 구하기 */
        var colWidth = 0;
        var hasHiddenCell = false;
        var showColLen = 0;
        if (!rewrite) this.fixedColSeq = cfg.fixedColSeq;
        var bodyWidth = this.body.width();
        if (bodyWidth == 0) bodyWidth = this.target.innerWidth();
        var astricCount = 0;

        for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
            if (CG.colSeq == undefined) CG.colSeq = cidx;
            if (CG.display == undefined) CG.display = true;
            if (CG.display) {
                if (!rewrite) {
                    if (CG.width == "*") {
                        cfg.hasAstricCol = true;
                        CG.width = 0;
                        CG.widthAstric = true;
                        astricCount++;
                    }
                    CG._owidth = CG.width;
                    /* 최초의 너비값 기억 하기 */
                }
                else {
                    if (CG.widthAstric) {
                        CG.width = 0;
                        CG._owidth = CG.width;
                        astricCount++;
                    }
                }

                if (typeof CG._owidth == "undefined") CG._owidth = CG.width;
                colWidth += (CG._owidth || 0).number();
                showColLen += 1;
            }
            else {
                hasHiddenCell = true;
                if (!rewrite) {
                    CG._owidth = CG.width;
                    /* 최초의 너비값 기억 하기 */
                }
            }
        }

        if (!cfg.fitToWidth) {
            /* width * 예외처리 구문 ------------ s */

            if ((bodyWidth - cfg.fitToWidthRightMargin) > (colWidth + 100 * astricCount)) {
                var remainsWidth = (bodyWidth - cfg.fitToWidthRightMargin) - colWidth;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display && CG.widthAstric) {
                        CG._owidth = (remainsWidth / astricCount).ceil();
                        CG.width = CG._owidth;
                        colWidth += (CG._owidth || 0).number();
                    }
                }
            }
            else {
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display && CG.widthAstric) {
                        CG._owidth = 100;
                        CG.width = 100;
                        colWidth += (CG._owidth || 0).number();
                    }
                }
            }
            /* width * 예외처리 구문 ------------ e */
        }
        else {
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && CG.widthAstric) {
                    CG.width = 100;
                    CG._owidth = 100;
                    colWidth += (CG._owidth || 0).number();
                }
            }
        }
        this.colWidth = colWidth;

        if (cfg.fitToWidth) { /*너비 자동 맞춤버전의 경우 */
            if (bodyWidth > this.colWidth) {

                var _bodyWidth = bodyWidth - cfg.fitToWidthRightMargin;
                var zoomRatio = bodyWidth / this.colWidth;
                colWidth = 0;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display) {
                        CG.width = (CG._owidth * zoomRatio).ceil();
                        if (_bodyWidth > CG.width) _bodyWidth -= CG.width;
                        else CG.width = _bodyWidth;
                        colWidth += CG.width.number();
                    }
                }
                this.colWidth = colWidth;
            }
            else {

                colWidth = 0;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (CG.display) {
                        if (CG._owidth == undefined) CG._owidth = (CG.width || 0).number();
                        CG.width = CG._owidth.number();
                        colWidth += CG.width.number();
                    }
                }
                this.colWidth = colWidth;
            }
        }

        this.showColLen = showColLen;
        /* col너비 합계 구하기 ~~~~~~~~~~~~~~ 구해진 너비합은 그리드 head, body 의 너비로 지정됨. */

        if (rewrite && cfg.colHead.rows) cfg._colHead_rows = axf.copyObject(cfg.colHead.rows);

        if (!cfg.colHead) cfg.colHead = {};
        if (!cfg.body) cfg.body = {};
        if (!cfg.page) cfg.page = {display: false, paging: false, status: {formatter: null}};
        if (cfg.colHead.rowsEmpty) cfg.colHead.rows = undefined;
        if (cfg.body.rowsEmpty) cfg.body.rows = undefined;

        /* colHead rows ----------------------------------------------------------------------------------------------------- */
        if (cfg.colHead.rows) {
            /* colHeadRow 정해진 경우 */
            cfg.colHead._maps = new Array(cfg.colHead.rows.length);
            var colMaxLen = 0;
            for (var r = 0; r < cfg.colHead.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.colHead.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) {
                            CH._colspan = CH.colspan;
                        }
                        else {
                            CH.colspan = CH._colspan;
                        }
                    }
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                    if (typeof CH.align == "undefined" && cfg.colHeadAlign) CH.align = cfg.colHeadAlign; // 고정값 아닌 설정 값 가져오기
                    colLen += (CH.colspan || 0).number();
                }
                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.colHead._maps.length; _m++) {
                cfg.colHead._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToColHeadMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.colHead._maps[rr][nC] == undefined) {
                                    cfg.colHead._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
                return startPosition;
            };
            for (var r = 0; r < cfg.colHead.rows.length; r++) {
                //var startPosition = null;
                //var isMultiRow = false;
                for (var CH, CHidx = 0, __arr = cfg.colHead.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return CH.key == this.item.key;
                        }).first();
                    }
                    if (myCG != null) {
                        if (CH.sort != myCG.sort) {
                            //console.log(CH, myCG);
                        }
                        myCG.colHeadTool = ((typeof CH.colHeadTool == "undefined") ? cfg.colHeadTool : CH.colHeadTool );
                        if (rewrite) AXUtil.overwriteObject(CH, myCG, true);
                        else AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1,
                            colHeadTool: ((typeof CH.colHeadTool == "undefined") ? cfg.colHeadTool : CH.colHeadTool )
                        }, false);
                    }
                    appendPosToColHeadMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                }
            }

            /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.colHead._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.colHead.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                /* colspan 감소 시키기 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        var rowPosition = null;
                        for (var a = 0; a < cfg.colHead._maps.length; a++) {
                            if (rowPosition != cfg.colHead._maps[a][cidx]) {
                                rowPosition = cfg.colHead._maps[a][cidx];
                                cfg.colHead.rows[rowPosition.r][rowPosition.c].colspan--;
                            }
                        }
                    }
                }
            }
            /* colHeadRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
        else {
            // colHeadRow 정해지지 않은 경우
            cfg.colHead._maps = [
                []
            ];
            var colHeadRows = [
                []
            ];

            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                var adder = {
                    key: CG.key,
                    colSeq: CG.colSeq,
                    label: CG.label,
                    align: (cfg.colHeadAlign || CG.align || "left"),
                    rowspan: 1,
                    colspan: 1,
                    valign: "bottom",
                    isLastCell: true,
                    display: CG.display,
                    formatter: CG.formatter,
                    formatterLabel: CG.formatterLabel,
                    checked: CG.checked,
                    disabled: CG.disabled,
                    sort: CG.sort,
                    colHeadTool: ((typeof CG.colHeadTool == "undefined") ? cfg.colHeadTool : CG.colHeadTool ),
                    tooltip: CG.tooltip,
                    displayLabel: (CG.displayLabel || false),
                    addClass: CG.addClass
                };
                if (cfg._colHead_rows) adder.sort = cfg._colHead_rows[0][cidx].sort; // redrawGrid 호출된 경우 예외처리
                colHeadRows[0].push(adder);
                cfg.colHead._maps[0].push({r: 0, c: cidx});
            }
            cfg.colHead.rows = colHeadRows;
            cfg.colHead.rowsEmpty = true;
            // colHeadRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        }

        for (var mr = 0, mrl = cfg.colHead._maps.length; mr < mrl; mr++) {
            //cfg.colHead.rows[m.r][m.c].isLastCell = true;
            var map_p = cfg.colHead._maps[mr].last();
            cfg.colHead.rows[map_p.r][map_p.c].isTrLastChild = true;
        }

        /* colHead rows ----------------------------------------------------------------------------------------------------- */

        /* body rows ------------------------------------------------------------------------------------------------------- */
        if (cfg.body.rows) {
            /* bodyRow 정해진 경우 */
            cfg.body._maps = new Array(cfg.body.rows.length);
            var colMaxLen = 0;
            for (var r = 0; r < cfg.body.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.body.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) CH._colspan = CH.colspan;
                        else CH.colspan = CH._colspan;
                    }
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "middle";
                    /* if(CH.align == undefined || CH.align == null) CH.align = "left"; */
                    colLen += CH.colspan.number();
                }
                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.body._maps.length; _m++) {
                cfg.body._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToBodyMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.body._maps[rr][nC] == undefined) {
                                    if (rr != posR) position._isRowMerged = true; /// status row merged
                                    cfg.body._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };

            for (var r = 0; r < cfg.body.rows.length; r++) {
                for (var CH, CHidx = 0, __arr = cfg.body.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return this.item.key == CH.key;
                        }).first();
                    }

                    if (myCG != null) {

                        AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }
                    appendPosToBodyMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                }
            }
            /*body._maps 마지막 줄에 해당하는 cfg.body.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.body._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.body.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                /* colspan 감소 시키기 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        for (var a = 0; a < cfg.body._maps.length; a++) {
                            var rowPosition = cfg.body._maps[a][cidx];
                            cfg.body.rows[rowPosition.r][rowPosition.c].colspan--;
                        }
                    }
                }
            }

            /* bodyRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
        else {
            /* bodyRow 정해지지 않은 경우 */
            cfg.body._maps = [
                []
            ];
            var bodyRows = [
                []
            ];
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                var adder = {
                    key: CG.key,
                    colSeq: CG.colSeq,
                    label: CG.label,
                    align: (CG.align || "left"),
                    rowspan: 1,
                    colspan: 1,
                    valign: (CG.valign || "middle"),
                    isLastCell: true,
                    display: CG.display,
                    checked: CG.checked,
                    disabled: CG.disabled,
                    formatter: CG.formatter,
                    editor: CG.editor,
                    formatterLabel: CG.formatterLabel,
                    tooltip: CG.tooltip,
                    addClass: CG.addClass
                };
                bodyRows[0].push(adder);
                cfg.body._maps[0].push({r: 0, c: cidx});
            }
            cfg.body.rows = bodyRows;
            cfg.body.rowsEmpty = true;
            /* bodyRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
        /* body rows ------------------------------------------------------------------------------------------------------- */

        /*marker 관련 데이터 정리 */
        if (cfg.body.marker) {
            cfg.body.marker = [].concat(cfg.body.marker);
            /* colEndPosition 관련 처리 함수 */

            var appendPosToMarkerMap = function (r, c, posR, position, marker) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (marker._maps[rr][nC] == undefined) {
                                    marker._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };

            for (var m = 0, l = cfg.body.marker.length, marker; m < l; m++) {
                marker = cfg.body.marker[m];

                if (marker.rows) {
                    this.bodyHasMarker = true;
                    marker._maps = new Array(marker.rows.length);
                    colMaxLen = 0;
                    for (var r = 0; r < marker.rows.length; r++) {
                        var colLen = 0;
                        for (var CH, CHidx = 0, __arr = marker.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                            if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                            if (CH.colspan == undefined || CH.colspan == null) {
                                CH.colspan = 1;
                                CH._colspan = 1;
                            }
                            else {
                                if (!rewrite) CH._colspan = CH.colspan;
                                else CH.colspan = CH._colspan;
                            }
                            if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                            colLen += CH.colspan.number();
                        }
                        if (colMaxLen < colLen) colMaxLen = colLen;
                    }
                    for (var _m = 0; _m < marker._maps.length; _m++) {
                        marker._maps[_m] = new Array(colMaxLen);
                    }

                    for (var r = 0; r < marker.rows.length; r++) {
                        for (var CH, CHidx = 0, __arr = marker.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                            if (CH.colSeq != undefined) {
                                var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                            }
                            else {
                                var myCG = cfg.colGroup.searchObject(function () {
                                    return this.item.key == CH.key;
                                }).first();
                            }

                            if (myCG != null) {
                                AXUtil.overwriteObject(CH, myCG, false);
                            }
                            else {
                                AXUtil.overwriteObject(CH, {
                                    align: "left",
                                    valign: "bottom",
                                    display: true,
                                    rowspan: 1,
                                    colspan: 1
                                }, false);
                            }
                            appendPosToMarkerMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx}, marker);
                        }

                    }
                    /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */

                    for (var rm, midx = 0, __arr = marker._maps.last(); (midx < __arr.length && (rm = __arr[midx])); midx++) {
                        if (rm) marker.rows[rm.r][rm.c].isLastCell = true;
                    }

                    if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                        /* colspan 감소 시키기 */
                        for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                            if (!CG.display) {
                                for (var a = 0; a < marker._maps.length; a++) {
                                    var rowPosition = marker._maps[a][cidx];
                                    marker.rows[rowPosition.r][rowPosition.c].colspan--;
                                }
                            }
                        }
                    }

                }
            }
        }
        /*marker 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*head 관련 데이터 정리 */
        if (cfg.head) {
            cfg.head._maps = new Array(cfg.head.rows.length);
            colMaxLen = 0;
            for (var r = 0; r < cfg.head.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.head.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) CH._colspan = CH.colspan;
                        else CH.colspan = CH._colspan;
                    }
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                    /*if(CH.align == undefined || CH.align == null) CH.align = "left"; */
                    colLen += CH.colspan.number();
                }

                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.head._maps.length; _m++) {
                cfg.head._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToHeadMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    /*컬럼 루프횟수 */
                    var isWhile = true;
                    /* 루프유지변수 */
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.head._maps[rr][nC] == undefined) {
                                    cfg.head._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };
            for (var r = 0; r < cfg.head.rows.length; r++) {
                for (var CH, CHidx = 0, __arr = cfg.head.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return this.item.key == CH.key;
                        }).first();
                    }

                    if (myCG != null) {
                        AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }
                    appendPosToHeadMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                }

            }

            /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.head._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.head.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                /* colspan 감소 시키기 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        for (var a = 0; a < cfg.head._maps.length; a++) {
                            var rowPosition = cfg.head._maps[a][cidx];
                            cfg.head.rows[rowPosition.r][rowPosition.c].colspan--;
                        }
                    }
                }
            }
        }
        /*head 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*foot 관련 데이터 정리 */
        if (cfg.foot) {
            cfg.foot._maps = new Array(cfg.foot.rows.length);
            colMaxLen = 0;
            for (var r = 0; r < cfg.foot.rows.length; r++) {
                var colLen = 0;
                for (var CH, CHidx = 0, __arr = cfg.foot.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                    if (CH.colspan == undefined || CH.colspan == null) {
                        CH.colspan = 1;
                        CH._colspan = 1;
                    }
                    else {
                        if (!rewrite) CH._colspan = CH.colspan;
                        else CH.colspan = CH._colspan;
                    }
                    if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                    colLen += CH.colspan.number();
                }

                if (colMaxLen < colLen) colMaxLen = colLen;
            }
            for (var _m = 0; _m < cfg.foot._maps.length; _m++) {
                cfg.foot._maps[_m] = new Array(colMaxLen);
            }
            /* colEndPosition 관련 처리 함수 */
            var appendPosToFootMap = function (r, c, posR, position) {
                var nC = position.c;
                /*시작 컬럼 위치 */
                var startPosition = null;
                for (var rr = posR; rr < (posR + r); rr++) {
                    if (r > 1) if (rr > 0 && startPosition != null) nC = startPosition;
                    var tC = c;
                    var isWhile = true;
                    while (isWhile) {
                        try {
                            if (tC == 0) {
                                isWhile = false;
                            }
                            else {
                                if (cfg.foot._maps[rr][nC] == undefined) {
                                    cfg.foot._maps[rr][nC] = position;
                                    if (startPosition == null) startPosition = nC;
                                    tC--;
                                }
                                else {
                                    nC++;
                                }
                            }
                        } catch (e) {
                            isWhile = false;
                        }
                    }
                }
            };
            for (var r = 0; r < cfg.foot.rows.length; r++) {
                for (var CH, CHidx = 0, __arr = cfg.foot.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.colSeq != undefined) {
                        var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                    }
                    else {
                        var myCG = cfg.colGroup.searchObject(function () {
                            return this.item.key == CH.key;
                        }).first();
                    }

                    if (myCG != null) {
                        AXUtil.overwriteObject(CH, myCG, false);
                    }
                    else {
                        AXUtil.overwriteObject(CH, {
                            align: "left",
                            valign: "bottom",
                            display: true,
                            rowspan: 1,
                            colspan: 1
                        }, false);
                    }

                    appendPosToFootMap((CH.rowspan || 1), (CH.colspan || 1), r, {r: r, c: CHidx});
                }
            }

            /*colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여 */
            for (var m, midx = 0, __arr = cfg.foot._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                if (m) cfg.foot.rows[m.r][m.c].isLastCell = true;
            }

            if (hasHiddenCell) { /* colGroup 중에 숨겨진 col 이 존재하는 경우 */
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        for (var a = 0; a < cfg.foot._maps.length; a++) {
                            var rowPosition = cfg.foot._maps[a][cidx];
                            cfg.foot.rows[rowPosition.r][rowPosition.c].colspan--;
                        }
                    }
                }

            }
        }
        /*foot 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*editor 관련 데이터 정리 */
        if (cfg.editor) {
            if (cfg.editor.rows) {
                this.hasEditor = true;
                cfg.editor._maps = new Array(cfg.editor.rows.length);
                colMaxLen = 0;
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    var colLen = 0;
                    for (var CH, CHidx = 0, __arr = cfg.editor.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                        if (CH) {
                            if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
                            if (CH.colspan == undefined || CH.colspan == null) {
                                CH.colspan = 1;
                                CH._colspan = 1;
                            }
                            else {
                                if (!rewrite) CH._colspan = CH.colspan;
                                else CH.colspan = CH._colspan;
                            }
                            if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
                            colLen += CH.colspan.number();
                        }
                    }

                    if (colMaxLen < colLen) colMaxLen = colLen;
                }
                for (var _m = 0; _m < cfg.editor._maps.length; _m++) {
                    cfg.editor._maps[_m] = new Array(colMaxLen);
                }
                /* colEndPosition 관련 처리 함수 */
                var appendPosToEditorMap = function (r, c, posR, position) {
                    var nC = position.c;
                    var startPosition = null;
                    for (var rr = posR; rr < (posR + r); rr++) {
                        var tC = c;
                        var isWhile = true;
                        while (isWhile) {
                            try {
                                if (tC == 0) {
                                    isWhile = false;
                                }
                                else {
                                    if (cfg.editor._maps[rr][nC] == undefined) {
                                        cfg.editor._maps[rr][nC] = position;
                                        if (startPosition == null) startPosition = nC;
                                        tC--;
                                    }
                                    else {
                                        nC++;
                                    }
                                }
                            } catch (e) {
                                isWhile = false;
                            }
                        }
                    }
                };
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    for (var CH, CHidx = 0, __arr = cfg.editor.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                        if (CH) {
                            if (CH.colSeq != undefined) {
                                var myCG = cfg.colGroup.getToSeq(CH.colSeq);
                            }
                            else {
                                var myCG = cfg.colGroup.searchObject(function () {
                                    return this.item.key == CH.key;
                                }).first();
                            }
                            if (myCG != null) {
                                AXUtil.overwriteObject(CH, myCG, false);
                            }
                            else {
                                AXUtil.overwriteObject(CH, {
                                    align: "left",
                                    valign: "bottom",
                                    display: true,
                                    rowspan: 1,
                                    colspan: 1
                                }, false);
                            }
                            appendPosToEditorMap(CH.rowspan, CH.colspan, r, {r: r, c: CHidx});
                        }
                    }

                }

                for (var m, midx = 0, __arr = cfg.editor._maps.last(); (midx < __arr.length && (m = __arr[midx])); midx++) {
                    if (m) cfg.editor.rows[m.r][m.c].isLastCell = true;
                }

                if (hasHiddenCell) {
                    for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                        if (!CG.display) {
                            for (var a = 0; a < cfg.editor._maps.length; a++) {
                                var rowPosition = cfg.editor._maps[a][cidx];
                                cfg.editor.rows[rowPosition.r][rowPosition.c].colspan--;
                            }
                        }
                    }

                }
            }
        }

        /*editor 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

        /*fixedColSeq가 설정된 경우 */
        if (cfg.fixedColSeq != undefined && cfg.fixedColSeq != null) {

            var fixedColSeq = this.fixedColSeq;

            for (var m, midx = 0, __arr = cfg.colHead._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                    if (c) {
                        if ((fixedColSeq + 1) > cidx) cfg.colHead.rows[c.r][c.c].isFixedCell = true;
                    }
                }

            }

            for (var m, midx = 0, __arr = cfg.body._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                    if (c) {
                        if (fixedColSeq == cidx) cfg.body.rows[c.r][c.c].isFixedEndCell = true;
                        if ((fixedColSeq + 1) > cidx) cfg.body.rows[c.r][c.c].isFixedCell = true;
                    }
                }

            }

            if (cfg.head) {
                for (var m, midx = 0, __arr = cfg.head._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                    for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                        if (c) {
                            if (fixedColSeq == cidx) cfg.head.rows[c.r][c.c].isFixedEndCell = true;
                            if ((fixedColSeq + 1) > cidx) cfg.head.rows[c.r][c.c].isFixedCell = true;
                        }
                    }

                }

            }
            if (cfg.foot) {
                for (var m, midx = 0, __arr = cfg.foot._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                    for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                        if (c) {
                            if (fixedColSeq == cidx) cfg.foot.rows[c.r][c.c].isFixedEndCell = true;
                            if ((fixedColSeq + 1) > cidx) cfg.foot.rows[c.r][c.c].isFixedCell = true;
                        }
                    }

                }
            }

            if (cfg.body.marker) {
                if (cfg.body.marker.rows) {
                    for (var m, midx = 0, __arr = cfg.body.marker._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                        for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                            if (c) {
                                if (fixedColSeq == cidx) cfg.body.marker.rows[c.r][c.c].isFixedEndCell = true;
                                if ((fixedColSeq + 1) > cidx) cfg.body.marker.rows[c.r][c.c].isFixedCell = true;
                            }
                        }

                    }

                }
            }

            if (cfg.editor) {
                if (cfg.editor.rows) {
                    for (var m, midx = 0, __arr = cfg.editor._maps; (midx < __arr.length && (m = __arr[midx])); midx++) {
                        for (var c, cidx = 0, __arr2 = m; (cidx < __arr2.length && (c = __arr2[cidx])); cidx++) {
                            if (c) {
                                if (fixedColSeq == cidx) cfg.editor.rows[c.r][c.c].isFixedEndCell = true;
                                if ((fixedColSeq + 1) > cidx) cfg.editor.rows[c.r][c.c].isFixedCell = true;
                            }
                        }

                    }

                }
            }
            this.hasFixed = true;
            if (hasHiddenCell) {
                var minusFixedCol = 0;
                var fixedColSeq = this.fixedColSeq;
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    if (!CG.display) {
                        if ((fixedColSeq + 1) > cidx) minusFixedCol++;
                    }
                }

                cfg.fixedColSeq = this.fixedColSeq - minusFixedCol;
            }
            else {
                cfg.fixedColSeq = this.fixedColSeq;
            }

            if (cfg.fixedColSeq == -1) {
                /*fixed 제거*/
                this.hasFixed = false;
            }

            var fixedColSeq = this.fixedColSeq, fixedColWidth = 0, fixedColLen = 0;
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && cidx < (fixedColSeq + 1)) {
                    fixedColWidth += CG.width.number();
                    fixedColLen++;
                }
            }
            this.showFixedColLen = fixedColLen;
            this.fixedColWidth = fixedColWidth;
        }

        var ri = cfg.body.rows.length;
        while (ri--) {
            var ii = cfg.body.rows[ri].length;
            while (ii--) {
                if (cfg.body.rows[ri][ii].display) {
                    cfg.body.rows[ri][ii].isTdEnd = true;
                    break;
                }
            }
        }
        if (cfg.editor) {
            ri = cfg.editor.rows.length;
            while (ri--) {
                var ii = cfg.editor.rows[ri].length;
                while (ii--) {
                    if (cfg.editor.rows[ri][ii].display) {
                        cfg.editor.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
        if (cfg.foot) {
            ri = cfg.foot.rows.length;
            while (ri--) {
                var ii = cfg.foot.rows[ri].length;
                while (ii--) {
                    if (cfg.foot.rows[ri][ii].display) {
                        cfg.foot.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
        if (cfg.head) {
            ri = cfg.head.rows.length;
            while (ri--) {
                var ii = cfg.head.rows[ri].length;
                while (ii--) {
                    if (cfg.head.rows[ri][ii].display) {
                        cfg.head.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
        if (cfg.body.marker && cfg.body.marker.rows) {
            ri = cfg.body.marker.rows.length;
            while (ri--) {
                var ii = cfg.body.marker.rows[ri].length;
                while (ii--) {
                    if (cfg.body.marker.rows[ri][ii].display) {
                        cfg.body.marker.rows[ri][ii].isTdEnd = true;
                        break;
                    }
                }
            }
        }
    },
    /**
     * @method AXGrid.setConfig
     * @param {Object} config - gridConfig
     * @description 선언된 클래스를 사용하기 위해 속성을 정의합니다.
     * @example
     * ```js
     * myGrid.setConfig({
 *     targetID    : "AXGridTarget", // {String} -- 그리드 div ID
 *     theme       : "AXGrid",       // {String} [AXGrid] -- CSS Class 이름
 *     fixedColSeq : 0,              // {Number} -- 컬럼고정 기능을 사용합니다. 고정할 마지막 컬럼의 인덱스 값입니다. 예제) http://dev.axisj.com/samples/AXGrid/fixedColSeq.html
 *     fitToWidth  : true,           // {Boolean} [false] -- 컬럼 가로 길이를 그리드의 가로 길이에 맞춥니다.
 *     colHeadAlign: "center",       // {String} 헤드의 기본 정렬. "left"|"center"|"right" 값을 사용할 수 있습니다. colHeadAlign 을 지정하면 colGroup 에서 정의한 정렬이 무시되고 colHeadAlign : false 이거나 없으면 colGroup 에서 정의한 속성이 적용됩니다.
 *     mergeCells  : [3,4]           // {Boolean|Array} -- 전체셀병합,병합안함,지정된 인덱스열만 병합 예제) http://dev.axisj.com/samples/AXGrid/mergeCells.html
 *     height      : "auto",         // {Number|String} -- 그리드의 높이를 지정합니다. 숫자를 사용하면 픽셀 단위로, "auto" 값을 사용하면 그리드의 높이가 내용에 맞춰서 늘어납니다. 예제) http://dev.axisj.com/samples/AXGrid/autoHeight.html
 *     sort        : true,           // {Boolean} -- true: 그리드의 헤더를 클릭해서 정렬 할 수 있습니다. false: 정렬 기능을 비활성화 합니다.  이 설정은 colGroup의 sort 보다 우선적으로 적용됩니다.
 *     remoteSort  : true,           // {Boolean} [false] -- 서버에서 정렬을 처리(서버에서 별도 처리 필요)합니다. 헤더 클릭시 'sortBy=cost desc' 형식의 정렬 정보가 ajax 요청에 포함됩니다.
 *     colHeadTool : true,           // {Boolean} -- 컬럼 display 여부를 설정 합니다. 이 설정은 colGroup의 colHeadTool 보다 우선적으로 적용됩니다.
 *     viewMode    : "grid"          // {String} -- 그리드가 보여지는 형태("grid"|"icon"|"mobile")를 지정합니다. viewMode는 mediaQuery에 의해서 자동으로 결정되기도 합니다. 예제) http://localhost/axisj/samples/AXGrid/viewMode.html
 *     reserveKeys : { // reserveKeys는 AXISJ에서 지정한 키를 다른 키로 지정하는 하는 경우 사용합니다. reserveKeys를 사용하면 데이터를 수정없이 바로 사용할 수 있습니다.
 *         parent_hash  : "phash", // {String} 부모해시 키의 이름을 지정합니다.
 *         child_hash   : "hash",  // {String} 자식해시 키의 이름을 지정합니다.
 *         sub_list     : "list",  // {String} 자식 리스트 키의 이름을 지정합니다.
 *         hidden       : "_hidden"// {String} hidden 키의 이름을 지정합니다.
 *     },
 *     colGroup : [ // 데이터 리스트의 컬럼을 정의합니다.
 *         {
 *             key      : "no",        // {String} -- 데이터와 맵핑할 키 입니다. key 명칭은 reservedKey
 *             label    : "번호",      // {String} -- 사용자에게 보여줄 컬럼명입니다.
 *             width    : 50,          // {Number|String} -- 컬럼의 가로길이를 설정합니다. 픽셀단위의 숫자나 "*" 문자를 사용할 수 있습니다. "*"을 사용하는 경우 그리드의 가로 길이에 따라 컬럼의 결이가 가변적으로 변합니다.
 *             align    : "right",     // {String} ["left"] -- 컬럼 내용의 정렬을 설정합니다. "left"|"center"|"right" 값을 사용할 수 있습니다.
 *             sort     : "asc",       // {String|Boolean} [""] -- 컬럼의 정렬을 지정합니다. "asc"|"desc"|false 값을 사용할 수 있습니다. false 값을 사용하면 컬럼의 정렬을 비활성화 합니다.
 *             colHeadTool : true      // {Boolean} -- 컬럼 display 여부를 설정 합니다.
 *             formatter: "money",     // {String|Function} -- 컬럼의 값을 표현하는 방식을 지정합니다. "money", "dec", "html", "checkbox", "radio", function은 아래 formatter 함수를 참고하세요.
 *             tooltip  : "money",     // {String|Function} -- 툴팁의 값을 표현하는 방식을 지정합니다. 툴팁을 지정하면 td div.bodyNode에 title 속성으로 값이 표현됩니다. 위 formatter와 동일한 변수를 사용합니다.
 *             disabled : function(){},// {Boolean|Function} -- formatter가 checkbox, radio인 경우 input의 disabled 값을 지정합니다. disabled(true|flase)를 반환하는 함수를 작성합니다. 아래 disabled 함수를 참고하세요.
 *             checked  : function(){} // {Boolean|Function} -- formatter가 checkbox, radio인 경우 input의 checked 값을 지정합니다. checked(true|flase)를 반환하는 함수를 작성합니다. 아래 checked 함수를 참고하세요.
 *         }
 *     ],
 *     colHead: { // 예제) http://dev.axisj.com/samples/AXGrid/colhead.html
 *         rows: [ // 컬럼 헤더를 병합할 수 있습니다. 사용법은 colGroup과 동일하며 key 대신 colSeq를 사용할 수 있습니다.
 *             [
 *                 {colSeq:0, rowspan:2},
 *                 {colSeq:null, colspan:3, label:"표현식", align:"center"},
 *                 {colSeq:4, rowspan:2, formatter: function(){} },
 *                 {colSeq:5, rowspan:2},
 *                 {colSeq:6, rowspan:2},
 *                 {colSeq:7, rowspan:2},
 *                 {colSeq:8, rowspan:2},
 *                 {colSeq:9, rowspan:2}
 *             ],
 *             [
 *                 {colSeq:1},
 *                 {colSeq:2},
 *                 {colSeq:3}
 *             ]
 *         ],
 *         onclick: function(){} // {Function} -- 그리드의 컬럼 헤드를 클릭시 발생하는 이벤트 입니다. 아래 onclick 함수를 참고하세요.
 *     },
 *     body: {
 *         marker: { // 그리드의 목록의 중간에 소계같은 원하는 데이터를 표현할 수 있습니다. 예제) http://dev.axisj.com/samples/AXGrid/marker.html
 *             display: function(){}, // {Function} -- marker 표시여부(true|flase)를 반환하는 함수를 작성합니다. 아래 display 함수를 참고하세요.
 *             rows: [] // marker를 표시할 형태를 정의 합니다. colHead의 rows와 동일한 형식을 사용합니다.
 *         },
 *         onclick       : function(){}, // 데이터 행의 click 이벤트를 정의합니다. 이벤트 변수 및 this 프로퍼티는 아래 onclick 함수를 참고하세요.
 *         ondblclick    : function(){}, // 데이터 행의 ondblclick 이벤트를 정의합니다. 이벤트 변수 및 this 프로퍼티는 아래 ondblclick 함수를 참고하세요.
 *         oncheck       : function(){}, // 데이터 행의 oncheck 이벤트를 정의합니다. 이벤트 변수 및 this 프로퍼티는 아래 oncheck 함수를 참고하세요.
 *         addClass      : function(){}, // 데이터 행의 사용자 정의 class를 할당할 수 있습니다.. 이벤트 변수 및 this 프로퍼티는 아래 addClass 함수를 참고하세요.
 *         onchangeScroll: function(){}, // 스크롤 변경 이벤트 입니다. 이벤트 변수 및 this 프로퍼티는 아래 onchangeScroll 함수를 참고하세요.
 *         onscrollend   : function(){}  // 그리드내의 스크롤이 마지막 항목까지 도달 하였을때 발생하는 이벤트를 설정할 수 있습니다. 이벤트 변수 및 this 프로퍼티는 아래 onscrollend 함수를 참고하세요.
 *     },
 *     foot: { // 그리드 마지막에 표시하는 행입니다. 예제) http://dev.axisj.com/samples/AXGrid/headfoot.html
 *         rows: [] // foot을 표시할 형태를 정의 합니다. colHead의 rows와 동일한 형식을 사용합니다.
 *     },
 *     page:{
 *         paging  : true, // {Boolean} -- 페이징 사용여부를 설정합니다.
 *         pageNo  : 1,    // {Number} -- 현재 페이지 번호를 설정합니다.
 *         pageSize: 100,  // {Number} -- 한 페이지장 표시할 데이터 수를 설정합니다.
 *         onchange: function(pageNo){} // {Funtion} -- 페이지 변경 이벤트입니다.
 *     },
 *     editor: { // 예제) http://localhost/axisj/samples/AXGrid/passive.html
 *         rows: [
 *             [
 *                 {
 *                     colSeq:0,
 *                     align:"center",
 *                     valign:"middle",
 *                     formatter: function(){},
 *                     form: {
 *                         type    : "readonly",  // {String} -- "hidden"|"text"|"readonly"|"textarea"|"select"|"radio"|"checkbox"
 *                         value   : "itemValue", // {String|Function} -- "itemValue"|"itemText": 해당 아이템의 값을 사용합니다. function을 사용해야 하는 경우 아래 formValue 함수를 참고하세요.
 *                         onClick : formOnClick, // {Function} -- 아래 formOnClick 함수를 참고하세요.
 *                         onBlur  : formOnBlur,  // {Function} -- 아래 formOnBlur  함수를 참고하세요.
 *                         onFocus : formOnFocus  // {Function} -- 아래 formOnFocus 함수를 참고하세요.
 *                         validate: function(formID, value){ // {Function} 입력된 값을 확인합니다.
 *                             //this.formID
 *                             //this.value
 *                             //this.checkedValues
 *                             //this.form
 *
 *                             return true | false;
 *                         }
 *                     },
 *                     AXBind:{
 *                         type  : "selector", // {String} -- form.type == "text"인 경우 "number"|"money"|"selector"|"slider"|"twinSlider"|"date"|"twinDate"|"dateTime"|"switch"를 사용할 수 있습니다. form.type == "select"인 경우 "select"를 사용할 수 있습니다.
 *                         config: {} // {Object} -- API(http://jdoc.axisj.com/jQueryExtends.html)에서 bind + type으로 검색하세요.
 *                     }
 *                 }
 *             ]
 *         ],
 *         request: {
 *             ajaxUrl :"saveGrid.php",
 *             ajaxPars:"param1=1&param2=2"
 *         },
 *         response: function(){ // ajax 응답에 대해 예외 처리 필요시 response 구현
 *             // response에서 처리 할 수 있는 객체 들
 *             //console.log({res:this.res, index:this.index, insertIndex:this.insertIndex, list:this.list, page:this.page});
 *             if(this.error){
 *                 console.log(this);
 *                 return;
 *             }
 *         },
 *         onkeyup: function(event, element){
 *             //this.list
 *             //this.item
 *             //this.element
 *         }
 *     },
 *     contextMenu: {} // API와 예제를 참고하세요. API) http://jdoc.axisj.com/AXContextMenu.html 예제) http://dev.axisj.com/samples/AXCore/AXContextMenu.html
 * });
     *
     * function formatter(itemIndex, item) {
 *     //this.index
 *     //this.list
 *     //this.item
 *     //this.page
 *     //this.key
 *     //this.value
 * }
     *
     * function disabled | checked() {
 *     //index: itemIndex,
 *     //list: this.list,
 *     //item: item,
 *     //page: this.page,
 *     //key: key,
 *     //value: value
 * }
     *
     * function display() {
 *     //this.index
 *     //this.list
 *     //this.item
 *     //this.page
 *
 *     return true | false;
 * }
     *
     * function onclick | ondblclick() {
 *     //this.index
 *     //this.r
 *     //this.c
 *     //this.list
 *     //this.colHead
 *     //this.page
 * }
     *
     * function addClass() {
 *     //this.index
 *     //this.item
 *     //this.list
 *     //this.page
 *
 *     return "red"|"green"|"blue"|"yellow"|"white"|"gray"; // 별도의 색상별 CSS를 추가로 정의해서 사용할 수 있습니다.
 * }
     *
     * function oncheck() {
 *     //this.index
 *     //this.checked
 *     //this.r
 *     //this.c
 *     //this.list
 *     //this.page
 * }
     *
     * function onchangeScroll(virtualScroll) {}
     *
     * function onscrollend() {
 *     //this.list
 *     //this.page
 * }
     *
     * function formOnClick | formOnBlur | formOnFocus() {
 *     //this.key
 *     //this.position
 *     //this.value
 * }
     *
     * function formValue(key, value) {
 *     //this.key
 *     //this.value
 *     //this.list
 *     //this.page
 * }
     *
     * ```
     */
    init: function () {
        var cfg = this.config, _this = this;

        if (Object.isUndefined(cfg.targetID)) {
            console.log("need targetID - setConfig({targetID:''})");
            return;
        }
        if (!cfg.colGroup) {
            console.log("need colGroup - setConfig({colGroup:[]})");
            return;
        }

        this.config.reserveKeys = Object.extend(this.reserveKeys, cfg.reserveKeys, true);

        if (typeof cfg.colHeadAlign == "undefined") {
            cfg.colHeadAlign = AXConfig.AXGrid.colHeadAlign;
        }
        cfg.emptyListMSG = cfg.emptyListMSG || AXConfig.AXGrid.emptyListMSG;
        cfg.listCountMSG = cfg.listCountMSG || AXConfig.AXGrid.listCountMSG || "전체 <b>{listCount}</b>개의 목록이 있습니다.";
        cfg.pageCountMSG = cfg.pageCountMSG || AXConfig.AXGrid.pageCountMSG;

        /*
         cfg.viewMode 결정 구간.
         */

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if (v.min != undefined && v.max != undefined) {
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                    else {
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

        if (Object.isObject(cfg.colGroup)) {
            var newColGroup = cfg.colGroup.concat();
            cfg.colGroup = newColGroup;
        }

        this.target = axdom("#" + cfg.targetID);

        var targetInnerHeight = this.target.innerHeight();
        if (targetInnerHeight == 0) targetInnerHeight = (AXConfig.AXGrid.pageHeight.number() || 400);
        this.theme = (cfg.theme) ? cfg.theme : "AXGrid";
        /* 테마기본값 지정*/
        cfg.__height = cfg.height;
        cfg.height = (cfg.height) ? cfg.height : targetInnerHeight.number() + "px";

        /* 그리드 높이 지정 */

        var theme = this.theme;
        var gridCss = [];
        gridCss.push("overflow:hidden;");
        if (cfg.width) gridCss.push("width:" + cfg.width + ";");
        if (cfg.height) gridCss.push("height:" + cfg.height + ";");

        /* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */
        var ol = [];
        //ol.push("<a id=\"" + cfg.targetID + "_AX_grid_focus\" href=\"#axtree\" ></a>");
        ol.push("<div class=\"" + theme + "\" id=\"" + cfg.targetID + "_AX_grid\" style=\"" + gridCss.join('') + "\">");
        ol.push("	<div class=\"AXgridScrollBody\" id=\"" + cfg.targetID + "_AX_gridScrollBody\" style=\"z-index:2;\">");
        ol.push("		<div class=\"AXGridColHead AXUserSelectNone\" id=\"" + cfg.targetID + "_AX_gridColHead\" onselectstart=\"return false;\"></div>");
        ol.push("		<div class=\"AXGridToolGroup top\" id=\"" + cfg.targetID + "_AX_gridToolGroupTop\"></div>");
        ol.push("		<div class=\"AXGridBody\" id=\"" + cfg.targetID + "_AX_gridBody\"></div>");
        ol.push("		<div class=\"AXGridToolGroup bottom\" id=\"" + cfg.targetID + "_AX_gridToolGroupBottom\"></div>");

        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackY\" class=\"gridScrollTrackY\">");
        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollYHandle\" class=\"gridScrollHandle\"></div>");
        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollY_AX_tip\" class=\"gridScroll-tip\"><span></span></div>");
        ol.push("</div>");
        ol.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackX\" class=\"gridScrollTrackX\"><div id=\"" + cfg.targetID + "_AX_scrollXHandle\" class=\"gridScrollHandle\"></div></div>");

        ol.push("	</div>");
        ol.push("   <div class=\"AXgridEditor\" id=\"" + cfg.targetID + "_AX_gridEditor\" style=\"z-index:2;\"></div>");

        ol.push("	<div class=\"AXgridPageBody\" id=\"" + cfg.targetID + "_AX_gridPageBody\" style=\"z-index:1;\">");
        ol.push("		<div class=\"AXgridPagingUnit\" id=\"" + cfg.targetID + "_AX_gridPagingUnit\">");
        ol.push("			<a class=\"AXgridPagingPrev\">PREV</a>");
        ol.push("			<div class=\"AXgridPageNumber\"><select id=\"" + cfg.targetID + "_AX_gridPageNo\" class=\"AXgridPageNo\"><option value=\"\">&nbsp;&nbsp;</option></select></div>");
        ol.push("			<div class=\"AXgridPageNumberCount\" id=\"" + cfg.targetID + "_AX_gridPageCount\">/ ...</div>");
        ol.push("			<a class=\"AXgridPagingNext\">NEXT</a>");
        ol.push("		</div>");
        ol.push("		<div class=\"AXgridStatus\" id=\"" + cfg.targetID + "_AX_gridStatus\">");
        ol.push("		" + cfg.listCountMSG.replace("{listCount}", "0"));
        ol.push("		</div>");
        ol.push("	</div>");
        ol.push("</div>");
        this.target.html(ol.join(''));
        /* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */

        /* 주요 타깃 설정 */
        //this.gridFocus = axdom("#" + cfg.targetID + "_AX_grid_focus");
        this.gridBody = axdom("#" + cfg.targetID + "_AX_grid");
        this.scrollBody = axdom("#" + cfg.targetID + "_AX_gridScrollBody");
        this.colHead = axdom("#" + cfg.targetID + "_AX_gridColHead");
        this.body = axdom("#" + cfg.targetID + "_AX_gridBody");

        this.scrollTrackY = axdom("#" + cfg.targetID + "_AX_scrollTrackY");
        this.scrollYHandle = axdom("#" + cfg.targetID + "_AX_scrollYHandle");
        this.scrollYTip = axdom("#" + cfg.targetID + "_AX_scrollY_AX_tip");
        this.scrollYTipSpan = axdom("#" + cfg.targetID + "_AX_scrollY_AX_tip").find("span");
        this.scrollTrackX = axdom("#" + cfg.targetID + "_AX_scrollTrackX");
        this.scrollXHandle = axdom("#" + cfg.targetID + "_AX_scrollXHandle");

        this.editor = axdom("#" + cfg.targetID + "_AX_gridEditor");

        this.pageBody = axdom("#" + cfg.targetID + "_AX_gridPageBody");
        this.pageBody.data("display", "show");
        this.pagingUnit = axdom("#" + cfg.targetID + "_AX_gridPagingUnit");
        this.status = axdom("#" + cfg.targetID + "_AX_gridStatus");
        //this.scroller = axdom("#" + cfg.targetID + "_AX_gridScroller");

        /* define part --------------------------------- */
        this.defineConfig();
        /* config object define */
        /* define part --------------------------------- */

        if (cfg.page) {
            this.page.pageNo = (cfg.page.pageNo || 1);
            this.page.pageSize = (cfg.page.pageSize || (AXConfig.AXGrid.pageSize || 100));
            this.page.onchange = cfg.page.onchange || this.page.onChange;
        }

        /*colHead setting */
        this.setColHead();

        /*body setting */
        this.setBody();

        /*editor setting */
        this.editor.hide();

        this.gridTargetSetSize();

        this.contentScrollResize();

        /* body event bind */
        var contentScrollTouchstart = this.contentScrollTouchstart.bind(this);
        this.contentScrollTouchstartBind = function (event) {
            contentScrollTouchstart(event);
        };
        /*
         var contentScrollScrollWheel = this.contentScrollScrollWheel.bind(this);
         this.contentScrollScrollWheelBind = function (event) {
         contentScrollScrollWheel(event);
         };
         */

        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
        if (document.attachEvent) { /*if IE (and Opera depending on user setting) */
            /*axf.getId(cfg.targetID+"_AX_gridBody").detachEvent("on"+mousewheelevt, this.contentScrollScrollWheelBind); */
            if (axf.getId(cfg.targetID + "_AX_gridBody")) axf.getId(cfg.targetID + "_AX_gridBody").attachEvent("on" + mousewheelevt, (function (e) {
                this.contentScrollScrollWheel(e || window.event);
            }).bind(this));
        }
        else if (document.addEventListener) { /*WC3 browsers */
            /*axf.getId(cfg.targetID+"_AX_gridBody").removeEventListener(mousewheelevt, this.contentScrollScrollWheelBind, false); */
            if (axf.getId(cfg.targetID + "_AX_gridBody")) axf.getId(cfg.targetID + "_AX_gridBody").addEventListener(mousewheelevt, (function (e) {
                this.contentScrollScrollWheel(e || window.event);
            }).bind(this), false);
        }

        if (document.addEventListener) {
            /*axf.getId(cfg.targetID+"_AX_gridBody").removeEventListener("touchstart", this.contentScrollTouchstartBind, false); */
            if (axf.getId(cfg.targetID + "_AX_gridBody")) axf.getId(cfg.targetID + "_AX_gridBody").addEventListener("touchstart", contentScrollTouchstart, false);
        }

        //this.target.bind("keydown", this.onKeydown.bind(this));
        //keydown 이벤트 방식 변경
        this.target.bind("click.axgrid", (function (e) {
            if (this.editorOpend || this.inline_edit) return;
            var e = e || window.event;
            if (e.target.tagName == "INPUT" || e.target.tagName == "SELECT" || e.target.tagName == "TEXTAREA" || e.target.tagName == "BUTTON") return;
            //this.gridFocus.focus();
        }).bind(this));

        //this.gridFocus.unbind("keydown.axgrid").bind("keydown.axgrid", this.onKeydown.bind(this));

        if (cfg.contextMenu) {
            AXContextMenu.bind({
                id: cfg.targetID + "ContextMenu",
                theme: cfg.contextMenu.theme,
                width: cfg.contextMenu.width,
                menu: cfg.contextMenu.menu
            });
            this.target.bind("contextmenu", this.onContextmenu.bind(this));
        }

        /* body event bind */

        /* page event bind */
        var goPageMove = this.goPageMove.bind(this);
        this.pagingUnit.find(".AXgridPagingPrev").bind("click", function (event) {
            goPageMove(-1);
        });
        this.pagingUnit.find(".AXgridPagingNext").bind("click", function (event) {
            goPageMove(1);
        });
        /* page event bind */

        var windowResizeApplyEvent = this.windowResizeApply.bind(this);
        this.windowEvents.push({
            "event": "resize",
            "fn": windowResizeApplyEvent
        });
        axdom(window).bind("resize", windowResizeApplyEvent);

        //this.printList();  printList는 setBody 에서 자동 실행 됨
    },
    windowResize: function () {
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 100);
    },
    windowResizeApply: function () {
        var cfg = this.config;

        if (this.config.resizeable === false) return; // 2016-06-12 reisze 안되는 옵션 추가.

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if (v.min != undefined && v.max != undefined) {
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                    else {
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "grid" : "mobile";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }
        this.redrawGrid(true);
    },
    gridTargetSetSize: function (react) { /* AXgridScrollBody 안쪽의 높이와 관련된 요소 설정 */
        var cfg = this.config;
        /*cfg.height */

        if (cfg.viewMode == "mobile") {

            this.target.css({height: "auto", "max-height": "auto"});
            this.gridBody.addClass("AXGridMobile");
            this.gridBody.css({height: "auto"});
            this.scrollBody.css({height: "auto"});
            this.body.css({top: "auto", height: "auto"});
            this.pageBody.hide();
            this.setPaging();

        }
        else {

            /*page setting */
            if (!cfg.page) {
                this.pageBody.hide();
                this.pageBody.data("display", "hide");
            }
            else {

                if (cfg.page.display == false) {
                    this.pageBody.hide();
                    this.pageBody.data("display", "hide");
                }
                else {
                    this.pageBody.show();
                    this.pageBody.data("display", "show");

                    if (cfg.page.paging) {
                        this.setPaging();
                    }
                    else {
                        this.pagingUnit.hide();
                    }
                    if (cfg.page.status == false) {
                        this.status.hide();
                    }
                }
            }

            this.gridBody.removeClass("AXGridMobile");

            if (cfg.__height == "auto") {
                var colHeadHeight = this.colHead.outerHeight();
                if (colHeadHeight == 1) colHeadHeight = 0;
                var scrollBodyHeight = this.scrollContent.height();
                this.scrollBody.css({height: scrollBodyHeight + colHeadHeight});
                /*colhead + body height */
                this.body.css({top: colHeadHeight, height: (scrollBodyHeight)});
                /* body Height */
                this.gridBody.css({height: "auto"});
                this.target.css({height: "auto", "max-height": "auto"});
            }
            else {
                if (cfg.height) this.gridBody.css({height: cfg.height});

                /// gridFoot - height 빼기 제거
                var pageBodyHeight = (this.pageBody.data("display") == "show") ? this.pageBody.outerHeight() : 0,
                    gridFootHeight = (cfg.foot) ? this.gridFoot.outerHeight() : 0;
                if (cfg.page.display == false) pageBodyHeight = 0;

                var scrollBodyHeight = cfg.height.number() - pageBodyHeight - 2; /// - gridFootHeight;
                this.scrollBody.css({height: scrollBodyHeight});

                var colHeadHeight = this.colHead.outerHeight();
                if (colHeadHeight == 1) colHeadHeight = 0;

                this.body.css({top: colHeadHeight, height: (scrollBodyHeight - colHeadHeight)});
                /* body Height */
            }
            if (react) this.contentScrollResize(false);
        }
    },
    resetHeight: function () {
        var cfg = this.config;
        var target = axdom("#" + cfg.targetID);

        if (cfg.viewMode != "mobile") {
            var targetInnerHeight = target.innerHeight();
            if (targetInnerHeight == 0) targetInnerHeight = 400;
            cfg.height = targetInnerHeight + "px"; // 그리드 높이 지정

            if (cfg.height && this.gridBody) this.gridBody.css({height: cfg.height});

            if (this.colHead) {
                this.redrawGrid();
                this.onevent_grid({type: "resetHeight"});
            }
            /*
             var pageBodyHeight = (this.pageBody.data("display") == "show") ? this.pageBody.outerHeight() : 0;
             if (cfg.page.display == false) pageBodyHeight = 0;
             var scrollBodyHeight = cfg.height.number() - pageBodyHeight - 2;
             this.scrollBody.css({ height: scrollBodyHeight });
             */

            /*
             var colHeadHeight = this.colHead.outerHeight();
             if (colHeadHeight == 1) colHeadHeight = 0;
             this.body.css({ top: colHeadHeight, height: (scrollBodyHeight - colHeadHeight) });

             this.contentScrollResize(false);
             */
        }
    },
    /**
     * @method AXGrid.setHeight
     * @param height {Number} - grid outerHeight
     * @description 그리드의 높이를 설정합니다. viewMode가 "mobile"인 경우는 작동하지 않습니다.
     * @returns {jQueryObject}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setHeight(600);
     * ```
     */
    setHeight: function (height) {
        var cfg = this.config;
        var target = axdom("#" + cfg.targetID);

        if (cfg.viewMode != "mobile" && typeof height == "number") {
            target.css({"height": height});
            this.resetHeight();
        }

        return target;
    },
    /**
     * @method AXGrid.getColGroup
     * @param suffix {String} - "CH" ColHead, "CB" ColBody, "EB" EditorBody, "FE" FixedEditorBody,"FB" FixedColBody,"FC" FixedColHead
     * @description ColGroup을 구성 합니다.
     * @returns {String} ColGroup html
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getColGroup("CB");
     * ```
     */
    getColGroup: function (suffix) {
        var cfg = this.config;
        var fixedColSeq = this.fixedColSeq;
        /*{colID:0, key:"no", label:"번호", width:"100", align:"left", addClassNames:"", style:"", display:true, sort:null} */
        var po = [];
        po.push("<colgroup>");
        if (suffix != "FC" && suffix != "FB" && suffix != "FE") {
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display) {
                    po.push("<col width=\"" + CG.width + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
                }
            }

            if (suffix == "CB") po.push("<col />");
        }
        else {
            /*fixedCol 존재 */
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && cidx < (fixedColSeq + 1)) {
                    po.push("<col width=\"" + CG.width + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
                }
            }

        }
        po.push("</colgroup>");
        return po.join('');
    },
    /**
     * @method AXGrid.getColSeqToHead
     * @param r {Number} - Row
     * @param c {Number} - Column
     * @description 대상의 colHead 내부 seq 가져옵니다.
     * @returns {Number} colSeq
     * @example
     * ```
     * var myGrid = new AXGrid();
     * var colSeq = myGrid.getColSeqToHead(colHeadR, colHeadC);
     * ```
     */
    getColSeqToHead: function (r, c) {
        /*console.log("getColSeqToHead:"+r+","+c); */
        var cfg = this.config;
        var colSeq = null;
        for (var a = cfg.colHead._maps[r].length - 1; a > -1; a--) {
            if (cfg.colHead._maps[r][a].r == r && cfg.colHead._maps[r][a].c == c) {
                colSeq = a;
                break;
            }
        }
        return colSeq;
    },
    /**
     * @method AXGrid.redrawGrid
     * @param changeGridView {string}
     * @description 그리드의 모든 요소를 재 정렬 해 줍니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.redrawGrid();
     * ```
     */
    redrawGrid: function (changeGridView) {
        var cfg = this.config, _this = this;
        /*
         모바일 모드로 요청 하면 뼈대 변경.
         */
        if (changeGridView) {
            if (cfg.viewMode == "grid") {
                this.pageBody.show();
                this.pageBody.data("display", "show");
            }
            else if (cfg.viewMode == "icon") {
                this.pageBody.show();
                this.pageBody.data("display", "show");
            }
            else if (cfg.viewMode == "mobile") {
                this.scrollTrackX.hide();
                this.scrollTrackY.hide();
                this.pageBody.hide();
                this.pageBody.data("display", "hide");
            }
        }

        if (typeof changeGridView == "undefined" || changeGridView) {
            this.defineConfig(true);
            this.setColHead();

            this.gridTargetSetSize(true);
            this.setBody(undefined, true);

            if (cfg.viewMode == "grid") {
                if (cfg.head) this.printHead();
                if (cfg.foot) {
                    this.printFoot();
                    this.contentScrollResize(false);
                }
            }
        }
        else {
            this.contentScrollResize();
        }

        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 바디 재구성 기능 포함 */
    },
    /**
     * @method AXGrid.checkedColSeq
     * @param {Number} colSeq - 대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @param {Boolean} checked - true면 check , false면 uncheck
     * @param {Number} itemIndex - 대상 열(미 지정시 전체)
     * @description colgroup내 해당 index의 checked 속성을 변경해 줍니다.해당 index의 아이템이 checkbox로 지정되어 있어야 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.checkedColSeq(0, true); // 모든 체크박스 속성을 checked로
     * myGrid.checkedColSeq(0, true,0); // 첫번째 열의 체크박스속성을 checked로
     * ```
     */
    checkedColSeq: function (colSeq, checked, itemIndex) {

        var cfg = this.config, _this = this, sendObj;
        var _list = this.list;

        if (typeof itemIndex === "undefined") {
            this.colHead.find(".gridCheckBox_colHead_colSeq" + colSeq).each(function () {
                this.checked = checked;
            });
            axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".gridCheckBox_colHead_colSeq" + colSeq).each(function () {
                this.checked = checked;
            });
            this.body.find(".gridCheckBox_body_colSeq" + colSeq).each(function () {
                if (axdom("#" + this.id).attr("disabled") != "disabled") {
                    this.checked = checked;
                }
            });
            for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                if (typeof item.___disabled == "undefined") item.___disabled = {};
                if (typeof item.___checked == "undefined") item.___checked = {};
                //cfg.colGroup[colSeq].checked.call({})
                var disabled = false;
                if (cfg.colGroup[colSeq].disabled) {
                    disabled = cfg.colGroup[colSeq].disabled.call({
                        index: itemIndex,
                        list: this.list,
                        item: item,
                        page: this.page,
                        key: cfg.colGroup[colSeq].key,
                        value: item[cfg.colGroup[colSeq].key]
                    });
                }
                if (!disabled) item.___checked[colSeq] = checked;
            }
            if (cfg.colGroup[colSeq].oncheck) {
                sendObj = {
                    index: colSeq,
                    list: _list
                };
                setTimeout(function () {
                    cfg.colGroup[colSeq].oncheck.call(sendObj, checked);
                }, 1);
            }
            if (cfg.body.oncheck) {
                sendObj = {
                    index: itemIndex,
                    checked: checked,
                    r: 0,
                    c: colSeq,
                    list: this.list,
                    page: this.page
                };
                //setTimeout(function() {
                cfg.body.oncheck.call(sendObj);
                //}, 1);
            }
        }
        else {
            if (cfg.colGroup[colSeq].formatter === "radio") {
                var ii = 0, ll = this.list.length;
                for (; ii < ll; ii++) {
                    if (typeof _this.list[ii].___checked === "undefined") _this.list[ii].___checked = {};
                    _this.list[ii].___checked[colSeq] = false;
                }
            }

            this.body.find(".gridBodyTr_" + itemIndex + " .gridCheckBox_body_colSeq" + colSeq).each(function () {
                if (checked == null) {
                    this.checked = !this.checked;
                }
                else {
                    this.checked = checked;
                }
            });

            var item = this.list[itemIndex];

            if (typeof item.___disabled === "undefined") item.___disabled = {};
            if (typeof item.___checked === "undefined") item.___checked = {};

            if (checked == null) {
                if (cfg.colGroup[colSeq].formatter === "radio") {
                    item.___checked[colSeq] = true;
                }
                else {
                    item.___checked[colSeq] = !(item.___checked[colSeq] == true);
                }
            }
            else {
                item.___checked[colSeq] = checked;
            }

            if (cfg.colGroup[colSeq].oncheck) {
                sendObj = {
                    index: checkboxIndex,
                    list: _list
                };
                //setTimeout(function() {
                cfg.colGroup[colSeq].oncheck.call(sendObj, checked);
                //}, 1);
            }
            if (cfg.body.oncheck) {
                sendObj = {
                    index: itemIndex,
                    checked: checked,
                    r: 0,
                    c: colSeq,
                    list: this.list,
                    item: item,
                    page: this.page
                };
                //setTimeout(function() {
                cfg.body.oncheck.call(sendObj, itemIndex, item);
                //}, 1);
            }
        }
        return this;
    },
    /**
     * @method AXGrid.getCheckedList
     * @param colSeq {Number} -대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @description  Grid list 내의 checked 된 아이템을 반환합니다.해당 colSeq의 아이템이 checkbox|radio로 지정되어 있어야 합니다.
     * @returns {Array} JSObject - 그리드 리스트의 체크된 인덱스 아이템
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getCheckedList(0);
     * ```
     */
    getCheckedList: function (colSeq) {
        var cfg = this.config;
        var collect = [];
        var list = this.list;

        for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
            if (!item.___disabled) item.___disabled = {};
            if (!item.___checked) item.___checked = {};
            if (item.___disabled[colSeq] != true && item.___checked[colSeq] == true) {
                collect.push(item);
            }
        }

        return collect;
    },
    /**
     * @method AXGrid.getCheckedListWithIndex
     * @param colSeq {Number} -대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @description  Grid list 내의 checked 된 아이템,index를 반환합니다.해당 colSeq의 아이템이 checkbox로 지정되어 있어야 합니다.
     * @returns {Array} [{index:Number, item:JSObject}] -그리드 리스트의 체크된 인덱스 , 아이템
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getCheckedListWithIndex(0);
     * ```
     */
    getCheckedListWithIndex: function (colSeq) {
        var cfg = this.config;
        var collect = [];
        var list = this.list;

        for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
            if (!item.___disabled) item.___disabled = {};
            if (!item.___checked) item.___checked = {};
            if (item.___disabled[colSeq] != true && item.___checked[colSeq] == true) {
                collect.push({index: itemIndex, item: item});
            }
        }
        return collect;
    },
    /**
     * @method AXGrid.onKeydown
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid 내부에서 감지되는 이벤트에 대한 처리를 합니다.(방향키로 포커스 이동등..)
     */
    onKeydown: function (event) {

        if (this.selectedRow.length == 0) return this;
        if (this.editorOpend) return this;
        if (this.inline_edit) return this;

        if (axdom(document.body).data("masked") === "true") return this;
        if (event.target) {
            if (event.target.tagName == "INPUT" || event.target.tagName == "TEXTAREA" || event.target.tagName == "SELECT" || event.target.tagName == "BUTTON") return this;
            if (event.target.id != this.config.targetID + "_AX_grid_focus" && event.target.tagName == "A") return this;
        }

        var _this = this, cfg = this.config, body = this.body,
            li, r, c;

        if (event.keyCode == 67 && event.ctrlKey) {
            // this.copyData();
        }

        if (event.keyCode == axf.Event.KEY_ESC) {
            this.selectClear();
        }
        else if (event.keyCode == axf.Event.KEY_RETURN) {
            li = this.selectedRow.first();
            c = this.selectedCells.first();
            if (cfg.colGroup[c].editor && cfg.control_lock_status < 1) {
                this.editCell(0, c, li);
                this.stopEvent(event);
            }
        }
        else if (event.keyCode == 65 && (event.ctrlKey || event.metaKey)) {

        }
        else if (!event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            if (event.keyCode == axf.Event.KEY_UP) { /* */
                this.focusMove(-1, event);
            }
            else if (event.keyCode == axf.Event.KEY_DOWN) { /* */
                this.focusMove(1, event);
            }
            else if (event.keyCode == axf.Event.KEY_LEFT) { /* */
                this.focusMove("L", event);
            }
            else if (event.keyCode == axf.Event.KEY_RIGHT) { /* */
                this.focusMove("R", event);
            }
        }
        else if (event.shiftKey) {
            if (event.keyCode == axf.Event.KEY_UP) { /* */
                // todo 멀티 셀렉트 기능 작
            }
            else if (event.keyCode == axf.Event.KEY_DOWN) { /* */

            }
        }
    },
    /**
     * @method AXGrid.onContextmenu
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  setConfig에서 설정된 contextMenu에 대한 처리를 합니다.
     * @returns {AXContextMenu}
     * @example // 마우스 오른쪽 버튼 클릭시 메뉴를 호출 합니다.(추가,삭제,수정)
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setConfig({
     *     targetID : "AXGridTarget",
     *     theme : "AXGrid",
     *     mediaQuery: {
     *         mx:{min:0, max:600}, dx:{min:600}
     *     },
     *     colGroup : [
     *         {key:"no", label:"번호", width:"40", align:"center", formatter:"money"}
     *     ],
     * 	    contextMenu: {
     * 		    theme:"AXContextMenu", // 선택항목
     * 		    width:"150", // 선택항목
     * 		    menu:[
     * 		    	{
     * 		    		userType:1, label:"추가하기", className:"plus", onclick:function(){
     * 		    			myGrid.appendList(null);
     * 		    		}
     * 		    	}
     * 		    ]
     * 	    }
     * });
     * ```
     */
    onContextmenu: function (event) {
        var cfg = this.config, body = this.body;

        if (this.readyMoved) return false;

        /* event target search - */
        //if (event.target.id == "") return;

        //console.log(event.target.tagName);

        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        if (eventTarget.tagName.toLowerCase() == "input") return;
        /*input 인 경우 제외 */
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("bodyTd") || axdom(evt).hasClass("bodyNodeIndent")) ? true : false;
            }
        });

        /**
         * start jglee
         * 2015.12.15
         */
        if (this.isMobile && myTarget == null) {
            myTarget = this.getEventTarget({
                evt: eventTarget, evtIDs: eid,
                until: function (evt, evtIDs) {
                    return (axdom(evt.parentNode).hasClass("gridBodyDiv")) ? true : false;
                },
                find: function (evt, evtIDs) {
                    return (axdom(evt).hasClass("bodyViewMobile")) ? true : false;
                }
            });
        }
        /* end jglee */

        /* event target search ------------------------ */

        if (myTarget) {
            /*colHeadTool ready */
            var targetID = myTarget.id;
            var itemIndex = targetID.split(/_AX_/g).last();
            var ids = targetID.split(/_AX_/g);
            /*
             if (this.selectedCells.length > 0) {
             axf.each(this.selectedCells, function () {
             axdom("#" + this).removeClass("selected");
             });
             this.selectedCells.clear();
             }
             */

            if (this.selectedRow.length < 2) {
                if (this.selectedRow.length > 0) {
                    axf.each(this.selectedRow, function () {
                        body.find(".gridBodyTr_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);
            }
            else {
                var hasItem = false;
                axf.each(this.selectedRow, function () {
                    if (this == itemIndex) {
                        hasItem = true;
                    }
                });
                if (!hasItem) {
                    axf.each(this.selectedRow, function () {
                        body.find(".gridBodyTr_" + this).removeClass("selected");
                    });
                    this.selectedRow.clear();
                    this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                    this.selectedRow.push(itemIndex);
                }
            }

            var item = this.list[itemIndex];
            AXContextMenu.open({
                id: cfg.targetID + "ContextMenu",
                filter: cfg.contextMenu.filter,
                sendObj: {item: item, index: itemIndex}
            }, event);
            /* event 직접 연결 방식 */
        }
        else {
            AXContextMenu.open({
                id: cfg.targetID + "ContextMenu",
                filter: cfg.contextMenu.filter,
                sendObj: null
            }, event);
            /* event 직접 연결 방식 */
        }
        return false;
    },
    copyData: function () {
        var cfg = this.config;
        var copyOut = [];
        axf.each(this.selectedCells, function (index, n) {
            var html = axdom("#" + n).find(".bodyNode").html();
            copyOut.push(html + '\t');
        });

        if (window.clipboardData) {
            window.clipboardData.setData('Text', copyOut.join(''));
            toast.push("데이터가 복사되었습니다. 원하시는 곳에 붙여넣기 하세요.");
        }
        else {
            dialog.push({title: "Copy Data", body: copyOut.join(''), type: "alert"});
        }
    },
    /* 공통 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    /* colHead 영역  */
    /**
     * @method AXGrid.getHeadMousePosition
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head에서 event를 일으킨 마우스의 위치를 캡쳐 합니다.
     * @returns {Object} -(x좌표,y좌표)
     */
    getHeadMousePosition: function (event) {
        var pos = this.colHead.offset();
        var x = (event.pageX - pos.left);
        var y = (event.pageY - pos.top);
        return {x: x, y: y};
    },
    /**
     * @method AXGrid.getColHeadTd
     * @param {Object} arg
     * @description  Grid head를 위한 html을 생성합니다.
     * @returns {String}
     * @example
     * ```
     * // arg
     * {
	 * 	valign: " valign=\"bottom\"",    - td valign option string
	 * 	rowspan: " rowspan=\"2\"",  - rowspan option string
	 * 	colspan: " colspan=\"2\"",  - colspan option string
	 * 	bottomClass: "",  - border-bottom 관련 후처리
	 * 	r: 0, - colhead row index
	 * 	CHidx: 0, -colhead cell index
	 * 	align: "right", - align option string
	 * 	colSeq: 0, - config 에서 지정된 colGroup 내 순서
	 * 	formatter: "checkbox", - html 표시중 checkbox 등 특정 요소 렌더링
	 * 	formatterLabel: "" - checkbox 등 특정 요소를 감쌀 label 태그 내부 출력 내용,
	 * 	sort: "desc", -정렬옵션
	 * 	tdHtml: "blah", - config colGroup 의 label 로 지정된 string
	 * 	ghost: false,  - true 시 비어있는 dummy cell 이 생성됨.
	 * 	displayLabel: false - Label이 지정된 경우 출력 여부. 기본적으로 사용시 false 로 셋팅됨. colgroup 에서 따로 지정하지 않기 때문에,,
	 * }
     * ```
     */
    getColHeadTd: function (arg) {
        var cfg = this.config, po = [], colHeadTdText = " colHeadTdText",
            toolUse = true, sortClass = "";

        if (arg.formatter == "html" || arg.formatter == "checkbox") {
            if (!arg.displayLabel) {
                colHeadTdText = " colHeadTdHtml";
                toolUse = false;
                if (arg.formatter == "checkbox") {
                    colHeadTdText = " colHeadTdCheck";
                    arg.tdHtml = "<label>" +
                        "<input type=\"checkbox\" name=\"checkAll\" class=\"gridCheckBox gridCheckBox_colHead_colSeq" + arg.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkAll_AX_" + arg.r + "_AX_" + arg.CHidx + "\" />" +
                        (arg.formatterLabel || "") +
                        "</label>";
                }
            }
        }

        if (arg.sort) sortClass = (arg.sort == "desc") ? " sortDesc" : " sortAsc";
        if (toolUse) toolUse = arg.colHeadTool;
        po.push("<td" + arg.valign + arg.rowspan + arg.colspan + " ");
        if (!arg.ghost) po.push("id=\"" + cfg.targetID + "_AX_colHead" + (arg.colHeadType || "") + "_AX_" + arg.r + "_AX_" + arg.CHidx + "\" ");
        po.push("class=\"colHeadTd" + arg.bottomClass + sortClass + "\" style=\"height:" + arg.tdHeight + "px;\">");
        po.push("<div class=\"tdRelBlock\" style=\"height:" + arg.tdHeight + "px;\">");
        po.push("<div class=\"colHeadNode" + colHeadTdText + "\" align=\"" + arg.align + "\" ");
        if (!arg.ghost) po.push("id=\"" + cfg.targetID + "_AX_colHeadText" + (arg.colHeadType || "") + "_AX_" + arg.r + "_AX_" + arg.CHidx + "\" ");
        po.push(">");
        po.push(arg.tdHtml);
        po.push("</div>");
        if (!arg.ghost && toolUse && arg.colSeq != null && arg.colSeq != undefined) po.push("<a href=\"#AXexec\" class=\"colHeadTool\" id=\"" + cfg.targetID + "_AX_colHeadTool" + (arg.colHeadType || "") + "_AX_" + arg.r + "_AX_" + arg.CHidx + "\">T</a>");
        if (!arg.ghost) po.push("<div class=\"colHeadResizer\" id=\"" + cfg.targetID + "_AX_colHeadResizer" + (arg.colHeadType || "") + "_AX_" + arg.r + "_AX_" + arg.CHidx + "\"></div>");
        po.push("</div>");
        po.push("</td>");

        if (!arg.ghotst && arg.sort) {
            var myColHead = cfg.colHead.rows[arg.r][arg.CHidx];
            var tdID = cfg.targetID + "_AX_colHead" + (arg.colHeadType || "") + "_AX_" + arg.r + "_AX_" + arg.CHidx;

            this.nowSortHeadID = tdID;
            this.nowSortHeadObj = myColHead;
        }

        return po.join('');
    },
    /**
     * @method AXGrid.setColHead
     * @description  Grid head를 디바이스(보기설정)에 맞춰 렌더링 합니다.(grid,icon,mobile)
     * @returns {String}
     */
    setColHead: function () {
        var cfg = this.config;
        var po = [];

        if (cfg.viewMode == "grid") {
            this.colHead.show();
            var getColHeadTd = this.getColHeadTd.bind(this);
            var _tdHeight = cfg.headTdHeight;

            //console.log(cfg.colHead.rows);

            if (!this.hasFixed) {  /* 일반 colHead 구현 */

                var tableWidth = this.colWidth;
                po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:", tableWidth, "px;\">");
                po.push(this.getColGroup("CH"));
                /*colGroup 삽입 */
                po.push("<tbody>");
                for (var r = 0; r < cfg.colHead.rows.length; r++) {
                    var isLastTR = (cfg.colHead.rows.length - 1 == r);
                    po.push("<tr>");
                    for (var CH, CHidx = 0, __arr = cfg.colHead.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                        if (CH.display && CH.colspan > 0) {

                            /*radio, check exception */
                            var tdHtml = CH.label || "untitle";
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\"";
                            var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";
                            if (CH.isTrLastChild) bottomClass += " isTrLastChild";

                            po.push(getColHeadTd({
                                valign: valign,
                                rowspan: rowspan,
                                colspan: colspan,
                                bottomClass: bottomClass,
                                r: r,
                                CHidx: CHidx,
                                align: (cfg.colHeadAlign || CH.align || "left"),
                                colSeq: CH.colSeq,
                                formatter: CH.formatter,
                                formatterLabel: CH.formatterLabel,
                                sort: CH.sort,
                                colHeadTool: CH.colHeadTool,
                                tdHtml: tdHtml,
                                ghost: false,
                                displayLabel: CH.displayLabel,
                                tdHeight: (function () {
                                    if (cfg.colHead.heights && cfg.colHead.heights[r]) {
                                        var tdHeight = 0;
                                        for (var i = r; i < r + (CH.rowspan); i++) {
                                            tdHeight += (cfg.colHead.heights[i] || 0);
                                        }
                                        return tdHeight;
                                    }
                                    else {
                                        return _tdHeight * (CH.rowspan || 1) + (CH.rowspan - 1);
                                    }
                                })()
                            }));
                        }
                    }
                    po.push("</tr>");
                }
                po.push("</tbody>");
                po.push("</table>");

            }
            else { /* fixedCol 구현 */

                po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
                po.push(this.getColGroup("CH"));
                /*colGroup 삽입 */
                po.push("<tbody>");
                for (var r = 0; r < cfg.colHead.rows.length; r++) {
                    var isLastTR = (cfg.colHead.rows.length - 1 == r);
                    po.push("<tr>");
                    var colCount = 0;
                    axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
                        if (CH.display && CH.colspan > 0) {
                            /*radio, check exception */
                            var tdHtml = CH.label || "untitle";
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\"";
                            var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

                            /*
                             po.push(getColHeadTd({
                             valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
                             align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
                             ghost: (colCount < (cfg.fixedColSeq + 1))
                             }));
                             */

                            var findedCol = true;
                            do {
                                var _map_col = cfg.colHead._maps[r][colCount];
                                if (!_map_col) findedCol = false;
                                else {
                                    if (_map_col.r == r && _map_col.c == colCount) findedCol = false;
                                    else colCount++;
                                }
                            }
                            while (findedCol)

                            po.push(getColHeadTd({
                                valign: valign,
                                rowspan: rowspan,
                                colspan: colspan,
                                bottomClass: bottomClass,
                                r: r,
                                CHidx: CHidx,
                                align: (cfg.colHeadAlign || CH.align || "left"),
                                colSeq: CH.colSeq,
                                formatter: CH.formatter,
                                formatterLabel: CH.formatterLabel,
                                sort: CH.sort,
                                colHeadTool: CH.colHeadTool,
                                tdHtml: tdHtml,
                                ghost: (colCount < (cfg.fixedColSeq + 1)),
                                tdHeight: (function () {
                                    if (cfg.colHead.heights && cfg.colHead.heights[r]) {
                                        var tdHeight = 0;
                                        for (var i = r; i < r + (CH.rowspan); i++) {
                                            tdHeight += (cfg.colHead.heights[i] || 0);
                                        }
                                        return tdHeight;
                                    }
                                    else {
                                        return _tdHeight * (CH.rowspan || 1) + (CH.rowspan - 1);
                                    }
                                })()
                            }));

                            colCount += CH.colspan;
                        }
                    });
                    po.push("</tr>");
                }
                po.push("</tbody>");
                po.push("</table>");

                var fpo = [];
                fpo.push("<div class=\"AXGridColHead fixedColHead\" id=\"" + cfg.targetID + "_AX_fixedColHead\" style=\"width:" + this.fixedColWidth + "px;\">");
                fpo.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.fixedColWidth + "px;\">");
                fpo.push(this.getColGroup("FC"));
                /*colGroup 삽입 */
                fpo.push("<tbody>");
                for (var r = 0; r < cfg.colHead.rows.length; r++) {
                    var isLastTR = (cfg.colHead.rows.length - 1 == r);
                    fpo.push("<tr>");
                    var colCount = 0;
                    axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
                        if (CH.display && CH.isFixedCell && CH.colspan > 0) {
                            ///radio, check exception
                            var tdHtml = CH.label || "untitle";
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\"";
                            var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

                            fpo.push(getColHeadTd({
                                colHeadType: "FC",
                                valign: valign,
                                rowspan: rowspan,
                                colspan: colspan,
                                bottomClass: bottomClass,
                                r: r,
                                CHidx: CHidx,
                                align: (cfg.colHeadAlign || CH.align || "left"),
                                colSeq: CH.colSeq,
                                formatter: CH.formatter,
                                formatterLabel: CH.formatterLabel,
                                sort: CH.sort,
                                colHeadTool: CH.colHeadTool,
                                tdHtml: tdHtml,
                                ghost: false,
                                tdHeight: (function () {
                                    if (cfg.colHead.heights && cfg.colHead.heights[r]) {
                                        var tdHeight = 0, tdBorder = CH.rowspan - 1;
                                        for (var i = r; i < r + (CH.rowspan); i++) {
                                            tdHeight += (cfg.colHead.heights[i] || 0);
                                        }
                                        return tdHeight + tdBorder;
                                    }
                                    else {
                                        return _tdHeight * (CH.rowspan || 1) + (CH.rowspan - 1);
                                    }
                                })()
                            }));
                        }
                        colCount += CH.colspan;
                    });
                    fpo.push("</tr>");
                }
                fpo.push("</tbody>");
                fpo.push("</table>");
                fpo.push("</div>");
            }
            /* fixedCol 구현 */

            this.colHead.html(po.join(''));
            axdom("#" + cfg.targetID + "_AX_fixedColHead").remove();
            if (fpo) this.colHead.after(fpo.join(''));

            this.colHead.find(".colHeadResizer").each(function () {
                var resizerID = this.id;

                var tdID = resizerID.replace("colHeadResizer", "colHead");
                var txtID = resizerID.replace("colHeadResizer", "colHeadText");
                var toolID = resizerID.replace("colHeadResizer", "colHeadTool");

                var rowspan = axdom("#" + tdID).attr("rowspan");
                var valign = axdom("#" + tdID).attr("valign");
                var tdHeight = axdom("#" + tdID).height();
                var txtHeight = axdom("#" + txtID).outerHeight();

                axdom(this).css({height: tdHeight});

                var cellMarginTop = 0;
                if (valign == "bottom") cellMarginTop = (tdHeight - txtHeight) + 5;
                if (valign == "middle") cellMarginTop = (tdHeight - txtHeight) / 2 + 5;
                axdom("#" + txtID).css({"padding-top": cellMarginTop + "px"});
                axdom("#" + toolID).css({"top": (cellMarginTop - 5) + "px"});
                cellMarginTop = null;
            });

            if (cfg.hasAstricCol || cfg.fitToWidth) {
                this.colHead.find(".isTrLastChild").css({"background": "none"});
            }

            this.colHead.bind("mouseover", this.colHeadMouseOver.bind(this));
            this.colHead.bind("mouseout", this.colHeadMouseOut.bind(this));
            this.colHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
            this.colHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
            this.colHead.find(".colHeadTool").bind("focus", function () {
                this.blur();
            });
            this.colHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
            this.colHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));

            if (this.hasFixed) { //fixedColHead에 대한 바인딩 및 처리
                this.fixedColHead = axdom("#" + cfg.targetID + "_AX_fixedColHead");
                this.fixedColHead.find(".colHeadResizer").each(function () {

                    var resizerID = this.id;
                    var tdID = resizerID.replace("colHeadResizer", "colHead");
                    var txtID = resizerID.replace("colHeadResizer", "colHeadText");
                    var toolID = resizerID.replace("colHeadResizer", "colHeadTool");
                    var rowspan = axdom("#" + tdID).attr("rowspan");
                    var valign = axdom("#" + tdID).attr("valign");
                    if (!rowspan) rowspan = 1;

                    var tdHeight = axdom("#" + tdID).height();
                    var txtHeight = axdom("#" + txtID).outerHeight();

                    axdom(this).css({height: tdHeight});

                    var cellMarginTop = 0;
                    if (valign == "bottom") cellMarginTop = (tdHeight - txtHeight) + 5;
                    if (valign == "middle") cellMarginTop = (tdHeight - txtHeight) / 2 + 5;
                    axdom("#" + txtID).css({"padding-top": cellMarginTop + "px"});
                    axdom("#" + toolID).css({"top": (cellMarginTop - 5) + "px"});
                });

                this.fixedColHead.bind("mouseover", this.colHeadMouseOver.bind(this));
                this.fixedColHead.bind("mouseout", this.colHeadMouseOut.bind(this));
                this.fixedColHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
                this.fixedColHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
                this.fixedColHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
                this.fixedColHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));
            }

        }
        else if (cfg.viewMode == "icon") {
            this.colHead.empty();
            this.colHead.hide();
        }
        else if (cfg.viewMode == "mobile") { /* 모바일에서는 헤드 제거 또는 모바일용 헤드 재구성 */
            this.colHead.empty();
            this.colHead.hide();
        }
    },
    /* colHead events */
    /**
     * @method AXGrid.colHeadMouseOver
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head에 마우스를 올렸을때 후처리를 합니다.(툴 박스 표시등)
     */
    colHeadMouseOver: function (event) {
        var cfg = this.config;
        /* event target search - */
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("colHeadTd")) ? true : false;
            }
        });
        /* event target search ------------------------ */

        if (myTarget) {
            /*colHeadTool ready */
            var targetID = myTarget.id;
            var toolID = targetID.replace("colHead", "colHeadTool");
            axdom("#" + toolID).addClass("readyTool");
        }
    },
    /**
     * @method AXGrid.colHeadMouseOut
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head가 마우스 포커스를 잃었을때의 처리를 합니다.
     */
    colHeadMouseOut: function (event) {
        var cfg = this.config;
        /* event target search - */
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("colHeadTd")) ? true : false;
            }
        });
        /* event target search ------------------------ */

        if (myTarget) {
            /*colHeadTool unready */
            var targetID = myTarget.id;
            var toolID = targetID.replace("colHead", "colHeadTool");
            axdom("#" + toolID).removeClass("readyTool");
        }
    },
    /**
     * @method AXGrid.colHeadResizerMouseDown
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 down(누른상태) 했을때의 처리를 합니다.
     */
    colHeadResizerMouseDown: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];
        var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
        var tdID = cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC;
        if (myColHead.isFixedCell) {
            tdID = cfg.targetID + "_AX_colHeadFC_AX_" + colHeadR + "_AX_" + colHeadC;
        }
        /*console.log({colHeadR:colHeadR, colHeadC:colHeadC}); */

        var colSeq = this.getColSeqToHead(colHeadR, colHeadC);
        if (colSeq == null) return;
        /* 예상할 수 없는 오류 */
        /*resize 상태 해제 */
        if (this.colResizing) {
            this.colHeadResizerEnd();
        }
        var offset = axdom("#" + tdID).find(".tdRelBlock").position();
        var relBlockWidth = axdom("#" + tdID).find(".tdRelBlock").width();
        var rightPosition = offset.left.number() + relBlockWidth.number();
        var blockWidth = axdom("#" + cfg.targetID + "_AX_col_AX_" + colSeq + "_AX_CH").attr("width");
        this.colResizeTarget = {
            colSeq: colSeq,
            leftPosition: (rightPosition - blockWidth),
            blockWidth: blockWidth,
            newWidth: blockWidth
        };
        /*console.log(this.colResizeTarget); */

        /* resize event bind */
        var colHeadResizerMouseMove = this.colHeadResizerMouseMove.bind(this);
        this.colHeadResizerMouseMoveBind = function (event) {
            colHeadResizerMouseMove(event);
        };
        var colHeadResizerMouseUp = this.colHeadResizerMouseUp.bind(this);
        this.colHeadResizerMouseUpBind = function (event) {
            colHeadResizerMouseUp(event);
        };
        axdom(document.body).bind("mousemove.AXGrid", this.colHeadResizerMouseMoveBind);
        axdom(document.body).bind("mouseup.AXGrid", this.colHeadResizerMouseUpBind);
        axdom(document.body).bind("mouseleave.AXGrid", this.colHeadResizerMouseUpBind);

        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");
        /* resize event bind ~~~~~~~~~~~~~~~~~~~ */

        // inline cell-editor 초기화
        if (this.inline_edit) {
            this.editCellClear();
        }
    },
    /**
     * @method AXGrid.colHeadResizerMouseMove
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag(누른상태) 했을때 마우스 감도 처리를 합니다.
     */
    colHeadResizerMouseMove: function (event) {
        if (!event.pageX) return;
        /*드래그 감도 적용 */
        if (this.config.moveSens > this.moveSens) this.moveSens++;
        if (this.moveSens == this.config.moveSens) this.colHeadResizerMove(event);
    },
    /**
     * @method AXGrid.colHeadResizerMove
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag(누른상태) 했을때의 처리를 합니다.
     */
    colHeadResizerMove: function (event) {
        var cfg = this.config;
        var mouse = this.getHeadMousePosition(event);
        var newWidth = (this.colResizeTarget.leftPosition - mouse.x).abs();
        if (newWidth < 31) return;

        /* colHead/colBody colGroup width 조정 */
        axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CH").attr("width", newWidth);
        axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CB").attr("width", newWidth);
        axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_EB").attr("width", newWidth);
        if (cfg.foot) {
            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FH").attr("width", newWidth);
        }

        cfg.colGroup[this.colResizeTarget.colSeq].width = newWidth;
        if (!cfg.colGroup[this.colResizeTarget.colSeq].widthAstric) {
            cfg.colGroup[this.colResizeTarget.colSeq]._owidth = newWidth;
        }

        if (this.hasFixed) {
            var fixedColSeq = this.fixedColSeq;

            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FC").attr("width", newWidth);
            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FB").attr("width", newWidth);
            axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FE").attr("width", newWidth);
            if (cfg.foot) {
                axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FF").attr("width", newWidth);
            }

            /*if(this.colResizeTarget.colSeq < fixedColSeq+1){ */

            var fixedColWidth = 0;
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                if (CG.display && cidx < (fixedColSeq + 1)) {
                    fixedColWidth += CG.width.number();
                }
            }

            this.fixedColWidth = fixedColWidth;

            axdom("#" + cfg.targetID + "_AX_fixedColHead").css({width: fixedColWidth});
            axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".colHeadTable").css({width: fixedColWidth});
            this.fixedScrollContent.css({width: fixedColWidth});
            this.fixedScrollContent.find(".gridFixedBodyTable").css({width: fixedColWidth});
            axdom("#" + cfg.targetID + "_AX_fixedEditorContent").css({width: fixedColWidth});
            axdom("#" + cfg.targetID + "_AX_fixedEditorContent").find(".gridFixedBodyTable").css({width: fixedColWidth});
            /*} */

        }

        if (this.editorOpend) {
            var colSeq = this.colResizeTarget.colSeq;
            /* */
            for (var _m = 0; _m < cfg.editor._maps.length; _m++) {
                var rc = cfg.editor._maps[_m][colSeq];
                var CH = cfg.editor.rows[rc.r][rc.c];
                var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + rc.r + "_AX_" + rc.c;
            }
            AXInput.alignAllAnchor();
        }

        /* colHead colGroup width 조정 ------------------------------ */
        this.colResizeTarget.newWidth = newWidth;
        var newColWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
        this.colHead.find(".colHeadTable").css({"width": newColWidth + "px"});
        /*this.body.find(".gridBodyTable").css({"width":newColWidth+"px"}); */
    },
    /**
     * @method AXGrid.colHeadResizerMouseUp
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag 상태가 해제 되었을때의 처리를 합니다.
     */
    colHeadResizerMouseUp: function (event) {
        if (this.colResizeTarget.blockWidth != this.colResizeTarget.newWidth) {
            this.colWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
        }
        this.colHeadResizerEnd();
        this.contentScrollResize(false);
    },
    /**
     * @method AXGrid.colHeadResizerEnd
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head의 크기 조절 바 (|)를 마우스로 drag 상태가 해제 되었을때의 처리를 합니다.
     */
    colHeadResizerEnd: function () {
        this.moveSens = 0;
        this.colResizing = false;
        axdom(document.body).unbind("mousemove.AXGrid");
        axdom(document.body).unbind("mouseup.AXGrid");
        axdom(document.body).unbind("mouseleave.AXGrid");

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");

        if (window.AXInput) AXInput.alignAllAnchor();
    },
    /**
     * @method AXGrid.colHeadNodeClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head를 클릭 했을때의 처리를 합니다(체크박스처리,정렬등).
     */
    colHeadNodeClick: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        if (this.editorOpend) {
            toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
            return;
            /* 에디터가 오픈된 상태이면 비활성화 */
        }

        if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
            this.colHeadCheckBoxClick(event);
            return this;
            /* checkbox block click */
        }
        if (axdom(eventTarget).hasClass("gridCheckBox")) return;
        /* checkbox click */

        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];

        try {
            var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
        } catch (e) {
            return;
        }

        if (cfg.sort == false || myColHead.sort == false) {
            return;
        }

        var tdID = cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC;
        if (myColHead.isFixedCell) {
            tdID = cfg.targetID + "_AX_colHeadFC_AX_" + colHeadR + "_AX_" + colHeadC;
        }

        if (myColHead.colSeq == undefined || myColHead.colSeq == null) {
            console.log("정렬할 수 없는 컬럼 입니다.");
        }
        else {
            if (this.nowSortHeadID) {
                if (this.nowSortHeadID != tdID) {
                    axdom("#" + this.nowSortHeadID).removeClass("sortDesc");
                    axdom("#" + this.nowSortHeadID).removeClass("sortAsc");
                    this.nowSortHeadObj.sort = undefined;
                }
            }
            if (cfg.colHead.rows[colHeadR][colHeadC].sort == "desc") axdom("#" + tdID).removeClass("sortDesc");
            else axdom("#" + tdID).removeClass("sortAsc");

            var nsort = "";
            if (myColHead.sort == "desc") nsort = "asc";
            else nsort = "desc";
            cfg.colHead.rows[colHeadR][colHeadC].sort = nsort;
            //console.log(colHeadR, colHeadC,  cfg.colHead.rows[colHeadR][colHeadC].sort);
            //sort 처리하기
            if (nsort == "desc") {
                axdom("#" + tdID).addClass("sortDesc");
            }
            else {
                axdom("#" + tdID).addClass("sortAsc");
            }

            this.nowSortHeadID = tdID;
            this.nowSortHeadObj = myColHead;

            var ai = this.ajaxInfo;
            if (ai && cfg.remoteSort) {
                if (!ai.ajaxPars) {
                    ai.ajaxPars = this.getSortParam("one");
                }
                else if (Object.isString(ai.ajaxPars)) {
                    ai.ajaxPars = $.extend(ai.ajaxPars.dec().queryToObject(), this.getSortParam("one").queryToObject());
                }
                else if (Object.isObject(ai.ajaxPars)) {
                    ai.ajaxPars = $.extend(ai.ajaxPars, this.getSortParam("one").queryToObject());
                }

                this.reloadList();
            }
            else {
                this.list = this.sortList(nsort, myColHead, this.list);
                this.printList({sort: true});
                this.contentScrollResize();
            }

        }

        if (cfg.colHead.onclick) { /* onclick    bind */
            var sendObj = {
                index: null,
                r: colHeadR,
                c: colHeadC,
                list: this.list,
                colHead: myColHead,
                page: this.page
            };
            cfg.colHead.onclick.call(sendObj);
        }

    },
    /**
     * @method AXGrid.colHeadToolClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head 우측의 도구 박스를 클릭 했을때의 처리를 합니다(ColGroupListBox 팝업).
     * @returns {String}
     */
    colHeadToolClick: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        if (this.editorOpend) {
            toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
            return;
            //에디터가 오픈된 상태이면 비활성화
        }

        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];
        var myColHead = cfg.colHead.rows[colHeadR][colHeadC];

        axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_colHeadMenu\" class=\"AXGridColGroupListBox\">");
        for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
            var addClass = (CG.display) ? " on" : "";
            var lastClass = (cidx == cfg.colGroup.length - 1) ? " last" : "";
            po.push("<a href=\"#AXexec\" class=\"AXGridColGroupListBoxItem" + addClass + lastClass + "\" id=\"" + cfg.targetID + "_AX_colHeadMenu_AX_" + CG.colSeq + "\">");
            po.push(CG.label);
            po.push("</a>");
        }

        po.push("</div>");
        axdom(document.body).append(po.join(''));

        var offset = axdom(eventTarget).offset();
        var css = {};
        css.top = offset.top - 5;
        css.left = offset.left - 20;
        axdom("#" + cfg.targetID + "_AX_colHeadMenu").css(css);

        /* colGroup click event bind */
        var colGroupListClick = this.colGroupListClick.bind(this);
        this.colGroupListClickBind = function (event) {
            colGroupListClick(event);
        };
        axdom(document).bind("click", this.colGroupListClickBind);
        axdom(document).bind("keydown", this.colGroupListClickBind);
        /* colGroup click bind ~~~~~~~~~~~~~~~~~~~ */
    },
    /**
     * @method AXGrid.colGroupListClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  colHeadToolClick 에서 호출된 ColGroupListBox의 아이템을 클릭했을때의 처리를 합니다.
     * @returns {String}
     */
    colGroupListClick: function (event) {
        var cfg = this.config;

        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
            axdom(document).unbind("keydown", this.colGroupListClickBind);
            axdom(document).unbind("click", this.colGroupListClickBind);
            return;
        }

        // event target search
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("AXGridColGroupListBoxItem") || axdom(evt).hasClass("colHeadTool")) ? true : false;
            }
        });

        if (myTarget) {
            if (axdom(myTarget).hasClass("colHeadTool")) return;
            //colHeadTool ready
            var targetID = myTarget.id;
            var colSeq = targetID.split(/_AX_/g).last();
            if (cfg.colGroup[colSeq].display) {
                cfg.colGroup[colSeq].display = false;
                axdom("#" + targetID).removeClass("on");
            }
            else {
                cfg.colGroup[colSeq].display = true;
                axdom("#" + targetID).addClass("on");
            }
            if (cfg.editor) {
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    cfg.editor.rows[r][colSeq].display = !cfg.editor.rows[r][colSeq].display;
                }
            }

            //redraw grid
            this.redrawGrid("all");

        }
        else {

            axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
            axdom(document).unbind("keydown", this.colGroupListClickBind);
            axdom(document).unbind("click", this.colGroupListClickBind);
        }
    },
    /**
     * @method AXGrid.colHeadCheckBoxClick
     * @param {Event} - Grid 내부에서 감지되는 이벤트
     * @description  Grid head checkbox를 클릭했을때의 처리를 합니다.
     */
    colHeadCheckBoxClick: function (event) {
        var cfg = this.config;
        if (event.target.id == "") return;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
            eventTarget = axdom(eventTarget).find("input").get(0);
            eventTarget.checked = !eventTarget.checked;
        }
        var lastIdx = eid.length - 1;
        var colHeadR = eid[lastIdx - 1];
        var colHeadC = eid[lastIdx];
        var myColHead = cfg.colHead.rows[colHeadR][colHeadC];

        this.checkedColSeq(myColHead.colSeq, eventTarget.checked);
    },
    /* colHead events ~~~~~~~~~~~~~~~~~*/
    /* colHead 영역  ~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /* body 영역 */
    needBindDBLClick: function () {
        return ((axf.browser.name == "ie") && (axf.docTD === "Q" || axf.browser.version < 9));
    },
    /**
     * @method AXGrid.sortList
     * @param nsort {String} -  "desc","asc"
     * @param myColHead {Object} - cfg.colHead.rows[colHeadR][colHeadC]  대상이 될 Grid head node
     * @param list {Object} - Grid list Object
     * @description  그리드의 리스트를 정렬 합니다.
     * @returns {Object}  - Grid list
     * @example
     * ```
     * var myGrid = new AXGrid();
     * // Array
     * myGrid.setList({Array});
     * ...
     * myGrid.sortList("desc",myGrid.cfg.colHead.rows[0][0],myGrid.list);
     * ```
     */
    sortList: function (nsort, myColHead, list) {
        var cfg = this.config;
        var _this = this;
        var getValueForSort = function (item, itemIndex) {
            if (myColHead.formatter) {
                var result;
                if (myColHead.formatter == "money") {
                    result = item[myColHead.key];
                }
                else if (myColHead.formatter == "dec") {
                    result = (item[myColHead.key] == undefined) ? "" : item[myColHead.key].dec();
                }
                else if (myColHead.formatter == "html") {
                    result = item[myColHead.key];
                }
                else if (myColHead.formatter == "checkbox" || myColHead.formatter == "radio") {
                    result = item[myColHead.key];
                }
                else {
                    var sendObj = {
                        index: itemIndex,
                        list: list,
                        item: item,
                        page: _this.page,
                        key: myColHead.key,
                        value: item[myColHead.key]
                    };
                    result = myColHead.formatter.call(sendObj, itemIndex, item) || "";
                    //result 값이 money 형식인지 체크 합니다.
                    var moneyCheck = (Object.isString(result)) ? result.replace(/,/g, "") : result;
                    if (axdom.isNumeric(moneyCheck)) result = result.number();
                }
                return result;
            }
            else {
                return item[myColHead.key] || "";
            }
        };

        if (nsort == "desc") {
            var listIndex = 0;
            list = list.sort(function (prevItem, nowItem) {
                var v1 = getValueForSort(prevItem, listIndex);
                var v2 = getValueForSort(nowItem, listIndex);
                listIndex++;
                if (v1 < v2) return 1;
                else if (v1 > v2) return -1;
                else if (v1 == v2) return 0;
            });
        }
        else {
            var listIndex = 0;
            list = list.sort(function (prevItem, nowItem) {
                var v1 = getValueForSort(prevItem, listIndex);
                var v2 = getValueForSort(nowItem, listIndex);
                listIndex++;
                if (v1 < v2) return -1;
                else if (v1 > v2) return 1;
                else if (v1 == v2) return 0;
            });
        }

        return list;
    },
    /**
     * @method AXGrid.setBody
     * @param list {Object} - Grid list Object
     * @param rewrite {Boolean} - true or false
     * @description  그리드의 몸통을 렌더링 합니다.
     */
    setBody: function (list, rewrite) {
        var cfg = this.config;
        if (list) {
            this.list = list;
        }
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_scrollContent\" class=\"gridScrollContent\">");
        if (cfg.viewMode == "grid") {
            po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridBodyTable\"  id=\"" + cfg.targetID + "_AX_gridBodyTable\">");
            po.push(this.getColGroup("CB"));
            /*colGroup 삽입 */
            po.push("<thead id=\"" + cfg.targetID + "_AX_thead\"></thead>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_hpadding\"><tr class='thpadding'><td colspan=\"" + (this.showColLen.number() + 1) + "\"></td></tr></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_tbody\">");
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showColLen) + "\">");
            po.push("<div class=\"tdRelBlock\">");
            po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
            po.push(cfg.emptyListMSG);
            po.push("</div>");
            po.push("</div>");
            po.push("</td>");
            po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            po.push("</tr>");
            po.push("</tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_tfoot\"></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_fpadding\"><tr class='tfpadding'><td colspan=\"" + (this.showColLen.number() + 1) + "\"></td></tr></tbody>");

            po.push("</table>");
        }
        else if (cfg.viewMode == "icon") {
            po.push("<div class=\"gridBodyDiv\" id=\"" + cfg.targetID + "_AX_gridBodyDiv\"></div>");
        }
        else if (cfg.viewMode == "mobile") {
            po.push("<div class=\"gridBodyDiv\" id=\"" + cfg.targetID + "_AX_gridBodyDiv\"></div>");
        }
        po.push("</div>");

        // trace(cfg.viewMode == "grid", this.hasFixed, (rewrite && this.list.length > 0), rewrite);

        //if (cfg.viewMode == "grid" && this.hasFixed && ((rewrite && this.list.length > 0) || !rewrite)) {
        if (cfg.viewMode == "grid" && this.hasFixed && (rewrite || typeof rewrite === "undefined")) {
            po.push("<div id=\"" + cfg.targetID + "_AX_fixedScrollContent\" class=\"gridFixedScrollContent\" style=\"width:" + this.fixedColWidth + "px;\">");
            po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridFixedBodyTable\" style=\"width:" + this.fixedColWidth + "px;\">");
            po.push(this.getColGroup("FB"));
            /*colGroup 삽입 */
            po.push("<thead id=\"" + cfg.targetID + "_AX_fixedThead\"></thead>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_fhpadding\"><tr class='thpadding'><td colspan=\"" + (this.showFixedColLen) + "\"></td></tr></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_fixedTbody\">");
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showFixedColLen) + "\"></td>");
            po.push("</tr>");
            po.push("</tbody>");

            po.push("<tbody id=\"" + cfg.targetID + "_AX_fixedTfoot\"></tbody>");
            po.push("<tbody id=\"" + cfg.targetID + "_AX_ffpadding\"><tr class='tfpadding'><td colspan=\"" + (this.showFixedColLen) + "\"></td></tr></tbody>");
            po.push("</table>");
            po.push("</div>");
        }

        if (cfg.viewMode == "grid" || cfg.viewMode == "icon") {
            po.push("<div class=\"AXGridFoot\" id=\"" + cfg.targetID + "_AX_gridFoot\"></div>");
            //po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackXY\" class=\"gridScrollTrackXY\"></div>");
        }
        this.body.html(po.join(''));

        this.gridFoot = axdom("#" + cfg.targetID + "_AX_gridFoot"); /// gridFoot 위치 변경 및 캐쉬순서 변경
        this.scrollContent = axdom("#" + cfg.targetID + "_AX_scrollContent");

        // tbody, fixedTbody dom cached
        if (cfg.viewMode == "grid") {
            // this.cachedDom.tbody, this.cachedDom.fixed_tbody, this.cachedDom.thpadding, this.cachedDom.tfpadding 윗마진 아래마진
            this.cachedDom.tbody = axdom("#" + cfg.targetID + "_AX_tbody");
            if (this.hasFixed) this.cachedDom.fixed_tbody = axdom("#" + cfg.targetID + "_AX_fixedTbody");
            this.cachedDom.thpadding = axdom("#" + cfg.targetID + "_AX_hpadding").find("td");
            this.cachedDom.tfpadding = axdom("#" + cfg.targetID + "_AX_fpadding").find("td");
            if (this.hasFixed) {
                this.cachedDom.fthpadding = axdom("#" + cfg.targetID + "_AX_fhpadding").find("td");
                this.cachedDom.ftfpadding = axdom("#" + cfg.targetID + "_AX_ffpadding").find("td");
            }
        }

        this.fixedScrollContent = axdom("#" + cfg.targetID + "_AX_fixedScrollContent");
        cfg.scrollContentBottomMargin = 2;

        if (this.list.length > 0) {
            var _this = this;
            if (typeof list === "undefined") {
                _this.setList(_this.list, true, "reload");
            }
            else {
                setTimeout(function () {
                    _this.setList(_this.list);
                }, 100);
            }
        }

        if (cfg.viewMode == "grid" || cfg.viewMode == "icon") {
            /* scroll event bind */
            // bind scroll tip
            this.scrollYHandle.unbind("mouseover").bind("mouseover", this.contentScrollTipOver.bind(this));
            this.scrollYHandle.unbind("mousedown").bind("mousedown", this.contentScrollScrollReady.bind(this));
            this.scrollXHandle.unbind("mousedown").bind("mousedown", this.contentScrollScrollReady.bind(this));
            /* scroll event bind ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
        }
    },
    /**
     * @method AXGrid.listLoadingDisplay
     * @description  그리드의 데이터 처리중 표시를 표현 합니다.
     */
    listLoadingDisplay: function () {
        var cfg = this.config;
        var po = [];

        if (cfg.viewMode != "mobile") {
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showColLen) + "\">");
            po.push("<div class=\"tdRelBlock\">");
            po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
            po.push("	<div class=\"AXLoading\"></div>");
            po.push("</div>");
            po.push("</div>");
            po.push("</td>");
            po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            po.push("</tr>");
            axdom("#" + cfg.targetID + "_AX_tbody").html(po.join(''));
            po = [];
            po.push("<tr class=\"noListTr\">");
            po.push("<td colspan=\"" + (this.showColLen) + "\">");
            po.push("</td>");
            po.push("</tr>");
            axdom("#" + cfg.targetID + "_AX_fixedTbody").html(po.join(''));
        }
        else {
            if (cfg.viewMode == "grid") {
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});
            }
            po.push("	<div class=\"AXLoading\"></div>");
            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").empty();
            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").append(po.join(''));
        }
    },
    /**
     * @method AXGrid.setList
     * @param obj {JSObject}
     * @param sortDisable
     * @param rewrite
     * @param exts
     * @description 그리드에 데이터를 선언하거나 AJAX url 속성을 정의합니다.
     * @example
     * ```
     * // Array
     * myGrid.setList({Array});
     *
     * // AJAX url 속성
     * myGrid.setList({
	 *  //method :
	 *  //contentType :
	 *  //responseType :
	 *  //dataType :
	 *  //headers :
	 *  //debug :
	 *  //ajaxUrl :
	 *  //ajaxPars :
	 *  //onLoad :
	 *  //onError :
	 *  ajaxUrl:"loadGrid.php",
	 *  ajaxPars:"param1=1&param2=2", // {String|Object}
	 *  onLoad:function(){
	 *
	 *  }
     * });
     * ```
     */
    setList: function (obj, sortDisable, rewrite, exts) {
        var cfg = this.config, _this = this;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        this.listLoadingDisplay();

        /*this.selectedCells.clear(); */
        /*this.selectedRow.clear(); */

        if (obj.ajaxUrl) {
            /*console.log("hear");	 */
            this.ajaxInfo = obj;
            this.ajax_sortDisable = sortDisable;
            this.pageActive = true;

            var url = obj.ajaxUrl;
            var appendPars = [
                "pageNo=" + ((exts == "paging") ? this.page.pageNo : 1),
                "pageSize=" + this.page.pageSize
            ];

            // 기본 소팅정보
            if (cfg.remoteSort) {
                var sortParam = this.getSortParam("one");
                if (sortParam) {
                    appendPars.push(sortParam);
                }
            }

            if (Object.isString(obj.ajaxPars)) {
                appendPars.push(obj.ajaxPars);
            }
            else if (Object.isObject(obj.ajaxPars)) {
                appendPars.push(axdom.param(obj.ajaxPars));
            }
            var pars = appendPars.join('&');

            var _method = "post";
            var _contentType = AXConfig.AXReq.contentType;
            var _headers = {};
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;

            if (obj.method) _method = obj.method;
            if (obj.contentType) _contentType = obj.contentType;
            if (obj.headers) _headers = obj.headers;

            var ajaxGetList = this.ajaxGetList.bind(this);
            new AXReq(url, {
                type: _method,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                headers: _headers,
                debug: obj.debug,
                pars: pars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        res._sortDisable = sortDisable;
                        if (obj.response) {
                            obj.response.call(res);
                        }
                        else {
                            ajaxGetList(res);
                        }
                        if (obj.onLoad) obj.onLoad.call(res);
                    }
                    else {
                        if (obj.onError) obj.onError.call(res);
                        else axf.alert(res);
                    }
                },
                onerr: function (res) {
                    if (obj.onError) obj.onError.call(res);
                    //else axf.alert(res.statusText);
                }
            });

        }
        else {
            if (axdom.isArray(obj)) {
                if (sortDisable || !cfg.sort) {
                    this.list = obj;
                }
                else {
                    if (nowSortHeadID) {
                        this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, obj);
                    }
                    else {
                        this.list = obj;
                    }
                }

                this.removedList = [];
                this.printList({reload: rewrite});
                this.contentScrollResize();
                if (rewrite != "reload") this.scrollTop(0);
                this.setStatus(this.list.length);

                if (!cfg.page.paging) {
                    this.pagingUnit.hide();
                    this.pageActive = false;
                }
            }
        }
    },
    /**
     * @method AXGrid.reloadList
     * @description 그리드리스트를 새로 고침 합니다.(ajax를 통할 경우 다시 가져 옵니다).
     * @example
     * ```
     * myGrid.setList({
     * 	ajaxUrl:"loadGrid.php",
     * 	ajaxPars:"param1=1&param2=2"
     *  });
     * myGrid.reloadList();
     * ```
     */
    reloadList: function () {
        var cfg = this.config;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        this.selectedCells.clear();
        this.selectedRow.clear();

        if (this.ajaxInfo) {
            var obj = this.ajaxInfo;
            var sortDisable = this.ajax_sortDisable;
            this.pageActive = true;

            this.listLoadingDisplay();

            var url = obj.ajaxUrl;
            var appendPars = [
                "pageNo=" + this.page.pageNo,
                "pageSize=" + this.page.pageSize
            ];
            if (Object.isString(obj.ajaxPars)) {
                appendPars.push(obj.ajaxPars);
            }
            else if (Object.isObject(obj.ajaxPars)) {
                appendPars.push(axdom.param(obj.ajaxPars));
            }
            var pars = appendPars.join('&');
            var _method = "post";
            var _contentType = AXConfig.AXReq.contentType;
            var _headers = {};
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;

            if (obj.method) _method = obj.method;
            if (obj.contentType) _contentType = obj.contentType;
            if (obj.headers) _headers = obj.headers;

            var scrollTop = function () {
                this.scrollTop(0);
            };
            var scrollTopBind = scrollTop.bind(this);
            var ajaxGetList = this.ajaxGetList.bind(this);

            var userResponseSetPaging = function (res) {
                axf.overwriteObject(this.page, res.page, true);
                this.setPaging();
            };
            var userResponse = userResponseSetPaging.bind(this);

            new AXReq(url, {
                type: _method,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                headers: _headers,
                debug: obj.debug,
                pars: pars,
                onsucc: function (res) {
                    //if (res.result == AXConfig.AXReq.okCode) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        res._sortDisable = sortDisable;
                        if (obj.response) {
                            obj.response.call(res);
                            userResponse(res);
                        }
                        else {
                            ajaxGetList(res);
                        }
                        scrollTopBind();
                    }
                    else {
                        AXUtil.alert(res);
                    }
                }
            });

        }
    },
    /**
     * @method AXGrid.ajaxGetList
     * @param res {Object}
     * @description setList 호출시 ajaxUrl에 의해 가져온 데이터를 그리드의 list로 적용 합니다.
     */
    ajaxGetList: function (res) {
        var cfg = this.config;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        if (res._sortDisable || !cfg.sort || cfg.remoteSort) {
            this.list = res[AXConfig.AXGrid.keyList];
        }
        else {
            if (nowSortHeadID) {
                this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, res[AXConfig.AXGrid.keyList]);
            }
            else {
                this.list = res[AXConfig.AXGrid.keyList];
            }
        }
        axf.overwriteObject(this.page, res.page, true);

        this.removedList = [];
        this.printList();
        this.contentScrollResize();
        this.scrollTop(0);
        this.setPaging();
    },

    /**
     * @method AXGrid.setData
     * @param gridData {JSObject} object of grid
     * @description <ko>그리드 데이터를 페이지까지 포함하여 정의해 줍니다. (ajax를 사용하지 않는 방법)</ko>
     * @example
     * ```
     * var gridData = {
     * 	list: _obj.document_list,
     * 	page:{
     * 		pageNo: _obj.page_navigation.cur_page,
     * 		pageSize: 20,
     * 		pageCount: _obj.page_navigation.page_count,
     * 		listCount: _obj.page_navigation.total_count,
     * 		onchange: function(pageNo){
     * 			dialog.push(Object.toJSON(this));
     * 			console.log(this, pageNo);
     * 		}
     * 	}
     * };
     * myGrid.setData(gridData);
     * ```
     */
    setData: function (res) {
        var cfg = this.config;
        var nowSortHeadID = this.nowSortHeadID;
        var nowSortHeadObj = this.nowSortHeadObj;

        if (res._sortDisable || !cfg.sort) {
            this.list = res.list;
        }
        else {
            if (nowSortHeadID) {
                this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, res.list);
            }
            else {
                this.list = res.list;
            }
        }
        if (!this.page.onchange) this.page.onchange = this.page.onChange;
        axf.overwriteObject(this.page, res.page, true);

        this.removedList = [];
        this.selectClear();
        this.printList();
        this.contentScrollResize();
        this.scrollTop(0);
        this.setStatus(this.list.length);

        if (cfg.page.paging) {
            this.setPaging();
        }
    },
    /**
     * @method AXGrid.getFormatterValue
     * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
     * @param {Object} item  - 대상 인덱스의 리스트 1개 열
     * @param {Number} itemIndex  - 대상 인덱스
     * @param {String} value - 표현 대상 값.
     * @param {Object} key - config 의 colGroup 내부 key 값
     * @param {Object} CH - 대상 그리드의 [열][행]
     * @param {Number} CHidx - 대상 그리드의 [열][행] 중 행의 index
     * @returns {String}
     * @description 지정된 표현 형식으로 데이터를 HTML String 으로 변환 시킵니다.
     */
    getFormatterValue: function (formatter, item, itemIndex, value, key, CH, CHidx) {
        var cfg = this.config;
        var result;

        if (CH.editor && (CH.editor.type == "checkbox" || CH.editor.type == "radio")) {
            //
            // editCell 처리
            var checkedStr = "", disabled = "",
                that = {
                    index: itemIndex,
                    list: this.list,
                    item: item,
                    page: this.page,
                    key: key,
                    value: value
                };

            if (value == true || value == 1 || value == "1" || value == "Y") checkedStr = ' checked="checked"';
            if (CH.editor.disabled) {
                if (CH.editor.disabled.call(that)) {
                    disabled = ' disabled="disabled"';
                }
            }

            result = '<input type="' + CH.editor.type + '" name="' + key + '" data-editor-key="' + itemIndex + ',' + CHidx + '" style="margin:0px;" class="inline-editor-checkbox" ' +
                checkedStr + disabled + ' onfocus="this.blur();" />';
            //"<input type=\"checkbox\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
        }
        else if (Object.isFunction(formatter)) {
            var sendObj = {
                index: itemIndex,
                list: this.list,
                item: item,
                page: this.page,
                key: key,
                value: value
            };
            result = formatter.call(sendObj, itemIndex, item);
        }
        else if (CH.editor && (CH.editor.type in this.formatter)) {
            // 동일한 이름을 가진 formatter와 editor가 있으면 해당 editor의 값을 보여줄 때 동일한 이름을 가진 formatter를 사용한다.
            result = this.formatter[CH.editor.type].call(this, CH.editor.type, item, itemIndex, value, key, CH, CHidx);
        }
        else if (Object.isString(formatter) && (formatter in this.formatter)) {
            result = this.formatter[formatter].call(this, formatter, item, itemIndex, value, key, CH, CHidx);
        }
        else {
            result = ((String(value) == "null") ? "" : value);
        }
        return result;
    },
    /**
     * @method AXGrid.getTooltipValue
     * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
     * @param {Object} item - 대상 인덱스의 리스트 1개 열
     * @param {Number} itemIndex - 대상 인덱스
     * @param {String} value - 표현 대상 값.
     * @param {Object} key - config 의 colGroup 내부 key 값
     * @param {Object} CH - 대상 그리드의 [열][행]
     * @returns {String}
     * @description 지정된 표현 형식으로 데이터를 HTML String으로 변환 시킵니다.
     */
    getTooltipValue: function (formatter, item, itemIndex, value, key, CH) {
        var cfg = this.config;
        var result;
        if (formatter == "money") {
            if (value == "" || value == "null") {
                result = "0";
            }
            else {
                result = value.number().money();
            }
        }
        else if (formatter == "dec") {
            result = (value == undefined) ? "" : value.dec();
        }
        else if (formatter == "html") {
            result = value;
        }
        else if (formatter == "checkbox" || formatter == "radio") {
            var checked = "";
            if (CH.checked) {
                var sendObj = {
                    index: itemIndex,
                    list: this.list,
                    item: item,
                    page: this.page,
                    key: key,
                    value: value
                };
                var callResult = CH.checked.call(sendObj);
                if (callResult) {
                    checked = " checked=\"checked\" ";
                }
            }
            result = "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checked + " />";
        }
        else {
            if (Object.isFunction(formatter)) {
                var sendObj = {
                    index: itemIndex,
                    list: this.list,
                    item: item,
                    page: this.page,
                    key: key,
                    value: value
                };
                result = formatter.call(sendObj, itemIndex, item);
            }
            else {
                result = value;
            }
        }
        return result;
    },

    /**
     * @method AXGrid.getAddingClass
     * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
     * @param {Object} item - 대상 인덱스의 리스트 1개 열
     * @param {Number} itemIndex - 대상 인덱스
     * @param {String} value - 표현 대상 값.
     * @param {Object} key - config 의 colGroup 내부 key 값
     * @param {Object} CH - 대상 그리드의 [열][행]
     * @returns {String}
     * @description 해당 컬럼에 추가클래스를 정의 합니다. 문자열 방식과 함수방식을 지원합니다.
     */
    getAddingClass: function (formatter, item, itemIndex, value, key, CH) {
        var cfg = this.config;
        var result = "";

        if (Object.isString(formatter)) {
            result = formatter;

        }
        else if (Object.isFunction(formatter)) {
            var sendObj = {
                index: itemIndex,
                list: this.list,
                item: item,
                page: this.page,
                key: key,
                value: value
            };
            result = formatter.call(sendObj, itemIndex, item);
        }
        else {

        }

        return result;
    },
    /**
     * @method AXGrid.getItem
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param isfix {String} - 고정 높이 사용시 "fix"
     * @param hasTr {String} - tr 표시 여부
     * @returns {String}
     * @description 대상의 데이터를 그리드에 출력되는 html 형태로 변환  합니다.
     */
    getItem: function (itemIndex, item, isfix, hasTr) {
        if (!item) return "";
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "line" + (itemIndex % 2);
        /*
         if(cfg.mergeCells){
         evenClassName = "line1"; // 줄무늬 기능 사용 안함.
         }
         */
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);
        var getAddingClass = this.getAddingClass.bind(this);

        var hasFixed = this.hasFixed;
        var hasTrValue = (hasTr === undefined);
        var trAddClass = "";
        var lastTdRowspan = "";
        if (cfg.body.addClass) {
            try {
                trAddClass = cfg.body.addClass.call({
                        index: itemIndex,
                        item: item,
                        list: this.list,
                        page: this.page
                    }) || "";
            } catch (e) {
                console.log(e);
            }
        }

        var r = 0, l = cfg.body.rows.length;

        for (; r < l; r++) {
            var isLastTR = (l - 1 == r);
            var trHeight = 0;
            trHeight = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex + " td").innerHeight();
            if (hasTrValue) {
                if (isfix == "fix") {
                    tpo.push("<tr class=\"gridBodyTr gridBodyTr_" + itemIndex + " " + evenClassName + " " + trAddClass + "\" " +
                        "id=\"" + cfg.targetID + "_AX_tr_" + r + "_AX_fix_AX_" + itemIndex + "\">");
                }
                else {
                    tpo.push("<tr class=\"gridBodyTr gridBodyTr_" + itemIndex + " " + evenClassName + " " + trAddClass + "\" " +
                        "id=\"" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex + "\">");
                }

            }
            var colCount = 0, CH, CHidx = 0, CG, CHLen = cfg.body.rows[r].length;

            for (; CHidx < cfg.body.rows[r].length; CHidx++) {
                CH = cfg.body.rows[r][CHidx];
                CG = cfg.colGroup[CHidx];


                if (CH.display && CH.colspan > 0) {


                    var printOk = false, makeBodyNode = true;
                    if (isfix == "n") {
                        printOk = true;
                        if (typeof CH.colSeq == "undefined") {

                        }
                        else {
                            if (typeof cfg.fixedColSeq != "undefined" && cfg.fixedColSeq > 0 && CH.colSeq < (cfg.fixedColSeq + 1)) {
                                makeBodyNode = false;
                            }
                        }
                    }
                    if (isfix == "fix" && CH.isFixedCell && CH.display) {
                        printOk = true;
                    }

                    if (printOk) {

                        colCount += CH.colspan;
                        //radio, check exception
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        lastTdRowspan = rowspan;
                        var valign = " valign=\"" + CH.valign + "\" ";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";
                        var styles = " style=\"vertical-align:" + CH.valign + ";\"";

                        var tdHeight = (function () {
                            if (cfg.body.heights && cfg.body.heights[r]) {
                                var tdHeight = 0;
                                for (var i = r; i < CH.rowspan; i++) {
                                    tdHeight += (cfg.body.heights[i] || 0);
                                }
                                return tdHeight;
                            }
                            else {
                                return 0;
                            }
                        })();

                        if (tdHeight) {
                            styles = " style=\"vertical-align:" + CH.valign + ";height:" + (tdHeight) + "px;\"";
                        }
                        else if (trHeight && CH.rowspan < 2 && CH.colspan < 2) styles = " style=\"vertical-align:" + CH.valign + ";height:" + trHeight + "px;\"";
                        else if (CH.rowspan > 1) {
                            styles = " style=\"vertical-align:" + CH.valign + ";height:" + (trHeight) + "px;\"";
                        }
                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        var tooltipValue = "";
                        if (CH.tooltip) tooltipValue = getTooltipValue(CH.tooltip, item, itemIndex, item[CH.key], CH.key, CH);

                        var addClasses = "";
                        if (CH.addClass) addClasses = " " + getAddingClass(CH.addClass, item, itemIndex, item[CH.key], CH.key, CH);
                        var tdEndStyles = "";
                        if (CH.isTdEnd && cfg.hiddenBorder_tdLastChild) {
                            tdEndStyles = "background-image:none;"
                        }
                        tpo.push("<td" + valign + rowspan + colspan + styles + " " +
                            " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "body_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" " +
                            " class=\"bodyTd bodyTd_" + CHidx + " bodyTdr_" + r + " " + bottomClass + fixedClass + "\" style=\"" + tdEndStyles + "\">");

                        if (makeBodyNode) {
                            tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + addClasses + "\" " +
                                " align=\"" + CH.align + "\" " +
                                " id=\"" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" " +
                                " title=\"" + tooltipValue + "\">");

                            if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                                if (CH.formatter) {
                                    tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH, CHidx));
                                }
                                else if (CH.editor && (CH.editor.type == "checkbox" || CH.editor.type == "radio" || CH.editor.type in this.formatter)) {
                                    // 동일한 이름을 가진 formatter와 editor가 있으면 해당 editor의 값을 보여줄 때 동일한 이름을 가진 formatter를 사용한다.
                                    tpo.push(getFormatterValue("", item, itemIndex, item[CG.key], CH.key, CH, CHidx));
                                }
                                else {
                                    tpo.push((String(item[CH.key]) == "null") ? "" : item[CH.key]);
                                }
                            }
                            else {
                                tpo.push("&nbsp;");
                            }
                            tpo.push("</div>");
                        }

                        tpo.push("</td>");
                    }
                }
            }

            if (r == 0 && isfix == "n") {
                tpo.push("<td " + styles + " class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_null_AX_" + itemIndex + "\" rowspan=\"" + cfg.body.rows.length + "\">" +
                    "<div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlock_AX_" + itemIndex + "\">&nbsp;</div>" +
                    "</td>");
            }
            if (hasTrValue) tpo.push("</tr>");


        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getIconItem
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param viewIconObj {Object} - Config 에서 설정된 view 속성.
     * @param {Object} cssObj
     * @returns {String}
     * @description config 의 viewMode가 icon 일때의 리스트를 구성 합니다.
     * @example
     * ```js
     * cssObj = {
     *     box: "width: ,height:",   - 기타 사용자 지정 스타일 추가 가능
     *     img:  "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     *     label: "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     *     description: "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     *     buttons: "left:, top: , width:, height:", - 기타 사용자 지정 스타일 추가 가능
     * };
     * ```
     */
    getIconItem: function (itemIndex, item, viewIconObj, cssObj) {
        var cfg = this.config;
        var tpo = [];
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);

        var format;
        try {
            format = viewIconObj.format.call({index: itemIndex, item: item});
        } catch (e) {
            console.log(e);
        }
        tpo.push("<div class=\"viewIcon bodyViewIcon bodyViewIcon_" + itemIndex + " " + (viewIconObj.addClass || "") + "\" style=\"" + cssObj.box + ";\" id=\"" + cfg.targetID + "_AX_viewIcon_AX_" + itemIndex + "\">");

        if (format.imgsrc) {
            tpo.push("<img src=\"");
            tpo.push(format.imgsrc);
            tpo.push("\" align=\"middle\" alt=\"" + format.label + "\" style=\"" + cssObj.img + ";\" class=\"gridViewIconThumbnail\" />");
        }

        if (format.label) {
            tpo.push("<div style=\"" + cssObj.label + ";\" class=\"gridViewIconLabel\">");
            tpo.push(format.label);
            tpo.push("</div>");
        }

        if (format.description) {
            tpo.push("<div style=\"" + cssObj.description + ";\" class=\"gridViewIconDescription\">");
            tpo.push(format.description);
            tpo.push("</div>");
        }
        if (viewIconObj.buttons) {
            if (viewIconObj.buttons.items) {
                tpo.push("<div style=\"" + cssObj.buttons + ";\" class=\"gridViewIconbuttons\">");
                for (var B, bidx = 0; (bidx < viewIconObj.buttons.items.length && (B = viewIconObj.buttons.items[bidx])); bidx++) {
                    tpo.push("<button type=\"button\" class=\"viewIconButtonsItem " + B.addClass + "\" id=\"" + cfg.targetID + "_AX_viewIcon_AX_" + itemIndex + "_AX_" + bidx + "\">");
                    tpo.push(B.label);
                    tpo.push("</button> ");
                }
                ;
                tpo.push("</div>");
            }
        }

        tpo.push("</div>");

        return tpo.join('');
    },
    /**
     * @method AXGrid.getMobileItem
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param mobileView {Object} - Config 에서 설정된 view 속성.
     * @returns {String}
     * @description config 의 viewMode가 mobile 일때의 리스트를 구성 합니다.
     */
    getMobileItem: function (itemIndex, item, mobileView) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "line" + (itemIndex % 2);
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);
        var trAddClass = "";
        if (cfg.body.addClass) {
            try {
                trAddClass = cfg.body.addClass.call({
                        index: itemIndex,
                        item: item,
                        list: this.list,
                        page: this.page
                    }) || "";
            } catch (e) {
                console.log(e);
            }
        }

        tpo.push("<section class=\"bodyViewMobile bodyViewMobile_" + itemIndex + " " + " " + evenClassName + " " + (mobileView.addClass || "") + "\" id=\"" + cfg.targetID + "_AX_viewMobile_AX_" + itemIndex + "\">");

        var __memoCol = null, displayColumnCount = 0;
        for (var CN, cidx = 0, __arr = mobileView.column; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
            if (CN.display == true || CN.display == undefined) displayColumnCount++;
        }
        for (var CN, cidx = 0, __arr = mobileView.column; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
            if (CN.display == true || CN.display == undefined) {
                var colClass = "", colAddClass = (CN.addClass || "");
                if (displayColumnCount === 1) colAddClass = ""; // show column 1
                if (CN.col) colClass = "col" + CN.col;
                else  colClass = "colNone";

                if (__memoCol != null && !CN.col) tpo.push("<div style='clear:both;'></div>");

                tpo.push("<div class='column " + colClass + " " + trAddClass + " " + colAddClass + "'>");
                if (mobileView.label != false) {
                    tpo.push("<span class='label'>" + CN.label + "</span>");
                    tpo.push("<span class='content'>");
                }
                else {
                    tpo.push("<span class='content solid'>");
                }
                if (CN.formatter) {
                    //formatter, item, itemIndex, value, key, CH, CHidx
                    for (var colSeq = 0; colSeq < cfg.colGroup.length; colSeq++) {
                        if (cfg.colGroup[colSeq].key == CN.key) {
                            CN.colSeq = colSeq;
                            break;
                        }
                    }
                    tpo.push(getFormatterValue(CN.formatter, item, itemIndex, item[CN.key], CN.key, CN));
                }
                else {
                    tpo.push(item[CN.key]);
                }
                tpo.push("</span>");
                tpo.push("</div>");
                __memoCol = CN.col;
            }
        }

        tpo.push("<div class='columnClear'></div>");
        tpo.push("<div class='buttonGroup'>");
        if (mobileView.buttons) {
            for (var B, bidx = 0, __arr = mobileView.buttons; (bidx < __arr.length && (B = __arr[bidx])); bidx++) {
                tpo.push("<a class='buttonGroupItem " + B.addClass + "' id='" + cfg.targetID + "_AX_mobileViewButton_AX_" + itemIndex + "_AX_" + bidx + "'>");
                tpo.push("</a>");
            }
        }
        tpo.push("</div>");
        tpo.push("</section>");

        return tpo.join('');
    },
    /**
     * @method AXGrid.getItemMarker
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @param isfix {String} - 고정 높이 사용시 "fix"
     * @returns {String}
     * @description body(list) 구성시 marker row 가 존재할경우 처리 합니다.
     */
    getItemMarker: function (itemIndex, item, isfix, markerIndexs) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "gridBodyMarker";
        var getFormatterValue = this.getFormatterValue.bind(this);
        var hasFixed = this.hasFixed;
        var trAddClass = "";

        for (var mi = 0, l = markerIndexs.length, markerIndex; mi < l; mi++) {
            var marker = cfg.body.marker[markerIndexs[mi]];
            if (marker.addClass) {
                try {
                    trAddClass = marker.addClass.call({
                            index: itemIndex,
                            item: item,
                            list: this.list,
                            page: this.page
                        }) || "";
                } catch (e) {
                    console.log(e);
                }
            }
            for (var r = 0; r < marker.rows.length; r++) {
                var isLastTR = (marker.rows.length - 1 == r);
                tpo.push("<tr class=\"gridBodyTr gridBodyMarkerTr_" + itemIndex + " " + evenClassName + " " + trAddClass + "\" id=\"" + cfg.targetID + "_AX_marker_" + r + "_AX_" + (isfix || "n") + "_AX_" + itemIndex + "\">");
                var colCount = 0;
                for (var CH, CHidx = 0, __arr = marker.rows[r]; (CHidx < __arr.length && (CH = __arr[CHidx])); CHidx++) {
                    if (CH.display && CH.colspan > 0) {

                        if (isfix == "n" || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

                            colCount += CH.colspan;

                            /*radio, check exception */
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                            var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                            var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                            /*console.log({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount}); */

                            var bodyNodeClass = "";
                            if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                            else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                            tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "bodyMarker_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                            /*tpo.push("<div class=\"tdRelBlock\">");*/
                            tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_bodyMarkerText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\">");
                            if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                                if (CH.formatter) {
                                    tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
                                }
                                else {
                                    tpo.push(item[CH.key]);
                                }
                            }
                            else {
                                tpo.push("&nbsp;");
                            }
                            tpo.push("</div>");
                            /*tpo.push("</div>");*/
                            tpo.push("</td>");
                        }
                    }
                }
                ;
                if (r == 0 && isfix == "n") {
                    tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_nullMarker_AX_" + itemIndex + "\" rowspan=\"" + marker.rows.length + "\"><div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlockMarker_AX_" + itemIndex + "\">&nbsp;</div></td>");
                }
                tpo.push("</tr>");
            }

        }

        return tpo.join('');
    },
    /**
     * @method AXGrid.getMarkerDisplay
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 1개 열
     * @returns {Boolean}
     * @description config 내의 marker row 를 출력할지 여부를 판단하는 사용자 함수를 호출 합니다.
     */
    getMarkerDisplay: function (itemIndex, item) {
        var cfg = this.config;
        var bodyHasMarker = this.bodyHasMarker;

        if (!bodyHasMarker) return [];
        var sendObj = {
            index: itemIndex,
            list: this.list,
            item: item,
            page: this.page
        };

        var markerDisplay = [];
        try {
            for (var m = 0, l = cfg.body.marker.length, marker; m < l; m++) {
                marker = cfg.body.marker[m];
                if (marker.display.call(sendObj, itemIndex, item)) {
                    markerDisplay.push(m);
                }
            }
        } catch (e) {
            console.log(e);
        }
        return markerDisplay;
    },
    /**
     * @method AXGrid.printList
     * @param args {Object} - 출력 옵션  {sort:true}
     * @returns {String}
     * @description grid list 의 전체 출력을 처리 합니다.
     */
    printList: function (args) {
        if (!args) args = {};
        var cfg = this.config, _this = this;
        var bodyHasMarker = this.bodyHasMarker;
        var getItem = this.getItem.bind(this);
        var getItemMarker = this.getItemMarker.bind(this);
        var getMarkerDisplay = this.getMarkerDisplay.bind(this);
        var markerIndex;
        if (this.editorOpend) this.cancelEditor();
        var getIconItem = this.getIconItem.bind(this);
        // --------------------------- icon view
        var getMobileItem = this.getMobileItem.bind(this);
        // --------------------------- mobile view

        var po = [];
        // view mode 가 grid 인경우만 유효
        if (cfg.viewMode == "grid") {
            if (cfg.__height == "auto") {
                for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                    po.push(getItem(itemIndex, item, "n"));
                    if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                        po.push(getItemMarker(itemIndex, item, "n", markerIndex));
                    }
                }
            }
            else {
                if (this.list.length > 0) {
                    var firstItem = this.list[0];
                    po.push(getItem(0, firstItem, "n"));
                    /* firstItem 예외처리
                     if (bodyHasMarker && getMarkerDisplay(0, firstItem)) {
                     po.push(getItemMarker(0, firstItem, "n"));
                     }
                     */
                }
            }

            if (this.list.length == 0) { // empty list
                po.push("<tr class=\"noListTr\">");
                po.push("<td colspan=\"" + (this.showColLen) + "\">");
                po.push("<div class=\"tdRelBlock\">");
                po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
                po.push(cfg.emptyListMSG);
                po.push("</div>");
                po.push("</div>");
                po.push("</td>");
                po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
                po.push("</tr>");
            }

            this.cachedDom.tbody.empty();
            this.cachedDom.tbody.append(po.join(''));

            if (this.hasFixed) {
                po = [];
                if (cfg.__height == "auto") {
                    for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                        po.push(getItem(itemIndex, item, "fix"));
                        if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                            po.push(getItemMarker(itemIndex, item, "fix", markerIndex));
                        }
                    }
                }
                else {
                    if (this.list.length > 0) {
                        po.push(getItem(0, firstItem, "fix"));
                        /* firstItem 예외처리
                         if (bodyHasMarker && getMarkerDisplay(0, firstItem)) {
                         po.push(getItemMarker(itemIndex, firstItem, "fix"));
                         }
                         */
                    }
                }

                this.cachedDom.fixed_tbody.empty();
                this.cachedDom.fixed_tbody.append(po.join(''));
                if (this.list.length == 0) {
                    this.fixedScrollContent.hide();
                }
                else {
                    this.fixedScrollContent.show();
                }
            }

            /// console.log(cfg.height, this.list.length);

            if (cfg.__height != "auto" && this.list.length > 0) {

                //아이템 한줄의 높이는?
                var
                    $itemTr = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0"),
                    itemTrHeight,
                    printListCount
                    ;

                if (!$itemTr.get(0)) return; // viewMode grid가 아닌 상황

                itemTrHeight = $itemTr.outerHeight().number();

                this.scrollContent.css({"padding-bottom": itemTrHeight});
                // 추가로 출력할 목록 선정
                po = [];
                printListCount = (this.body.height() / itemTrHeight).ceil();

                if (this.list.length > (printListCount + cfg.listCountMargin)) printListCount += cfg.listCountMargin;
                else printListCount = this.list.length;
                for (var item, itemIndex = 0, __arr = this.list; (itemIndex < printListCount && (item = __arr[itemIndex])); itemIndex++) {
                    po.push(getItem(itemIndex, item, "n"));
                    if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                        po.push(getItemMarker(itemIndex, item, "n", markerIndex));
                    }
                }
                this.cachedDom.tbody.empty();
                this.cachedDom.tbody.append(po.join(''));

                if (this.hasFixed) {
                    po = [];
                    for (var item, itemIndex = 0, __arr = this.list; (itemIndex < printListCount && (item = __arr[itemIndex])); itemIndex++) {
                        po.push(getItem(itemIndex, item, "fix"));
                        if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                            po.push(getItemMarker(itemIndex, item, "fix", markerIndex));
                        }
                    }
                    this.cachedDom.fixed_tbody.empty();
                    this.cachedDom.fixed_tbody.append(po.join(''));
                }

                // init virtualScroll & control height thpadding
                this.virtualScroll = {
                    startIndex: 0,
                    endIndex: printListCount - 1,
                    itemTrHeight: itemTrHeight,
                    printListCount: printListCount,
                    scrollTop: 0
                };

                // 출력된 테이블에 mergeCells 호출
                if (cfg.mergeCells) {
                    this.mergeCells(this.cachedDom.tbody, "n");
                    if (this.hasFixed) {
                        this.mergeCells(this.cachedDom.fixed_tbody, "f");
                    }
                }

                this.cachedDom.thpadding.css({height: 0});
                this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - printListCount) * (itemTrHeight)});
                if (this.hasFixed) {
                    this.cachedDom.fthpadding.css({height: 0});
                    this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - printListCount) * (itemTrHeight)});
                }

                // 스크롤 y 포지션 초기화
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});

            }
            else if (cfg.__height == "auto" && this.list.length > 0) {

                this.virtualScroll = {
                    startIndex: 0,
                    endIndex: this.list.length,
                    itemTrHeight: this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0").outerHeight().number(),
                    printListCount: this.list.length,
                    scrollTop: 0
                };

                if (!cfg.foot) {
                    this.cachedDom.thpadding.css({height: 0});
                    this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    if (this.hasFixed) {
                        this.cachedDom.fthpadding.css({height: 0});
                        this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    }
                }
                else {
                    this.cachedDom.thpadding.css({height: 0});
                    this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    if (this.hasFixed) {
                        this.cachedDom.fthpadding.css({height: 0});
                        this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                    }
                }

                if (cfg.mergeCells) {
                    this.mergeCells(this.cachedDom.tbody, "n");
                    if (this.hasFixed) {
                        this.mergeCells(this.cachedDom.fixed_tbody, "f");
                    }
                }

                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});
                this.gridTargetSetSize();
            }
            else {

                this.virtualScroll = {
                    startIndex: 0,
                    endIndex: 0,
                    itemTrHeight: 0,
                    printListCount: 0,
                    scrollTop: 0
                };
                this.cachedDom.thpadding.css({height: 0});
                this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                if (this.hasFixed) {
                    this.cachedDom.fthpadding.css({height: 0});
                    this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number()});
                }
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});

            }

            this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOver.bind(this));
            this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOut.bind(this));
            this.body.find(".gridBodyTr:not(.gridBodyMarker)").bind("click", this.gridBodyClick.bind(this));
            if (this.needBindDBLClick()) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClick.bind(this));

            if (this.selectedRow && this.selectedRow.length > 0) {

                for (var itemIndex = 0, __arr = this.selectedRow; itemIndex < __arr.length; itemIndex++) {
                    this.body.find(".gridBodyTr_" + __arr[itemIndex]).addClass("selected");
                }
                var itemIndex = this.selectedRow.last();
                var itemDom = this.body.find(".gridBodyTr_" + itemIndex);
                if (itemDom[0]) {
                    var trTop = itemDom.position().top;
                    var scrollHeight = this.scrollContent.height();
                    var bodyHeight = this.body.height();

                    var
                        $itemTr = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0"),
                        trHeight;

                    if (!$itemTr.get(0)) return; // viewMode grid가 아닌 상황
                    trHeight = $itemTr.outerHeight().number();
                    if (trTop.number() + trHeight.number() > bodyHeight) {
                        var scrollTop = bodyHeight - (trTop.number() + itemTrHeight.number());
                        this.scrollContent.css({top: (scrollTop - cfg.listCountMargin)});
                        this.contentScrollContentSync({top: (scrollTop - cfg.listCountMargin)}, null, args.reload);
                    }
                    else {
                        if (trTop.number() == 0) {
                            var scrollTop = 0;
                            this.scrollContent.css({top: scrollTop});
                            this.contentScrollContentSync({top: scrollTop}, null, args.reload);
                        }
                    }
                    this.bigDataSync("reload");
                }
            }

            // printList then body.onchangeScroll
            if (cfg.body.onchangeScroll) {
                var sendObj = axf.copyObject(this.virtualScroll);
                cfg.body.onchangeScroll.call(sendObj, sendObj);
            }

        }
        else if (cfg.viewMode == "icon") {

            var viewIconObj = cfg.view;
            var viewIconCss = [];
            viewIconCss.push("width:" + viewIconObj.width.number() + "px");
            viewIconCss.push("height:" + viewIconObj.height.number() + "px");
            if (viewIconObj.style) viewIconCss.push(viewIconObj.style);

            var viewIconImgCss = [];
            viewIconImgCss.push("left:" + viewIconObj.img.left.number() + "px");
            viewIconImgCss.push("top:" + viewIconObj.img.top.number() + "px");
            viewIconImgCss.push("width:" + viewIconObj.img.width.number() + "px");
            viewIconImgCss.push("height:" + viewIconObj.img.height.number() + "px");
            if (viewIconObj.img.style) viewIconImgCss.push(viewIconObj.img.style);

            var viewIconLabelCss = [];
            viewIconLabelCss.push("left:" + viewIconObj.label.left.number() + "px");
            viewIconLabelCss.push("top:" + viewIconObj.label.top.number() + "px");
            viewIconLabelCss.push("width:" + viewIconObj.label.width.number() + "px");
            viewIconLabelCss.push("height:" + viewIconObj.label.height.number() + "px");
            if (viewIconObj.label.style) viewIconLabelCss.push(viewIconObj.label.style);

            var viewIconDescriptionCss = [];
            viewIconDescriptionCss.push("left:" + viewIconObj.description.left.number() + "px");
            viewIconDescriptionCss.push("top:" + viewIconObj.description.top.number() + "px");
            viewIconDescriptionCss.push("width:" + viewIconObj.description.width.number() + "px");
            viewIconDescriptionCss.push("height:" + viewIconObj.description.height.number() + "px");
            if (viewIconObj.description.style) viewIconDescriptionCss.push(viewIconObj.description.style);

            var viewIconButtonsCss = [];
            if (viewIconObj.buttons) {
                viewIconButtonsCss.push("left:" + viewIconObj.buttons.left.number() + "px");
                viewIconButtonsCss.push("top:" + viewIconObj.buttons.top.number() + "px");
                viewIconButtonsCss.push("width:" + viewIconObj.buttons.width.number() + "px");
                viewIconButtonsCss.push("height:" + viewIconObj.buttons.height.number() + "px");
                if (viewIconObj.buttons.style) viewIconButtonsCss.push(viewIconObj.buttons.style);
            }

            var cssObj = {
                box: viewIconCss.join(";"),
                img: viewIconImgCss.join(";"),
                label: viewIconLabelCss.join(";"),
                description: viewIconDescriptionCss.join(";"),
                buttons: viewIconButtonsCss.join(";")
            };

            for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                po.push(getIconItem(itemIndex, item, viewIconObj, cssObj));
            }

            po.push("<div style='clear:both;'></div>");

            var gridBodyDiv = axdom("#" + cfg.targetID + "_AX_gridBodyDiv");
            gridBodyDiv.empty();
            gridBodyDiv.append(po.join(''));

            this.body.find(".bodyViewIcon").bind("click", this.gridBodyClick.bind(this));
            if (this.needBindDBLClick()) this.body.find(".bodyViewIcon").bind("dblclick", this.gridBodyDBLClick.bind(this));

            if (this.selectedRow && this.selectedRow.length > 0) {
                var body = this.body;
                for (var item, itemIndex = 0, __arr = this.selectedRow; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                    body.find(".bodyViewIcon_" + item).addClass("selected");
                }
            }

            var _list = this.list;
            var iconButtonClick = function (event) {
                var ids = event.target.id.split(/_AX_/g);
                var itemIndex = ids[ids.length - 2];
                var buttonIndex = ids[ids.length - 1];

                if (viewIconObj.buttons.items[buttonIndex].onclick) {
                    viewIconObj.buttons.items[buttonIndex].onclick.call({
                        index: itemIndex,
                        list: _list,
                        item: _list[itemIndex],
                        buttonItem: viewIconObj.buttons.items[buttonIndex]
                    });
                }
            };
            var iconButtonClickBind = iconButtonClick.bind(this);

            this.body.find(".bodyViewIcon .viewIconButtonsItem").bind("click", function (event) {
                iconButtonClickBind(event);
            });

        }
        else if (cfg.viewMode == "mobile") {

            var mobileView = cfg.view;
            if (mobileView == undefined) {
                var columns = [];
                for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                    var col = null, addClass = "";
                    if (CG.widthAstric || CG.width.number() >= 200) {
                        col = 4;
                        addClass = "underLine";
                    }
                    else if (CG.width.number() >= 100) {
                        col = 2;
                    }
                    else if (CG.width.number() >= 40) {
                        //col = 1;
                    }
                    columns.push(
                        {
                            key: CG.key,
                            label: CG.label,
                            col: col,
                            formatter: CG.formatter,
                            addClass: addClass,
                            sort: (CG.sort || ""),
                            display: (CG.display || true)
                        }
                    );
                }
                columns = columns.sort(function (pItem, nItem) {
                    var v1 = pItem.col;
                    var v2 = nItem.col;
                    if (v1 < v2) return 1;
                    else if (v1 > v2) return -1;
                    else if (v1 == v2) return 0;
                });
                mobileView = {
                    labelView: true,
                    column: columns
                };
            }

            for (var item, itemIndex = 0, __arr = this.list; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                po.push(getMobileItem(itemIndex, item, mobileView));
            }

            if (this.list.length == 0) { /* empty tags */
                po.push("<div class=\"bodyViewMobile\" align=\"center\">");
                po.push(cfg.emptyListMSG);
                po.push("</div>");
            }

            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").empty();
            axdom("#" + cfg.targetID + "_AX_gridBodyDiv").append(po.join(''));

            this.body.find(".bodyViewMobile").bind("click", this.gridBodyClick.bind(this));
            if (this.needBindDBLClick()) this.body.find(".bodyViewMobile").bind("dblclick", this.gridBodyDBLClick.bind(this));

            if (this.selectedRow && this.selectedRow.length > 0) {
                var body = this.body;
                for (var item, itemIndex = 0, __arr = this.selectedRow; (itemIndex < __arr.length && (item = __arr[itemIndex])); itemIndex++) {
                    body.find(".bodyViewMobile_" + item).addClass("selected");
                }
            }

            var _list = this.list;
            var mobileButtonClick = function (event) {
                var ids = event.target.id.split(/_AX_/g);
                var itemIndex = ids[ids.length - 2];
                var buttonIndex = ids[ids.length - 1];

                if (mobileView.buttons[buttonIndex].onclick) {
                    mobileView.buttons[buttonIndex].onclick.call({
                        index: itemIndex,
                        list: _list,
                        item: _list[itemIndex],
                        buttonItem: mobileView.buttons[buttonIndex]
                    });
                }
            };
            var mobileButtonClickBind = mobileButtonClick.bind(this);

            this.body.find(".bodyViewMobile").find(".buttonGroupItem").bind("click", function (event) {
                mobileButtonClick(event);
            });
        }

        this.selectedCells.clear();
        // selectedCells clear

        if (typeof args == "undefined") {
            this.contentScrollResize();
        }
        else if (typeof args != "undefined" && args.sort) {
            this.contentScrollResize(false);
        }

        this.contentScrollXAttr = null;
        this.contentScrollYAttr = null;
    },
    /**
     * @method AXGrid.updateList
     * @param itemIndex {Number} - 대상 인덱스
     * @param item {Object} - 대상 인덱스의 리스트 아이템.
     * @returns {AXGrid}
     * @description body(list) 구성시 marker row 가 존재할경우 처리 합니다.
     * @example
     * ```
     *  var item = {
     * 	a: "a",
     * 	b: "b",
     * 	c: "c",
     * 	d: "d",
     * 	e: 14350
     *  };
     *      myGrid.updateList(0,item);
     * ```
     */
    updateList: function (itemIndex, item) {
        var cfg = this.config;
        this.cancelEditor();

        if (item._CUD == "C") {

        }
        else if (item._CUD == "D") {
            toast.push("삭제된 아이템 입니다. 수정할 수 없습니다.");
            return;
            /*삭제된 개체 수정 금지 */
        }
        else {
            item._CUD = "U";
        }

        this.list[itemIndex] = item;

        var npo = this.getItem(itemIndex, item, "n", "notr");
        if (this.hasFixed) {
            var fpo = this.getItem(itemIndex, item, "fix", "notr");
        }

        axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).html(npo);
        if (this.hasFixed) {
            axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).html(fpo);
        }

        var trAddClass = "";
        if (cfg.body.addClass) {
            try {
                trAddClass = cfg.body.addClass.call({
                        index: itemIndex,
                        item: item,
                        list: this.list
                    }) || "";
            } catch (e) {
                console.log(e);
            }
        }

        axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
        if (this.hasFixed) {
            axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
        }
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.pushList
     * @param {Object|Array} pushItem
     * @param {Number} [insertIndex] - 삽입위치 인덱스 <en>Index of Insert Position</en>
     * @returns {AXGrid}
     * @description 그리드에 데이터를 삽입합니다. <en>push to Grid.list</en>
     * @example
     * ```
     *  myGrid.pushList([item Array]);
     *  myGrid.pushList([item Array], 1);
     *  myGrid.pushList([item]);
     * ```
     */
    pushList: function (pushItem, insertIndex) {
        var cfg = this.config;

        if (this.inline_edit) {
            setTimeout((function () {
                this.pushList(pushItem, insertIndex);
            }).bind(this), 300);
            return this;
        }
        this.cancelEditor();
        var pushData = [];
        // 오브젝트 또는 Array를 처리 할 수 있도록 변경
        if (Object.isArray(pushItem)) {
            pushData = pushItem;
        }
        else {
            pushData = [pushItem];
        }

        pushItem._CUD = "C";
        if (insertIndex != null && typeof insertIndex != "undefined") {
            if (insertIndex > this.list.length) {
                insertIndex = this.list.length;
            }
            var itemIndex = insertIndex;
            var newList = [];
            for (var L, listIndex = 0, __arr = this.list; (listIndex < __arr.length && (L = __arr[listIndex])); listIndex++) {
                if (listIndex == itemIndex) {
                    for (var li = 0; li < pushData.length; li++) {
                        newList.push(pushData[li]);
                    }
                }
                newList.push(L);
            }

            if (listIndex == itemIndex) {
                for (var li = 0; li < pushData.length; li++) {
                    newList.push(pushData[li]);
                }
            }

            this.list = newList;

            /*
             var item = this.list[itemIndex];
             var npo = this.getItem(itemIndex, item, "n");
             if (this.hasFixed) {
             var fpo = this.getItem(itemIndex, item, "fix");
             }
             */

            this.printList();
            //this.bigDataSyncApply();
            this.contentScrollResize(false);
            this.setFocus(itemIndex);

        }
        else {
            for (var li = 0; li < pushData.length; li++) {
                this.list.push(pushData[li]);
            }
            this.printList();
            //this.bigDataSyncApply();
            this.contentScrollResize(false);
            //this.setFocus(this.list.length-1); insertIndex 가 없으면 focus 실행 안함.
        }

        this.setStatus(this.list.length);
        this.redrawDataSet();

        return this;
    },
    /**
     * @method AXGrid.fetchList
     * @param list {Array} - 추가될 list item Array
     * @returns {AXGrid}
     * @description grid의 리스트에 아이템을 추가 합니다.(배열)
     * @example
     * ```
     *  var list = [
     *      {no:1, title:"AXGrid 첫번째 줄 입니다.", writer:"장기영", regDate:"2013-01-18", desc:"myGrid.setList 의 첫번째 사용법 list json 직접 지정 법", price:123000, amount:10},
     *      {no:2, title:"AXGrid 두번째 줄 입니다.", writer:"장기영", regDate:"2013-01-18", desc:"myGrid.setList 의 첫번째 사용법 list json 직접 지정 법", price:12300, amount:7},
     *      {no:3, title:"AXGrid 세번째 줄 입니다.", writer:"장기영", regDate:"2013-01-18", desc:"myGrid.setList 의 첫번째 사용법 list json 직접 지정 법", price:12000, amount:5}
     *  ];
     *  myGrid.fetchList(list);
     * ```
     */
    fetchList: function (list) {
        var cfg = this.config, VS = this.virtualScroll;
        this.list = this.list.concat(list);

        this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - VS.startIndex - 1) * (VS.itemTrHeight)});
        if (this.hasFixed) {
            this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number() + (this.list.length - VS.endIndex - 1) * (VS.itemTrHeight)});
        }

        if (!cfg.page.paging) {
            this.setStatus(this.list.length);
        }
        this.contentScrollResize(false);
    },
    /**
     * @method AXGrid.removeList
     * @param removeList {Array} - 키값 배열
     * @returns {AXGrid}
     * @description removeList의 전달된 키값 과 일치하는 대상을 삭제 합니다.이때 고유한 값이 아닌 항목을 전달 할 때에는 에러가 발생 할 수 있습니다.
     * @example
     * ```
     * var checkedList = myGrid.getCheckedList(0);// colSeq
     * var removeList = [];
     * $.each(checkedList, function(){
     * 	removeList.push({no:this.no});
     * });
     * myGrid.removeList(removeList);
     * ```
     */
    removeList: function (removeList) {

        console.log(removeList);

        var cfg = this.config;
        if (cfg.passiveMode) {

            var _list = this.list;
            var collect = [];
            axf.each(removeList, function (ridx, r) {
                axf.each(_list, function (lidx, l) {
                    var isDel = false;
                    axf.each(r, function (k, v) {
                        if (l[k] == v) {
                            isDel = true;
                        }
                        else {
                            isDel = false;
                            return false;
                        }
                    });
                    if (isDel) {
                        if (cfg.passiveRemoveHide) {
                            l._isDel = true;
                        }
                        else {
                            if (l._CUD != "C") {
                                l._CUD = "D";
                            }
                            else {
                                l._isDel = true;
                            }
                        }
                        collect.push(l);
                    }
                    else {
                        collect.push(l);
                    }
                });
            });
            this.list = collect;
        }
        else {
            var collect = [];
            axf.each(this.list, function (lidx, l) {
                var isPush = true;
                axf.each(removeList, function (ridx, r) {
                    axf.each(r, function (k, v) {
                        if (l[k] == v) {
                            isPush = false;
                            return false;
                        }
                    });
                    if (!isPush) return false;
                });
                if (isPush) collect.push(l);
            });

            this.list = collect;
        }

        if (cfg.viewMode == "grid" && cfg.height != "auto") {
            this.bigDataSync(true);
        }
        else {
            this.printList();
            this.contentScrollResize();
        }
        this.setStatus(this.list.length);
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.removeListIndex
     * @param removeList {Array} - index 배열 (key value "index" 가 있어야 함)
     * @returns {AXGrid}
     * @description removeList의 index에 해당하는 항목을 제거 합니다..
     * @example
     * ```
     *  var removeList = [{index:0},{index:1},{index:2}];
     *  myGrid.removeListIndex(removeList);
     * ```
     */
    removeListIndex: function (removeList) {
        var cfg = this.config;

        var _list = this.list;

        if (cfg.passiveMode) {

            axf.each(removeList, function (ridx, r) {
                if (_list[r.index]) {
                    if (cfg.passiveRemoveHide) {
                        _list[r.index]._isDel = true;
                    }
                    else {
                        if (_list[r.index]._CUD != "C") {
                            _list[r.index]._CUD = "D";
                        }
                        else {
                            _list[r.index]._isDel = true;
                        }
                    }
                }
            });

            var collect = [];
            var removeCollect = this.removedList;
            axf.each(_list, function () {
                if (!this._isDel) collect.push(this);
                else {
                    if (this._CUD != "C") {
                        removeCollect.push(this);
                    }
                }
            });
            this.list = collect;
            this.removedList = removeCollect;

        }
        else {

            var collect = [];
            axf.each(removeList, function (ridx, r) {
                if (_list[r.index]) {
                    _list[r.index]._isDel = true;
                }
            });

            var collect = [];
            var removeCollect = this.removedList;
            axf.each(_list, function () {
                if (!this._isDel) collect.push(this);
                else removeCollect.push(this);
            });
            this.list = collect;
            this.removedList = removeCollect;
        }

        this.selectedCells.clear();
        this.selectedRow.clear();

        if (cfg.viewMode == "grid" && cfg.height != "auto") {
            this.bigDataSync(true);
        }
        else {
            this.printList();
            this.contentScrollResize();
        }

        this.setStatus(this.list.length);
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.restoreList
     * @param removeList {Array} - 키값 배열
     * @returns {AXGrid}
     * @description restoreList 전달된 키값 과 일치하는 대상의 삭제 표시를 제거 합니다.이때 고유한 값이 아닌 항목을 전달 할 때에는 에러가 발생 할 수 있습니다.(passive)
     * @example
     * ```
     *  var myGrid = new AXGrid();
     *  myGrid.setConfig({passiveMode:true});
     *  var checkedList = myGrid.getCheckedList(0);// colSeq
     *  var removeList = [];
     *  $.each(checkedList, function(){
     * 	removeList.push({no:this.no});
     *  });
     *  myGrid.restoreList(removeList);
     * ```
     */
    restoreList: function (restoreList) {
        var cfg = this.config;
        var collect = [];

        for (var lidx = 0; lidx < this.list.length; lidx++) {
            var isDel = false, l = this.list[lidx];
            for (var ridx = 0; ridx < restoreList.length; ridx++) {
                var r = restoreList[ridx];
                axf.each(r, function (k, v) {
                    if (l[k] == v) {
                        isDel = true;
                    }
                    else {
                        isDel = false;
                        return false;
                    }
                });
                if (isDel) break;
            }
            if (isDel) {
                if (l._CUD == "D") {
                    l._CUD = "";
                }
                collect.push(l);
            }
            else {
                collect.push(l);
            }
        }

        this.list = collect;
        if (cfg.viewMode == "grid" && cfg.height != "auto") {
            this.bigDataSync(true);
        }
        else {
            this.printList();
            this.contentScrollResize();
        }
        this.setStatus(this.list.length);
        this.redrawDataSet();
    },
    /**
     * @method AXGrid.gridBodyOver
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 mouseover 이벤트 처리를 합니다.
     */
    gridBodyOver: function (event) {
        var cfg = this.config;

        if (this.overedItemIndex) {
            this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
        }
        var itemIndex = (event.target.id).split(/_AX_/g).last();
        if (itemIndex != "") {
            this.body.find(".gridBodyTr_" + itemIndex).addClass("hover");
            this.overedItemIndex = itemIndex;
        }

        this.onevent_grid({type: "grid-list-over"});
    },
    /**
     * @method AXGrid.gridBodyOut
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 mouseout 이벤트 처리를 합니다.
     */
    gridBodyOut: function (event) {
        var cfg = this.config;

        if (this.overedItemIndex) {
            this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
        }

    },
    /**
     * @method AXGrid.gridBodyClick
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 click 이벤트 처리를 합니다.
     */
    gridBodyClick: function (event) {
        var cfg = this.config;

        if (event.target.tagName.toLowerCase() == "input" && (
                event.target.type == "radio" || event.target.type == "checkbox"
            )) {
            this.gridBodyClickAct(event);
        }
        else if (cfg.body.ondblclick && !event.shiftKey && !(event.metaKey || event.ctrlKey)) {
            if (this.needBindDBLClick()) {
                clearTimeout(this.bodyClickObserver);
                this.gridBodyClickAct(event);
            }
            else {
                if (this.bodyClickObserver) {
                    clearTimeout(this.bodyClickObserver);
                    this.gridBodyDBLClick(event);
                    this.bodyClickObserver = null;
                    return;
                }
                var gridBodyClickAct = this.gridBodyClickAct.bind(this);
                this.bodyClickObserver = setTimeout(function () {
                    gridBodyClickAct(event);
                }, 400);
            }
        }
        else {
            this.gridBodyClickAct(event);
        }
    },
    /**
     * @method AXGrid.gridBodyClickAct
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)내부 요소에 대한 클릭 후 처리를 합니다(checkbox,radio).
     */
    gridBodyClickAct: function (event) {
        this.bodyClickObserver = null;
        var cfg = this.config;
        var eventTarget = event.target;

        if (event.target.id != "") {
            //var eid = event.target.id.split(/_AX_/g);
            var isoncheck = false, checkedValue;
            if (eventTarget.tagName.toLowerCase() == "input") {
                if (!eventTarget.disabled) {
                    if (eventTarget.type.toLowerCase() == "checkbox" || eventTarget.type.toLowerCase() == "radio") {

                        isoncheck = true;
                        checkedValue = eventTarget.checked;

                        var ieid = event.target.id.split(/_AX_/g);
                        var checkboxColSeq = ieid[ieid.length - 2];
                        var checkboxIndex = ieid[ieid.length - 1];
                        if (cfg.colGroup[checkboxColSeq] && cfg.colGroup[checkboxColSeq].oncheck) {
                            var sendObj = {
                                index: checkboxIndex,
                                list: this.list,
                                item: this.list[checkboxIndex]
                            };
                            try {
                                cfg.colGroup[checkboxColSeq].oncheck.call(sendObj, event.target.checked);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                    }
                }
            }
        }

        if (isoncheck) { /*체크박스 구현 */
            var targetID = event.target.id;
            var itemIndex = targetID.split(/_AX_/g).last();
            var ids = targetID.split(/_AX_/g);
            if (ids.length < 4) return; //  약속된 아이디 형식이 아님.
            var item = this.list[itemIndex], r = ids[ids.length - 3], c = ids[ids.length - 2];

            if (cfg.colGroup[c].formatter === "radio") {
                var ii = 0, ll = this.list.length;
                for (; ii < ll; ii++) {
                    if (typeof this.list[ii].___checked === "undefined") this.list[ii].___checked = {};
                    this.list[ii].___checked[c] = false;
                }
            }

            if (typeof this.list[itemIndex].___checked === "undefined") this.list[itemIndex].___checked = {};
            this.list[itemIndex].___checked[c] = checkedValue;
            //console.log(this.list[itemIndex].___checked[c]);

            var target = event.target;
            var checked = event.target.checked;
            var sendObj = {
                index: itemIndex,
                target: event.target,
                checked: event.target.checked,
                r: r,
                c: c,
                list: this.list,
                item: item,
                page: this.page
            };
            try {
                if (cfg.body.oncheck) cfg.body.oncheck.call(sendObj, itemIndex, item);
            } catch (e) {
                console.log(e);
            }
        }
        else {
            var myTarget = axf.get_event_target(eventTarget, function (el) {
                var edom = axdom(el);
                return (!edom.hasClass("buttonGroupItem") && (edom.hasClass("bodyTd") || edom.hasClass("bodyViewIcon") || edom.hasClass("bodyViewMobile")));
            });

            /* event target search ------------------------ */

            if (cfg.viewMode == "grid") {
                if (myTarget) {

                    var body = this.body,
                        targetID = myTarget.id,
                        itemIndex = targetID.split(/_AX_/g).last(),
                        ids = targetID.split(/_AX_/g),
                        len = this.selectedRow.length, _selectedRow = [], hasItem = false,
                        r = ids[ids.length - 3], c = ids[ids.length - 2],
                        CG = cfg.colGroup[(cfg.body.rowsEmpty) ? c : (cfg.body.rows[r][c].colSeq || c)],
                        i = 0;

                    this._focusedItemIndex = itemIndex;
                    if (this.editCellClear(r, c, itemIndex) === false) {

                        if (CG.editor) return this; // 현재 에디팅 중인 셀이 클릭 되었을 때는 아무런 클릭 이벤트를 발생 시키지 않습니다.
                    }

                    if (event.shiftKey) {
                        if (this.selectedCells.length > 0) { // 셀선택 클리어
                            axf.each(this.selectedCells, function () {
                                body.find(".bodyTd_" + this).removeClass("selected");
                            });
                            this.selectedCells.clear();
                        }

                        if (len > 0) {
                            var l_itemIndex = this.selectedRow.last().number(), itemIndex = itemIndex.number(), st_index, ed_index;
                            if (l_itemIndex < itemIndex) {
                                st_index = l_itemIndex + 1;
                                ed_index = itemIndex;
                            }
                            else {
                                st_index = itemIndex;
                                ed_index = l_itemIndex;
                            }

                            for (var k = st_index; k < (ed_index + 1); k++) {
                                hasItem = false;
                                i = 0;
                                for (; i < len; i++) {
                                    if (k == this.selectedRow[i].number()) {
                                        hasItem = true;
                                        break;
                                    }
                                }
                                if (!hasItem) {
                                    this.body.find(".gridBodyTr_" + k).addClass("selected");
                                    this.selectedRow.push(k);
                                }
                            }
                        }
                        else {
                            this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                            this.selectedRow.push(itemIndex.number());
                        }
                        this.clearRange();
                    }
                    else if (event.metaKey || event.ctrlKey) {
                        if (this.selectedCells.length > 0) { // 셀선택 클리어
                            axf.each(this.selectedCells, function () {
                                body.find(".bodyTd_" + this).removeClass("selected");
                            });
                            this.selectedCells.clear();
                        }

                        for (; i < len; i++) {
                            if (this.selectedRow[i] == itemIndex.number()) {
                                body.find(".gridBodyTr_" + itemIndex).removeClass("selected");
                                hasItem = true;
                            }
                            else {
                                _selectedRow.push(this.selectedRow[i]);
                            }
                        }
                        this.selectedRow = _selectedRow;

                        if (!hasItem) {
                            body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                            this.selectedRow.push(itemIndex.number());
                        }

                        // 셀 선택 기능 : 비활성처리
                        /*
                         if(false) {
                         var hasID = false;
                         var collect = [];
                         axf.each(this.selectedCells, function () {
                         if (this == targetID) {
                         hasID = true;
                         } else {
                         collect.push(this);
                         }
                         });
                         if (hasID) {
                         axdom("#" + targetID).removeClass("selected");
                         this.selectedCells = collect;
                         } else {
                         axdom("#" + targetID).addClass("selected");
                         this.selectedCells.push(targetID);
                         }
                         }
                         */

                        this.clearRange();
                    }
                    else {
                        if (this.selectedCells.length > 0) { // 셀선택 클리어
                            axf.each(this.selectedCells, function () {
                                body.find(".bodyTd_" + this).removeClass("selected");
                            });
                            this.selectedCells.clear();
                        }

                        if (CG.editor && (CG.editor.type == "checkbox" || CG.editor.type == "radio" || CG.editor.type == "select" || CG.editor.type == "AXSelect")) {
                            this.editCell(r, c, itemIndex, 0, event);
                        }
                        else if (this.selectedRow.length > 0) {
                            // colGroup 에 editor이 있는지 파악

                            if (CG.editor && cfg.control_lock_status < 1) {
                                for (; i < len; i++) {
                                    if (this.selectedRow[i] == itemIndex) {
                                        hasItem = true;
                                        break;
                                    }
                                }
                                if (hasItem) { // inline 에디트가 발생할 수 있는 상황
                                    this.editCell(r, c, itemIndex);
                                }
                            }

                            if (!hasItem) {
                                for (i = 0; i < len; i++) {
                                    body.find(".gridBodyTr_" + this.selectedRow[i]).removeClass("selected");
                                }
                            }
                        }
                        this.selectedRow.clear();
                        this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                        this.selectedRow.push(itemIndex.number());

                        if (cfg.mergeCells) { /// mergeCells 이 있는 경우 함께 선택 표시해야할 대상이 있는지 판단 후 처리

                            (function () {
                                var colGroupLen = 0, nowTrTd = this.body.find(".gridBodyTable .gridBodyTr_" + itemIndex).find("td");
                                for (var i = 0, l = cfg.colGroup.length; i < l; i++) {
                                    if (cfg.colGroup[i].display) colGroupLen++;
                                }
                                if (colGroupLen == nowTrTd.length - 1) {
                                    // td중에 rowspan이 있는 컬럼이 있는지 체크
                                    for (var i = 0, l = nowTrTd.length; i < l; i++) {
                                        if (nowTrTd[i].getAttribute("rowspan") > 1) {
                                            for (var ai = 0; ai < nowTrTd[i].getAttribute("rowspan") - 1; ai++) {
                                                this.body.find(".gridBodyTr_" + (Number(itemIndex) + ai + 1)).addClass("selected");
                                                this.selectedRow.push((Number(itemIndex) + ai + 1));
                                            }
                                            break;
                                        }
                                    }
                                }
                                else {
                                    this.selectedRow.clear();
                                    // 이가 빠졌음 머지된 컬럼을 검색 (위로 탐색 나올때까지)
                                    var finding = true, parentItemIndex = itemIndex, safeLoop = 0;
                                    do {
                                        parentItemIndex = parentItemIndex - 1;
                                        var _nowTrTd = this.body.find(".gridBodyTable .gridBodyTr_" + (parentItemIndex)).find("td");
                                        //console.log(colGroupLen, (_nowTrTd.length - 1), parentItemIndex);
                                        if (colGroupLen == _nowTrTd.length - 1) {
                                            for (var i = 0, l = _nowTrTd.length; i < l; i++) {

                                                if (_nowTrTd[i].getAttribute("rowspan") > 1) {
                                                    //console.log(_nowTrTd[i].getAttribute("rowspan"));
                                                    for (var ai = 0; ai < _nowTrTd[i].getAttribute("rowspan"); ai++) {
                                                        this.body.find(".gridBodyTr_" + (Number(parentItemIndex) + ai)).addClass("selected");
                                                        this.selectedRow.push((Number(parentItemIndex) + ai));
                                                    }
                                                    break;
                                                }
                                            }
                                            finding = false;
                                        }
                                        safeLoop++;
                                        if (safeLoop > 1000) finding = false;
                                    } while (finding)

                                }
                            }).call(this);
                        }

                        this.body.find(".gridBodyTr_" + itemIndex).find(".bodyTd_" + c + ".bodyTdr_" + r).addClass("selected");
                        this.selectedCells.push(c);

                        var item = this.list[itemIndex];

                        if (!hasItem && cfg.body.onclick) {

                            var sendObj = {
                                index: itemIndex,
                                r: r,
                                c: c,
                                list: this.list,
                                item: item,
                                page: this.page
                            };
                            try {
                                cfg.body.onclick.call(sendObj, itemIndex, item);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                        /*if(this.hasEditor) this.setEditor(item, itemIndex); */
                    }
                }
            }
            else if (cfg.viewMode == "icon") {
                if (myTarget) {
                    var targetID = myTarget.id;
                    var itemIndex = targetID.split(/_AX_/g).last();
                    this._focusedItemIndex = itemIndex;

                    if (event.shiftKey) {

                    }
                    else if (!(event.metaKey || event.ctrlKey)) {

                        if (this.selectedRow.length > 0) {
                            var body = this.body;
                            axf.each(this.selectedRow, function () {
                                body.find(".bodyViewIcon_" + this).removeClass("selected");
                            });
                        }

                        this.selectedRow.clear();
                        this.body.find(".bodyViewIcon_" + itemIndex).addClass("selected");
                        this.selectedRow.push(itemIndex);

                        var item = this.list[itemIndex];

                        if (cfg.body.onclick) {
                            var sendObj = {
                                index: itemIndex,
                                list: this.list,
                                item: item,
                                page: this.page
                            };
                            try {
                                cfg.body.onclick.call(sendObj, itemIndex, item);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                    }
                }
            }
            else if (cfg.viewMode == "mobile") {
                if (myTarget) {
                    var targetID = myTarget.id;
                    var itemIndex = targetID.split(/_AX_/g).last();
                    this._focusedItemIndex = itemIndex;

                    if (event.shiftKey) {

                    }
                    else if (event.metaKey || event.ctrlKey) {

                    }
                    else {

                        if (this.selectedRow.length > 0) {
                            var body = this.body;
                            axf.each(this.selectedRow, function () {
                                body.find(".bodyViewMobile_" + this).removeClass("selected");
                            });
                        }

                        this.selectedRow.clear();
                        this.body.find(".bodyViewMobile_" + itemIndex).addClass("selected");
                        this.selectedRow.push(itemIndex);

                        var item = this.list[itemIndex];

                        if (cfg.body.onclick) {
                            var sendObj = {
                                index: itemIndex,
                                list: this.list,
                                item: item,
                                page: this.page
                            };
                            try {
                                cfg.body.onclick.call(sendObj, itemIndex, item);
                            } catch (e) {
                                console.log(e);
                            }
                        }
                    }
                }
            }

            this.onevent_grid({type: "grid-list-click"});
        }

    },
    /**
     * @method AXGrid.gridBodyDBLClick
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  Grid 리스트(body)에 대한 doubleclick 이벤트 처리를 합니다.
     */
    gridBodyDBLClick: function (event) {
        var cfg = this.config;
        var eventTarget = event.target;
        if (eventTarget.tagName.toLowerCase() == "input" || eventTarget.tagName.toLowerCase() == "button") return;
        /*input, button 인 경우 제외 */

        var myTarget = axf.get_event_target(eventTarget, function (el) {
            var edom = axdom(el);
            return (!edom.hasClass("buttonGroupItem") && (edom.hasClass("bodyTd") || edom.hasClass("bodyViewIcon") || edom.hasClass("bodyViewMobile")));
        });

        /* event target search ------------------------ */
        if (cfg.viewMode == "grid") {
            if (myTarget) {
                /*colHeadTool ready */
                /*console.log({tagName:myTarget.tagName, id:myTarget.id}); */
                var targetID = myTarget.id;
                var itemIndex = targetID.split(/_AX_/g).last();
                var ids = targetID.split(/_AX_/g);

                if (this.selectedRow.length > 0) {
                    var body = this.body;
                    axf.each(this.selectedRow, function () {
                        body.find(".gridBodyTr_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.body.ondblclick) {
                    var r = ids[ids.length - 3];
                    var c = ids[ids.length - 2];
                    var item = this.list[itemIndex];
                    var sendObj = {
                        index: itemIndex,
                        r: r,
                        c: c,
                        list: this.list,
                        item: item,
                        page: this.page
                    };
                    try {
                        cfg.body.ondblclick.call(sendObj, itemIndex, item);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        }
        else if (cfg.viewMode == "icon") {
            if (myTarget) {
                /*colHeadTool ready */
                /*console.log({tagName:myTarget.tagName, id:myTarget.id}); */
                var targetID = myTarget.id;
                var itemIndex = targetID.split(/_AX_/g).last();

                if (this.selectedRow.length > 0) {
                    var body = this.body;
                    axf.each(this.selectedRow, function () {
                        body.find(".bodyViewIcon_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".bodyViewIcon_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.body.ondblclick) {
                    var item = this.list[itemIndex];
                    var sendObj = {
                        index: itemIndex,
                        list: this.list,
                        item: item,
                        page: this.page
                    };
                    try {
                        cfg.body.ondblclick.call(sendObj, itemIndex, item);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        }
        else if (cfg.viewMode == "mobile") {
            if (myTarget) {
                /*colHeadTool ready */
                /*console.log({tagName:myTarget.tagName, id:myTarget.id}); */
                var targetID = myTarget.id;
                var itemIndex = targetID.split(/_AX_/g).last();

                if (this.selectedRow.length > 0) {
                    var body = this.body;
                    axf.each(this.selectedRow, function () {
                        body.find(".bodyViewMobile_" + this).removeClass("selected");
                    });
                }
                this.selectedRow.clear();
                this.body.find(".bodyViewMobile_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.body.ondblclick) {
                    var item = this.list[itemIndex];
                    var sendObj = {
                        index: itemIndex,
                        list: this.list,
                        item: item,
                        page: this.page
                    };
                    try {
                        cfg.body.ondblclick.call(sendObj, itemIndex, item);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        }

        this.stopEvent(event);
        this.clearRange();
    },
    /**
     * 그리드 셀 인라인 에디트
     * @method AXGrid.editCell
     * @param {Number} r - index of body.rows
     * @param {Number} c - index of colGroup
     * @param {Number} itemIndex - index of this.list
     * @returns {AXGrid}
     */
    editCell: function (r, c, ii, times, event) {

        this.setFocus(ii);
        var get_editor;
        // todo : 바디아이템으로 부터 colGroup 정확히 구하기
        var _this = this, cfg = this.config, CG = cfg.colGroup[(cfg.body.rowsEmpty) ? c : (cfg.body.rows[r][c].colSeq || c)],
            po = [], that = {item: this.list[ii], index: ii, CG: CG, r: r, c: c};

        //td : div 의 부모TD 태그, parent_type : nbody|fixedbody 로 결정되어 위치를 판단하는데 쓰임.
        //po : 태그 생성 배열, inline_editor_id : 인라인 에디터의 아이디
        // todo : 틀고정 영역이 있을 때 인라인 에디팅 테스트

        // disabled 체크
        if (CG.editor.disabled) {
            if (CG.editor.disabled.call(that)) {
                return this;
            }
        }

        // 2015-06-04 신규 , 수정시 필드  시작
        if (CG.editor.createEdit === false && that.item['_CUD'] == 'C') {
            return this;
        }

        if (CG.editor.updateEdit === false && that.item['_CUD'] != 'C') {
            return this;
        }
        // 2015-06-04 신규 , 수정시 필드  끝

        // 2015-06-09 edit 활성화시 스크롤 이동하게 처리.
        var trackX = _this.scrollTrackX;

        if (trackX.is(':visible')) {
            var _r = r, _c = c;
            var colHeadRows = cfg.colHead.rows;
            if (colHeadRows.length > 1) {
                if (!this.config.colHead._headerRow) {
                    this.config.colHead._headerRow = {};

                    for (var i = 0; i < colHeadRows.length; i++) {
                        for (var j = 0; j < colHeadRows[i].length; j++) {
                            this.config.colHead._headerRow[colHeadRows[i][j].key] = {r: i, c: j};
                        }
                    }
                }
                _r = this.config.colHead._headerRow[that.CG.key].r;
                _c = this.config.colHead._headerRow[that.CG.key].c;
            }

            var selColHeader = jQuery("#" + cfg.targetID + "_AX_colHead_AX_" + _r + "_AX_" + _c)
                , scrollXW = _this.scrollXHandle.width()
                , trackXW = trackX.width()
                , editHeaderLW = (selColHeader.position().left + selColHeader.width())
                , absEditHeaderLW = editHeaderLW - Math.abs(_this.colHead.position().left);

            var _leftval = 0, scrollSyncFlag = false;
            if (absEditHeaderLW > 0 && absEditHeaderLW < trackXW * 2) {
                if (absEditHeaderLW > trackXW) {
                    scrollSyncFlag = true;
                    _leftval = _this.scrollXHandle.position().left + ((absEditHeaderLW - trackXW) / (_this.colHead.width() / trackXW));
                    _leftval = _leftval + 10;
                }
                else {
                    if (selColHeader.width() > absEditHeaderLW) {
                        scrollSyncFlag = true;
                        _leftval = _this.scrollXHandle.position().left - ((selColHeader.width() - absEditHeaderLW) / (_this.colHead.width() / trackXW));
                        _leftval = _leftval - 10;
                    }
                }
            }
            else {
                scrollSyncFlag = true;
                _leftval = editHeaderLW / (_this.colHead.width() / trackXW) - (scrollXW / 2);
            }

            if (scrollSyncFlag) {
                _leftval = _leftval < 0 ? 0 : ( _leftval > trackXW - scrollXW ? trackXW - scrollXW : _leftval );

                _this.contentScrollScrollSync({left: _leftval});
                _this.scrollXHandle.css('left', (_leftval) + 'px');
            }
        }
        // 2015-06-09 edit 활성화시 스크롤 이동하게 처리.

        this.editCellClear();

        if (CG.editor.type == "checkbox" || CG.editor.type == "radio") {
            if (CG.editor.type == "radio") {
                var _i = 0, _l = this.list.length;
                for (; _i < _l; _i++) this.list[_i][CG.key] = false;
            }
            var checkbox_els = _this.body.find('[data-editor-key="' + ii + ',' + c + '"]').get(0);
            if (event && event.target.tagName != "INPUT" && CG.editor.type == "checkbox") {
                _this.updateItem(r, c, ii, !checkbox_els.checked);
            }
            else if (event && event.target.tagName != "INPUT" && CG.editor.type == "radio") {
                _this.updateItem(r, c, ii, true);
            }
            else {
                _this.updateItem(r, c, ii, checkbox_els.checked);
            }
            return this;
        }

        // 타입이 finder 이면 토스~
        if (CG.editor.type == "finder") {
            CG.editor.finder.onclick.call({
                id: cfg.targetID + '_inline_editor',
                value: jQuery('#' + cfg.targetID + '_inline_editor').val(),
                r: r, c: c, index: ii, item: _this.list[ii]
            });
            return this;
        }

        setTimeout(function () {
            var div = _this.body.find("#" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + c + "_AX_" + ii),
                td, td_ids, td_val, parent_type, inline_editor_id, inline_editor, inline_css, AXBindConfig = {};

            if (!div.get(0)) {
                if ((times | 0) < 3) _this.editCell(r, c, ii, (times | 0) + 1); // 3번시도후 포기 합니다.
                else console.log("에디팅 타겟을 찾을 수 없습니다. AXGrid.editCell");
                // call again
                return false;
            }

            td = div.parent(), td_ids = td.get(0).id.split(/_AX_/g),
                td_val = _this.list[ii][CG.key],
                parent_type = td_ids[td_ids.length - 4],
                inline_editor_id = cfg.targetID + "_AX_inline_editor_AX_" + r + "_AX_" + c + "_AX_" + ii;

            td_val = _this.getFormatterValue(CG.editor.formatter, _this.list[ii], ii, td_val, CG.key, {}, 0);

            po.push('<div class="inline-editor" id="' + inline_editor_id + '">');
            po.push(get_editor(CG.editor, td_val));
            po.push('</div>');
            div.after(po.join(''));

            inline_editor = jQuery("#" + inline_editor_id);

            inline_css = div.position();
            inline_css.width = div.width();
            inline_editor.css(inline_css).find("input").select();
            _this.inline_edit = {editor: inline_editor, r: r, c: c, ii: ii, cell: div};

            if (inline_editor.find("input").get(0) && CG.editor.type != "calendar" && CG.editor.type != "AXSelector") {
                jQuery(document.body).unbind("click.axgrid").bind("click.axgrid", function (e) {
                    var target = axf.get_event_target(e.target, {id: inline_editor_id});
                    if (!target) {
                        _this.updateItem(r, c, ii, inline_editor.find("input").val());
                        jQuery(document.body).unbind("click.axgrid");
                        _this.gridFocus.focus();
                    }
                });
            }

            // AXBind 연결
            jQuery.extend(AXBindConfig, CG.editor.config);

            if (CG.editor.type in _this.inlineEditor) {
                _this.inlineEditor[CG.editor.type].init.call(_this, inline_editor, AXBindConfig, CG, r, c, ii);
            }

            inline_editor.bind("keydown", function (e) {
                if (!e) e = window.event;
                if ((e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_TAB) && (!e.altKey)) {
                    try {
                        if (e.preventDefault) event.preventDefault();
                        if (e.stopPropagation) event.stopPropagation();
                        e.cancelBubble = true;
                    } catch (err) {

                    }
                }
                setTimeout(function () {
                    if (
                        (
                            e.keyCode == axf.Event.KEY_DOWN || e.keyCode == axf.Event.KEY_UP ||
                            e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_TAB
                        ) && (!e.altKey)
                    ) {
                        if (e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_TAB) {
                            //_this.updateItem(r, c, ii, e.target.value);
                            jQuery(document.body).trigger('click.axgrid'); //2015-06-12 탭키 눌렀을때 select box 값이 object가 아닌 value로 들어와서 trigger 처리.
                            _this.gridFocus.focus();
                        }

                        if (e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_UP || e.keyCode == axf.Event.KEY_DOWN) {
                            var new_ii;
                            if (e.shiftKey && e.keyCode == axf.Event.KEY_RETURN || e.keyCode == axf.Event.KEY_UP) {
                                new_ii = ii.number() - 1;
                            }
                            else {
                                new_ii = ii.number() + 1;
                            }
                            if (new_ii < 0) new_ii = _this.list.length - 1;
                            if (_this.list.length > new_ii) _this.editCell(r, c, new_ii);

                            //else if (_this.list.length <= new_ii) new_ii = 0;

                        }
                        else if (e.keyCode == axf.Event.KEY_TAB) {
                            var new_c, ci, cl;
                            ci = 0, cl = cfg.colGroup.length;
                            if (e.shiftKey && e.keyCode == axf.Event.KEY_TAB) {
                                for (ci = cl - 1; ci > -1; ci--) {
                                    if (cfg.colGroup[ci].editor && cfg.colGroup[ci].editor.type != "finder") {
                                        if (typeof new_c == "undefined") {
                                            new_c = ci;
                                        }
                                        else if (ci < c) {
                                            new_c = ci;
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                for (; ci < cl; ci++) {
                                    if (cfg.colGroup[ci].editor && cfg.colGroup[ci].editor.type != "finder") {
                                        if (typeof new_c == "undefined") {
                                            new_c = ci;
                                        }
                                        else if (ci > c) {
                                            new_c = ci;
                                            break;
                                        }
                                    }
                                }
                            }
                            _this.editCell(r, new_c, ii);
                        }
                        _this.stopEvent(e);
                    }
                    else if (e.keyCode == axf.Event.KEY_ESC) {
                        _this.editCellClear();
                    }
                }, 10);
            });
        }, 10);

        get_editor = function (cond, val) {
            if (typeof val == "undefined") val = "";
            // text, number, money, calendar, select, selector, switch, segment, slider, finder
            var po = [], _val, maxLength = "";
            if (cond.maxLength) maxLength = ' maxLength="' + cond.maxLength + '"';

            if (cond.type === "select" || cond.type === "AXSelect") {

                if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
                    _val = val;
                }
                else {
                    _val = val[cond.optionValue || "optionValue"];
                }
                po.push('<select name="inline_editor_item" id="' + cfg.targetID + '_inline_editor" class="inline_editor_select ' + cond.type + '">');

                if ($.isFunction(cond.options)) {
                    (function (options) {
                        for (var oi = 0; oi < options.length; oi++) {
                            var value, text;
                            value = options[oi][cond.optionValue || "optionValue"], text = options[oi][cond.optionText || "optionText"];
                            po.push('<option value="' + value + '"');
                            if (value == _val) {
                                po.push(' selected="selected"');
                            }
                            po.push('>' + text + '</option>');
                        }
                    })(cond.options.call({
                        list: _this.list,
                        item: _this.list[ii],
                        value: val
                    }));
                }
                else if (cond.options) {
                    for (var oi = 0; oi < cond.options.length; oi++) {
                        var value, text;
                        value = cond.options[oi][cond.optionValue || "optionValue"], text = cond.options[oi][cond.optionText || "optionText"];
                        //obj[cond.optionValue||"optionValue"] = sdom.options[sdom.selectedIndex].value;

                        po.push('<option value="' + value + '"');
                        if (value == _val) {
                            po.push(' selected="selected"');
                        }
                        po.push('>' + text + '</option>');
                    }
                }
                po.push('</select>');
            }
            else if (cond.type === "AXSelector") {
                //console.log(cond.config.reserveKeys);
                if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
                    _val = val;
                }
                else if (cond.config.reserveKeys) {
                    _val = val[cond.config.reserveKeys.optionText];
                }
                else {
                    _val = val["optionText"];
                }

                po.push('<input type="text" name="inline_editor_item" id="' + cfg.targetID + '_inline_editor" value="' + _val + '" class="inline_editor_input ' + cond.type + '" ' + (cond.readonly ? 'readonly="readonly"' : '') + ' />');
            }
            else {
                if (cond.type == "finder") {
                    po.push('<input type="text" name="inline_editor_item" id="' + cfg.targetID + '_inline_editor"' + maxLength + ' value="' + val + '" ');

                    if (cond.readonly) {
                        po.push(' class="inline_editor_input ' + cond.type + '" ');
                        po.push(' readonly="readonly" ');
                    }
                    else {
                        po.push(' class="inline_editor_input ' + cond.type + '" ');
                    }
                    po.push(' />');
                    po.push('<a class="finder-handle"></a>');
                }
                else {
                    po.push('<input type="' + (cond.textType || "text") + '" name="inline_editor_item" id="' + cfg.targetID + '_inline_editor"' + maxLength + ' value="' + val + '" class="inline_editor_input ' + cond.type + '" ' + (cond.readonly ? 'readonly="readonly"' : '') + ' />');
                }
            }
            return po.join('');
        };

        return this;
    },
    /**
     * 셀 인라인 에디트 상태 해제
     * @method AXGrid.editCellClear
     * @param {Number} [r] - index of config.body.rows
     * @param {Number} [c] - index of colGrop
     * @param {Number} [itemIndex] - index of data
     * @returns {AXGrid|false}
     * @example
     * ```
     * mygrid.editCellClear(); // 셀 에디트 상태 해제
     * mygrid.editCellClear(0, 1, 1); // 셀 에디트 해제 하려는 위치가 값을 현재 위치와 비교 하여 false가 리턴되면 현재 위치
     * ```
     */
    editCellClear: function () {
        if (this.inline_edit) {
            if (this.inline_edit.r == arguments[0] && this.inline_edit.c == arguments[1] && this.inline_edit.ii == arguments[2]) {
                return false;
            }
            else if (typeof arguments[2] != "undefined" && this.inline_edit && this.inline_edit.editor.find("input").get(0)) {
                var ids = this.inline_edit.editor.get(0).id.split(/_AX_/g);
                var r, c, ii;
                r = ids[ids.length - 3], c = ids[ids.length - 2], ii = ids[ids.length - 1];
                this.updateItem(r, c, ii, this.inline_edit.editor.find("input").val());
            }
            else {
                try {
                    this.inline_edit.editor.find("input").unbindInput();
                } catch (e) {
                }
                this.inline_edit.editor.remove();
                this.inline_edit = null;
            }
        }
        jQuery(document.body).unbind("click.axgrid");
        return this;
    },
    /**
     * 현재 활성화된 인라인 에디트 input에 값을 지정합니다.
     * @method AXGrid.setEditCellValue
     * @param {String} val
     * @returns {AXGrid}
     * @example
     * ```
     * mygrid.setEditCellValue("123");
     * ```
     */
    setEditCellValue: function (val) {
        if (this.inline_edit) {
            this.inline_edit.editor.find("input, select, textarea").val(val);
        }
        return this;
    },
    /**
     * 리스트데이터의 특정 아이템값을 변경합니다.
     * @method AXGrid.updateItem
     * @param {Number} rowsIndex - 바디의 한아이템의 줄 대게 0 body안에 rows를 구성하는 경우에 사용
     * @param {Number} colsIndex - 컬럼 위치
     * @param {Number} itemIndex - 아이템의 인덱스 <en>index of item<en>
     * @param {String|Number} value - 변경하려는 값
     * @returns {AXGrid}
     * @example
     * ```
     * myGrid.updateItem(0, 2, 1, "AXISJ");
     * ```
     */
    updateItem: function (r, c, itemIndex, value) {
        var _this = this, cfg = this.config,
            CH = cfg.body.rows[r][c], item = this.list[itemIndex],
            CG = cfg.colGroup[c],
            that = {grid: this, item: item, index: itemIndex, value: item[CG.key], CG: CG, r: r, c: c};

        if (cfg.control_lock_status > 1) {
            return this;
        }

        var beforeValue = _this.list[itemIndex][CH.key];

        if (CG.editor) {
            if (CG.editor.type in _this.inlineEditor) {
                value = _this.inlineEditor[CG.editor.type].getValue.call(that, value);
            }

            if (CG.editor.beforeUpdate) {
                value = CG.editor.beforeUpdate.call(that, value);
            }
        }

        _this.list[itemIndex][CH.key] = value;

        // ._CUD 값 조정
        if (_this.list[itemIndex]._CUD != "C" && _this.list[itemIndex]._CUD != "D") {
            var isChanged = false;
            if (Object.isObject(beforeValue)) {
                var beforeValueString = Object.values(beforeValue).join("_");
                var valueString = Object.values(value).join("_");
                isChanged = (beforeValueString != valueString);
            }
            else {
                isChanged = (beforeValue != value);
            }

            if (isChanged) {
                _this.list[itemIndex]._CUD = "U";
            }
        }

        if (this.inline_edit && CG.editor) {
            function cellUpdate() {
                _this.inline_edit.cell.html(_this.getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH, c));
                if (CG.editor.updateWith) {
                    var i = 0, l = CG.editor.updateWith.length;
                    for (; i < l; i++) {
                        var v = CG.editor.updateWith[i], wCH, wc;
                        // 컬럼 인덱스 찾기
                        axf.each(cfg.colGroup, function (cidx, C) {
                            if (C.key == v) {
                                wc = cidx;
                                return false;
                            }
                        });
                        if (typeof(wc) === "number") {
                            wCH = cfg.body.rows[r][wc];
                            //console.log(v, wCH, r, wc);
                            _this.body.find("#" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + wc + "_AX_" + itemIndex).html(_this.getFormatterValue(wCH.formatter, item, itemIndex, item[v], v, wCH, wc));
                        }
                    }
                }
            }

            cellUpdate();

            // 2015-06-08 column 별 수정 관련해서 수정 여부 추가. start
            if (_this.list[itemIndex][CH.key + '_VAL']) {
                _this.list[itemIndex][CH.key + '_VAL']['_modify'] = true;
            }
            //end

            if (CG.editor.afterUpdate) {
                CG.editor.afterUpdate.call(that, value);
            }
            _this.editCellClear();
        }
        else {
            //console.log("bigDataSyncApply");
            this.bigDataSyncApply("reload");
        }
        return this;
    },
    /**
     * @method AXGrid.contentScrollResize
     * @param resetLeft {Boolean} - false 시 가로 스크롤은 초기화 하지 않습니다.
     * @description  Grid의 화면에 맞게 스크롤을 생성 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.contentScrollResize(false);
     * ```
     */
    contentScrollResize: function (resetLeft) {
        var cfg = this.config, _this = this;
        if (cfg.viewMode == "mobile") return; // 모바일이면 scroll이 없음.

        var bodyHeight = _this.body.height();
        var scrollHeight = _this.scrollContent.height();

        var bodyWidth = _this.body.width();
        var _colWidth = (_this.colWidth.number() + cfg.fitToWidthRightMargin);
        var scrollWidth = (_colWidth > bodyWidth) ? _colWidth : bodyWidth;

        _this.scrollContent.css({width: scrollWidth});
        _this.colHead.css({width: scrollWidth});

        /* colHead width 재정의 */
        if (_this.hasEditor) _this.editor.css({width: bodyWidth});
        if (_this.hasFoot) {
            if (this.cachedDom) {
                (function () {
                    if (!this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0").outerHeight()) return;
                    var itemTrHeight = this.cachedDom.tbody.find("#" + cfg.targetID + "_AX_null_AX_0").outerHeight().number();
                    var printListCount = (this.body.height() / itemTrHeight).ceil();
                    var _count = 0;
                    if (printListCount < this.list.length) {
                        _count = this.list.length - printListCount;
                    }
                    //console.log(cfg.scrollContentBottomMargin, _count, itemTrHeight, this.body.height());

                    this.cachedDom.tfpadding.css({height: cfg.scrollContentBottomMargin.number() + (_count * itemTrHeight)});
                    if (this.hasFixed) {
                        this.cachedDom.ftfpadding.css({height: cfg.scrollContentBottomMargin.number() + (_count * itemTrHeight)});
                    }
                }).call(this);
            }
            _this.gridFoot.css({width: bodyWidth});
        }
        /// 가로 스크롤 포지션 초기화 처리 여부
        if (resetLeft != false || (_this.scrollContent.width() + _this.scrollContent.position().left) < _this.body.width()) {
            _this.scrollContent.css({left: 0});
            _this.colHead.css({left: 0});
            _this.scrollXHandle.css({left: 0});
            if (_this.hasEditor) _this.editor.css({left: 0});
        }

        var show_scroll_x = false,
            show_scroll_y = false,
            scrollContentAdjust = 0
            ;

        if ("수평스크롤 생성 조건 체크") {
            if (scrollWidth > (bodyWidth + 4) && cfg.xscroll) {
                show_scroll_x = true;
            }

            if (show_scroll_x) {
                _this.scrollTrackX.show();
                _this.scrollTrackX.css({width: bodyWidth});
                scrollContentAdjust = _this.scrollTrackX.outerHeight();

                var scrollXHandleWidth = (bodyWidth * bodyWidth) / scrollWidth;
                // 바디너비 트랙너비 , 스크롤 너비
                _this.scrollXHandle.data("width", scrollXHandleWidth);
                if (scrollXHandleWidth < 30) scrollXHandleWidth = 30;
                _this.scrollXHandle.css({width: scrollXHandleWidth});
            }
            else {
                _this.scrollTrackX.hide();
            }

            if (cfg.__height == "auto") {
                // Foot의 높이 만큼 body를 늘려주어야 함.
                _this.scrollBody.css({
                    height: (
                        _this.colHead.outerHeight() +
                        _this.scrollContent.height() +
                        scrollContentAdjust
                    )
                });
                _this.body.css({
                    top: _this.colHead.outerHeight(), height: (
                        _this.scrollContent.height()
                    )
                });
            }
            else {
                _this.body.css({
                    height: (
                        cfg.height.number() -
                        ((this.pageBody.data("display") == "show") ? this.pageBody.outerHeight() : 0) -
                        2 -
                        this.colHead.outerHeight() -
                        scrollContentAdjust
                    )
                });
                _this.scrollTrackY.css({top: _this.colHead.outerHeight(), height: bodyHeight});
            }

            // bodyHeight 재정의
            bodyHeight = _this.body.height();
            scrollHeight = _this.scrollContent.height();
        }

        if ("수직스크롤 생성 조건 체크") {
            if (cfg.__height == "auto") {
                show_scroll_y = false;
            }
            else {
                if (bodyHeight < scrollHeight) {
                    show_scroll_y = true;
                }
            }

            if (show_scroll_y) {
                _this.scrollTrackY.show();
                _this.scrollTrackY.css({top: _this.colHead.outerHeight(), height: bodyHeight});

                var scrollYHandleHeight = (bodyHeight * bodyHeight) / scrollHeight;
                // scrollYHandleHeight 최소 사이즈 예외 처리 최소 높이 = 30
                _this.scrollYHandle.data("height", scrollYHandleHeight);
                if (scrollYHandleHeight < 30) scrollYHandleHeight = 30;
                _this.scrollYHandle.css({height: scrollYHandleHeight});
            }
            else {
                _this.scrollTrackY.hide();
            }
        }

        _this.onevent_grid({type: "scroll-resize"});

        return this;
    },
    /**
     * @method AXGrid.contentScrollScrollSync
     * @param pos {Object} - top, left.
     * @description  top, left에 맞게 스크롤을 이동 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.contentScrollScrollSync({left: myGrid.scrollXHandle.position().left});
     * ```
     */
    contentScrollScrollSync: function (pos) {  // move scrollContent
        var cfg = this.config, _this = this;
        // if(_this.colWidth != _this.prev_colWidth) return; // 이전스크롤과 비교

        if (pos.left != undefined) {

            if (!this.contentScrollXAttr) {
                var scrollWidth = (this.colWidth > this.colHead.width()) ? this.colWidth : this.colHead.width();
                this.contentScrollXAttr = {
                    bodyWidth: this.body.width(),
                    scrollWidth: scrollWidth,
                    scrollTrackXWidth: this.scrollTrackX.width(),
                    scrollXHandleWidth: this.scrollXHandle.outerHeight()
                };
            }
            var L = (function (D) {
                //return ((D.scrollWidth - D.bodyWidth) * pos.left / (D.scrollTrackXWidth - D.scrollXHandleWidth)).round();
                return ((D.scrollWidth) * pos.left / (D.scrollTrackXWidth - D.scrollXHandleWidth)).round();
            })(this.contentScrollXAttr);

            // 범위를 넘어서는 경우 체크
            if (this.contentScrollXAttr.scrollWidth - L < this.body.width()) {
                L = this.contentScrollXAttr.scrollWidth - this.body.width();
            }

            this.scrollContent.css({left: -L});
            this.colHead.css({left: -L});

            if (this.hasFoot) {
                this.gridFoot_content.css({left: -L});
            }
            if (this.hasEditor) axdom("#" + cfg.targetID + "_AX_editorContent").css({left: -L});

        }
        else {
            if (cfg.__height == "auto") return;
            if (!this.contentScrollYAttr) {
                this.contentScrollYAttr = {
                    bodyHeight: this.body.height(),
                    scrollHeight: this.scrollContent.outerHeight(),
                    scrollTrackYHeight: this.scrollTrackY.height(),
                    scrollYHandleHeight: this.scrollYHandle.outerHeight()
                };
            }
            else {
                // scrollContent height update
                this.contentScrollYAttr.bodyHeight = this.body.height();
                this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
                this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
                this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
            }

            //trace(this.contentScrollYAttr);

            var _sh = this.contentScrollYAttr.scrollHeight, _bh = this.contentScrollYAttr.bodyHeight, _th = this.contentScrollYAttr.scrollTrackYHeight, _hh = this.contentScrollYAttr.scrollYHandleHeight;
            var T = pos.top * (_sh - _bh) / (_th - _hh);
            //var T = (this.contentScrollYAttr.scrollHeight * (pos.top) / this.contentScrollYAttr.scrollTrackYHeight).floor();
            //var T = (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight) * ( (pos.top) / (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) ).number();

            this.scrollContent.css({top: -T});
            if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) this.fixedScrollContent.css({top: -T});
            if (this.editorOpend) {
                this.editor.css({top: -T + this.editorOpenTop + this.body.position().top});
            }
            this.bigDataSyncApply();
        }
    },
    /**
     * @method AXGrid.contentScrollContentSync
     * @param pos {Object} - top, left
     * @param touch {String} - "touch"
     * @description  top, left에 맞게 그리드 내용을 이동 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.contentScrollContentSync({top: 0}, "touch");
     * ```
     */
    contentScrollContentSync: function (pos, touch, reload) { // move scrollHandle
        var cfg = this.config;
        if (typeof pos.left !== "undefined") {

            if (!this.contentScrollXAttr) {
                var scrollWidth = (this.colWidth > this.body.width()) ? this.colWidth : this.body.width();
                this.contentScrollXAttr = {
                    bodyWidth: this.body.width(),
                    scrollWidth: scrollWidth,
                    scrollTrackXWidth: this.scrollTrackX.width(),
                    scrollXHandleWidth: this.scrollXHandle.outerWidth()
                };
            }

            var L = (this.contentScrollXAttr.scrollTrackXWidth - this.contentScrollXAttr.scrollXHandleWidth) *
                ((pos.left) / (this.contentScrollXAttr.scrollWidth - this.contentScrollXAttr.bodyWidth));
            this.scrollXHandle.css({left: -L});
            this.colHead.css({left: pos.left});

            if (this.hasFoot) {
                this.gridFoot_content.css({left: pos.left});
            }
            if (this.hasEditor) {
                axdom("#" + cfg.targetID + "_AX_editorContent").css({left: pos.left});
            }

        }
        else {
            if (cfg.__height == "auto") return;
            if (!this.contentScrollYAttr) {
                this.contentScrollYAttr = {
                    bodyHeight: this.body.height(),
                    scrollHeight: this.scrollContent.height(),
                    scrollTrackYHeight: this.scrollTrackY.height(),
                    scrollYHandleHeight: this.scrollYHandle.outerHeight()
                };
            }
            else {
                // scrollContent height update
                this.contentScrollYAttr.bodyHeight = this.body.height();
                this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
                this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
                this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
            }
            var _sh = this.contentScrollYAttr.scrollHeight, _bh = this.contentScrollYAttr.bodyHeight, _th = this.contentScrollYAttr.scrollTrackYHeight, _hh = this.contentScrollYAttr.scrollYHandleHeight;
            var T = pos.top * (_th - _hh) / (_sh - _bh);

            this.scrollYHandle.css({top: -T});
            if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) this.fixedScrollContent.css({top: pos.top});
            if (this.editorOpend) {
                this.editor.css({top: pos.top + this.editorOpenTop + this.body.position().top});
            }
        }

        if (!reload) {
            if (typeof touch == "undefined") this.bigDataSync();
            if (touch == "direct")  this.bigDataSyncApply();
        }
    },
    /**
     * @method AXGrid.getMousePositionToContentScroll
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @param contentScrollID {String} - Event가 일어난 스크롤 객체 ID
     * @description  스크롤이 발생된 마우스 위치를 반환합니다.
     * @returns {Object} ({x,y})
     */
    getMousePositionToContentScroll: function (event, contentScrollID) {
        var pos = axdom("#" + contentScrollID).offset();
        var x = (event.pageX - pos.left);
        var y = (event.pageY - pos.top);
        return {x: x, y: y};
    },
    /**
     * @method AXGrid.getTouchPositionToContentScroll
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  터치 이벤트가 일어난 위치를 반환 합니다.
     * @returns {Object} ({x,y})
     */
    getTouchPositionToContentScroll: function (event) {
        var cfg = this.config;
        var touch = event.touches[0], x, y;

        if (cfg.touchDirection) {
            x = touch.pageX.round(10);
            y = touch.pageY.round(10);
        }
        else {
            x = -touch.pageX.round(10);
            y = -touch.pageY.round(10);
        }

        return {x: x, y: y};
    },
    /**
     * @method AXGrid.contentScrollScrollReady
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  스크롤에 대한 기본 속성/이벤트를 지정합니다.
     */
    contentScrollScrollReady: function (event) {
        var cfg = this.config;
        var handleName = (event.target.id).split(/_AX_/).last();
        /*console.log(handleName); */
        this.contentScrollAttrs = {handleName: handleName};
        this.contentScrollXAttr = null;
        this.contentScrollYAttr = null;

        if (handleName == "scrollYHandle") {
            this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackY";
        }
        else {
            this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackX";
        }
        axdom(event.target).addClass("hover");

        var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
        this.contentScrollAttrs.x = axdom(event.target).position().left - pos.x;
        this.contentScrollAttrs.y = axdom(event.target).position().top - pos.y;
        this.contentScrollAttrs.handleWidth = axdom(event.target).outerWidth();
        this.contentScrollAttrs.handleHeight = axdom(event.target).outerHeight();
        this.contentScrollAttrs.trackWidth = this.scrollTrackX.width();
        this.contentScrollAttrs.trackHeight = this.scrollTrackY.height();

        if (!this.contentScrollYAttr) {
            this.contentScrollYAttr = {
                bodyHeight: this.body.height(),
                scrollHeight: this.scrollContent.outerHeight(),
                scrollTrackYHeight: this.scrollTrackY.height(),
                scrollYHandleHeight: this.scrollYHandle.outerHeight()
            };
        }
        else {
            // scrollContent height update
            this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
            this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
            this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
        }

        /* srcoll event bind */
        var contentScrollScrollMove = this.contentScrollScrollMove.bind(this);
        this.contentScrollScrollMoveBind = function (event) {
            contentScrollScrollMove(event);
        };
        var contentScrollScrollEnd = this.contentScrollScrollEnd.bind(this);
        this.contentScrollScrollEndBind = function (event) {
            contentScrollScrollEnd(event);
        };

        if (handleName == "scrollYHandle") {
            this.scrollYTip.show();
            this.contentScrollTipOverMove();
        }

        axdom(document.body).bind("mousemove.AXGrid", this.contentScrollScrollMoveBind);
        axdom(document.body).bind("mouseup.AXGrid", this.contentScrollScrollEndBind);
        axdom(document.body).bind("mouseleave.AXGrid", this.contentScrollScrollEndBind);

        axdom(document.body).attr("onselectstart", "return false");
        //axdom(document.body).addClass("AXUserSelectNone");

        this.contentScrollScrolling = true;
        /* scroll event bind ~~~~~~~~~~~~~~~~~~~ */
    },
    /**
     * @method AXGrid.contentScrollScrollMove
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  스크롤바가 스크롤 될때 내부 처리를 합니다.
     */
    contentScrollScrollMove: function (event) {
        var cfg = this.config;
        var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
        var handleName = this.contentScrollAttrs.handleName;
        /*console.log(this.contentScrollAttrs); */
        var handleTop = 0;
        var handleLeft = 0;
        if (handleName == "scrollYHandle") {
            handleTop = (pos.y + this.contentScrollAttrs.y);
            if (handleTop < 0) handleTop = 0;
            if ((handleTop + this.contentScrollAttrs.handleHeight) > this.contentScrollAttrs.trackHeight) {
                handleTop = this.contentScrollAttrs.trackHeight - this.contentScrollAttrs.handleHeight;
            }
            this.scrollYHandle.css({top: handleTop});
            this.scrollYHandle.data("top", handleTop);
            this.contentScrollScrollSync({top: handleTop});
            this.contentScrollTipOverMove(handleTop);
        }
        else {
            handleLeft = pos.x + this.contentScrollAttrs.x;
            if (handleLeft < 0) handleLeft = 0;
            if ((handleLeft + this.contentScrollAttrs.handleWidth) > this.contentScrollAttrs.trackWidth)
                handleLeft = this.contentScrollAttrs.trackWidth - this.contentScrollAttrs.handleWidth;
            this.scrollXHandle.css({left: handleLeft});
            // 스크롤 X 예외 처리
            this.contentScrollScrollSync({left: handleLeft});
        }
        this.onevent_grid({type: "onscroll"});
    },
    /**
     * @method AXGrid.contentScrollScrollEnd
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  스크롤바의 스크롤이 끝났을때의 처리를 합니다.
     */
    contentScrollScrollEnd: function (event) {
        var cfg = this.config;
        axdom(document.body).unbind("mousemove.AXGrid");
        axdom(document.body).unbind("mouseup.AXGrid");
        axdom(document.body).unbind("mouseleave.AXGrid");

        axdom(document.body).removeAttr("onselectstart");
        //axdom(document.body).removeClass("AXUserSelectNone");
        axdom("#" + cfg.targetID + "_AX_" + this.contentScrollAttrs.handleName).removeClass("hover");
        this.contentScrollScrolling = false;

        if (this.contentScrollAttrs.handleName == "scrollYHandle") {
            this.contentScrollScrollSync({top: this.scrollYHandle.position().top});
            if (this.contentScrollAttrs.trackHeight - this.contentScrollAttrs.handleHeight == this.scrollYHandle.data("top")) {
                this.contentScrollEnd();
            }
            this.scrollYTip.hide();
        }
        else {
            this.contentScrollScrollSync({left: this.scrollXHandle.position().left});
        }
    },
    /**
     * @method AXGrid.contentScrollScrollWheel
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드 몸통에서 일어나는 마우스 휠 이벤트 처리를 합니다.
     */
    contentScrollScrollWheel: function (e) {
        var cfg = this.config,
            scrollTop = this.scrollContent.position().top,
            scrollLeft = this.scrollContent.position().left,
            eventCancle = false,
            event = e || window.event, deltaX = 0, deltaY = 0, attr;

        if (cfg.__height == "auto") return;

        attr = {
            bodyHeight: this.body.height(),
            bodyWidth: this.body.width()
        };
        attr.scrollHeight = this.scrollContent.height();
        attr.scrollWidth = this.scrollContent.width();
        attr.scrollTrackYHeight = this.scrollTrackY.height();
        attr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
        attr.scrollTrackYWidth = this.scrollTrackY.width();
        attr.scrollYHandleWidth = this.scrollYHandle.outerWidth();

        if (event.wheelDeltaX) {
            deltaX = (event.wheelDeltaX / 2).ceil();
            deltaY = (event.wheelDeltaY / 2).ceil();
        }
        else {
            deltaY = (event.detail ? event.detail * (-20) : event.wheelDelta / 2).ceil();
        }
        /*check for detail first so Opera uses that instead of wheelDelta */

        // 아무일도 하지 말기
        if (deltaX == 0 && deltaY == 0) return true;

        if (deltaY.abs() > deltaX.abs() && deltaY.abs() > 0) {
            if (attr.scrollHeight < attr.bodyHeight) return;
            scrollTop += deltaY;

            if (scrollTop > 0) {
                scrollTop = 0;
                eventCancle = true;
            }
            else if (scrollTop.abs() + attr.bodyHeight > attr.scrollHeight) {
                scrollTop = attr.bodyHeight - attr.scrollHeight;
                eventCancle = true;
            }
            else if (scrollTop == 0) {
                scrollTop = 0;
                eventCancle = true;
            }
            this.scrollContent.css({top: scrollTop});
            this.contentScrollContentSync({top: scrollTop}, "direct");
            this.onevent_grid({type: "onscroll"});
        }
        else if (deltaX.abs() > deltaY.abs() && deltaX.abs() > 0) {
            scrollLeft += deltaX;

            if (scrollLeft > 0) {
                scrollLeft = 0;
                eventCancle = true;
            }
            else if (scrollLeft.abs() + attr.bodyWidth > attr.scrollWidth) {
                scrollLeft = attr.bodyWidth - attr.scrollWidth;
                eventCancle = true;
            }
            else if (scrollLeft == 0) {
                scrollLeft = 0;
                eventCancle = true;
            }
            this.scrollContent.css({left: scrollLeft});
            this.contentScrollContentSync({left: scrollLeft}, "direct");
            this.onevent_grid({type: "onscroll"});
        }

        if (!eventCancle) {
            if (event.preventDefault) event.preventDefault();
            if (event.stopPropagation) event.stopPropagation();
            event.cancelBubble = true;
            return false;
        }
        else {
            if (scrollTop != 0) {
                var contentScrollEnd = this.contentScrollEnd.bind(this);
                if (this.contentScrollEndObserver) clearTimeout(this.contentScrollEndObserver);
                this.contentScrollEndObserver = setTimeout(function () {
                    contentScrollEnd();
                }, 100);
            }
        }

    },
    /**
     * @method AXGrid.contentScrollTouchstart
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드 스크롤바에 대한 터치 이벤트를 처리 합니다.
     */
    contentScrollTouchstart: function (e) {
        var cfg = this.config;
        var event = window.event || e;

        if (cfg.viewMode == "mobile") return;

        this.contentScrollTouchMoved = true;
        this.contentScrollIDOffset = this.scrollContent.offset();
        this.contentScrollXAttr = null;
        this.contentScrollYAttr = null;

        var pos = this.getTouchPositionToContentScroll(event);

        this.scrollYHandle.addClass("hover");
        this.scrollXHandle.addClass("hover");

        this.scrollTouchAttr = {
            y: pos.y,
            h: this.body.outerHeight(),
            th: this.scrollContent.height(),
            nt: this.scrollContent.position().top,
            x: pos.x,
            w: this.body.outerWidth(),
            tw: this.scrollContent.width(),
            nl: this.scrollContent.position().left
        };

        var contentScrollTouchEnd = this.contentScrollTouchEnd.bind(this);
        this.contentScrollTouchEndBind = function () {
            contentScrollTouchEnd(event);
        };

        var contentScrollTouchMove = this.contentScrollTouchMove.bind(this);
        this.contentScrollTouchMoveBind = function () {
            contentScrollTouchMove(event);
        };

        if (document.addEventListener) {
            document.addEventListener("touchend", this.contentScrollTouchEndBind, false);
            document.addEventListener("touchmove", this.contentScrollTouchMoveBind, false);
        }
    },
    /**
     * @method AXGrid.contentScrollTouchMove
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드내의 터치에 의한 화면 이동을 처리 합니다..
     */
    contentScrollTouchMove: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        if (this.contentScrollTouchMoved) {

            var pos = this.getTouchPositionToContentScroll(event);
            var scrollTouchAttr = this.scrollTouchAttr;

            var eventCancle = false;

            if (scrollTouchAttr.th > scrollTouchAttr.h && cfg.height != "auto") {
                var scrollTop = scrollTouchAttr.nt - (pos.y - scrollTouchAttr.y);
                //console.log(scrollTop);
                if (scrollTop > 0) {
                    scrollTop = 0;
                    eventCancle = true;
                }
                else if (scrollTop.abs() + scrollTouchAttr.h > scrollTouchAttr.th) {
                    scrollTop = scrollTouchAttr.h - scrollTouchAttr.th;
                    eventCancle = true;
                }
                else if (scrollTop == 0) {
                    scrollTop = 0;
                    eventCancle = true;
                }

                this.scrollContent.css({top: scrollTop});
                this.contentScrollContentSync({top: scrollTop}, "touch");
            }
            else {
                eventCancle = true;
            }

            if (this.show_scrollTrackX && (pos.x - scrollTouchAttr.x).abs() > 8) {
                eventCancle = false;
                var scrollLeft = scrollTouchAttr.nl - (pos.x - scrollTouchAttr.x);

                if (scrollLeft > 0) {
                    scrollLeft = 0;
                    eventCancle = true;
                }
                else if (scrollLeft.abs() + scrollTouchAttr.w > scrollTouchAttr.tw) {
                    scrollLeft = scrollTouchAttr.w - scrollTouchAttr.tw;
                    eventCancle = true;
                }
                else if (scrollLeft == 0) {
                    scrollLeft = 0;
                    eventCancle = true;
                }
                this.scrollContent.css({left: scrollLeft});
                this.contentScrollContentSync({left: scrollLeft}, "touch");
            }

            if (!eventCancle) {
                if (event.preventDefault) event.preventDefault();
                //if (event.stopPropagation) event.stopPropagation();
                //event.cancelBubble = true;
                //return false;
            }
            else {
                if (scrollTop != 0) {
                    var contentScrollEnd = this.contentScrollEnd.bind(this);
                    if (this.contentScrollEndObserver) clearTimeout(this.contentScrollEndObserver);
                    this.contentScrollEndObserver = setTimeout(function () {
                        contentScrollEnd();
                    }, 100);
                }
            }
        }
    },
    /**
     * @method AXGrid.contentScrollTouchEnd
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description  그리드내의 터치(point)가 끝났을때의 처리를 합니다.
     */
    contentScrollTouchEnd: function (e) {
        var cfg = this.config;
        var event = window.event || e;
        if (this.contentScrollTouchMoved) {

            if (cfg.height != "auto") this.bigDataSync();

            // 관성법칙 적용 해야함.
            this.scrollXHandle.removeClass("hover");
            this.scrollYHandle.removeClass("hover");

            if (document.removeEventListener) {
                document.removeEventListener("touchend", this.contentScrollTouchEndBind, false);
                document.removeEventListener("touchmove", this.contentScrollTouchMoveBind, false);
            }
            this.contentScrollTouchMoved = false;
        }
    },
    /**
     * @method AXGrid.contentScrollEnd
     * @description  그리드내의 스크롤이 마지막 항목까지 도달 하였을때의 처리를 합니다. config에서 설정한 onscrollend 지정 함수도 이때 발생됩니다.
     */
    contentScrollEnd: function () {
        if (this.contentScrollEndObserver) clearTimeout(this.contentScrollEndObserver);
        var cfg = this.config;
        if (cfg.body.onscrollend) {
            try {
                cfg.body.onscrollend.call({list: this.list, page: this.page});
            } catch (e) {
                console.log(e);
            }
        }
    },
    /**
     * @method AXGrid.contentScrollTipOver
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     */
    contentScrollTipOver: function (event) {
        // contentScrollTopOver
        /*
         var cfg = this.config;
         this.scrollYHandle.bind("mousemove");
         this.scrollYHandle.bind("mouseout");
         */
    },
    /**
     * @method AXGrid.contentScrollTipOverMove
     * @param handleTop {Number} - 툴팁 출력위치의 상단 offset
     * @description - Grid의 스크롤바를 움직일때 현레코드/전체레코드의 툴팁을 출력합니다.
     */
    contentScrollTipOverMove: function (handleTop) {
        var cfg = this.config;
        /*
         if (!this.contentScrollYAttr) {
         this.contentScrollYAttr = {
         bodyHeight: this.body.height(),
         scrollHeight: this.scrollContent.outerHeight(),
         scrollTrackYHeight: this.scrollTrackY.height(),
         scrollYHandleHeight: this.scrollYHandle.outerHeight()
         };
         }else{
         // scrollContent height update
         this.contentScrollYAttr.scrollHeight = this.scrollContent.height();
         this.contentScrollYAttr.scrollTrackYHeight = this.scrollTrackY.height();
         this.contentScrollYAttr.scrollYHandleHeight = this.scrollYHandle.outerHeight();
         }
         */
        var hTop = handleTop || this.scrollYHandle.position().top;
        var T = (this.contentScrollYAttr.scrollHeight - this.contentScrollYAttr.bodyHeight) * ( (hTop) / (this.contentScrollYAttr.scrollTrackYHeight - this.contentScrollYAttr.scrollYHandleHeight) ).number();
        this.scrollYTipSpan.empty();
        this.scrollYTipSpan.append(((T.abs() / this.virtualScroll.itemTrHeight)).floor().money() + "/" + this.list.length.money());
        this.scrollYTip.css({top: hTop});
    },
    /**
     * @method AXGrid.contentScrollTipOverOut
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description - Grid의 스크롤바에 대한 이동 이벤트가 끝났을때 툴팁을 해제합니다.
     */
    contentScrollTipOverOut: function (event) {
        var cfg = this.config;
        this.scrollYHandle.unbind("mousemove");
        this.scrollYHandle.unbind("mouseout");
        this.scrollYTip.hide();
    },
    /**
     * @method AXGrid.dataSync
     * @description - 그리드 데이터를 조작후 그리드에 현재 위치된 아이템을 다시 생성합니다.
     * @returns {AXGrid}
     * @example
     * ```
     * myGrid.list[0].id = 12;
     * myGrid.dataSync();
     * ```
     */
    dataSync: function () {
        this.bigDataSync(true);
        return this;
    },
    /**
     * @method AXGrid.bigDataSync
     * @description - bigDataSyncApply를 호출 합니다.(grid에서만 동작, mobile,icon등의 모드에서는 동장 안함)
     */
    bigDataSync: function (reload) {
        var cfg = this.config, _this = this;
        if (cfg.viewMode == "grid") {
            if (this.bigDataSyncObserver) clearTimeout(this.bigDataSyncObserver);
            this.bigDataSyncObserver = setTimeout(function () {
                _this.bigDataSyncApply(reload);
            }, 10);
        }
    },
    /**
     * @method AXGrid.bigDataSyncApply
     * @param {Boolean} reload - 현재 그리드 스크롤된 컨텐츠를 다시 출력합니다.
     * @description - Grid의 리스트 내부 인덱스가 변경되거나 포커싱 대상 인덱스가 스크롤을 벗어나 있을경우 그리드를 재구성 합니다.
     */
    bigDataSyncApply: function (reload) {

        var cfg = this.config;
        if (cfg.viewMode != "grid") return this;
        var bodyHasMarker = this.bodyHasMarker;
        var getItem = this.getItem.bind(this);
        var getItemMarker = this.getItemMarker.bind(this);
        var getMarkerDisplay = this.getMarkerDisplay.bind(this);
        var markerIndex = 0;
        // bigDataSyncApply
        var scrollContentScrollTop, VS = this.virtualScroll, po = [], item;

        if (VS.scrollTop != (scrollContentScrollTop = this.scrollContent.position().top) || reload) {
            var newStartIndex = (scrollContentScrollTop.abs() / VS.itemTrHeight).ceil() - 6;
            if (newStartIndex < 0) newStartIndex = 0;
            var newEndIndex = newStartIndex + VS.printListCount;
            if (newEndIndex > this.list.length) {
                newEndIndex = this.list.length;
                //newStartIndex = newEndIndex - VS.printListCount - 6; 스크롤 이상발생 포인트
            }

            if (VS.startIndex != newStartIndex || reload) {
                //그리드 내용 다시 구성
                po = [];
                for (var itemIndex = newStartIndex; itemIndex < newEndIndex; itemIndex++) {

                    item = this.list[itemIndex];
                    po.push(getItem(itemIndex, item, "n"));

                    if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                        po.push(getItemMarker(itemIndex, item, "n", markerIndex));
                    }
                }
                this.cachedDom.tbody.empty();
                this.cachedDom.tbody.append(po.join(''));

                // 현재 표시할 아이템 범위 설정
                VS.startIndex = newStartIndex;
                VS.endIndex = newEndIndex;
                VS.scrollTop = scrollContentScrollTop;

                // 셀머지
                if (cfg.mergeCells) {
                    this.mergeCells(this.cachedDom.tbody, "n");
                }

                if (this.hasFixed) {
                    po = [];
                    for (var itemIndex = newStartIndex; itemIndex < newEndIndex; itemIndex++) {
                        item = this.list[itemIndex];
                        po.push(getItem(itemIndex, item, "fix"));
                        if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                            po.push(getItemMarker(itemIndex, item, "fix", markerIndex));
                        }
                    }
                    this.cachedDom.fixed_tbody.empty();
                    this.cachedDom.fixed_tbody.append(po.join(''));
                    //셀머지
                    if (cfg.mergeCells) {
                        this.mergeCells(this.cachedDom.fixed_tbody, "f");
                    }
                }

                this.cachedDom.thpadding.css({height: (newStartIndex) * VS.itemTrHeight}); // 상단패딩증가

                var tfpaddingHeight = cfg.scrollContentBottomMargin.number() + (this.list.length - newEndIndex - 1) * (VS.itemTrHeight);
                if (tfpaddingHeight < cfg.scrollContentBottomMargin.number()) tfpaddingHeight = cfg.scrollContentBottomMargin.number();

                this.cachedDom.tfpadding.css({height: tfpaddingHeight});
                if (this.hasFixed) {
                    this.cachedDom.fthpadding.css({height: (newStartIndex) * VS.itemTrHeight}); // 상단패딩증가
                    this.cachedDom.ftfpadding.css({height: tfpaddingHeight});
                }

                this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOver.bind(this));
                this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOut.bind(this));
                this.body.find(".gridBodyTr").bind("click", this.gridBodyClick.bind(this));

                if (this.needBindDBLClick()) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClick.bind(this));

                // body.onchangeScroll
                if (cfg.body.onchangeScroll) {
                    var sendObj = axf.copyObject(this.virtualScroll);
                    cfg.body.onchangeScroll.call(sendObj, sendObj);
                }
                this.editCellClear();

                if (typeof this.selectedRow != "undefined" && this.selectedRow.length > 0) {
                    var body = this.body;
                    for (var ri = 0; ri < this.selectedRow.length; ri++) {
                        body.find(".gridBodyTr_" + this.selectedRow[ri]).addClass("selected");
                        //body.find(".gridBodyTr_" + this.selectedRow[ri]).find(".bodyTd_" + this.selectedCells[0]).addClass("selected");
                        body.find(".gridBodyTr_" + this.selectedRow[ri]).find(".bodyTd_" + this.selectedCells[0] + ".bodyTdr_0").addClass("selected");
                    }

                    if (typeof reload != "undefined") {
                        var itemIndex = this.selectedRow.last();
                        var itemDom = this.body.find(".gridBodyTr_" + itemIndex);
                        if (itemDom[0]) {
                            var trTop = itemDom.position().top;
                            var scrollHeight = this.scrollContent.height();
                            var bodyHeight = this.body.height();

                            var trHeight = this.body.find(".bodyNullTd").outerHeight().number();

                            if (trTop.number() + trHeight.number() > bodyHeight) {
                                var scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                                this.scrollContent.css({top: (scrollTop - cfg.listCountMargin)});
                                this.contentScrollContentSync({top: (scrollTop - cfg.listCountMargin)});
                            }
                            else {
                                if (trTop.number() == 0) {
                                    var scrollTop = 0;
                                    this.scrollContent.css({top: scrollTop});
                                    this.contentScrollContentSync({top: scrollTop});
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    /**
     * @method AXGrid.scrollTop
     * @param itemIndex {Number} - 스크롤될 아이템 인덱스
     * @description - itemIndex에 스크롤을 이동시킵니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.scrollTop(0);
     * ```
     */
    scrollTop: function (itemIndex) {
        var cfg = this.config;
        if (cfg.__height == "auto") return;
        try {
            var trTop = this.body.find(".gridBodyTr_" + itemIndex).position().top;
            var trHeight = this.body.find(".gridBodyTr_" + itemIndex).height();

            var scrollHeight = this.scrollContent.height();
            var bodyHeight = this.body.height();
            var handleHeight = this.scrollYHandle.outerHeight();
            var trackHeight = this.scrollTrackY.height();

            if (trTop.number() + trHeight.number() > bodyHeight) {
                var scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                if (this.body.height() < scrollHeight) {
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
            }
            else {
                if (trTop.number() == 0) {
                    var scrollTop = 0;
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
            }
        } catch (e) {
            var scrollTop = 0;
            this.scrollContent.css({top: scrollTop});
            this.contentScrollContentSync({top: scrollTop});
        }
    },
    /**
     * @method AXGrid.setFocus
     * @param itemIndex {Number} - 선택될 아이템 인덱스
     * @description - itemIndex에 해당하는 열을 선택 합니다..
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setFocus(0);
     * ```
     */
    setFocus: function (itemIndex) {
        var cfg = this.config, _this = this;

        if (cfg.viewMode == "grid") {

            var c_index = this.selectedCells.first();
            if (this.selectedRow.length > 0) {
                var body = this.body;
                axf.each(this.selectedRow, function (ridx, Row) {
                    body.find(".gridBodyTr_" + Row).removeClass("selected");
                    if (_this.selectedCells.length > 0) {
                        axf.each(_this.selectedCells, function () {
                            body.find(".gridBodyTr_" + Row).find(".bodyTd_" + this).removeClass("selected");
                        });
                    }
                });
            }

            //console.log(this.virtualScroll.startIndex, this.virtualScroll.endIndex, itemIndex);
            this._focusedItemIndex = itemIndex;
            if (this.virtualScroll.startIndex <= itemIndex && this.virtualScroll.endIndex >= itemIndex) {
                this.selectedRow.clear();
                if (itemIndex == 0) itemIndex = '' + itemIndex;

                this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
                this.selectedRow.push(itemIndex);

                if (cfg.mergeCells) { /// mergeCells 이 있는 경우 함께 선택 표시해야할 대상이 있는지 판단 후 처리

                    (function () {
                        var colGroupLen = 0, nowTrTd = this.body.find(".gridBodyTr_" + itemIndex).find("td");
                        for (var i = 0, l = cfg.colGroup.length; i < l; i++) {
                            if (cfg.colGroup[i].display) colGroupLen++;
                        }
                        if (colGroupLen == nowTrTd.length - 1) {
                            // td중에 rowspan이 있는 컬럼이 있는지 체크
                            for (var i = 0, l = nowTrTd.length; i < l; i++) {
                                if (nowTrTd[i].getAttribute("rowspan") > 1) {
                                    for (var ai = 0; ai < nowTrTd[i].getAttribute("rowspan") - 1; ai++) {
                                        this.body.find(".gridBodyTr_" + (Number(itemIndex) + ai + 1)).addClass("selected");
                                        this.selectedRow.push((Number(itemIndex) + ai + 1));
                                    }
                                    break;
                                }
                            }
                        }
                        else {
                            this.selectedRow.clear();
                            // 이가 빠졌음 머지된 컬럼을 검색 (위로 탐색 나올때까지)
                            var finding = true, parentItemIndex = itemIndex, safeLoop = 0;
                            do {
                                parentItemIndex = parentItemIndex - 1;
                                var _nowTrTd = this.body.find(".gridBodyTr_" + (parentItemIndex)).find("td");
                                //console.log(colGroupLen, (_nowTrTd.length - 1), parentItemIndex);
                                if (colGroupLen == _nowTrTd.length - 1) {
                                    for (var i = 0, l = _nowTrTd.length; i < l; i++) {

                                        if (_nowTrTd[i].getAttribute("rowspan") > 1) {
                                            //console.log(_nowTrTd[i].getAttribute("rowspan"));
                                            for (var ai = 0; ai < _nowTrTd[i].getAttribute("rowspan"); ai++) {
                                                this.body.find(".gridBodyTr_" + (Number(parentItemIndex) + ai)).addClass("selected");
                                                this.selectedRow.push((Number(parentItemIndex) + ai));
                                            }
                                            break;
                                        }
                                    }
                                    finding = false;
                                }
                                safeLoop++;
                                if (safeLoop > 1000) finding = false;
                            } while (finding)

                        }
                    }).call(this);
                }

                this.body.find(".gridBodyTr_" + itemIndex).find(".bodyTd_" + c_index + ".bodyTdr_0").addClass("selected");

                var trTop = this.body.find(".gridBodyTr_" + itemIndex).position().top,
                    trHeight = this.body.find(".gridBodyTr_" + itemIndex).height(),
                    scrollHeight = this.scrollContent.height(),
                    bodyHeight = this.body.height(),
                    handleHeight = this.scrollYHandle.outerHeight(),
                    trackHeight = this.scrollTrackY.height(),
                    scrollContentTop = this.scrollContent.position().top, scrollTop;

                if (_this.hasFoot) {
                    bodyHeight -= this.gridFoot.height();
                }

                if (!cfg.body.rowsEmpty) trHeight = cfg.body.rows.length * trHeight;

                //console.log(trTop, scrollContentTop, bodyHeight);
                if (trTop.number() + scrollContentTop < 0) { // 아래에서 위로 포커스 이동
                    scrollTop = -trTop.number();
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
                else if (trTop.number() + trHeight.number() + scrollContentTop > bodyHeight) { // 위에서 아래로 이동
                    scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop});
                }
                else { // 예외처리
                    if (trTop.number() == 0) {
                        scrollTop = 0;
                        this.scrollContent.css({top: scrollTop});
                        this.contentScrollContentSync({top: scrollTop});
                    }
                }

            }
            else {
                if (this.list.length > itemIndex && itemIndex > -1) {

                    if (itemIndex == 0) itemIndex = '' + itemIndex;

                    var scrollHeight = this.scrollContent.height();
                    var bodyHeight = this.body.height();
                    var handleHeight = this.scrollYHandle.outerHeight();
                    var trackHeight = this.scrollTrackY.height();

                    //var scrollTop = bodyHeight - scrollHeight;
                    // itemIndex 에 맞는 scrollTop 구하기
                    var scrollTop = this.virtualScroll.itemTrHeight * itemIndex;
                    if (bodyHeight >= scrollHeight) {
                        scrollTop = 0;
                    }
                    this.scrollContent.css({top: scrollTop});
                    this.contentScrollContentSync({top: scrollTop}, "direct");

                    setTimeout(function () {
                        if (_this.body.find(".gridBodyTr_" + itemIndex).get(0)) {
                            var trTop = _this.body.find(".gridBodyTr_" + itemIndex).position().top;
                            var trHeight = _this.body.find(".gridBodyTr_" + itemIndex).height();

                            if (trTop.number() + trHeight.number() > bodyHeight) {
                                scrollTop = bodyHeight - (trTop.number() + trHeight.number());
                                if (itemIndex == _this.list.length - 1) scrollTop -= 10;
                                _this.scrollContent.css({top: scrollTop});
                                _this.contentScrollContentSync({top: scrollTop}, "direct");
                            }
                            else {
                                if (trTop.number() == 0) {
                                    scrollTop = 0;
                                    _this.scrollContent.css({top: scrollTop});
                                    _this.contentScrollContentSync({top: scrollTop}, "direct");
                                }
                            }

                            _this.selectedRow.clear();
                            _this.selectedRow.push(itemIndex);
                            _this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");

                            if (cfg.mergeCells) { /// mergeCells 이 있는 경우 함께 선택 표시해야할 대상이 있는지 판단 후 처리

                                (function () {
                                    var colGroupLen = 0, nowTrTd = this.body.find(".gridBodyTr_" + itemIndex).find("td");
                                    for (var i = 0, l = cfg.colGroup.length; i < l; i++) {
                                        if (cfg.colGroup[i].display) colGroupLen++;
                                    }
                                    if (colGroupLen == nowTrTd.length - 1) {
                                        // td중에 rowspan이 있는 컬럼이 있는지 체크
                                        for (var i = 0, l = nowTrTd.length; i < l; i++) {
                                            if (nowTrTd[i].getAttribute("rowspan") > 1) {
                                                for (var ai = 0; ai < nowTrTd[i].getAttribute("rowspan") - 1; ai++) {
                                                    this.body.find(".gridBodyTr_" + (Number(itemIndex) + ai + 1)).addClass("selected");
                                                    this.selectedRow.push((Number(itemIndex) + ai + 1));
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        this.selectedRow.clear();
                                        // 이가 빠졌음 머지된 컬럼을 검색 (위로 탐색 나올때까지)
                                        var finding = true, parentItemIndex = itemIndex, safeLoop = 0;
                                        do {
                                            parentItemIndex = parentItemIndex - 1;
                                            var _nowTrTd = this.body.find(".gridBodyTr_" + (parentItemIndex)).find("td");
                                            //console.log(colGroupLen, (_nowTrTd.length - 1), parentItemIndex);
                                            if (colGroupLen == _nowTrTd.length - 1) {
                                                for (var i = 0, l = _nowTrTd.length; i < l; i++) {

                                                    if (_nowTrTd[i].getAttribute("rowspan") > 1) {
                                                        //console.log(_nowTrTd[i].getAttribute("rowspan"));
                                                        for (var ai = 0; ai < _nowTrTd[i].getAttribute("rowspan"); ai++) {
                                                            this.body.find(".gridBodyTr_" + (Number(parentItemIndex) + ai)).addClass("selected");
                                                            this.selectedRow.push((Number(parentItemIndex) + ai));
                                                        }
                                                        break;
                                                    }
                                                }
                                                finding = false;
                                            }
                                            safeLoop++;
                                            if (safeLoop > 1000) finding = false;
                                        } while (finding)

                                    }
                                }).call(_this);
                            }
                        }
                    });

                }
                else {
                    //console.log("out of index");
                    this._focusedItemIndex = undefined;
                }
            }
            this.onevent_grid({type: "grid-list-focus"});
        }
        else if (cfg.viewMode == "icon") {

        }
        else if (cfg.viewMode == "mobile") {

            if (this.selectedCells.length > 0) {
                axf.each(this.selectedCells, function () {
                    axdom("#" + this).removeClass("selected");
                });
                this.selectedCells.clear();
            }
            if (this.selectedRow.length > 0) {
                var body = this.body;
                axf.each(this.selectedRow, function () {
                    body.find(".bodyViewMobile_" + this).removeClass("selected");
                });
            }

            this.selectedRow.clear();
            this.body.find(".bodyViewMobile_" + itemIndex).addClass("selected");
            this.selectedRow.push(itemIndex);

            this.body.find(".bodyViewMobile_" + itemIndex).focus();
        }
    },
    /**
     * @method AXGrid.focusMove
     * @param direction {Number|String} - 정수/음수 또는 L/R
     * @param {Event} - Grid body내부에서 감지되는 이벤트
     * @description - direction 만큼 포커스를 이동 합니다.
     */
    focusMove: function (direction, event) {
        var cfg = this.config, body = this.body;
        var myIndex, my_c, itemIndex;

        if (direction == "L" || direction == "R") {
            if (this.selectedCells.length > 0) {
                myIndex = this.selectedRow.first();
                my_c = this.selectedCells.first();

                if (direction == "L") {
                    my_c = my_c - 1;
                    if (my_c < 0) my_c = 0;
                }
                else {
                    my_c = my_c.number() + 1;
                    if (my_c >= cfg.colGroup.length) my_c = cfg.colGroup.length - 1;
                }

                axf.each(this.selectedCells, function () {
                    body.find(".gridBodyTr_" + myIndex).find(".bodyTd_" + this).removeClass("selected");
                });
                this.selectedCells.clear();

                this.body.find(".gridBodyTr_" + myIndex).find(".bodyTd_" + my_c + ".bodyTdr_0").addClass("selected");
                this.selectedCells.push(my_c);

                this.stopEvent(event);
            }
        }
        else {
            myIndex = this.selectedRow.first();
            if (cfg.mergeCells && this.selectedRow.length > 1 && direction > 0) {
                if (Math.abs(this.selectedRow[0] - this.selectedRow[1]) == 1) { // 인점 선택인 경우
                    myIndex = this.selectedRow.last();
                }
            }
            itemIndex = myIndex.number() + direction;
            /*
             if (itemIndex < 0) itemIndex = this.list.length - 1;
             else if (itemIndex > this.list.length - 1) itemIndex = 0;
             */
            if (itemIndex < 0) itemIndex = 0;
            else if (itemIndex > this.list.length - 1) itemIndex = this.list.length - 1;
            // 사용 할 수 있는 itemIndex를 찾아라

            while (this.list[itemIndex][cfg.reserveKeys.hidden]) {
                if (direction < 0) {
                    itemIndex--;
                    // if (itemIndex < 0) itemIndex = this.list.length - 1;
                    if (itemIndex < 0) itemIndex = 0;
                }
                else {
                    itemIndex++;
                    // if (itemIndex > this.list.length - 1) itemIndex = 0;
                    if (itemIndex > this.list.length - 1) itemIndex = this.list.length - 1;
                }
            }

            this.setFocus(itemIndex);
            this.stopEvent(event);
        }
        return false;
    },
    /**
     * @method AXGrid.getSelectedItem
     * @description - 선택된 행의 index, item 을 가져 옵니다.선택된 행이 없으면 에러 객체를 전달 합니다.
     * @returns {Object} - {index,item} , exception no item selected {error,description}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getSelectedItem();
     * ```
     */
    getSelectedItem: function () {
        var cfg = this.config;
        if (this.selectedRow != undefined && this.selectedRow != null && this.selectedRow.length > 0) {
            if (this.selectedRow.length == 1) {
                return {index: this.selectedRow.first().number(), item: this.list[this.selectedRow.first()]};
            }
            else {
                var selectedList = [], len = this.selectedRow.length;
                for (var i = 0; i < len; i++) {
                    selectedList.push(this.list[this.selectedRow[i]]);
                }
                return {index: this.selectedRow, item: selectedList};
            }
        }
        else {
            return {error: "noselected", description: "선택된 item이 없습니다."};
        }
    },
    /**
     * @method AXGrid.click
     * @param itemIndex {Number} - 선택될 그리드 아이템 인덱스
     * @description - 인덱스에 해당하는 행을 클릭 한 효과를 발생 시킵니다.config 에 body항목의 onclick 지정함수가 있다면 호출 됩니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.click(0);
     * ```
     */
    click: function (itemIndex) {
        var cfg = this.config;
        this.setFocus(itemIndex);

        var item = this.list[itemIndex];

        if (cfg.body.onclick) {

            var sendObj = {
                index: itemIndex,
                list: this.list,
                item: item,
                page: this.page
            };

            try {
                cfg.body.onclick.call(sendObj, itemIndex, item);
            } catch (e) {
                console.log(e);
            }
        }

        // this.stopEvent(event);
    },
    /**
     * @method AXGrid.mergeCells
     * @param tgDom {Object} - 그리드 몸통 객체
     * @param typ {String} - 표현 형식 ("n" normal, "f" fixed)
     * @description - config 내의 옵션에 따라 셀 병합을 실행 합니다.
     */
    mergeCells: function (tgDom, typ) {
        var cfg = this.config;
        // 중복된 셀 머지 함수
        // 1 셀정보 수집
        var rows = [];
        var typn = typ == 'f' ? 'fix' : 'n';
        // 마지막 한줄이 빠지는 경우 발생됨.
        for (var tri = this.virtualScroll.startIndex; tri <= this.virtualScroll.endIndex; tri++) {
            var row = [];
            if (this.list[tri]) {
                for (var tdi = 0; tdi < cfg.colGroup.length; tdi++) {
                    var tdn = cfg.colGroup[tdi].key; //Column Name Variable
                    var item = {
                        tdom: tgDom.find("#" + cfg.targetID + "_AX_" + typn + "body_AX_0_AX_" + tdi + "_AX_" + tri),
                        rowspan: 1
                    };
                    if (cfg.colGroup[tdi] && cfg.colGroup[tdi].display && item.tdom.length == 0) {
                        break; // end loop
                    }
                    else if (!item.tdom.hasClass("bodyNullTd")) {
                        item.html = this.list[tri][tdn];
                        item.tri = tri;
                        item.tdi = tdi;
                        row.push(item);
                    }
                }
                rows.push(row);
            }
        }
        var _val = {};
        if (Object.isArray(cfg.mergeCells)) {
            for (var tri = 0; tri < rows.length; tri++) {
                var isMerge = true;
                for (var mci = 0; mci < cfg.mergeCells.length; mci++) {
                    var tdi;
                    if (rows[tri][(tdi = cfg.mergeCells[mci])]) {
                        if (_val["td_" + tdi]) {
                            if (_val["td_" + tdi].html == rows[tri][tdi].html && isMerge) {
                                rows[_val["td_" + tdi].tri][tdi].rowspan++;
                                rows[tri][tdi].rowspan = 0;
                                isMerge = true;
                            }
                            else {
                                _val["td_" + tdi] = {
                                    tri: tri,
                                    tdi: tdi,
                                    rowspan: 1,
                                    html: rows[tri][tdi].html
                                };
                                isMerge = false;
                            }
                        }
                        else {
                            _val["td_" + tdi] = {
                                tri: tri,
                                tdi: tdi,
                                rowspan: 1,
                                html: rows[tri][tdi].html
                            };
                            isMerge = false;
                        }
                    }
                }
            }
        }
        else {
            for (var tri = 0; tri < rows.length; tri++) {
                for (var tdi = 0; tdi < rows[tri].length; tdi++) {
                    if (_val["td_" + tdi]) {
                        if (_val["td_" + tdi].html == rows[tri][tdi].html) {
                            rows[_val["td_" + tdi].tri][tdi].rowspan++;
                            rows[tri][tdi].rowspan = 0;
                        }
                        else {
                            _val["td_" + tdi] = {
                                tri: tri,
                                tdi: tdi,
                                rowspan: 1,
                                html: rows[tri][tdi].html
                            };
                        }
                    }
                    else {
                        _val["td_" + tdi] = {
                            tri: tri,
                            tdi: tdi,
                            rowspan: 1,
                            html: rows[tri][tdi].html
                        };
                    }
                }
            }
        }
        _val = null;

        if (typ == "n") {
            for (var tri = 0; tri < rows.length; tri++) {
                for (var tdi = 0; tdi < rows[tri].length; tdi++) {
                    if (rows[tri][tdi].rowspan == 0) {
                        rows[tri][tdi].tdom.remove();
                    }
                    else {
                        rows[tri][tdi].tdom.attr("rowspan", rows[tri][tdi].rowspan);
                        //tgDom.find(".gridBodyTr_" + tri).removeAttr("data-mergedBy");
                    }
                }
            }
        }
        else if (typ == "f") {
            for (var tri = 0; tri < rows.length; tri++) {
                for (var tdi = 0; tdi < rows[tri].length; tdi++) {
                    if (rows[tri][tdi].rowspan == 0) {
                        rows[tri][tdi].tdom.remove();
                    }
                    else {
                        rows[tri][tdi].tdom.attr("rowspan", rows[tri][tdi].rowspan);
                        //tgDom.find(".gridBodyTr_" + tri).removeAttr("data-mergedBy");
                        if (tdi > 0 || cfg.fixedColSeq == 0)
                            rows[tri][tdi].tdom.css({height: (this.virtualScroll.itemTrHeight) * rows[tri][tdi].rowspan - 1});
                    }
                }
            }
        }
        rows = null;
        return this;
    },
    // body 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ head & foot 영역
    /**
     * @method AXGrid.getDataSetFormatterValue
     * @param {String} formatter - formatter - config 에서 지정된 표현 형식
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} value - dataSet 객체 가 지니고 있는 값
     * @param {String} key - config colgroup의 key
     * @param {String} CH - config colgroup의 컬럼 객체
     * @description - dataSet의 값을 지정된  formatter에 맞게 가공합니다.
     * @returns {String} result
     */
    getDataSetFormatterValue: function (formatter, dataSet, value, key, CH) {
        var cfg = this.config;
        var result;
        if (formatter == "money") {
            if (value == "" || value == "null" || value == undefined) {
                result = "0";
            }
            else {
                result = value.number().money();
            }
        }
        else if (formatter == "dec") {
            result = (value == undefined) ? "" : value.dec();
        }
        else if (formatter == "html") {
            result = value;
        }
        else if (formatter == "checkbox" || formatter == "radio") {
            result = value;
        }
        else {
            var sendObj = {
                index: null,
                list: this.list,
                item: dataSet,
                dataSet: dataSet,
                page: this.page,
                key: key,
                value: value
            };
            try {
                result = formatter.call(sendObj);
            } catch (e) {
                console.log(e);
            }
        }
        return result;
    },
    /**
     * @method AXGrid.getHeadDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드의 header를 생성 합니다.
     * @returns {String}
     */
    getHeadDataSet: function (dataSet, isfix) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.head.rows.length; r++) {
            var isLastTR = (cfg.head.rows.length - 1 == r);
            tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_head_" + r + "_AX_" + (isfix || "n") + "\">");
            var colCount = 0;

            axf.each(cfg.head.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {

                    if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

                        colCount += CH.colspan;

                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        /*console.log({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount}); */

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "head_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                        /*tpo.push("<div class=\"tdRelBlock\">");*/
                        tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_headText_AX_" + r + "_AX_" + CHidx + "\">");
                        if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                            if (CH.formatter) {
                                tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                            }
                            else {
                                tpo.push(dataSet[CH.key]);
                            }
                        }
                        else {
                            tpo.push("&nbsp;");
                        }
                        tpo.push("</div>");
                        /*tpo.push("</div>");*/
                        tpo.push("</td>");
                    }
                }
            });
            if (r == 0 && isfix == undefined) {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_headnull\" rowspan=\"" + cfg.head.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            }
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getFootDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드의 footer 생성 합니다.
     * @returns {String}
     */
    getFootDataSet: function (dataSet, isfix) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.foot.rows.length; r++) {
            var isLastTR = (cfg.foot.rows.length - 1 == r);
            tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_foot_" + r + "_AX_" + (isfix || "n") + "\">");
            var colCount = 0;

            axf.each(cfg.foot.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (typeof isfix == "undefined" || (typeof isfix != "undefined" && CH.isFixedEndCell)) {

                        colCount += CH.colspan;

                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        /*console.log({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount}); */
                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "foot_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                        /*tpo.push("<div class=\"tdRelBlock\">");*/
                        tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_footText_AX_" + r + "_AX_" + CHidx + "\">");
                        if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                            if (CH.formatter) {
                                tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                            }
                            else {
                                tpo.push(dataSet[CH.key]);
                            }
                        }
                        else {
                            tpo.push("&nbsp;");
                        }
                        tpo.push("</div>");
                        /*tpo.push("</div>");*/
                        tpo.push("</td>");
                    }
                }
            });
            if (r == 0 && isfix == undefined) {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_footnull\" rowspan=\"" + cfg.foot.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            }
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.setDataSet
     * @param {Object} obj - ({key:value})
     * @description - head, foot 속성을 정의한 경우 head, foot 에 값을 표시합니다. 비어있는 객체를 전달할 경우 formatter 연결된 함수에 의해 값이 계산됩니다.
     * @example
     * ```
     *  var myGrid = new AXGrid();
     *  myGrid.setDataSet({price:123000, amount:10});
     *  myGrid.setDataSet({});
     * ```
     */
    setDataSet: function (obj) {
        var cfg = this.config;
        if (obj.ajaxUrl) {

        }
        else {
            if (axdom.isPlainObject(obj)) {
                this.dataSet = obj;
                if (cfg.head) this.printHead();
                if (cfg.foot) {
                    this.printFoot();
                }
                this.contentScrollResize(false);
            }
        }
    },
    /**
     * @method AXGrid.redrawDataSet
     * @description - setDataSet애 의해 dataSet 객체가 변경된 경우 header나 footer를 다시 렌더링 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setDataSet({price:123000, amount:10});
     * myGrid.redrawDataSet();
     * ```
     */
    redrawDataSet: function () {
        var cfg = this.config;
        if (this.dataSet) {
            if (cfg.head) this.printHead();
            if (cfg.foot) this.printFoot();
        }
    },
    /**
     * @method AXGrid.printHead
     * @description - grid의 header를 구성합니다 . (getDataSet)
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setDataSet({price:123000, amount:10});
     * myGrid.printHead();
     * ```
     */
    printHead: function () {
        var cfg = this.config;
        var getDataSet = this.getHeadDataSet.bind(this);
        var po = [];
        po.push(getDataSet(this.dataSet));
        axdom("#" + cfg.targetID + "_AX_thead").html(po.join(''));
        if (this.hasFixed) {
            po = [];
            po.push(getDataSet(this.dataSet, "fix"));
            axdom("#" + cfg.targetID + "_AX_fixedThead").html(po.join(''));
        }
    },
    /**
     * @method AXGrid.printFoot
     * @description - grid의 footer를 구성합니다 . (getDataSet)
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setDataSet({price:123000, amount:10});
     * myGrid.printFoot();
     * ```
     */
    printFoot: function () {
        // todo : foot 출력 방식 변경
        var cfg = this.config,
            tableWidth = this.colWidth,
            getDataSet = this.getFootDataSet.bind(this),
            _tdHeight,
            po = [];

        this.hasFoot = true;

        po.push('<div class="gridFootContent">');
        po.push('<table cellpadding="0" cellspacing="0" class="gridFootTable" style="width:', tableWidth, 'px;">');
        po.push(this.getColGroup("FH"));
        po.push('<tbody>');
        po.push(getDataSet(this.dataSet));
        po.push('</tbody>');
        po.push('</table>');
        po.push('</div>');
        if (this.hasFixed) {
            po.push('<div class="gridFootfixedContent" style="width:' + this.fixedColWidth + 'px;">');
            po.push('<table cellpadding="0" cellspacing="0" class="gridFootTable" style="width:', this.fixedColWidth, 'px;">');
            po.push(this.getColGroup("FF"));
            po.push('<tbody>');
            po.push(getDataSet(this.dataSet, "fix"));
            po.push('</tbody>');
            po.push('</table>');
            po.push('</div>');
        }

        this.gridFoot.html(po.join(''));
        this.gridFoot.show(); // cfg.foot 활성화
        this.gridFoot_content = this.gridFoot.find(".gridFootContent");
        this.gridFoot.css({height: this.gridFoot_content.height()});

        _tdHeight = undefined;

        this.gridFoot.find(".bodyTd").each(function () {
            var td_dom = $(this),
                rowspan = td_dom.attr("rowspan"),
                valign = td_dom.attr("valign"),
                tdHeight;

            if (!rowspan) rowspan = 1;
            if (typeof _tdHeight === "undefined") {
                _tdHeight = td_dom.height() / rowspan;
            }
            tdHeight = _tdHeight * rowspan;

            if (rowspan > 1) {
                td_dom.css({height: tdHeight + 1});
            }
        });

        /// gridFoot 위치 변경으로 gridTargetSetSize 호출 불필요해 짐
        /// this.gridTargetSetSize();
        cfg.scrollContentBottomMargin = this.gridFoot_content.height();
    },
    /* head & foot 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ editor 영역  */
    /**
     * @method AXGrid.getEditorFormatterValue
     * @param {String} formatter - config editor 에서 지정된 표현 형식
     * @param {Object} dataSet - 데이터 객체
     * @param {String} value - dataSet 객체 가 지니고 있는 값
     * @param {String} key - config colgroup의 key
     * @param {String} CH - config colgroup의 컬럼 객체
     * @param {String} idAttr - Editor 타겟 구분 값
     * @description - Editor의 데이터를 formatter에 맞게 가공하여 반환 합니다.
     * @returns {Object|String}
     */
    getEditorFormatterValue: function (formatter, dataSet, value, key, CH, idAttr) {
        var cfg = this.config,
            result, sendObj;

        if (formatter == "money") {
            if (value == "" || value == "null" || value == undefined) {
                result = "0";
            }
            else {
                result = value.number().money();
            }
        }
        else if (formatter == "dec") {
            result = (value == undefined) ? "" : value.dec();
        }
        else if (formatter == "html") {
            result = value;
        }
        else if (formatter == "checkbox" || formatter == "radio") {
            result = value;
        }
        else {
            sendObj = {
                index: null,
                list: this.list,
                item: dataSet,
                dataSet: dataSet,
                page: this.page,
                key: key,
                value: value
            };
            try {
                result = formatter.call(sendObj);
            } catch (e) {
                console.log(e);
            }
        }

        return result;
    },
    /**
     * @method AXGrid.getEditorFormValue
     * @param {Object} form -  config editor rows form에서 지정된 객체
     * @param {Object} dataSet - 데이터 객체
     * @param {String} value - dataSet 객체 가 지니고 있는 값
     * @param {String} key - config colgroup의 key
     * @param {String} CH - config colgroup의 컬럼 객체
     * @param {String} idAttr - Editor 타겟 구분 값
     * @description - Editor의 데이터를 config editor rows form에 정의된 형식에 맞게 반환 합니다.
     * @returns {String}
     */
    getEditorFormValue: function (form, dataSet, value, key, CH, idAttr) {
        var cfg = this.config;
        var paddingRight = cfg.formPaddingRight;
        var result = [];

        var formClass = (form.addClass) ? " " + form.addClass : "";
        var formWidth = (form.width) ? "width:" + form.width + ";" : "width:100%;";
        var formHeight = (form.height) ? "height:" + form.height + ";" : "";
        var formStyle = (form.style) ? form.style : "";
        var formID = (form.id) ? form.id : cfg.targetID + "_AX_" + key + "_AX_" + idAttr;

        var getFormValue = function (formvalue, value) {
            if (formvalue == "itemValue" || formvalue == "itemText") {
                if (typeof value != "undefined" && axdom.isArray(value)) {
                    return value;
                }
                else if (typeof value == "boolean") {
                    return value;
                }
                else if (typeof value == "string") {
                    return value.dec();
                }
                else {
                    return value;
                }
            }
            else if (axdom.isFunction(formvalue)) {
                var sendObj = {
                    key: key,
                    value: value,
                    list: this.list,
                    page: this.page
                };
                return formvalue.call(sendObj, key, value);
            }
            else {
                return formvalue;
            }
        };

        if (form.type == "hidden") {
            /*result.push("<div style=\"padding-right:"+paddingRight+";\">"); */
            result.push("&nbsp;");
            result.push("<input type=\"hidden\" id=\"" + formID + "\" name=\"" + key + "\" value=\"" + getFormValue(form.value, dataSet[key]) + "\" class=\"AXInput" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" />");
            /*result.push("</div>"); */
        }
        else if (form.type == "text") {
            result.push("<div style=\"padding-right:" + paddingRight + ";\">");
            result.push("<input type=\"text\" id=\"" + formID + "\" name=\"" + key + "\" value=\"" + getFormValue(form.value, dataSet[key]) + "\" class=\"AXInput" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" />");
            result.push("</div>");
        }
        else if (form.type == "readonly") {
            result.push("<div style=\"padding-right:" + paddingRight + ";\">");
            result.push("<input type=\"text\" readonly=\"readonly\" id=\"" + formID + "\" name=\"" + key + "\" value=\"" + getFormValue(form.value, dataSet[key]) + "\" class=\"AXInput" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" />");
            result.push("</div>");
        }
        else if (form.type == "textarea") {
            result.push("<div style=\"padding-right:" + paddingRight + ";\">");
            result.push("<textarea id=\"" + formID + "\" name=\"" + key + "\" class=\"AXTextarea" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" >" + getFormValue(form.value, dataSet[key]) + "</textarea>");
            result.push("</div>");
        }
        else if (form.type == "select") {
            var formValue = getFormValue(form.value, dataSet[key]);
            /*console.log({key:key, dataSet_key:dataSet[key], formValue:formValue}); */
            result.push("<div style=\"padding-right:1px;\">");
            result.push("<select id=\"" + formID + "\" name=\"" + key + "\" class=\"AXSelect" + formClass + "\" style=\"" + formWidth + formHeight + formStyle + "\" >");
            if (form.isspace) result.push("<option value=\"\">", (form.isspaceTitle || "").dec(), "</option>");
            axf.each(form.options, function () {
                result.push("<option value=\"" + (this.value || this.optionValue) + "\"");
                if (form.value == "itemText") {
                    if (formValue == (this.text || this.optionText).dec()) result.push(" selected=\"selected\"");
                }
                else {
                    if (formValue == (this.value || this.optionValue)) result.push(" selected=\"selected\"");
                }
                result.push(">" + (this.text || this.optionText).dec() + "</option>");
            });
            result.push("</select>");
            result.push("</div>");
        }
        else if (form.type == "radio") {
            var formValue = getFormValue(form.value, dataSet[key]);
            axf.each(form.options, function (oidx, opt) {
                result.push("<input type=\"radio\" id=\"" + formID + "_AX_" + oidx + "\" name=\"" + key + "\" value=\"" + this.value + "\"");
                if (formValue == this.value) result.push(" checked=\"checked\"");
                result.push("><label for=\"" + formID + "_AX_" + oidx + "\">" + this.text.dec() + "</label><br/>");
            });
        }
        else if (form.type == "checkbox") {
            var formValue = getFormValue(form.value, dataSet[key]);
            axf.each(form.options, function (oidx, opt) {
                result.push("<input type=\"checkbox\" id=\"" + formID + "_AX_" + oidx + "\" name=\"" + key + "\" value=\"" + this.value + "\"");
                if (axdom.isArray(formValue)) {
                    var isChecked = false;
                    var _value = this.value;
                    axf.each(formValue, function () {
                        if (this == _value) {
                            isChecked = true;
                            return false;
                        }
                    });
                    if (isChecked) result.push(" checked=\"checked\"");
                }
                else {
                    if (formValue == this.value) result.push(" checked=\"checked\"");
                }
                result.push("><label for=\"" + formID + "_AX_" + oidx + "\">" + this.text.dec() + "</label><br/>");
            });
        }
        return result.join('');
    },
    /**
     * @method AXGrid.getEditorBody
     * @param {Object} dataSet - 데이터 객체
     * @param {String} isfix - fix option . (AXGrid.hasFixed == true) "fix"
     * @description - 에디터를 생성 합니다.
     * @returns {String}
     */
    getEditorBody: function (dataSet, isfix) {
        var cfg = this.config;
        var getEditorFormatterValue = this.getEditorFormatterValue.bind(this);
        var getEditorFormValue = this.getEditorFormValue.bind(this);
        var tpo = [];
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.editor.rows.length; r++) {
            var isLastTR = (cfg.editor.rows.length - 1 == r);
            tpo.push("<tr class=\"gridBodyTr gridBodyTr_editor\" id=\"" + cfg.targetID + "_AX_editor_" + r + "_AX_" + (isfix || "n") + "\">");
            var colCount = 0;

            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {
                        colCount += CH.colspan;

                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "editor_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
                        /*tpo.push("<div class=\"tdRelBlock\">");*/
                        tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_editorText_AX_" + r + "_AX_" + CHidx + "\">");
                        if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
                            if (CH.form) {
                                tpo.push(getEditorFormValue(CH.form, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx));
                            }
                            else if (CH.formatter) {
                                tpo.push(getEditorFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx, CH.form));
                            }
                            else {
                                tpo.push(dataSet[CH.key]);
                            }
                        }
                        else {
                            tpo.push("&nbsp;");
                        }
                        tpo.push("</div>");
                        /*tpo.push("</div>");*/
                        tpo.push("</td>");
                    }
                }
                else {
                    tpo.push("<td style=\"display:none\">");
                    if (CH.form) {
                        tpo.push(getEditorFormValue(CH.form, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx));
                    }
                    else if (CH.formatter) {
                        tpo.push(getEditorFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH, r + "_AX_" + CHidx, CH.form));
                    }
                    else {
                        tpo.push(dataSet[CH.key]);
                    }
                    tpo.push("</td>");
                }
            });
            if (r == 0 && isfix == undefined) {
                tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_editornull\" rowspan=\"" + cfg.editor.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
            }
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.setEditor
     * @param {Array} item - 삽입될 아이템 데이터
     * @param {Number} itemIndex - 에디터가 가져올 아이템 인덱스
     * @param {Number} insertIndex - 에디터가 삽입될 위치 인덱스
     * @description - 해당하는 인덱스에 에디터를 활성화 합니다.config 내에 editor 관련 항목이 없다면 작동하지 않습니다.
     * @example
     * ```
     *  var myGrid = new AXGrid();
     *  myGrid.setEditor({}, 1);
     *  myGrid.setEditor(null, null, 1);
     * ```
     */
    setEditor: function (item, itemIndex, insertIndex) {
        var cfg = this.config, _this = this, itemTrHeight;

        this.editorItemIndex = null;
        if (!this.hasEditor) {
            alert("setConfig 에 editor 가 설정 되지 않아 요청을 처리 할 수 없습니다.");
            return;
        }
        this.unbindAXbind();
        this.editorButtonPosition = "bottom";

        var dataSet = {};
        if (item) {
            dataSet = item;
        }
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */

        /*setEditor */
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_editorContent\" class=\"editorContent\" style=\"padding-left:1px;\">");
        po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridBodyTable\" style=\"\">");
        po.push(this.getColGroup("EB"));
        /*colGroup 삽입 */
        po.push("<tbody id=\"" + cfg.targetID + "_AX_editor_AX_tbody\">");
        po.push(this.getEditorBody(dataSet));
        po.push("</tbody>");
        po.push("</table>");
        po.push("</div>");
        if (this.hasFixed) {
            po.push("<div id=\"" + cfg.targetID + "_AX_fixedEditorContent\" class=\"fixedEditorContent\" style=\"width:" + this.fixedColWidth + "px;padding-left:1px;\">");
            po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"gridFixedBodyTable\" style=\"width:" + this.fixedColWidth + "px;\">");
            po.push(this.getColGroup("FE"));
            /*colGroup 삽입 */
            po.push("<tbody id=\"" + cfg.targetID + "_AX_editor__AX_fixedTbody\">");
            po.push(this.getEditorBody(dataSet, "fix"));
            po.push("</tbody>");
            po.push("</table>");
            po.push("</div>");
        }
        po.push("<div id=\"" + cfg.targetID + "_AX_editorButtons\" class=\"editorButtons\">");
        po.push("	<input type=\"button\" id=\"" + cfg.targetID + "_AX_editorButtons_AX_save\" value=\"Save\" class=\"AXButtonSmall Classic\" />");
        po.push("	<input type=\"button\" id=\"" + cfg.targetID + "_AX_editorButtons_AX_cancel\" value=\"Cancel\" class=\"AXButtonSmall\" />");
        po.push("</div>");
        this.editor.html(po.join(''));

        if (typeof itemIndex !== "undefined") {

            var scrollTop = this.scrollContent.position().top, list = this.list;

            if (cfg.__height == "auto") {
                var editorTop = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + itemIndex).position().top;
                itemTrHeight = (function () {
                    if (list.length == 0) {
                        return 0;
                    }
                    else if (list.length == 1) {
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + itemIndex).height();
                        return p2;
                    }
                    else if ((list.length - 1) == itemIndex) {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (itemIndex - 1)).position().top;
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + itemIndex).position().top;
                        return p2 - p1;
                    }
                    else {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (itemIndex)).position().top;
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (itemIndex.number() + 1)).position().top;
                        return p2 - p1;
                    }
                })();
            }
            else {
                var editorTop = itemIndex * (itemTrHeight = this.virtualScroll.itemTrHeight);
            }

            this.editor.css({top: editorTop + scrollTop + this.body.position().top});
            this.editorOpend = true;
            this.editorOpenTop = editorTop + this.body.position().top;
            this.editorItemIndex = itemIndex;
            this.editorButtonPosition = "bottom";

            var trTop = -editorTop;

            if (
                editorTop + scrollTop + this.body.position().top > this.body.height() - this.body.position().top &&
                ( this.scrollContent.height() + this.editor.height() - 31 > this.body.height() ) &&
                this.list.length != 0
            ) {
                trTop = this.body.height() - this.scrollContent.height();
                // 에디터 위로 들기
                this.editorButtonPosition = "top";
            }

        }
        else if (typeof insertIndex !== "undefined") {

            var scrollTop = this.scrollContent.position().top, list = this.list;
            ;

            if (cfg.__height == "auto") {
                var editorTop = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).position().top;
                var trHeight = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).outerHeight();
                itemTrHeight = (function () {
                    if (list.length == 0) {
                        return 0;
                    }
                    else if (list.length == 1) {
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).height();
                        return p2;
                    }
                    else if ((list.length - 1) == itemIndex) {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (insertIndex - 1)).position().top;
                        var p2 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + insertIndex).position().top;
                        return p2 - p1;
                    }
                    else {
                        var p1 = axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (insertIndex)).position().top;
                        var p2 = (axdom("#" + cfg.targetID + "_AX_tr_0_AX_n_AX_" + (insertIndex.number() + 1)).position() || 0).top;
                        return p2 - p1;
                    }
                })();
                editorTop += trHeight;
            }
            else {
                var editorTop = insertIndex * (itemTrHeight = this.virtualScroll.itemTrHeight);
            }

            this.editor.css({top: editorTop + this.body.position().top});
            this.editorOpend = true;
            this.editorOpenTop = editorTop;
            this.editorInsertIndex = insertIndex;
            this.editorButtonPosition = "bottom";

            var trTop = -editorTop;

            if (
                trTop.abs() + this.body.height() > this.scrollContent.height() &&
                (this.scrollContent.height() + this.editor.height() - 31 > this.body.height()) &&
                this.list.length > 0
            ) {
                trTop = this.body.height() - this.scrollContent.height();
                // 에디터 위로 들기
                this.editorButtonPosition = "top";
            }

            if (this.body.height() < this.scrollContent.height()) {
                this.scrollContent.css({top: trTop});
                this.contentScrollContentSync({top: trTop});
            }

        }
        else {
            var editorTop = 0, itemTrHeight = this.virtualScroll.itemTrHeight;

            this.editor.css({top: editorTop + this.body.position().top});
            this.editorOpend = true;
            this.editorOpenTop = editorTop;
            this.editorItemIndex = null;
            this.editorButtonPosition = "bottom";
            if (this.body.height() < this.scrollContent.height()) {
                this.scrollContent.css({top: 0});
                this.contentScrollContentSync({top: 0});
            }
        }

        //this.scrollTrackY.before(this.editor); 위치이동 안함. input focus할 때 스크롤 오버 버그 발생
        this.editor.show();
        this.editor.find("input[type=text],textarea").bind("mousedown.AXGrid", function () {
            this.focus();
        });
        this.editor.find("input,textarea,select").bind("focus.AXGrid", function () {
            //console.log("editor focus");
            //console.log(axdom(this).position().left);
        });

        if (cfg.editor.onkeyup) {
            this.editor.find("input[type=text],textarea").unbind("keyup.AXGrid").bind("keyup.AXGrid", function (event) {
                cfg.editor.onkeyup.call({
                    list: _this.list,
                    item: item,
                    element: this
                }, event, this);
            });
        }

        /* form item bind AX */
        for (var r = 0; r < cfg.editor.rows.length; r++) {
            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    var formID = "";
                    if (CH.AXBind) {
                        formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                        if (CH.AXBind.type == "number" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindNumber((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "money" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindMoney((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "selector" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindSelector((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "slider" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindSlider((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "twinSlider" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindTwinSlider((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "date" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindDate((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "twinDate" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindTwinDate((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "dateTime" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindDateTime((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "switch" && CH.form.type == "text") {
                            /*axdom("#"+formID).unbindInput(); */
                            axdom("#" + formID).bindSwitch((CH.AXBind.config || {}));
                        }
                        else if (CH.AXBind.type == "select" && CH.form.type == "select") {
                            /*axdom("#"+formID).unbindSelect(); */
                            axdom("#" + formID).bindSelect((CH.AXBind.config || {}));
                        }
                    }
                    if (CH.form) {
                        formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                        if (CH.form.onChange) {
                            axdom("#" + formID).bind("change", function () {
                                CH.form.onChange.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val(),
                                    text: axf.getId(formID).options[axf.getId(formID).options.selectedIndex].text
                                });
                            });
                        }
                        if (CH.form.onClick) {
                            axdom("#" + formID).bind("click", function () {
                                CH.form.onClick.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val()
                                });
                            });
                        }
                        if (CH.form.onBlur) {
                            axdom("#" + formID).bind("blur", function () {
                                CH.form.onBlur.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val()
                                });
                            });
                        }
                        if (CH.form.onFocus) {
                            axdom("#" + formID).bind("focus", function () {
                                CH.form.onFocus.call({
                                    key: CH.key,
                                    position: CHidx,
                                    value: axdom("#" + formID).val()
                                });
                            });
                        }
                    }
                }
            });
        }

        var editorContent = axdom("#" + cfg.targetID + "_AX_editorContent"),
            fixedEditorContent = axdom("#" + cfg.targetID + "_AX_fixedEditorContent"),
            editorButtons = axdom("#" + cfg.targetID + "_AX_editorButtons");
        var editorContentHeight = editorContent.height();
        var fixedEditorContentHeight = fixedEditorContent.height();
        if (editorContentHeight < fixedEditorContentHeight) {
            editorContentHeight = fixedEditorContentHeight;
            editorContent.find(".gridBodyTable").css({height: editorContentHeight});
        }
        else {
            fixedEditorContent.find(".gridFixedBodyTable").css({height: editorContentHeight});
        }

        editorButtons.css({top: editorContentHeight});
        var editorBoxHeight = editorContentHeight.number();

        if (itemTrHeight > editorContentHeight) {
            editorContentHeight = itemTrHeight;
            editorContent.find(".gridBodyTable").css({height: editorContentHeight});
            fixedEditorContent.find(".gridFixedBodyTable").css({height: editorContentHeight});
            this.editor.css({height: (editorContentHeight.number())});
            editorButtons.css({top: editorContentHeight});
        }

        var scrollLeft = this.scrollContent.position().left;
        editorContent.css({left: scrollLeft});

        if (this.editorButtonPosition == "top") {
            if (insertIndex != undefined) this.editor.css({top: this.editor.position().top - editorContentHeight});
            else this.editor.css({top: this.editor.position().top - editorContentHeight + itemTrHeight});
            editorButtons.addClass("top");
            editorButtons.css({top: -editorButtons.outerHeight() + 1});
        }

        axdom("#" + cfg.targetID + "_AX_editorButtons_AX_save").bind("click", this.saveEditor.bind(this));
        axdom("#" + cfg.targetID + "_AX_editorButtons_AX_cancel").bind("click", this.cancelEditor.bind(this));
    },
    /**
     * @method AXGrid.setEditorForm
     * @param {Object} obj - 삽입될 아이템 데이터
     * @description - 활성화된 에디터에 특정 값을 전달 합니다.
     * @example
     * ```
     * var obj = {
     * 	key : , colgroup 컬럼 key
     * 	position :, 적용될 대상의 배열 순서 [0,0]
     * 	value : , 넘겨줄 값 {String}
     * }
     *
     * var myGrid = new AXGrid();
     *      myGrid.setEditorForm({
     * 	key:"title",
     * 	position:[0,2],
     * 	value:"가나다라"
     * });
     * ```
     */
    setEditorForm: function (obj) {
        var cfg = this.config;
        var formID = cfg.targetID + "_AX_" + obj.key + "_AX_" + obj.position.join("_AX_");
        if (!axf.getId(formID)) alert(formID + "로 Element를 찾을 수 없습니다.");
        axdom("#" + formID).val(obj.value);
    },
    /**
     * @method AXGrid.focusEditorForm
     * @param {String} key - colgroup 컬럼 key
     * @description - 활성화된 에디터의 특정 key 값과 매칭되는 요소를 활성화 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.focusEditorForm("regDate");
     * ```
     */
    focusEditorForm: function (key) { /* editor 활성화 된 폼의 특정 요소에 포커스 주기 */
        var cfg = this.config;
        this.editor.find("input[type=text],textarea").each(function () {
            if (this.name == key) {
                this.focus();
                return false;
            }
        });
    },
    /**
     * @method AXGrid.saveEditor
     * @description - 에디터의 내용을 저장하고 리스트에 반영 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.saveEditor();
     * ```
     */
    saveEditor: function () {
        var cfg = this.config;

        var editorFormItem = {};
        if (this.editorItemIndex == null) {
            editorFormItem.requestType = "new";
        }
        else {
            editorFormItem.requestType = "edit";
        }

        var setEditorFormItemValue = function (k, v, type) {
            if (editorFormItem[k]) {
                if (type == "checkbox") {
                    if (Object.isArray(editorFormItem[k])) {
                        editorFormItem[k].push(v);
                    }
                    else {
                        editorFormItem[k] = [editorFormItem[k]];
                        editorFormItem[k].push(v);
                    }
                }
                else {
                    editorFormItem[k] = v;
                }
            }
            else {
                editorFormItem[k] = v;
            }
        };

        for (var r = 0; r < cfg.editor.rows.length; r++) {
            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.form) {
                    var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                    if (CH.form.type == "radio") {
                        var checkedValue = [];
                        axf.each(CH.form.options, function (oidx, opt) {
                            var opt_formID = formID + "_AX_" + oidx;
                            if (axdom("#" + opt_formID).get(0).checked) setEditorFormItemValue(CH.key, axdom("#" + opt_formID).val(), "radio");
                            //editorFormItem.push(CH.key + "=" + axdom("#" + opt_formID).val().enc());
                        });
                    }
                    else if (CH.form.type == "checkbox") {
                        var checkedValue = [];
                        axf.each(CH.form.options, function (oidx, opt) {
                            var opt_formID = formID + "_AX_" + oidx;
                            if (axdom("#" + opt_formID).get(0).checked) setEditorFormItemValue(CH.key, axdom("#" + opt_formID).val(), "checkbox");
                            else setEditorFormItemValue(CH.key, "", "checkbox");
                        });
                    }
                    else if (CH.form.type == "select") {
                        if (CH.form.value == "itemText") {
                            setEditorFormItemValue(CH.key, axf.getId(formID).options[axf.getId(formID).options.selectedIndex].text, "select");
                        }
                        else {
                            setEditorFormItemValue(CH.key, axdom("#" + formID).val(), "select");
                        }
                    }
                    else {
                        setEditorFormItemValue(CH.key, axdom("#" + formID).val(), "text");
                    }
                }
                else {
                    var formID = cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                    if (axf.getId(formID)) {
                        setEditorFormItemValue(CH.key, axdom("#" + formID).val(), "text");
                    }
                }
            });
        }

        /* form validate -- s */
        var validate = function (formID, CH) {
            var checkedValues = [];
            var value;

            if (CH.form.type == "radio") {
                axf.each(CH.form.options, function (oidx, opt) {
                    var opt_formID = formID + "_AX_" + oidx;
                    if (axdom("#" + opt_formID).get(0).checked) checkedValues.push(axdom("#" + opt_formID).val());
                });
                value = checkedValues.join(",");
            }
            else if (CH.form.type == "checkbox") {
                axf.each(CH.form.options, function (oidx, opt) {
                    var opt_formID = formID + "_AX_" + oidx;
                    if (axdom("#" + opt_formID).get(0).checked) checkedValues.push(axdom("#" + opt_formID).val());
                    else checkedValues.push(CH.key + "=");
                });
                value = checkedValues.join(",");
            }
            else if (CH.form.type == "select") {
                if (CH.form.value == "itemText") {
                    value = axf.getId(formID).options[axf.getId(formID).options.selectedIndex].text;
                }
                else {
                    value = axdom("#" + formID).val();
                }
            }
            else {
                value = axdom("#" + formID).val().trim();
            }
            var sendObj = {
                formID: formID,
                value: value,
                checkedValues: checkedValues,
                form: CH.form
            };
            return CH.form.validate.call(sendObj, formID, value);
        };

        var validateError = false;
        for (var r = 0; r < cfg.editor.rows.length; r++) {
            /*console.log(cfg.editor.rows[r]);*/
            axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                if (CH.form) {
                    if (CH.form.validate) {
                        var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                        var result = validate(formID, CH);
                        if (!result) {
                            validateError = true;
                            axdom("#" + formID).focus();
                        }
                    }
                }
            });
        }

        if (validateError) {
            return;
        }
        /* form validate -- e */

        if (cfg.editor.request) {
            this.unbindAXbind();

            var po = [];
            po.push("<div class=\"editorContent\" style=\"background:#fff;\">");
            po.push("<div class=\"AXLoading\"></div>");
            po.push("</div>");
            this.editor.html(po.join(''));

            var saveEditorRequest = this.saveEditorRequest.bind(this);
            var cancelEditor = this.cancelEditor.bind(this);
            var ajax = cfg.editor.request, url = ajax.ajaxUrl;
            var formPars = [];
            axf.each(editorFormItem, function (k, v) {
                formPars.push(k + "=" + v.enc());
            });
            if (Object.isString(obj.ajaxPars)) {
                formPars.push(obj.ajaxPars);
            }
            else if (Object.isObject(obj.ajaxPars)) {
                formPars.push(axdom.param(obj.ajaxPars));
            }
            var pars = formPars.join('&');

            var _method = "post";
            var _contentType = AXConfig.AXReq.contentType;
            var _headers = {};
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;

            if (ajax.method) _method = ajax.method;
            if (ajax.contentType) _contentType = ajax.contentType;
            if (ajax.headers) _headers = ajax.headers;

            new AXReq(url, {
                type: _method,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                headers: _headers,
                debug: ajax.debug,
                pars: pars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
                        saveEditorRequest(res);
                    }
                    else {
                        toast.push({body: res.msg.dec(), type: "Caution"});
                        cancelEditor();
                    }
                },
                onerr: function (res) {
                    //toast.push({ body: res.msg.dec(), type: "Caution" });
                    if (cfg.editor.response) { /*  */
                        var sendObj = {
                            error: true,
                            res: res,
                            index: this.editorItemIndex,
                            insertIndex: this.editorInsertIndex,
                            list: this.list,
                            page: this.page
                        };
                        cfg.editor.response.call(sendObj, this.editorItemIndex);
                    }
                    cancelEditor();
                }
            });

            return true;

        }
        else {

            /*
             var po = [];
             po.push("<div class=\"editorContent\" id=\"\" style=\"background:#fff;\">");
             po.push("<div class=\"editorContent AXLoading\"></div>");
             po.push("</div>");
             this.editor.append(po.join(''));
             */

            // -------------- editor response 에서 return false 가 오는 상황을 고려 하면 사용
            //this.editor.hide();
            //this.editorOpend = false;

            var saveEditorRequest = this.saveEditorRequest.bind(this);
            var cancelEditor = this.cancelEditor.bind(this);
            saveEditorRequest({item: editorFormItem});

        }
    },
    /**
     * @method AXGrid.saveEditorRequest
     * @param {Object} res - editorFormItem
     * @description - config editor 항목에 request가 설정 되었을경우 서버 연동 처리를 합니다 response설정으로 예외 처리를 합니다.
     */
    saveEditorRequest: function (res) {
        var cfg = this.config;

        if (this.editorOpend) {
            /*this.editorItemIndex */
            /* this.list[n] 에 서버로 부터 받은 값 덮어쓰기 */
            if (cfg.editor.response) { /*  */

                var sendObj = {
                    res: res,
                    index: this.editorItemIndex,
                    insertIndex: this.editorInsertIndex,
                    list: this.list,
                    page: this.page
                };
                var callResult = cfg.editor.response.call(sendObj, this.editorItemIndex);

                /*
                 // -------------- editor response 에서 return false 가 오는 상황을 고려 하면 사용
                 if(callResult === true){
                 this.editorOpend = false;
                 this.unbindAXbind();
                 }else{
                 this.editor.show();
                 this.editorOpend = true;
                 }
                 */

            }
            else {

                this.unbindAXbind();
                if (this.editorItemIndex != null && this.editorItemIndex != undefined) {
                    AXUtil.overwriteObject(this.list[this.editorItemIndex], res.item, true);
                    this.updateList(this.editorItemIndex, this.list[this.editorItemIndex]);
                }
                else if (this.editorInsertIndex != null && this.editorInsertIndex != undefined) {
                    this.pushList(res.item, this.editorInsertIndex);
                }
                else {
                    this.pushList(res.item);
                }
                this.editorItemIndex = null;
                this.editorInsertIndex = null;
                this.editor.hide();
                this.editorOpend = false;
            }

        }
    },
    /**
     * @method AXGrid.cancelEditor
     * @description - 활성화된 에디터를 해제 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.cancelEditor();
     * ```
     */
    cancelEditor: function () {
        this.editor.hide();
        this.editorOpend = false;
        this.unbindAXbind();
    },
    /**
     * @method AXGrid.unbindAXbind
     * @description - 에디터내부 요소에 부여된 특성을 해제 합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.unbindAXbind();
     * ```
     */
    unbindAXbind: function () {
        var cfg = this.config;
        try {
            if (cfg.editor && cfg.editor.rows) {
                for (var r = 0; r < cfg.editor.rows.length; r++) {
                    axf.each(cfg.editor.rows[r], function (CHidx, CH) {
                        if (CH.display && CH.colspan > 0) {

                            if (CH.AXBind) {
                                var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + r + "_AX_" + CHidx;
                                /*console.log(formID); */
                                if (CH.AXBind.type == "number" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "money" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "selector" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "slider" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "twinSlider" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "date" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "twinDate" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "dateTime" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "switch" && CH.form.type == "text") {
                                    axdom("#" + formID).unbindInput();
                                }
                                else if (CH.AXBind.type == "select" && CH.form.type == "select") {
                                    axdom("#" + formID).unbindSelect();
                                }
                            }
                        }
                    });
                }
            }
        } catch (e) {
            console.log(e);
        }
    },
    /**
     * @method AXGrid.appendList
     * @param {Object} item - item dataset
     * @param {Number} insertIndex - 삽입 대상 index
     * @description - 그리드에 신규 데이터를 삽입하기 위해 삽입용 에디터를 활성화 하여 줍니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * var item = {};
     * myGrid.appendList(item);
     * myGrid.appendList(item, 3);
     * ```
     */
    appendList: function (item, insertIndex) {
        if (insertIndex >= this.list.length) insertIndex = this.list.length;
        this.setEditor(item, undefined, insertIndex);
    },
    /* editor 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /**
     * @method AXGrid.setMobileTool
     * @description - 출력 대상이 모바일일 경우 모바일용 page indicator를 생성합니다.
     * @returns {String}
     */
    setMobileTool: function () {
        var cfg = this.config, _this = this;

        var toolGroupTop = axdom("#" + cfg.targetID + "_AX_gridToolGroupTop");
        var toolGroupBottom = axdom("#" + cfg.targetID + "_AX_gridToolGroupBottom");

        var po = [];
        po.push('<a name="' + cfg.targetID + '_AX_top"></a>');
        po.push('<a class="tool-config"><span class="displayNone">congif</span></a>');
        if (cfg.page) {
            if (cfg.page.paging) {
                po.push('<div class="tool-pageGroup">');
                po.push('<a class="tool-prevPage"><span class="displayNone">prev</span></a>');
                po.push('<div class="tool-pageNo"><span id="' + cfg.targetID + '_AX_gridToolTopPageNoDisplay"></span><select id="' + cfg.targetID + '_AX_gridToolTopPageNo"></select></div>');
                po.push('<a class="tool-nextPage"><span class="displayNone">next</span></a>');
                po.push('</div>');
            }
        }
        po.push('<a href="#' + cfg.targetID + '_AX_bottom" class="tool-gotoTop"><span class="displayNone">top</span></a>');
        toolGroupTop.empty();
        toolGroupTop.append(po.join(''));

        po = [];
        po.push('<a name="' + cfg.targetID + '_AX_bottom"></a>');
        po.push('<a class="tool-config"><span class="displayNone">congif</span></a>');
        if (cfg.page) {
            if (cfg.page.paging) {
                po.push('<div class="tool-pageGroup">');
                po.push('<a class="tool-prevPage"><span class="displayNone">prev</span></a>');
                po.push('<div class="tool-pageNo"><span id="' + cfg.targetID + '_AX_gridToolBottomPageNoDisplay"></span><select id="' + cfg.targetID + '_AX_gridToolBottomPageNo"></select></div>');
                po.push('<a class="tool-nextPage"><span class="displayNone">next</span></a>');
                po.push('</div>');
            }
        }
        po.push('<a href="#' + cfg.targetID + '_AX_top" class="tool-gotoBottom"><span class="displayNone">bottom</span></a>');
        toolGroupBottom.empty();
        toolGroupBottom.append(po.join(''));

        var pgCount = this.page.pageCount.number();
        var pageNo = this.page.pageNo.number();

        if (cfg.page) {
            if (cfg.page.paging) {
                if (pgCount == 0) {
                    po = [];
                    po.push("<option value=\"\">..</option>");
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").html(po.join(''));
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNoDisplay").html(po.join(''));
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").html(po.join(''));
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNoDisplay").html(po.join(''));
                }
                else {
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").html("");
                    axdom("#" + cfg.targetID + "_AX_gridToolTopPageNoDisplay").html(pageNo);
                    var mySelect = axf.getId(cfg.targetID + "_AX_gridToolTopPageNo");
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").html("");
                    axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNoDisplay").html(pageNo);
                    var mySelectBottom = axf.getId(cfg.targetID + "_AX_gridToolBottomPageNo");
                    var oi = 0;
                    for (var p = 1; p < pgCount + 1; p++) {
                        mySelect.options[oi] = new Option(p, p.money());
                        mySelectBottom.options[oi] = new Option(p, p.money());
                        if (pageNo == p) {
                            mySelect.options[oi].selected = true;
                            mySelectBottom.options[oi].selected = true;
                        }
                        oi++;
                    }
                }

                axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").bind("change", this.onPageChange.bind(this));
                axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").bind("change", this.onPageChange.bind(this));

                /* page event bind */
                var goPageMove = this.goPageMove.bind(this);
                toolGroupTop.find(".tool-prevPage").bind("click", function (event) {
                    goPageMove(-1);
                });
                toolGroupBottom.find(".tool-prevPage").bind("click", function (event) {
                    goPageMove(-1);
                });
                toolGroupTop.find(".tool-nextPage").bind("click", function (event) {
                    goPageMove(1);
                });
                toolGroupBottom.find(".tool-nextPage").bind("click", function (event) {
                    goPageMove(1);
                });
                /* page event bind */

            }

            var openMobileConfig = this.openMobileConfig.bind(this);
            toolGroupTop.find(".tool-config").bind("click", function (event) {
                openMobileConfig(event);
            });
            toolGroupBottom.find(".tool-config").bind("click", function (event) {
                openMobileConfig(event);
            });
        }
    },
    /**
     * @method AXGrid.setPaging
     * @description - 그리드 하단 page indicator를 생성합니다.
     * @returns {String}
     */
    setPaging: function () {
        var cfg = this.config;
        if (cfg.viewMode == "mobile") {
            this.setMobileTool();
            return this;
        }
        else {
            axdom("#" + cfg.targetID + "_AX_gridToolGroupTop").empty();
            axdom("#" + cfg.targetID + "_AX_gridToolGroupBottom").empty();
        }

        /* apply page vars */
        var pageNos = axf.getId(cfg.targetID + "_AX_gridPageNo");
        var pgCount = this.page.pageCount.number();
        var pageNo = this.page.pageNo.number();

        if (pgCount === 0) {
            var po = [];
            po.push("<option value=\"\">..</option>");
            axdom("#" + cfg.targetID + "_AX_gridPageNo").html(po.join(''));
        }
        else {
            axdom("#" + cfg.targetID + "_AX_gridPageNo").html("");
            var mySelect = axf.getId(cfg.targetID + "_AX_gridPageNo");
            if (pgCount > 1000) {
                var oi = 0;
                var pageStart = 1;
                var pageEnd = pageNo + 49;
                if (pageNo > 50) pageStart = pageNo - 50;
                if (pageEnd > pgCount) pageEnd = pgCount;
                for (var p = pageStart; p < pageEnd + 1; p++) {
                    mySelect.options[oi] = new Option(p, p.money());
                    if (pageNo == p) mySelect.options[oi].selected = true;
                    oi++;
                }
            }
            else {
                var oi = 0;
                for (var p = 1; p < pgCount + 1; p++) {
                    mySelect.options[oi] = new Option(p, p.money());
                    if (pageNo == p) mySelect.options[oi].selected = true;
                    oi++;
                }
            }
        }
        axdom("#" + cfg.targetID + "_AX_gridPageCount").html("/ " + pgCount.money() + " " + cfg.pageCountMSG);

        if (this.page.listCount.number() == 0) this.page.listCount = this.list.length;
        axdom("#" + cfg.targetID + "_AX_gridStatus").html(cfg.listCountMSG.replace("{listCount}", this.page.listCount.number().money()));

        if (this.isMobile) {
            axdom("#" + cfg.targetID + "_AX_gridPageNo").bind("change", this.onPageChange.bind(this));
        }
        else {
            var onPageChange = this.onPageChange.bind(this);
            axdom("#" + cfg.targetID + "_AX_gridPageNo").bindSelect({
                onchange: function (arg) {
                    onPageChange();
                }
            });
        }
    },
    /**
     * @method AXGrid.goPageMove
     * @param pageAdd {Number} - 이동할 페이지 증/감(-) 수
     * @description - pageAdd 만큼 페이지를 이동합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.goPageMove(-1);
     * ```
     */
    goPageMove: function (pageAdd) {
        var cfg = this.config;

        if (this.page.pageCount.number() > 0) {
            var pgCount = this.page.pageCount.number();
            var pageNo = this.page.pageNo.number();

            if (pageNo + pageAdd < 1) {
                return false;
            }
            else if (pageNo + pageAdd > pgCount) {
                return false;
            }
            else {
                pageNo += pageAdd;
            }

            if (cfg.viewMode == "mobile") {
                axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").val(pageNo);
                axdom("#" + cfg.targetID + "_AX_gridToolBottomPageNo").val(pageNo);
                this.onPageChange();
            }
            else {
                axdom("#" + cfg.targetID + "_AX_gridPageNo").setValueSelect(pageNo);
            }
        }
        /*this.page.pageNo = pageNo; */
        /*this.onPageChange(); bindSelectSetValue 시 자동 호출되는 구조 */
    },
    /**
     * @method AXGrid.onPageChange
     * @param e {Event} - change 이벤트
     * @description - 페이지 이동시 호출 됩니다.
     */
    onPageChange: function (e) {
        var cfg = this.config;
        var pgCount, pageNo, npageNo;
        pgCount = this.page.pageCount.number();
        pageNo = this.page.pageNo.number();

        if (cfg.viewMode == "mobile") {
            npageNo = (e) ? e.target.value : axdom("#" + cfg.targetID + "_AX_gridToolTopPageNo").val();
        }
        else {
            npageNo = axdom("#" + cfg.targetID + "_AX_gridPageNo").val();
        }
        this.page.pageNo = npageNo;

        if (this.page.onchange) {
            this.page.onchange.call(this.page, npageNo);
        }
        else {

            /*스크롤 위치 변경 */
            if (cfg.viewMode != "mobile") {

                var scrollTop = 0;
                this.scrollContent.css({top: scrollTop});
                this.contentScrollContentSync({top: scrollTop});

                if (this.pageActive && this.ajaxInfo) {
                    this.setList(this.ajaxInfo, this.ajax_sortDisable, null, "paging");
                    this.contentScrollResize();
                }
            }
            else {
                if (this.pageActive && this.ajaxInfo) {
                    this.setList(this.ajaxInfo, this.ajax_sortDisable, null, "paging");
                }
            }
        }
    },
    /**
     * @method AXGrid.setStatus
     * @param listLength {Number} - 그리드 리스트 아이템 갯수(length)
     * @description - 그리드 리스트 아이템 갯수(length)를 표시 합니다.
     * @returns {String}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.setStatus(myGrid.list.length);
     * ```
     */
    setStatus: function (listLength) {
        var cfg = this.config, listCount;

        if (typeof listLength !== "undefined") {
            listCount = listLength;
        }
        else {
            var page;
            if (this.page) page = this.page;
            listCount = (page.listCount || 0);
        }

        axdom("#" + cfg.targetID + "_AX_gridStatus").html(cfg.listCountMSG.replace("{listCount}", listCount.number().money()));
    },
    /**
     * @method AXGrid.getSortParam
     * @param {String} ty - 출력옵션 "one" 으로 요청시 String 형태로, 미 지정시 Object 형태로 반환
     * @description - 정렬옵션을 반환 합니다.
     * @returns {String|Object}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getSortParam();
     *
     * // return value
     * {
	 * sortKey:"" , -  정렬 기준 key
	 * sortWay:""   -  정렬 방법 "asc" or "desc"
	 * }
     * ```
     */
    getSortParam: function (ty) {
        var cfg = this.config;
        var sortObj = this.nowSortHeadObj;
        if (sortObj) {
            if (ty == "one") {
                return "sortBy=" + sortObj.key + " " + sortObj.sort;
            }
            else {
                return axdom.param({sortKey: sortObj.key, sortWay: sortObj.sort});
            }
        }
        else {
            return "";
        }
    },
    /**
     * @method AXGrid.getExcelColHeadTd
     * @param {Object} arg
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 컬럼 해더를 생성 합니다.
     * @returns {String}
     * @example
     *```
     * var arg = {
     *     valign,  - valign 옵션
     *     rowspan, - rowspan 옵션
     *     colspan, - colspan 옵션
     *     align,   - align 옵션
     *     colSeq,  - config colgroup 내부 순서
     *     formatter, - config colgroup에서 지정된 formatter
     *     sort,  - 정렬 옵션
     *     tdHtml, - config colgroup 지정된 label
     *     displayLabel - Label이 지정된 경우 출력 여부. 기본적으로 사용시 false 로 셋팅됨. colgroup 에서 따로 지정하지 않기 때문에,,
     * }
     *```
     */
    getExcelColHeadTd: function (arg, filter) {
        var cfg = this.config;
        var po = [];

        if (filter) {
            if (!filter.call(cfg.colGroup[arg.colSeq])) return '';
        }
        if (arg.formatter == "html" || arg.formatter == "checkbox") {
            if (!arg.displayLabel) {
                colHeadTdText = " colHeadTdHtml";
                toolUse = false;
                if (arg.formatter == "checkbox") {
                    colHeadTdText = " colHeadTdCheck";
                    //arg.tdHtml = "<input type=\"checkbox\" name=\"checkAll\" />";
                }
            }
        }

        po.push("<td" + arg.valign + arg.rowspan + arg.colspan + ">");
        po.push(arg.tdHtml);
        po.push("</td>");

        return po.join('');
    },
    /**
     * @method AXGrid.getExcelItem
     * @param {Number} itemIndex - 그리드 리스트중 대상 index
     * @param {Object} item - 그리드 리스트중 index 데이타
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 리스트 데이터를 변환 합니다.
     * @returns {String}
     */
    getExcelItem: function (itemIndex, item, filter) {
        var cfg = this.config;
        var tpo = [];
        var _this = this;
        var evenClassName = "line" + (itemIndex % 2);
        var getFormatterValue = this.getFormatterValue.bind(this);
        var getTooltipValue = this.getTooltipValue.bind(this);
        var trAddClass = "";

        for (var r = 0; r < cfg.body.rows.length; r++) {
            tpo.push("<tr>");
            cfg.body.rows[r].forEach(function (CH, CHidx) {

                //console.log(CH, CHidx);
                var result = "";
                if (CH.display && CH.colspan > 0) {
                    if (filter && !filter.call(CH)) {

                    }
                    else {
                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan='" + CH.rowspan + "'" : "";
                        var colspan = (CH.colspan > 1) ? " colspan='" + CH.colspan + "'" : "";
                        var valign = " valign='" + CH.valign + "' style='vertical-align:" + CH.valign + ";mso-number-format:\\@ ;'";

                        var bodyNodeClass = "";

                        var tooltipValue = "";
                        if (CH.tooltip) {
                            tooltipValue = getTooltipValue(CH.tooltip, item, itemIndex, item[CH.key], CH.key, CH);
                        }

                        tpo.push("<td" + valign + rowspan + colspan + ">");
                        if (CH.formatter) {
                            if (Object.isFunction(CH.formatter)) {
                                var sendObj = {
                                    index: itemIndex,
                                    list: this.list,
                                    item: item,
                                    page: this.page,
                                    key: CH.key,
                                    value: item[CH.key] || ""
                                };
                                result = CH.formatter.call(sendObj, itemIndex, item);
                                result = ("" + result).delHtml();
                            }
                            else if (Object.isString(CH.formatter) && (CH.formatter in _this.formatter)) {
                                if (CH.formatter == "checkbox") {
                                    result = item[CH.key];
                                } else {
                                    result = _this.formatter[CH.formatter].call(_this, CH.formatter, item, itemIndex, item[CH.key], CH.key, CH, CHidx);
                                }
                            }
                            else {
                                result = _this.formatter[CH.formatter].call(_this, CH.formatter, item, itemIndex, item[CH.key], CH.key, CH, CHidx);
                            }
                            //tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
                            tpo.push((result || ""));
                        }
                        else {
                            tpo.push((item[CH.key] || ""));
                        }
                        tpo.push("</td>");
                    }
                }
            });
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getExcelItemMarker
     * @param {Number} itemIndex - 그리드 리스트중 대상 index
     * @param {Object} item - 그리드 리스트중 index 데이타
     * @param {String} isfix - isfix {String} - fix option .
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 maker 데이터가 존재시 처리 합니다.
     * @returns {String}
     */
    getExcelItemMarker: function (itemIndex, item, isfix, filter, markerIndexs) {
        var cfg = this.config;
        var tpo = [];
        var evenClassName = "gridBodyMarker";
        var getFormatterValue = this.getFormatterValue.bind(this);

        for (var mi = 0, l = markerIndexs.length, markerIndex; mi < l; mi++) {
            var marker = cfg.body.marker[markerIndexs[mi]];
            for (var r = 0; r < marker.rows.length; r++) {
                var isLastTR = (marker.rows.length - 1 == r);
                tpo.push("<tr>");
                axf.each(marker.rows[r], function (CHidx, CH) {
                    if (CH.display && CH.colspan > 0) {
                        if (filter && !filter.call(CH)) {

                        }
                        else {
                            /*radio, check exception */
                            var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                            var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                            var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";

                            tpo.push("<td" + valign + rowspan + colspan + ">");
                            if (CH.formatter) {
                                tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
                            }
                            else {
                                tpo.push(item[CH.key]);
                            }
                            tpo.push("</td>");
                        }
                    }
                });
                tpo.push("</tr>");
            }
        }

        return tpo.join('');
    },

    /**
     * @method AXGrid.getExcelHeadDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 header 데이터가 존재시 처리 합니다.
     * @returns {String}
     */
    getExcelHeadDataSet: function (dataSet, isfix, filter) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */

        for (var r = 0; r < cfg.head.rows.length; r++) {
            var isLastTR = (cfg.head.rows.length - 1 == r);
            tpo.push("<tr>");
            var colCount = 0;

            axf.each(cfg.head.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (filter && !filter.call(CH)) {

                    }
                    else {
                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + ">");
                        if (CH.formatter) {
                            tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                        }
                        else {
                            tpo.push(dataSet[CH.key]);
                        }
                        tpo.push("</td>");
                    }
                }
            });
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getExcelFootDataSet
     * @param {Object} dataSet - setDataSet 메소드에 전달된 데이터 객체
     * @param {String} isfix - "fix","n" 고정 형태
     * @description - 그리드 내용을 엑셀 포맷(html)으로 변환시 footer 데이터가 존재시 처리 합니다.
     * @returns {String}
     */
    getExcelFootDataSet: function (dataSet, isfix, filter) {
        var cfg = this.config;
        if (dataSet == undefined) return;
        var tpo = [];
        var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
        /*dataSet 빈 Key 채우기 */
        axf.each(cfg.colGroup, function () {
            if (dataSet[this.key] == undefined) dataSet[this.key] = "";
        });
        /*dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~ */
        var hasFixed = this.hasFixed;

        for (var r = 0; r < cfg.foot.rows.length; r++) {
            var isLastTR = (cfg.foot.rows.length - 1 == r);
            tpo.push("<tr>");
            axf.each(cfg.foot.rows[r], function (CHidx, CH) {
                if (CH.display && CH.colspan > 0) {
                    if (filter && !filter.call(CH)) {

                    }
                    else {
                        /*radio, check exception */
                        var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
                        var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
                        var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
                        var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
                        var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

                        var bodyNodeClass = "";
                        if (CH.formatter == "checkbox" || CH.formatter == "radio") bodyNodeClass = " bodyTdCheckBox";
                        else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

                        tpo.push("<td" + valign + rowspan + colspan + ">");
                        if (CH.formatter) {
                            tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
                        }
                        else {
                            tpo.push(dataSet[CH.key]);
                        }
                        tpo.push("</td>");
                    }
                }
            });
            tpo.push("</tr>");
        }
        return tpo.join('');
    },
    /**
     * @method AXGrid.getExcelFormat
     * @param {String} format - "html","json" 변환 옵션
     * @param {Function} [filter] - "html" 인 경우 filter 옵션으로 표현하고 싶은 열을 선택할 수 있습니다.
     * @description -  format에 맞춰 그리드의 내용을 엑셀 포맷으로 변환 합니다.
     * @returns {String|Object}
     * @example
     * ```
     * var txt = myGrid.getExcelFormat("html");
     * var txt = myGrid.getExcelFormat("html", function(){
     *  // colGroup item => this
     *  return this.key != 'no'; // key가 no가 아님 컬럼만 출력
     * );
     * var json = myGrid.getExcelFormat("json");
     * ```
     */
    getExcelFormat: function (format, filter) {
        var cfg = this.config;
        var getExcelColHeadTd = this.getExcelColHeadTd.bind(this);

        var bodyHasMarker = this.bodyHasMarker;
        var getExcelItem = this.getExcelItem.bind(this);
        var getExcelItemMarker = this.getExcelItemMarker.bind(this);
        var getMarkerDisplay = this.getMarkerDisplay.bind(this);
        var markerIndex;
        var getHeadDataSet = this.getExcelHeadDataSet.bind(this);
        var getFootDataSet = this.getExcelFootDataSet.bind(this);

        var po = [];

        if (format == "html") {

            po.push("<table border='1'>");
            po.push("	<thead>");
            for (var r = 0; r < cfg.colHead.rows.length; r++) {
                var isLastTR = (cfg.colHead.rows.length - 1 == r);
                po.push("<tr>");
                axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
                    if (CH.display && CH.colspan > 0) {

                        var tdHtml = CH.label || "untitle";
                        var rowspan = (CH.rowspan > 1) ? " rowspan='" + CH.rowspan + "'" : "";
                        var colspan = (CH.colspan > 1) ? " colspan='" + CH.colspan + "'" : "";
                        var valign = " valign='" + CH.valign + "'";

                        po.push(getExcelColHeadTd({
                            valign: valign,
                            rowspan: rowspan,
                            colspan: colspan,
                            align: CH.align,
                            colSeq: CH.colSeq,
                            formatter: CH.formatter,
                            sort: CH.sort,
                            tdHtml: tdHtml,
                            displayLabel: CH.displayLabel
                        }, filter));
                    }
                });
                po.push("</tr>");
            }
            po.push("	</thead>");
            po.push("	<tbody>");

            if (cfg.head) po.push(getHeadDataSet(this.dataSet, false, filter));

            axf.each(this.list, function (itemIndex, item) {
                po.push(getExcelItem(itemIndex, item, filter));
                if (bodyHasMarker && (markerIndex = getMarkerDisplay(itemIndex, item)).length > 0) {
                    po.push(getExcelItemMarker(itemIndex, item, 'n', filter, markerIndex));
                }
            });

            if (cfg.foot) po.push(getFootDataSet(this.dataSet, false, filter));

            po.push("	</tbody>");
            po.push("</table>");

            return po.join('');

        }
        else if (format == "json") {
            return {
                colGroup: cfg.colGroup,
                list: this.list
            }
        }

    },

    /**
     * @method AXGrid.changeGridView
     * @param {JSONObject} obj
     * @description - 그리드의 뷰모드를 체인지 합니다.
     * @example
     * ```
     * myGrid.changeGridView({
     *     viewMode:"grid"
     * });
     * myGrid.changeGridView({
     *     viewMode:"icon",
     *     view: {
     *         width:"200",
     *         // icon width
     *         height:"300",
     *         // icon height
     *         img: {
     *             left:"10",
     *             top:"10",
     *             width:"179",
     *             height:"180",
     *             style:"border:1px solid #ccc;"
     *         },
     *         label:{
     *             left:"10",
     *             top:"200",
     *             width:"180",
     *             height:"20"
     *         },
     *         description: {
     *             left:"10",
     *             top:"225",
     *             width:"180",
     *             height:"65",
     *             style:"color:#888;"
     *         },
     *         buttons: {
     *             left:"5",
     *             top:"5",
     *             width:"180",
     *             height:"20",
     *             style:"",
     *             items:[
     *                 {
     *                     label:"but1",
     *                     style:"",
     *                     addClass:"AXButton Green",
     *                     onclick:function(){
     *                         fnObj.otherFunction(this);
     *                     }
     *                 },
     *                 {
     *                     label:"but2",
     *                     style:"",
     *                     addClass:"AXButton",
     *                     onclick:function(){
     *                         fnObj.otherFunction(this);
     *                     }
     *                 }
     *             ]
     *         },
     *         format: function(){
     *             return {
     *                 imgsrc : this.item.img,
     *                 label : this.item.title,
     *                 description : this.item.writer+", "+this.item.no+" / " + (this.item.desc || "")
     *             }
     *         }
     *     }
     * });
     * myGrid.changeGridView({
     *     viewMode:"mobile"
     * });
     *
     * ```
     */
    changeGridView: function (JSObject) {
        var cfg = this.config;

        if (cfg.viewMode != JSObject.viewMode) {
            cfg.viewMode = JSObject.viewMode;
            if (JSObject.viewMode == "icon") {
                if (JSObject.view) cfg.view = JSObject.view;
                this.redrawGrid("changeGridView");
            }
            else if (JSObject.viewMode == "grid") {
                //if(JSObject.view) cfg.view = JSObject.view;
                this.redrawGrid("changeGridView");
            }
            else if (JSObject.viewMode == "mobile") {
                if (JSObject.view) cfg.view = JSObject.view;
                this.redrawGrid("changeGridView");

            }
        }
    },
    /**
     * @method AXGrid.openMobileConfig
     * @param {event} event
     * @description - 모바일 툴바가 클릭되었을 때 툴바 박스 호출 이벤트 함수
     */
    openMobileConfig: function (event) {
        var cfg = this.config, _this = this;
        //console.log(cfg.view.column);

        var mobileView = cfg.view;
        if (mobileView == undefined) {
            var columns = [];
            for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
                var col = null, addClass = "";
                if (CG.widthAstric || CG.width.number() >= 200) {
                    col = 4;
                    addClass = "underLine";
                }
                else if (CG.width.number() >= 100) {
                    col = 2;
                }
                else if (CG.width.number() >= 40) {
                    //col = 1;
                }
                columns.push(
                    {
                        key: CG.key,
                        label: CG.label,
                        col: col,
                        formatter: CG.formatter,
                        addClass: addClass,
                        sort: (CG.sort || ""),
                        display: (CG.display || true)
                    }
                );
            }
            columns = columns.sort(function (pItem, nItem) {
                var v1 = pItem.col;
                var v2 = nItem.col;
                if (v1 < v2) return 1;
                else if (v1 > v2) return -1;
                else if (v1 == v2) return 0;
            });
            mobileView = {
                labelView: true,
                column: columns
            };
            cfg.view = mobileView;
        }

        for (var CN, cidx = 0, __arr = mobileView.column; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
            if (CN.display == undefined || CN.display == true) {
                CN.display = true;
                CN.checked = true;
            }
        }

        var contextMenu = mobileView.column.concat();
        this.mobileContextMenu.setConfig({responsiveMobile: 900000});
        this.mobileContextMenu.bind({
            id: cfg.targetID + "myContextMenu",
            theme: "AXContextMenu", // 선택항목
            width: "150", // 선택항목
            checkbox: "checkbox", // [checkbox|radio]
            sortbox: true,
            menu: contextMenu,
            onchange: function () { // 체크박스 선택값이 변경 된 경우 호출 됩니다.
                for (var CN, cidx = 0, __arr = this.menu; (cidx < __arr.length && (CN = __arr[cidx])); cidx++) {
                    CN.display = CN.checked;
                }
                cfg.view.column = axf.copyObject(this.menu);
                _this.printList();
                this.contentScrollResize();
            },
            onsort: function () { // 정렬이 변경 된 경우 호출 됩니다.
                //console.log(this.sortMenu);
                _this.list = _this.sortList(this.sortMenu.sort, this.sortMenu, _this.list);
                _this.printList();
                this.contentScrollResize();

                return true;// 메뉴 창이 닫히지 않게 합니다.
            }
        });
        this.mobileContextMenu.open({id: cfg.targetID + "myContextMenu"}, event);
    },
    /**
     *
     * @method AXGrid.clipBoardClear
     * @returns {AXGrid}
     */
    clipBoardClear: function () {
        var body = this.body;
        axf.each(this.copiedRow, function () {
            body.find(".gridBodyTr_" + this).removeClass("copied");
        });
        this.copiedRow.clear();
        this.clipBoard.type = "";
        this.clipBoard.list = [];

        return this;
    },
    /**
     *
     * @method AXGrid.selectClear
     * @returns {AXGrid}
     */
    selectClear: function () {
        var body = this.body;

        if (this.selectedCells.length > 0) { // 셀선택 클리어
            axf.each(this.selectedCells, function () {
                body.find(".bodyTd_" + this).removeClass("selected");
            });
            this.selectedCells.clear();
        }
        if (this.selectedRow.length > 0) { // 로우선택 클리어
            axf.each(this.selectedRow, function () {
                body.find(".gridBodyTr_" + this).removeClass("selected");
            });
            this.selectedRow.clear();
        }
        if (this.copiedRow.length > 0) {
            axf.each(this.copiedRow, function () {
                body.find(".gridBodyTr_" + this).removeClass("copied");
            });
            this.copiedRow.clear();
        }
        this.clipBoard.type = "";
        this.clipBoard.list = [];

        return this;
    },

    /**
     * AXGrid의 checked 값을 jQuery.param 메서드에서 사용 가능한 배열로 반환합니다.
     * @method AXGrid.getCheckedParams
     * @param colSeq {Number} -대상 체크박스(formatter:"checkbox" 로 선언된 항목의 순서)
     * @param traditional {Boolean} [false] 반환 형태 지정
     * @return {Array} traditional[false]: [ { name: 'no', value: 1 }, { name: 'no', value: 2 } ], traditional[true]: [ { 'no': 1 }, { 'no': 2 } ]
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getCheckedParams(0); // -> [ { name: 'no', value: 1 }, { name: 'no', value: 2 } ]
     * myGrid.getCheckedParams(0); // -> [ { 'no': 1 }, { 'no': 2 } ]
     * ```
     */
    getCheckedParams: function (colSeq, traditional) {
        var colName = this.config.colGroup[colSeq].key;
        var checkedList = this.getCheckedList(colSeq);
        var params = [];

        if (!colName) {
            console.log("colSeq invalid. Please check the colSeq value.");
            return params;
        }
        if (!checkedList || checkedList.length === 0) {
            return params;
        }

        $.each(checkedList, function (idx, item) {
            if (traditional) {
                var p = {};
                p[colName] = (item[colName] || '');
                params.push(p);
            }
            else {
                params.push({"name": colName, "value": (item[colName] || "")});
            }
        });

        return params;
    },

    /**
     * 그리드의 데이터를 조건에 따라 반환하며 clone 옵션을 사용해서 복사된 값을 받을 수 있다.
     * @method AXGrid.getList
     * @param filter {String|Function|Boolean} [undefined] - String: "C,U,D" 추가,수정,삭제. Function: true/false를 반환하는 함수를 사용한다. Boolean: filter 조건을 생략하고 바로 clone 옵션을 사용할 수 있다.
     * @param clone {Boolean} [false] true: referance 데이터를 반환 받는다. false: clone 데이터를 반환받는다.
     * @returns {Array}
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.getList(); // 전체 데이터(referance) 배열 반환
     * myGrid.getList(true); // 전체 데이터(clone) 배열 반환
     * myGrid.getList("C,U"); // 추가,수정된 데이터(referance) 배열 반환
     * myGrid.getList("C,U", true); // 추가,수정된 데이터(clone) 배열 반환
     * function fnFilter(idx, item) { return (idx % 2) === 0; }
     * myGrid.getList(fnFilter); // 함수에서 true를 반환한 데이터(referance) 배열 반환
     * myGrid.getList(fnFilter, true); // 함수에서 true를 반환한 데이터(clone) 배열 반환
     * ```
     */
    getList: function (filter, clone) {
        var filteredList = [];
        if (filter === false || Object.isUndefined(filter)) {
            filteredList = this.list;
            clone = false;
        }
        else if (filter === true) {
            filteredList = this.list;
            clone = true;
        }
        else if (Object.isString(filter)) {
            axf.each(this.list, function (idx, item) {
                if (filter.indexOf(item._CUD) > -1) {
                    filteredList.push(item);
                }
            });
            if (filter.indexOf("D") > -1) {
                axf.each(this.removedList, function (idx, item) {
                    filteredList.push(item);
                });
            }
        }
        else if (Object.isFunction(filter)) {
            var fnFilter = filter.bind(this);
            axf.each(this.list, function (idx, item) {
                if (fnFilter(idx, item)) {
                    filteredList.push(item);
                }
            });
        }

        if (clone) {
            var clonedList = [];
            axf.each(filteredList, function (idx, item) {
                clonedList.push(Object.clone(item));
            });
            return clonedList;
        }
        else {
            return filteredList;
        }
    },
    /**
     * 그리드 추가 , 수정시 validation 체크 메소드
     * @method AXGrid.validateCheck
     * @param filter {String} [undefined] - String: "C,U,D" 추가,수정,삭제
     * @returns boolean
     * @example
     * ```
     *
     * colGroup : [{
	    "key": "date",
	    "label": "date",
	    "width": 95,
	    "sort": false,
	    "align": "center",
	    "editor": {
	        "type": "calendar",
	        "config": {
	            "valueFormat": "yyyymmdd",
	            "separator": "-"
	        },
	        "updateWith": ["_CUD"],
	        "maxLength": 8
	    },
	}, {
	    "key": "string",
	    "label": "string",
	    "width": 95,
	    "sort": false,
	    "align": "center",
	    "editor": {
	    	"updateEdit": true,  // 필드 없데이트시  default true, false 수정안됨.
	        "createEdit": true,  // 필드 신규추가시  default true, false 추가시 입력안됨.
	        "notEmpty": true, // 필수 입력 여부 default false, true or string  빈 항목일 경우 보여줄 메시지 .
	        "type": "text",
	        "updateWith": ["_CUD"],
	        "maxLength": 40
	    }
	}, {
	    "key": "number",
	    "label": "number",
	    "width": 95,
	    "sort": false,
	    "align": "right",
	    "formatter": "money",
	    "editor": {
	        "type": "money",
	        "updateWith": ["_CUD"],
	        "maxLength": 12,
	        "range": { // 숫자일 경우 숫자자릿수와 소수점 자릿수 지정
	            "val": "9,3"
	            ,msg : '' // 자릿수를 초과 했을대 보여줄 메시지.
	        }
	    },
	}]
     * var myGrid = new AXGrid();
     * AXGrid.validateCheck('C'); // 추가시 validation check
     * AXGrid.validateCheck('U'); // 수정시 validation check
     * ```
     */
    validateCheck: function (filter) {
        var cfg = this.config;
        var _self = this;

        if (Object.isString(filter)) {
            if (!cfg.colGroup) return false;

            var __arr = cfg.colGroup, arrKeyEditor = {}, item, editorItem;

            for (var i in __arr) {
                item = __arr[i];
                editorItem = item.editor;

                if (Object.isObject(editorItem)) {
                    var validateflag = false;
                    if (!Object.isUndefined(editorItem.notEmpty)) {
                        validateflag = true;
                        item.editor.notEmpty = editorItem.notEmpty === true ? (item.label + ' 필수 입력항목입니다.') : ( Object.isString(editorItem.notEmpty) ? editorItem.notEmpty : false);
                    }

                    if (!Object.isUndefined(editorItem.range)) {
                        validateflag = true;
                        item.editor.range.msg = Object.isUndefined(item.editor.range.msg) ? (item.label + ' 입력 값을 초과 하였습니다.') : item.editor.range.msg;
                    }

                    if (validateflag) {
                        arrKeyEditor[i] = {};
                        arrKeyEditor[i].editor = item.editor;
                        arrKeyEditor[i].key = item.key;
                    }
                }
            }
            var reval = true, _colseq, _idx;
            axf.each(this.list, function (idx, item) {
                if (filter.indexOf(item._CUD) > -1) {
                    var itemval;

                    for (var colseq in arrKeyEditor) {
                        editorItem = arrKeyEditor[colseq].editor;

                        itemval = item[arrKeyEditor[colseq].key];

                        _colseq = colseq;
                        _idx = idx;

                        if (editorItem.notEmpty) {
                            if ($.trim(itemval) == '') {
                                if (editorItem.notEmpty) alert(editorItem.notEmpty);

                                reval = false;
                                return false;
                            }
                        }
                        itemval = itemval ? itemval + '' : (editorItem.type != 'money' ? '' : '0');

                        if (editorItem.type != 'money') continue;

                        if (editorItem.range) {
                            var rangeval = editorItem.range.val;
                            var rangeArr = rangeval.split(',');

                            var decimalNum = rangeArr[0]
                                , decimalPoint = rangeArr.length > 1 ? rangeArr[1] : 0
                                , numval = '', pointval = '';

                            decimalNum = isNaN(decimalNum) ? 0 : parseInt(decimalNum, 10);
                            decimalPoint = isNaN(decimalPoint) ? 0 : parseInt(decimalPoint, 10);

                            numval = itemval.replace(/[$,]+/g, '');

                            if (isNaN(numval)) {
                                alert('숫자만 입력가능합니다.');
                                reval = false;
                                return false;
                            }

                            if (itemval.indexOf('.') > -1) {
                                var valArr = itemval.split('.');
                                numval = valArr[0];
                                pointval = valArr[1];
                            }

                            if (numval.length > decimalNum || pointval.length > decimalPoint) {
                                if (editorItem.range.msg) {
                                    if (editorItem.range.msg)  alert(editorItem.range.msg + '\n' + itemval);

                                    reval = false;
                                    return false;
                                }
                            }
                        }
                    }
                }
            });

            if (reval === false) {
                _self.editCell(0, _colseq, _idx);
                _self.setFocus(_idx);
                _self.scrollTop(_idx);
            }
        }

        return reval;
    },
    onevent_grid: function () {

    },

    /**
     * @method AXGrid.clearSort
     * @description - 그리드의 소트관련 설정 데이터 및 소트표현 클래스를 삭제합니다.
     * @example
     * ```
     * var myGrid = new AXGrid();
     * myGrid.clearSort();
     * ```
     */
    clearSort: function () {
        var cfg = this.config
            , _this = this
            , rows = cfg.colHead.rows
            , sort = ''
            , removeTg = '';

        $.each(rows, function (idx, o) {
            if (sort == '') {
                $.each(o, function (idx_idx, o_o) {
                    if (o_o.sort != undefined) {
                        sort = o_o.sort;
                        delete o_o.sort;

                        return false;
                    }
                });
            }
        });

        if (sort != '') {
            if (sort == 'desc') {
                removeTg = 'sortDesc';
            }
            else if (sort == 'asc') {
                removeTg = 'sortAsc';
            }

            document.getElementById(this.nowSortHeadID).classList.remove(removeTg);
            this.nowSortHeadObj = undefined;
            this.nowSortHeadID = undefined;
        }
    },

    /**
     * @method AXGrid.reorderColgroup
     * @param {Array} rColgroupreorderColGroup
     *
     */
    reorderColGroup: function (rColgroup) {
        var
            cfg = this.config,
            oldColGroup = [].concat(cfg.colGroup),
            newColGroup = []
            ;

        if (rColgroup) {
            // colGroup
            rColgroup.forEach(function (c) {
                jQuery.each(oldColGroup, function (idx, oc) {
                    if (oc.key == c.key) {
                        delete oc.colSeq;
                        newColGroup.push(oc);
                        oldColGroup.splice(idx, 1);
                        return false;
                    }
                });
            });
            cfg.colGroup = newColGroup.concat(oldColGroup);

            // body
            (function () {
                var
                    oldBodyRows = []
                    ;

                for (var r = 0; r < cfg.body.rows.length; r++) {
                    oldBodyRows.push([].concat(cfg.body.rows[r]));
                }

                for (var r = 0; r < oldBodyRows.length; r++) {
                    oldBodyRows[r].forEach(function (c, cidx) {
                        var matchIdx = cidx;
                        jQuery.each(cfg.colGroup, function (idx, cg) {
                            if (cg.key == c.key) {
                                matchIdx = idx;
                                return false;
                            }
                        });
                        oldBodyRows[r][cidx].matchIdx = matchIdx;
                    });
                    oldBodyRows[r].sort(function (a, b) {
                        return a.matchIdx - b.matchIdx;
                    });
                    oldBodyRows[r].forEach(function (c) {
                        delete c.matchIdx;
                        delete c.colSeq;
                    });
                }

                cfg.body.rows = [];
                for (var r = 0; r < oldBodyRows.length; r++) {
                    cfg.body.rows.push(oldBodyRows[r]);
                }
            }).call(this);

            // marker
            (function () {
                if (!cfg.body.marker) return;

                function convertMarker(marker) {
                    if (!marker.rows) return;
                    var oldMarkerRows = [];
                    for (var r = 0; r < marker.rows.length; r++) {
                        oldMarkerRows.push([].concat(marker.rows[r]));
                    }

                    for (var r = 0; r < oldMarkerRows.length; r++) {
                        oldMarkerRows[r].forEach(function (c, cidx) {
                            var matchIdx = cidx;
                            jQuery.each(cfg.colGroup, function (idx, cg) {
                                if (cg.key == c.key) {
                                    matchIdx = idx;
                                    return false;
                                }
                            });
                            oldMarkerRows[r][cidx].matchIdx = matchIdx;
                        });
                        oldMarkerRows[r].sort(function (a, b) {
                            return a.matchIdx - b.matchIdx;
                        });
                        oldMarkerRows[r].forEach(function (c) {
                            delete c.matchIdx;
                            delete c.colSeq;
                        });
                    }

                    marker.rows = [];
                    for (var r = 0; r < oldMarkerRows.length; r++) {
                        marker.rows.push(oldMarkerRows[r]);
                    }
                }

                if (Object.isArray(cfg.body.marker)) {
                    for (var m = 0, l = cfg.body.marker.length; m < l; m++) {
                        convertMarker(cfg.body.marker[m]);
                    }
                } else {
                    convertMarker(cfg.body.marker);
                }

            }).call(this);

            // foot
            (function () {
                if (!cfg.foot) return;

                var
                    oldFootRows = []
                    ;
                for (var r = 0; r < cfg.foot.rows.length; r++) {
                    oldFootRows.push([].concat(cfg.foot.rows[r]));
                }

                for (var r = 0; r < oldFootRows.length; r++) {
                    oldFootRows[r].forEach(function (c, cidx) {
                        var matchIdx = cidx;
                        jQuery.each(cfg.colGroup, function (idx, cg) {
                            if (cg.key == c.key) {
                                matchIdx = idx;
                                return false;
                            }
                        });
                        oldFootRows[r][cidx].matchIdx = matchIdx;
                    });
                    oldFootRows[r].sort(function (a, b) {
                        return a.matchIdx - b.matchIdx;
                    });
                    oldFootRows[r].forEach(function (c) {
                        delete c.matchIdx;
                        delete c.colSeq;
                    });
                }


                cfg.foot.rows = [];
                for (var r = 0; r < oldFootRows.length; r++) {
                    cfg.foot.rows.push(oldFootRows[r]);
                }
            }).call(this);

            this.defineConfig(false, true);
            this.redrawGrid();
        }

        return this;

        /*
         console.log(cfg.colGroup);
         console.log(cfg.colHead);
         console.log(cfg.body);
         console.log(cfg.head);
         console.log(cfg.foot);
         console.log(cfg.editor);
         */
    },

    /**
     * 그리드 제거. DOM, event, global variable을 제거한다.
     * @method AXGrid.removeGrid
     * @returns {Class} AXGrid instance
     * @example
     * ```js
     * myGrid.removeGrid();
     * myGrid = null;
     * ```
     */
    removeGrid: function () {
        // remove window event
        axf.each(this.windowEvents, function (i, we) {
            axdom(window).unbind(we.event, we.fn);
        });

        // remove dom
        axdom('#' + myGrid.config.targetID).remove();

        axf.each(AXGrid_instances, function (i, instance) {
            if (instance === this) {
                var klass = AXGrid_instances.splice(i, 1);
                delete klass;
                return false;
            }
        });

        return this;
    }
});

/**
 * @method AXGrid.prototype.formatter
 * @description - 그리드의 formatter 입니다. 사용자 정의 formatter를 추가할 수 있습니다.
 * @example
 * ```js
 * Object.extend(AXGrid.prototype.formatter, {
 *     link: function(formatter, item, itemIndex, value, key, CH, CHidx){
 *         return '<a href="https://www.axisj.com">www.axisj.com</a>';
 *     }
 * });
 * ```
 */
AXGrid.prototype.formatter = (function () {
    // checkbox, radiobox formatter
    function boxFormatter(formatter, item, itemIndex, value, key, CH, CHidx) {
        var cfg = this.config;
        var checkedStr = "";
        var disabled = "";
        var sendObj = {
            index: itemIndex,
            list: this.list,
            item: item,
            page: this.page,
            key: key,
            value: value
        };

        if (this.list[itemIndex].___checked && this.list[itemIndex].___checked[CHidx]) {
            if (this.list[itemIndex].___checked[CHidx]) checkedStr = " checked=\"checked\" ";
            //if(itemIndex == 0) console.log(this.list[itemIndex].___checked[CHidx], checkedStr);
        }
        else if (Object.isFunction(CH.checked)) {
            if (CH.checked.call(sendObj)) {
                checkedStr = " checked=\"checked\" ";
                if (!this.list[itemIndex].___checked) this.list[itemIndex].___checked = {};
                this.list[itemIndex].___checked[CHidx] = true;
            }
        }

        if (CH.disabled) {
            if (CH.disabled.call(sendObj)) {
                disabled = " disabled=\"disabled\" ";
                if (!this.list[itemIndex].___checked) this.list[itemIndex].___disabled = {};
                this.list[itemIndex].___disabled[CHidx] = true;
            }
        }
        /*
         return "<label class=\"gridCheckboxLabel\">" +
         "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />" +
         "</label>";
         */
        return "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"gridCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
    }

    return {
        "wordwrap": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            if (!value) {
                return "";
            }

            return '<span class="AXWordwrap">' + value.dec().crlf().replace(/ /g, '&nbsp;') + '</span>';
        },
        "money": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            if (value == "" || value == "null" || value == null || value == undefined) {
                return "0";
            }
            else {
                return (value || 0).number().money();
            }
            return result;
        },
        "dec": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            return (value == undefined) ? "" : value.toString().dec();
        },
        "html": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            return value;
        },
        "checkbox": boxFormatter,
        "radio": boxFormatter,
        "select": function (formatter, item, itemIndex, value, key, CH, CHidx) {
            var txtKey = CH.editor.optionText;
            var valKey = CH.editor.optionValue;
            var options = CH.editor.options || [];
            var text = "";

            if (!txtKey && AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) {
                txtKey = AXConfig.AXSelect.keyOptionText || "optionText";
            }
            if (!valKey && AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) {
                valKey = AXConfig.AXSelect.keyOptionValue || "optionValue";
            }

            if (options.length === 0) {
                return text;
            }

            var isObjectVal = Object.isObject(value);
            var optionVal = isObjectVal ? value[valKey] : value;
            for (var i = 0; i < options.length; i++) {
                if (options[i][valKey] == optionVal) {
                    text = options[i][txtKey];
                    break;
                }
            }
            return text;
            //},
            //"AXSelect": function(formatter, item, itemIndex, value, key, CH, CHidx){
            //    // TODO ajax를 매번 호출 할수는 없다. 한번 호출해서 caching 해야 하는데... cache 다시 로드 하는 기능이나 시점도 필요하다. HJ.Park 2015-08-05
            //    return "";
        }
    };
})();

/**
 * @method AXGrid.prototype.inlineEditor
 * @description - 그리드의 inline editor 입니다. 사용자 정의 editor를 추가할 수 있습니다.
 * @example
 * ```js
 * Object.extend(AXGrid.prototype.inlineEditor, {
 *     switch: {
 *         init: function(inline_editor, AXBindConfig, CG, r, c, ii){
 *             inline_editor.find("input").bindSwitch(AXBindConfig);
 *         },
 *         getValue: function(value) {
 *             // this: {item:item, index:itemIndex, CG:CG, r:r, c:c}
 *             return value;
 *         }
 *     }
 * });
 * ```
 */
AXGrid.prototype.inlineEditor = (function () {
    var getOptionValueKey = function getOptionValueKey(AXBindConfig) {
        if (AXBindConfig && AXBindConfig.reserveKeys && AXBindConfig.reserveKeys.optionValue) {
            return AXBindConfig.reserveKeys.optionValue;
        }
        else if (AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) {
            return AXConfig.AXSelect.keyOptionValue;
        }
        else {
            return "optionValue";
        }
    };

    var getOptionTextKey = function getOptionTextKey(AXBindConfig) {
        if (AXBindConfig && AXBindConfig.reserveKeys && AXBindConfig.reserveKeys.optionText) {
            return AXBindConfig.reserveKeys.optionText;
        }
        else if (AXConfig && AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) {
            return AXConfig.AXSelect.keyOptionText;
        }
        else {
            return "optionValue";
        }
    };

    // getValue -> this: {item:item, index:itemIndex, CG:CG, r:r, c:c}
    return {
        "number": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                inline_editor.find("input").bindNumber(AXBindConfig).select();
            },
            getValue: function (value) {
                return String(value || "").number();
            }
        },
        "money": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                inline_editor.find("input").bindMoney(AXBindConfig);
                setTimeout(function () {
                    inline_editor.find("input").select();
                }, 100);
            },
            getValue: function (value) {
                return String(value || "").money();
            }
        },
        "calendar": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                AXBindConfig.expand = true;
                jQuery.extend(AXBindConfig, CG.editor.config, true);

                AXBindConfig.onchange = function () {
                    _this.updateItem(r, c, ii, this.value);
                };

                inline_editor.find("input").bindDate(AXBindConfig);
            },
            getValue: function (value) {
                return value || "";
            }
        },
        "select": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                var cfg_key_value = getOptionValueKey(AXBindConfig);
                var cfg_key_text = getOptionTextKey(AXBindConfig);

                inline_editor.find("select").bind("change", function () {
                    var sdom = inline_editor.find("select").get(0);
                    var obj = {};
                    obj[cfg_key_value] = sdom.options[sdom.selectedIndex].value;
                    obj[cfg_key_text] = sdom.options[sdom.selectedIndex].text;
                    _this.updateItem(r, c, ii, obj);
                });
                setTimeout(function () {
                    inline_editor.find("select").focus();
                }, 100);

                jQuery(document.body).unbind("click.axgrid").bind("click.axgrid", function (e) {
                    var target = axf.get_event_target(e.target, {id: inline_editor.attr("id")});
                    if (!target) {
                        var sdom = inline_editor.find("select").get(0);
                        if (sdom.options[sdom.selectedIndex]) {
                            var obj = {};
                            obj[cfg_key_value] = sdom.options[sdom.selectedIndex].value;
                            obj[cfg_key_text] = sdom.options[sdom.selectedIndex].text;

                            _this.updateItem(r, c, ii, obj);
                        }
                        else {
                            _this.editCellClear();
                        }
                        _this.gridFocus.focus();
                        jQuery(document.body).unbind("click.axgrid");
                    }
                });
            },
            getValue: function (value) {
                if (typeof(value) === "string") return value;
                return value[getOptionValueKey(this.CG.editor.config)];
            }
        },
        "AXSelect": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                var cfg = this.config;
                var cfg_key_value = getOptionValueKey(AXBindConfig);
                var cfg_key_text = getOptionTextKey(AXBindConfig);

                // todo : inline_editor.config에 onchange함수 재 정의
                AXBindConfig.onchange = function () {
                    var obj = {};
                    obj[cfg_key_value] = this.value;
                    obj[cfg_key_text] = this.text;
                    setTimeout(function () {
                        _this.updateItem(r, c, ii, obj);
                    }, 100);
                };
                var td_val = _this.list[ii][CG.key];
                AXBindConfig.setValue = td_val[cfg_key_value];
                inline_editor.find("select").bindSelect(AXBindConfig);
                setTimeout(function () {
                    inline_editor.find("select").focus();
                }, 100);

                jQuery(document.body).unbind("click.axgrid").bind("click.axgrid", function (e) {
                    var select_id = (cfg.targetID + '_inline_editor').lcase();
                    var target = axf.get_event_target(e.target, function (el) {
                        if (!el.id) return false;
                        return ((el.id.split(/_AX_/g)[1] || "").lcase() == select_id);
                    });
                    if (!target) {
                        var sdom = inline_editor.find("select").get(0);
                        if (sdom.options[sdom.selectedIndex]) {
                            var obj = {};
                            obj[cfg_key_value] = sdom.options[sdom.selectedIndex].value;
                            obj[cfg_key_text] = sdom.options[sdom.selectedIndex].text;

                            _this.updateItem(r, c, ii, obj);
                        }
                        else {
                            _this.editCellClear();
                        }
                        _this.gridFocus.focus();
                        jQuery(document.body).unbind("click.axgrid");
                    }
                });
            },
            getValue: function (value) {
                return value;
            }
        },
        "AXSelector": {
            init: function (inline_editor, AXBindConfig, CG, r, c, ii) {
                var _this = this;
                var cfg = this.config;
                var cfg_key_value = getOptionValueKey(AXBindConfig);
                var cfg_key_text = getOptionTextKey(AXBindConfig);

                // todo : inline_editor.config에 onchange함수 재 정의
                AXBindConfig.onchange = function () {
                    var obj = {};
                    if (this.selectedOption) {
                        obj[cfg_key_value] = this.selectedOption[cfg_key_value];
                        obj[cfg_key_text] = this.selectedOption[cfg_key_text];
                    }
                    else {
                        obj[cfg_key_value] = "";
                        obj[cfg_key_text] = "";
                    }
                    setTimeout(function () {
                        _this.updateItem(r, c, ii, obj);
                    }, 100);
                };

                var td_val = _this.list[ii][CG.key];
                if (typeof td_val === "undefined") AXBindConfig.setValue = "";
                else if (typeof td_val === "string" || typeof td_val === "number" || typeof td_val === "boolean") {
                    AXBindConfig.setValue = td_val;
                }
                else {
                    AXBindConfig.setValue = td_val[cfg_key_value];
                }

                inline_editor.find("input").bindSelector(AXBindConfig);
                setTimeout(function () {
                    inline_editor.find("input").focus();
                }, 100);

            },
            getValue: function (value) {
                return value;
            }
        }
    };
})();

/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 
 
axdom.fn.loadHtmlElement = function(arg) {
	if(arg == undefined) arg = {}
	var varObj = new AXHtmlElement();
	arg.target = this.get(0).id;
	varObj.setConfig(arg);
    return this;
};

var AXHtmlElement = Class.create(AXJ, {

    version: "AXHtmlElement V1.0",
    author: "tom@axisj.com",
    logs: [
        "2013-04-17 - mods에서 변환했음 - json@axisj.com"
    ],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.defaultValue = "";
        this.config.firstEmpty = false;
        this.config.firstChecked = true;
    },
    init: function() {
        var config = this.config;

        if (config.loadUrl) {
            var url = config.loadUrl;
            var qs = config.loadPars;
            var pars =  qs;
            var onLoad = this.onLoad.bind(this);
            new AXReq(url, { pars: pars, onsucc: function(res) {
                if (res.result == "00") {
                    onLoad(res);
                } else {
                    alert(res.msg.dec());
                }
            }
            });
        } else if (config.options) {
            this.onLoad({ ds: config.options });
        }
    },
    onLoad: function(res) {
        var config = this.config;
        if (config.displayType == "select") {
            // firstItemName 추가했음 by raniel, 2013-04-30 
            this.setSelectOption(
    			{ tg: axdom("#" + config.target)[0], ds: res.ds }, config.defaultValue, config.firstEmpty, config.firstEmptyItemName
    		);
            axdom("#" + config.target).unbind("change", this.onchange.bind(this));
            axdom("#" + config.target).bind("change", this.onchange.bind(this));
        }
        if (config.displayType == "radio") {
            this.setInputOption(
    			{ tg: axdom("#" + config.target), ds: res.ds }, config.defaultValue
    		);
        }
        if (config.displayType == "checkbox") {
            this.setInputOption(
    			{ tg: axdom("#" + config.target), ds: res.ds }, config.defaultValue
    		);
        }
    },
    setSelectOption: function (obj, selectValue, firstEmpty, firstEmptyItemName) {
        var config = this.config;

        /*
        for (var a = obj.tg.length - 1; a > -1; a--) {
        //obj.tg.options[a] = null;
        alert(a);
        }
        */
		try{
	        obj.tg.innerHTML = "";
		}catch(e){
			return;
		}


        if (firstEmpty) {
            var opts = document.createElement('option');
            opts.value = "";
            if (firstEmptyItemName) {
                opts.text = firstEmptyItemName;
            } else {
                opts.text = "모두";
            }
            obj.tg.appendChild(opts);
        }
        axdom.each(obj.ds, function(index, n) {
            if (n.optgroup) {

                var oGroup = document.createElement('optgroup');
                oGroup.label = n.optgroup.dec();

                axdom.each(n.option, function() {
                  if ( this.value != null ) {
                      var opts = document.createElement('option');
                      opts.value = this.value.dec();
                      opts.innerText = this.text.dec();
                      if (selectValue != undefined) if (selectValue == this.value.dec()) opts.selected = true;
                      oGroup.appendChild(opts);
                    }
                });

                obj.tg.appendChild(oGroup);

            } else {

                var opts = document.createElement('option');
                opts.value = n.value.dec();
                opts.innerText = n.text.dec();
                if (selectValue != undefined) if (selectValue == n.value.dec()) opts.selected = true;
                obj.tg.appendChild(opts);

            }
        });

        var robj = (obj.tg.selectedIndex > -1) ? { value: obj.tg.options[obj.tg.selectedIndex].value, text: obj.tg.options[obj.tg.selectedIndex].text} : { value: "", text: "" };
        this.loadSucc(robj);

    },
    setInputOption: function(obj, selectValue) {
        var config = this.config;
        obj.tg.empty(); //타켓 초기화

        var po = [];
        var robj = { value: "", text: "" };
        this.ids = obj.ds;
        axdom.each(obj.ds, function(index, n) {
            //alert(Object.toJSON(n));

            if (config.title) {
                po.push("<input type=\"" + config.displayType + "\" name=\"" + config.name + "\" value=\"" + n.value.dec() + "\" title=\"" + config.title.dec() + "\" class=\"" + config.className + "\" ");
            } else {
                po.push("<input type=\"" + config.displayType + "\" name=\"" + config.name + "\" value=\"" + n.value.dec() + "\" class=\"" + config.className + "\" ");
            }

            if (selectValue != "" && selectValue == n.value.dec()) {
                po.push(" checked=\"checked\" ");
                robj.value = n.value.dec();
                robj.text = n.text.dec();
            }
            else if (selectValue == "" && config.firstChecked == true && index == 0) {
                po.push(" checked=\"checked\" ");
                robj.value = n.value.dec();
                robj.text = n.text.dec();
            }
            po.push("/>");

            po.push(n.text.dec() + "&nbsp;");
        });
        obj.tg.html(po.join(''));

        this.loadSucc(robj);

        axdom("#" + config.target).find("input").unbind("click", this.onchange2.bind(this));
        axdom("#" + config.target).find("input").bind("click", this.onchange2.bind(this));
    },
    loadSucc: function(obj) {
        var config = this.config;
        if (config.onLoad) {
            config.onLoad({
                target: config.target,
                value: obj.value,
                text: obj.text
            });
        }
    },
    onchange: function(event) {
        var tg = event.target;
        var config = this.config;
        if (config.onChange) {
            config.onChange({
                target: config.target,
                value: tg.options[tg.selectedIndex].value,
                text: tg.options[tg.selectedIndex].text
            });
        }
    },
    onchange2: function(event) {
        var tg = event.target;
        var config = this.config;

        var myText = "";
        axdom.each(this.ids, function(idx, D) {
            if (D.value.dec() == tg.value) {
                myText = D.text.dec();
            }
        });

        if (config.onChange) {
            config.onChange({
                target: config.target,
                value: tg.value,
                text: myText
            });
        }
    }
});
/* ---------------------------- */
var AXInputConverter = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.objects = [];
        this.inputTypes = [
            {type: "search"}, {type: "number"}, {type: "money"}, {type: "slider"}, {type: "twinSlider"},
            {type: "selector"}, {type: "switch"}, {type: "segment"},
            {type: "date"}, {type: "dateTime"}, {type: "twinDate"}, {type: "twinDateTime"},
            {type: "checked"}, {type: "pattern"}
        ];
        this.config.anchorClassName = "AXanchor";
        this.config.anchorPlaceHolderClassName = "AXanchorPlaceHolder";
        this.config.anchorSearchClassName = "AXanchorSearch";
        this.config.anchorNumberContainerClassName = "AXanchorNumberContainer";
        this.config.anchorIncreaseClassName = "AXanchorIncrease";
        this.config.anchorDecreaseClassName = "AXanchorDecrease";
        this.config.anchorSelectorHandleContainerClassName = "AXanchorSelectorHandleContainer";
        this.config.anchorSelectorFinderContainerClassName = "AXanchorSelectorFinderContainer";
        this.config.anchorSelectorHandleClassName = "AXanchorSelectorHandle";
        this.config.anchorSelectorFinderClassName = "AXanchorSelectorFinder";
        this.config.anchorSelectorExpandBoxClassName = "AXanchorSelectorExpandBox";
        this.config.anchorSelectorExpandScrollClassName = "AXanchorSelectorExpandScroll"
        this.config.anchorSliderBoxClassName = "AXanchorSliderBox";
        this.config.anchorSwitchBoxClassName = "AXanchorSwitchBox";
        this.config.anchorSegmentBoxClassName = "AXanchorSegmentBox";
        this.config.anchorDateHandleClassName = "AXanchorDateHandle";
        this.config.bindDateExpandBoxClassName = "AXbindDateExpandBox";
        this.config.bindTwinDateExpandBoxClassName = "AXbindTwinDateExpandBox";
        this.config.anchorCheckedContainerClassName = "AXbindCheckedHandle";
        /* 모바일 반응 너비 */
        this.config.responsiveMobile = AXConfig.mobile.responsiveWidth;

        this.config.reserveKeys = {
            options: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptions) || "options",
            optionValue: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) || "optionValue",
            optionText: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) || "optionText",
            optionData: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionData) || "optionData",
            optionDesc: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionDesc) || "optionDesc"
        };
    },
    init: function () {
        axdom(window).resize(this.alignAllAnchor.bind(this));

        // 예약어 초기화
        this.config.reserveKeys = {
            options: (AXConfig.AXInput && AXConfig.AXInput.keyOptions) || "options",
            optionValue: (AXConfig.AXInput && AXConfig.AXInput.keyOptionValue) || "optionValue",
            optionText: (AXConfig.AXInput && AXConfig.AXInput.keyOptionText) || "optionText",
            optionDesc: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionDesc) || "optionDesc"
        };
    },
    windowResize: function () {
        // 사용안함
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 1);
    },
    windowResizeApply: function () {
        // 사용안함
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.alignAllAnchor();
    },
    alignAllAnchor: function () {
        for (var i = 0; i < this.objects.length; i++) {
            this.alignAnchor(this.objects[i].id, i);
        }
    },
    msgAlert: function (msg) {
        var errorPrintType = "toast";
        if (AXConfig.AXInput) {
            errorPrintType = (AXConfig.AXInput.errorPrintType || "toast");
        }
        if (errorPrintType == "toast") toast.push(msg);
        else if (errorPrintType == "dialog") dialog.push(msg);
        else if (errorPrintType == "alert") AXUtil.alert(msg);
    },
    bindSetConfig: function (objID, configs) {
        var findIndex = null;
        axf.each(this.objects, function (index, O) {
            if (O.id == objID) {
                findIndex = index;
                return false;
            }
        });
        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        else {
            var _self = this.objects[findIndex];
            axf.each(configs, function (k, v) {
                _self.config[k] = v;
            });
        }
    },
    bind: function (obj) {
        var cfg = this.config;
        if (!AXgetId(obj.id)) {
            trace("bind 대상이 없어 bind 처리할 수 없습니다.");
            return;
        }

        if (obj.reserveKeys) cfg.reserveKeys = jQuery.extend(cfg.reserveKeys, obj.reserveKeys, true);
        var objID = obj.id;
        var objSeq = null;

        axf.each(this.objects, function (idx, O) {
            //if (this.id == objID && this.isDel == true) objSeq = idx;
            if (this.id == objID) {
                objSeq = idx;
                return false;
            }
        });

        if (typeof obj.href === "undefined") obj.href = cfg.href;

        if (objSeq == null) {
            objSeq = this.objects.length;
            this.objects.push({
                id: objID,
                anchorID: cfg.targetID + "_AX_" + objID,
                config: obj,
                bindType: obj.bindType
            });
        }
        else {
            this.objects[objSeq].isDel = undefined;
            this.objects[objSeq].config = obj;
        }

        //if (obj.bindType != "checked") {
        //	this.appendAnchor(objID, objSeq, obj.bindType);
        //}
        // bind checked anchor 연결
        this.appendAnchor(objID, objSeq, obj.bindType);

        if (obj.bindType == "placeHolder") {
            this.bindPlaceHolder(objID, objSeq);
        }
        else if (obj.bindType == "search") {
            this.bindSearch(objID, objSeq);
        }
        else if (obj.bindType == "number") {
            this.bindNumber(objID, objSeq);
        }
        else if (obj.bindType == "money") {
            this.bindMoney(objID, objSeq);
        }
        else if (obj.bindType == "selector") {
            this.bindSelector(objID, objSeq);
        }
        else if (obj.bindType == "slider") {
            this.bindSlider(objID, objSeq);
        }
        else if (obj.bindType == "twinSlider") {
            this.bindTwinSlider(objID, objSeq);
        }
        else if (obj.bindType == "switch") {
            this.bindSwitch(objID, objSeq);
        }
        else if (obj.bindType == "segment") {
            this.bindSegment(objID, objSeq);
        }
        else if (obj.bindType == "date") {
            this.bindDate(objID, objSeq);
        }
        else if (obj.bindType == "twinDate") {
            this.bindTwinDate(objID, objSeq);
        }
        else if (obj.bindType == "twinDateTime") {
            this.bindTwinDate(objID, objSeq, "time");
        }
        else if (obj.bindType == "checked") {
            this.bindChecked(objID, objSeq);
        }
        else if (obj.bindType == "pattern") {
            this.bindPattern(objID, objSeq);
        }
    },
    unbind: function (obj) {
        var cfg = this.config;
        var removeAnchorId;
        var removeIdx;
        axf.each(this.objects, function (idx, O) {
            if (O.id != obj.id) {
                // collect.push(this);
            }
            else {
                if (O.isDel != true) {
                    removeAnchorId = this.anchorID;
                    removeIdx = idx;
                }
            }
        });

        var objID = obj.id;
        var obj = this.objects[removeIdx];
        if (obj) {
            if (obj.documentclickEvent) axdom(document).unbind("click.AXInput", obj.documentclickEvent);
            var objDom = axdom("#" + objID);
            objDom.unbind("keydown.AXInput");
            objDom.unbind("keydown.AXInputCheck");
            objDom.unbind("change.AXInput");
            objDom.unbind("focus.AXInput");
            objDom.unbind("blur.AXInput");
        }

        if (removeAnchorId) {
            this.objects[removeIdx].isDel = true;
            axdom("#" + obj.id).removeAttr("data-axbind");
            axdom("#" + removeAnchorId).remove();

            if (obj.bindSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindSliderMouseMove);
            if (obj.bindSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindSliderMouseUp);
            if (obj.bindSliderTouchMove) document.removeEventListener("touchmove.AXInput", obj.bindSliderTouchMove, false);
            if (obj.bindSliderTouchEnd) document.removeEventListener("touchend.AXInput", obj.bindSliderTouchEnd, false);
            if (obj.bindTwinSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindTwinSliderMouseMove);
            if (obj.bindTwinSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindTwinSliderMouseUp);

            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
            }
        }
    },
    bindInputDisabled: function (objID, _disabled) {
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        ;

        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        else {
            var obj = this.objects[findIndex];
            var cfg = this.config;

            var elDisabled = !axf.getId(objID).disabled;
            axf.getId(objID).disabled = (typeof _disabled == "boolean") ? _disabled : elDisabled;
            if (obj.bindType == "twinDate") {
                axf.getId(obj.config.startTargetID).disabled = (typeof _disabled == "boolean") ? _disabled : elDisabled;
            }

            obj.bindAnchorTarget.data("disabled", axf.getId(objID).disabled);
            if (axf.getId(objID).disabled) {
                obj.bindAnchorTarget.addClass("disable");
                obj.bindAnchorTarget.attr("disable", "disable");
                obj.bindAnchorTarget.find("a").bind("mousedown.AXInputDisabled", function (e) {
                    //alert("block");
                    var event = window.event || e;
                    if (event.preventDefault) event.preventDefault();
                    if (event.stopPropagation) event.stopPropagation();
                    event.cancelBubble = true;
                    return false;
                });

            }
            else {
                obj.bindAnchorTarget.removeClass("disable");
                obj.bindAnchorTarget.removeAttr("disable");

                obj.bindAnchorTarget.find("a").unbind("mousedown.AXInputDisabled");
            }
        }
    },
    appendAnchor: function (objID, objSeq, bindType) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        //trace("appendAnchor");
        axdom("#" + cfg.targetID + "_AX_" + objID).remove();
        var anchorNode = axdom("<div id=\"" + cfg.targetID + "_AX_" + objID + "\" class=\"" + cfg.anchorClassName + "\" style=\"display:none;\"></div>");
        var iobj = axdom("#" + objID);
        iobj.attr("data-axbind", bindType);
        iobj.after(anchorNode);

        obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        obj.bindTarget = iobj;

        //var offSetParent = iobj.offsetParent();
        var iobjPosition = iobj.position();
        var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

        var borderW = iobj.css("border-left-width").number();
        var borderH = iobj.css("border-top-width").number();
        var marginW = iobj.css("margin-left").number();
        var marginH = iobj.css("margin-top").number();
        l = l + marginW;

        /*t = t;*/
        w = iobj.outerWidth();
        h = (iobj.css("box-sizing") == "content-box") ? iobj.outerHeight() : iobj.height();

        var css = {left: l, top: t, width: w, height: 0};

        obj.bindAnchorTarget.css(css);
        obj.bindAnchorTarget.data("height", h);

        var _this = this;
        setTimeout(function () {
            _this.alignAnchor(objID, objSeq);
        });
        setTimeout(function () {
            _this.alignAnchor(objID, objSeq);
        }, 500);
    },
    alignAnchor: function (objID, objSeq) {
        var cfg = this.config;

        if (typeof objSeq == "undefined") {
            for (var i = 0; i < this.objects.length; i++) {
                if (this.objects[i].id == objID && !this.objects[i].isDel) {
                    objSeq = i;
                    break;
                }
            }
        }

        var obj = this.objects[objSeq];

        if (!AXgetId(objID)) return;
        /* 엘리먼트 존재 여부 확인 */

        if (!obj.bindTarget) {
            obj.bindTarget = axdom("#" + objID);
            obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        }

        var iobjPosition = obj.bindTarget.position();
        var l = iobjPosition.left, t = iobjPosition.top;
        var w = obj.bindTarget.outerWidth();
        var h = obj.bindTarget.outerHeight();
        if (obj.bindTarget.css("display") == "none") {
            h = obj.bindAnchorTarget.data("height");
            var css = {width: w};
        }
        else {
            var css = {left: l, top: t, width: w, height: 0};
        }
        //trace(css);
        if (!obj.bindAnchorTarget) {
            obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
            obj.bindTarget = axdom("#" + objID);
        }
        if (obj.bindAnchorTarget) {
            obj.bindAnchorTarget.css(css);
            obj.bindAnchorTarget.data("height", h);
        }

        if (obj.bindType == "placeHolder") {

        }
        else if (obj.bindType == "search") {

        }
        else if (obj.bindType == "number") {
            var UPh = parseInt((h - 2) / 2) - 1;
            var DNh = parseInt((h - 2) / 2) - 2;
            var handleWidth = h - 2;
            if (handleWidth > 20) handleWidth = 20;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer").css({width: handleWidth, height: h - 2});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_increase").css({width: handleWidth, height: UPh});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_decrease").css({
                top: (UPh + 1),
                width: handleWidth,
                height: DNh
            });
            //trace({top:(UPh+1), width:h, height:DNh});
        }
        else if (obj.bindType == "money") {

        }
        else if (obj.bindType == "selector") {
            h -= 2;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer").css({width: h, height: h});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").css({width: h, height: h});

            if (obj.config.finder) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_FinderContainer").css({right: h, width: h, height: h});
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Finder").css({width: h, height: h});
            }
        }
        else if (obj.bindType == "slider") {

        }
        else if (obj.bindType == "twinSlider") {

        }
        else if (obj.bindType == "switch") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").css({width: w, height: h});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").css({height: h, "line-height": h + "px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchHandle").css({height: h});
            obj.bindAnchorTarget.css({height: h});
        }
        else if (obj.bindType == "segment") {
            obj.bindAnchorTarget.css({
                height: h + "px",
                "position": "relative",
                display: "inline-block",
                left: "auto",
                top: "auto"
            });
            var borderTop = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-top-width").number();
            var borderBot = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-bottom-width").number();
            obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css({
                height: (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px",
                "line-height": (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px"
            });
        }
        else if (obj.bindType == "date") {
            var handleWidth = h - 2;
            if (handleWidth > 20) handleWidth = 20;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").css({width: h, height: h});
        }
        else if (obj.bindType == "twinDate") {
            var handleWidth = h - 2;
            if (handleWidth > 20) handleWidth = 20;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").css({width: h, height: h});
        }
        else if (obj.bindType == "twinDateTime") {
            var handleWidth = h - 2;
            if (handleWidth > 20) handleWidth = 20;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").css({width: h, height: h});
        }
        else if (obj.bindType == "checked") {

        }
    },
    bindSetValue: function (objID, value) {
        var cfg = this.config;
        var objSeq = null;
        axf.each(this.objects, function (index, O) {
            if (O.id == objID) {
                objSeq = index;
                return false;
            }
        });
        if (objSeq == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        }
        else {
            var obj = this.objects[objSeq];

            if (obj.bindType == "search") {
                //	this.bindSearch(objID, objSeq);
            }
            else if (obj.bindType == "number") {
                //	this.bindNumber(objID, objSeq);
            }
            else if (obj.bindType == "money") {
                //	this.bindMoney(objID, objSeq);
            }
            else if (obj.bindType == "selector") {
                this.bindSelectorSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "slider") {
                this.bindSliderSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "twinSlider") {
                this.bindTwinSliderSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "switch") {
                this.bindSwitchSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "segment") {
                this.bindSegmentSetValue(objID, objSeq, value);
            }
            else if (obj.bindType == "date") {
                //	this.bindDate(objID, objSeq);
            }
            else if (obj.bindType == "twinDate") {
                //	this.bindTwinDate(objID, objSeq);
            }
        }
    },

    // onlyHolder ~~~~~~~~~~~~~~~
    bindPlaceHolder: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        // 브라우저 체크
        if (AXUtil.browser.name != "ie") return;
        if (AXUtil.browser.name == "ie" && AXUtil.browser.version > 9) return;

        var w = axdom("#" + cfg.targetID + "_AX_" + objID).width();
        var h = axdom("#" + cfg.targetID + "_AX_" + objID).data("height");

        var placeholder = axdom("#" + objID).attr("placeholder");
        if (placeholder == "undefined") placeholder = "";

        var po = ["<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder\" class=\"" + cfg.anchorPlaceHolderClassName + "\" style=\"left:0px;top:0px;width:" + w + "px;height:" + h + "px;line-height:" + h + "px;\">" + placeholder + "</a>"];
        //append to anchor
        axdom("#" + cfg.targetID + "_AX_" + objID).append(po.join(''));
        //bind handle
        var bindPlaceHolderKeyup = this.bindPlaceHolderSyncAnchor.bind(this);
        axdom("#" + objID).unbind("keyup.AXInput").bind("keyup.AXInput", function () {
            bindPlaceHolderKeyup(objID, objSeq);
        });
        bindPlaceHolderKeyup(objID, objSeq);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder").unbind("click.AXInput").bind("click.AXInput", function () {
            //axdom("#"+objID).val("");
            axdom("#" + objID).focus();
            bindPlaceHolderKeyup(objID, objSeq);
        });
        //------------------------------------
    },
    bindPlaceHolderSyncAnchor: function (objID, objSeq) {
        var cfg = this.config;
        if (axdom("#" + objID).val().trim() == "") {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display == "none") 
            axdom("#" + cfg.targetID + "_AX_" + objID).show();
        }
        else {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display != "none") 
            axdom("#" + cfg.targetID + "_AX_" + objID).hide();
        }
    },
    // onlyHolder ~~~~~~~~~~~~~~

    // search
    bindSearch: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var w = axdom("#" + cfg.targetID + "_AX_" + objID).width();
        var h = axdom("#" + cfg.targetID + "_AX_" + objID).data("height");
        var placeholder = axdom("#" + objID).attr("placeholder");
        if (placeholder == undefined) placeholder = "";
        var po = [];

        if (AXUtil.browser.name == "ie" && AXUtil.browser.version < 10 && placeholder != "") {
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder\" class=\"" + cfg.anchorPlaceHolderClassName + "\" ");
            po.push(" style=\"left:0px;top:0px;width:" + w + "px;height:" + h + "px;line-height:" + h + "px;\">" + placeholder + "</a>");
        }
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_Search\" class=\"" + cfg.anchorSearchClassName + "\" ");
        po.push(" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">Search</a>");
        //append to anchor
        axdom("#" + cfg.targetID + "_AX_" + objID).append(po.join(''));
        //bind handle
        var bindSearchKeyup = this.bindSearchSyncAnchor.bind(this);
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", function () {
            bindSearchKeyup(objID, objSeq);
        });
        bindSearchKeyup(objID, objSeq);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Search").unbind("click.AXInput").bind("click.AXInput", function () {
            axdom("#" + objID).val("");
            axdom("#" + objID).focus();
            bindSearchKeyup(objID, objSeq);
        });
        //------------------------------------
    },
    bindSearchSyncAnchor: function (objID, objSeq) {
        var cfg = this.config;
        axdom("#" + cfg.targetID + "_AX_" + objID).show();

        if (axdom("#" + objID).val() == "") {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display != "none") axdom("#"+cfg.targetID+"_AX_"+objID).hide();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Search").hide();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder").show();
        }
        else {
            //if(AXgetId(cfg.targetID+"_AX_"+objID).style.display == "none") axdom("#"+cfg.targetID+"_AX_"+objID).fadeIn();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Search").show();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_PlaceHolder").hide();
        }
    },

    // number
    bindNumber: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        var h = obj.bindAnchorTarget.data("height");
        //trace(objID+"//"+h);
        var po = [];
        var UPh = parseInt((h - 2) / 2) - 1;
        var DNh = parseInt((h - 2) / 2) - 2;
        //trace(UPh+"//"+DNh);
        var handleWidth = h - 2;
        if (handleWidth > 20) handleWidth = 20;

        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer\" class=\"" + cfg.anchorNumberContainerClassName + "\" style=\"right:0px;top:0px;width:" + handleWidth + "px;height:" + (h - 2) + "px;\" onselectstart=\"return false;\">");
        po.push("	<a id=\"" + cfg.targetID + "_AX_" + objID + "_AX_increase\" class=\"" + cfg.anchorIncreaseClassName + "\" style=\"right:0px;top:0px;width:" + handleWidth + "px;height:" + UPh + "px;\">increase</a>");
        po.push("	<a id=\"" + cfg.targetID + "_AX_" + objID + "_AX_decrease\" class=\"" + cfg.anchorDecreaseClassName + "\" style=\"right:0px;top:" + (UPh + 1) + "px;width:" + handleWidth + "px;height:" + DNh + "px;\">decrease</a>");
        po.push("</div>");
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        //alert("show");

        var bindNumberAdd = this.bindNumberAdd.bind(this);
        var bindNumberCheck = this.bindNumberCheck.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_increase").unbind("mousedown.AXInput").bind("mousedown.AXInput", function (event) {
            bindNumberAdd(objID, 1, objSeq);
            bindNumberCheck(objID, objSeq, event);
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_decrease").unbind("mousedown.AXInput").bind("mousedown.AXInput", function (event) {
            bindNumberAdd(objID, -1, objSeq);
            bindNumberCheck(objID, objSeq, event);
        });
        /*
         obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
         bindNumberCheck(objID, objSeq, event);
         });
         */
        obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function (event) {
            if (event.keyCode == AXUtil.Event.KEY_UP) bindNumberAdd(objID, 1, objSeq);
            else if (event.keyCode == AXUtil.Event.KEY_DOWN) bindNumberAdd(objID, -1, objSeq);
            //else bindNumberCheck(objID, objSeq, event);
        });
        obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindNumberCheck(objID, objSeq, event);
        });
    },
    bindNumberAdd: function (objID, adder, objSeq) {
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        var maxval = obj.config.max;
        var minval = obj.config.min;
        var nval = obj.bindTarget.val().number();
        if (adder > 0) {
            //max 를 초과 하는지 확인
            if ((nval + adder) < minval) nval = minval;
            if (maxval != undefined && maxval != null) {
                if ((nval + adder) > maxval) return;
            }
        }
        else {
            //min 를 초과 하는지 확인
            if (minval != undefined && minval != null) {
                if ((nval + adder) < minval) return;
            }
        }
        obj.bindTarget.val(nval + adder);
        obj.bindTarget.change();
    },
    bindNumberCheck: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (this.numbercheck_obs) clearTimeout(this.numbercheck_obs);
        this.numbercheck_obs = setTimeout(function () {
            var maxval = obj.config.max;
            var minval = obj.config.min;
            var nval;
            if (obj.bindTarget.val() == "") {
                if (minval != undefined && minval != null) {
                    nval = minval;
                }
                else {
                    nval = obj.bindTarget.val().number();
                }
            }
            else {
                nval = obj.bindTarget.val().number();
            }

            if (maxval != undefined && maxval != null) {
                if ((nval) > maxval) {
                    obj.bindTarget.val("");
                    try {
                        this.msgAlert("설정된 최대값을 넘어서는 입력입니다.");
                    } catch (e) {
                    }
                }
                else {
                    if (minval != undefined && minval != null) {
                        if ((nval) < minval) {
                            obj.bindTarget.val("");
                            try {
                                this.msgAlert("설정된 최소값보다 작은 입력입니다.");
                            } catch (e) {
                            }
                        }
                        else {
                            obj.bindTarget.val(nval);
                        }
                    }
                }
            }
            else {
                if (minval != undefined && minval != null) {
                    if ((nval) < minval) {
                        obj.bindTarget.val("");
                        try {
                            this.msgAlert("설정된 최소값보다 작은 입력입니다.");
                        } catch (e) {
                        }
                    }
                }
                else {
                    obj.bindTarget.val(nval);
                }
            }
            obj.bindTarget.trigger("change");

            if (event && event.type == "mousedown") {
                obj.bindTarget.setCaret();
            }

            if (obj.config.onChange) {
                obj.config.onChange.call({objID: objID, objSeq: objSeq, value: axdom("#" + objID).val()});
            }
            if (obj.config.onchange) {
                obj.config.onchange.call({objID: objID, objSeq: objSeq, value: axdom("#" + objID).val()});
            }
        }, 1);

    },

    // money
    bindMoney: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        obj.bindTarget.css({"text-align": "right"});
        var bindMoneyCheck = this.bindMoneyCheck.bind(this);
        var val = obj.bindTarget.val().trim();
        if (val != "") val = obj.bindTarget.val().number().money();
        obj.bindTarget.val(val);

        obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function (event) {
            if ((event.ctrlKey || event.metaKey)) {
                obj.bindTarget.data("ctrlKey", "T");
            }
            else {
                obj.bindTarget.data("ctrlKey", "F");
            }
        });
        obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function (event) {
            var elem = obj.bindTarget.get(0);

            if (elem.type != "number") {
                event = window.event || event;

                // ignore tab & shift key 스킵 & ctrl
                if (
                    (!event.keyCode || event.keyCode == 9 || event.keyCode == 16 || event.keyCode == 17) ||
                    ((obj.bindTarget.data("ctrlKey") == "T") && (event.keyCode == 65 || event.keyCode == 91))
                ) {
                    jQuery.removeData(obj.bindTarget.get(0), "focusPosition");
                }
                else {
                    var elemFocusPosition;
                    if ('selectionStart' in elem) {
                        // Standard-compliant browsers
                        elemFocusPosition = elem.selectionStart;
                    }
                    else if (document.selection) {
                        // IE
                        //elem.focus();
                        var sel = document.selection.createRange();
                        var selLen = document.selection.createRange().text.length;
                        sel.moveStart('character', -elem.value.length);
                        elemFocusPosition = sel.text.length - selLen;
                    }
                    //trace(elemFocusPosition);
                    // 계산된 포커스 위치 앞에 쉼표 갯수를 구합니다.

                    obj.bindTarget.data("focusPosition", elemFocusPosition);
                    obj.bindTarget.data("prevLen", elem.value.length);

                    if (event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
                        bindMoneyCheck(objID, objSeq, "keyup");
                    }
                    else if (event.keyCode == AXUtil.Event.KEY_DELETE || event.keyCode == AXUtil.Event.KEY_BACKSPACE) {
                        bindMoneyCheck(objID, objSeq, "keyup");
                    }
                }
            }
        });

        /* blur 이벤트 처리 이상 작동으로 제거 - 15-01-16
         obj.bindTarget.unbind("change.AXInput").bind("change.AXInput", function (event) {
         if(obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable"){
         return false;
         }
         if(event.target.type != "number") {
         bindMoneyCheck(objID, objSeq, "change");
         }
         });
         */
    },
    bindMoneyCheck: function (objID, objSeq, eventType) {
        var obj = this.objects[objSeq];
        var maxval = obj.config.max;
        var minval = obj.config.min;
        var nval;
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;

        if (obj.bindTarget.val() == "") {
            if (minval != undefined && minval != null) {
                nval = minval;
            }
            else {
                nval = "";
            }
        }
        else {
            if (obj.bindTarget.val() != "-") {
                nval = obj.bindTarget.val().number();
            }
            else {
                nval = "";
            }
        }
        if (maxval != undefined && maxval != null) {
            if ((nval) > maxval) {
                obj.bindTarget.val(maxval.money());
                try {
                    if (eventType == "change") this.msgAlert("설정된 최대값{" + maxval.number().money() + "} 을 넘어서는 입력입니다.");
                } catch (e) {
                }
            }
            else {
                if (minval != undefined && minval != null) {
                    if ((nval) < minval) {
                        obj.bindTarget.val(minval.money());
                        try {
                            if (eventType == "change") this.msgAlert("설정된 최소값{" + minval.number().money() + "}보다 작은 입력입니다.");
                        } catch (e) {
                        }
                    }
                    else {
                        obj.bindTarget.val(nval.money());
                    }
                }
                else {
                    obj.bindTarget.val(nval.money());
                }
            }
        }
        else {
            if (minval != undefined && minval != null) {
                if ((nval) < minval) {
                    obj.bindTarget.val(minval.money());
                    try {
                        if (eventType == "change") this.msgAlert("설정된 최소값{" + minval.number().money() + "}보다 작은 입력입니다.");
                    } catch (e) {
                    }
                }
                else {
                    if (nval != "" && nval != "-") obj.bindTarget.val(nval.money());
                }
            }
            else {
                if (nval != "" && nval != "-") obj.bindTarget.val(nval.money());
            }
        }
        obj.bindTarget.trigger("change");

        if (!axf.isEmpty(obj.bindTarget.data("focusPosition"))) {
            obj.bindTarget.setCaret(obj.bindTarget.data("focusPosition").number() + ( obj.bindTarget.val().length - obj.bindTarget.data("prevLen") ));
        }

        if (obj.config.onChange) {
            obj.config.onChange.call({objID: objID, objSeq: objSeq, value: obj.bindTarget.val().number()});
        }

        if (eventType == "change") {
            if (obj.bindTarget.val() == "-") obj.bindTarget.val('');
        }
    },

    // selector
    bindSelector: function (objID, objSeq) {
        var _this = this;
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        obj.bindTarget.data("val", obj.bindTarget.val());

        var reserveKeys = jQuery.extend({}, cfg.reserveKeys);
        if (typeof obj.config.reserveKeys == "undefined") obj.config.reserveKeys = {};
        obj.config.reserveKeys = jQuery.extend(reserveKeys, obj.config.reserveKeys, true);

        var h = obj.bindAnchorTarget.data("height") - 2;
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_HandleContainer\" class=\"bindSelectorNodes " + cfg.anchorSelectorHandleContainerClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">");
        po.push("	<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_Handle\" class=\"bindSelectorNodes " + cfg.anchorSelectorHandleClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">expand</a>");
        po.push("</div>");
        if (obj.config.finder) {
            po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_FinderContainer\" class=\"bindSelectorNodes " + cfg.anchorSelectorFinderContainerClassName + "\" style=\"right:" + h + "px;top:0px;width:" + h + "px;height:" + h + "px;\">");
            po.push("	<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_Finder\" class=\"bindSelectorNodes " + cfg.anchorSelectorFinderClassName + "\" style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">finder</a>");
            po.push("</div>");
        }

        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();

        var bindSelectorExpand = this.bindSelectorExpand.bind(this);
        var bindSelectorClose = this.bindSelectorClose.bind(this);

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").unbind("click.AXInput").bind("click.AXInput", function (event) {
            if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                //axdom("#" + objID).focus();
                bindSelectorExpand(objID, objSeq, true, event);
            }
            else {
                bindSelectorClose(objID, objSeq, event);
            }
        });
        obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
                return false;
            }
            try {
                this.select();
            } catch (e) {
            }
            if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                //bindSelectorExpand(objID, objSeq, false, event);
            }
        });

        obj.bindTarget.unbind("keydown.AXInputCheck").bind("keydown.AXInputCheck", function (event) {
            if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
                return false;
            }

            if(event.which == axf.Event.KEY_UP || event.which == axf.Event.KEY_DOWN){
                if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                    bindSelectorExpand(objID, objSeq, false, event);
                }
                _this.stopEvent(event);
                return false;
            }
            else if(event.which == axf.Event.KEY_RETURN || event.which == axf.Event.KEY_TAB){

            }
            else{
                if (!AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                    bindSelectorExpand(objID, objSeq, false, event);
                }
            }
        });

        if (obj.config.finder) {
            if (obj.config.finder.onclick) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Finder").unbind("click.AXInput").bind("click.AXInput", function (event) {
                    if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
                        return false;
                    }
                    obj.config.finder.onclick.call({
                        targetID: objID,
                        value: axdom("#" + objID).val()
                    }, objID);
                    bindSelectorClose(objID, objSeq, event);
                });
            }
        }

        /*
         var bindSelectorInputChange = this.bindSelectorInputChange.bind(this);
         obj.inputChange = function(event){
         bindSelectorInputChange(objID, objSeq, event);
         }
         axdom("#"+objID).bind("change.AXInput", obj.inputChange);
         */
    },
    bindSelectorExpand: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var reserveKeys = obj.config.reserveKeys;
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        obj.bindTarget.data("val", obj.bindTarget.val().enc());

        //alert(obj.bindTarget.data("val").end());

        if (this.opendExpandBox) {
            this.bindSelectorClose(this.opendExpandBox.objID, this.opendExpandBox.objSeq, event); // 셀럭터 외의 영역이 므로 닫기
        }

        var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
        //trace({objID:objID, objSeq:objSeq});

        if (axdom("#" + cfg.targetID + "_AX_" + objID).data("blurEvent")) {
            //blur event 발생 상태 메소드 작동 중지
            return;
        }

        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
        //Expand Box 생성 구문 작성
        var anchorWidth = jqueryTargetObjID.width() - 2; // anchor width
        var anchorHeight = jqueryTargetObjID.data("height") - 1;
        var styles = [];
        styles.push("top:" + anchorHeight + "px");
        styles.push("width:" + (obj.config.anchorWidth || anchorWidth) + "px");
        styles.push("z-index:5100");

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandBoxClassName + "\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandScrollClassName + "\">");
        po.push("	<div class=\"AXLoadingSmall bindSelectorNodes\"></div>");
        po.push("</div>");
        po.push("</div>");
        axdom(document.body).append(po.join(''));
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").addClass("on");

        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        if (obj.config.positionFixed) {
            expandBox.css({"position": "fixed"});
        }
        var expBoxHeight = expandBox.outerHeight();
        var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();
        if (obj.config.position) {
            offset = jqueryTargetObjID.offset();
            if (obj.config.position.top != undefined) {
                offset.top = obj.config.position.top;
            }
        }
        var css = {};
        css.top = offset.top + anchorHeight;
        if (obj.config.direction == "bottom") {
            css.top -= expandBox.outerHeight();
        }

        css.left = offset.left;
        expandBox.css(css);

        this.opendExpandBox = {objID: objID, objSeq: objSeq};

        //_AX_expandBox set options
        //trace(obj.config.ajaxUrl);
        if (obj.config.onsearch) {
            this.bindSelectorKeyupChargingUp(objID, objSeq, event);
        }
        else if (obj.config.ajaxUrl) {
            // AJAX호출
            this.bindSelectorKeyupChargingUp(objID, objSeq, event);
        }
        else {
            if (!obj.config.options) {
                trace("options 항목이 없어 bind selector 를 완성 할 수 없습니다.");
                return;
            }
            this.bindSelectorSetOptions(objID, objSeq);
            this.bindSelectorKeyupChargingUp(objID, objSeq, event);
        }

        var bindSelectorOptionsClick = this.bindSelectorOptionsClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindSelectorOptionsClick(objID, objSeq, event);
        };
        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);

    },
    bindSelectorBlur: function (objID) {
        var cfg = this.config;
        var objSeq = null;
        axf.each(this.objects, function (idx, O) {
            //if (this.id == objID && this.isDel == true) objSeq = idx;
            if (this.id == objID) {
                objSeq = idx;
            }
        });
        if (objSeq != null) this.bindSelectorClose(objID, objSeq);
    },
    bindSelectorClose: function (objID, objSeq, event, originChangeCall) {

        var cfg = this.config;
        var obj = this.objects[objSeq];
        var reserveKeys = obj.config.reserveKeys;
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        if (obj.inProgress) AXReqAbort(); // AJAX 호출 중지 하기

        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {

            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");

            //비활성 처리후 메소드 종료

            axdom(document).unbind("click.AXInput");
            obj.bindTarget.unbind("keydown.AXInput");
            obj.bindTarget.unbind("change.AXInput");

            if (obj.bindTarget.data("val") == obj.bindTarget.val().enc() && !obj.config.isSelectorClick) {
                //return obj.bindTarget.val();
            }

            if (obj.config.isChangedSelect) {

                var myVal = "";
                if (obj.config.selectedObject) {
                    myVal = obj.config.selectedObject[reserveKeys.optionText];
                }

                if (obj.config.appendable) {
                    //trace(myVal);
                    if (myVal != "") axdom("#" + objID).val(myVal);
                }
                else {
                    axdom("#" + objID).val(myVal);
                }

                if (obj.config.onChange) {
                    var sendObj = {
                        targetID: objID,
                        options: obj.config.options,
                        selectedIndex: obj.config.selectedIndex,
                        selectedOption: obj.config.selectedObject
                    }
                    if (obj.config.onChange) obj.config.onChange.call(sendObj);
                    else if (obj.config.onchange) obj.config.onchange.call(sendObj);
                }
                obj.config.isChangedSelect = false;
                if (originChangeCall) obj.bindTarget.change();
            }
            //trace(obj.config.selectedObject);
            if (obj.config.selectedObject) this.bindSelectorInputChange(objID, objSeq);
            else {
                if (!obj.config.appendable) {
                    if (!obj.config.selectedObject && !obj.inProgress) axdom("#" + objID).val("");
                }
            }
            //if(event) event.stopPropagation(); // disableevent
            //return;
        }
    },
    bindSelectorSetOptions: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        var maxHeight = obj.config.maxHeight || 130;
        var optionPrintLength = obj.config.optionPrintLength || 100;
        if (!obj.config.options) return;

        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
        var po = [];
        axf.each(obj.config.options, function (index, O) {
            if (!isNaN(optionPrintLength)) {
                if (index > optionPrintLength - 1) return false;
            }

            // options의 optionText, optionDesc의 참조값을 디코딩해서 디코딩은 한 번만 사용하도록 변경
            O[reserveKeys.optionText] = (O[reserveKeys.optionText] ? O[reserveKeys.optionText].dec() : "");
            O.desc = (O.desc ? O.desc.dec() : "");
            O.optionDesc = (O[reserveKeys.optionDesc] ? O[reserveKeys.optionDesc].dec() : "");

            var descStr = O.desc || O.optionDesc;
            if (descStr != "") descStr = "<span>" + descStr + "</span>";
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option\" class=\"bindSelectorNodes\">" + O[reserveKeys.optionText] + descStr + "</a>");
        });
        if (po.length == 0) {
            var selectorOptionEmpty = "";
            if (AXConfig.AXInput) selectorOptionEmpty = (AXConfig.AXInput.selectorOptionEmpty || "empty options");
            po.push("<div class=\"empty\">" + selectorOptionEmpty + "</div>");
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").html(po.join(''));
        obj.config.isSelectorClick = false;

        var expandScrollHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").outerHeight();
        if (expandScrollHeight > maxHeight) expandScrollHeight = maxHeight;
        expandBox.css({height: expandScrollHeight + "px"});

        var bindSelectorOptionsClick = this.bindSelectorOptionsClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindSelectorOptionsClick(objID, objSeq, event);
        };
        var bindSelectorKeyup = this.bindSelectorKeyup.bind(this);
        obj.inputKeyup = function (event) {
            bindSelectorKeyup(objID, objSeq, event);
        };

        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", obj.inputKeyup);

        if (obj.myUIScroll) obj.myUIScroll.unbind();
        obj.myUIScroll = new AXScroll();
        obj.myUIScroll.setConfig({
            CT_className: "AXScrollSmall",
            targetID: cfg.targetID + "_AX_" + objID + "_AX_expandBox",
            scrollID: cfg.targetID + "_AX_" + objID + "_AX_expandScroll",
            touchDirection: false
        });
        obj.myUIScroll.scrollTop(0);

        if (obj.config.selectedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option").addClass("on");
            obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option"); //focus
            obj.config.focusedIndex = obj.config.selectedIndex;
        }

        if (obj.config.direction == "bottom") {
            var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();
            if (obj.config.position) {
                offset = jqueryTargetObjID.offset();
                if (obj.config.position.top != undefined) {
                    offset.top = obj.config.position.top;
                }
            }
            expandBox.css({top: offset.top - expandBox.outerHeight()});
        }
    },
    bindSelectorOptionsClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;

        var myTarget = this.getEventTarget({
            evt: eventTarget,
            until: function (evt, evtIDs) {
                return (evt.parentNode.tagName == "body") ? true : false;
            },
            find: function (evt, evtIDs) {
                if (evt.id == "") return false;
                if (evt.id == objID || axdom(evt).hasClass("bindSelectorNodes")) {
                    return true;
                }
                else {
                    return false;
                }
            }
        });
        var isSelectorClick = (myTarget) ? true : false;
        if (!isSelectorClick) {
            this.bindSelectorClose(objID, objSeq, event); // 셀럭터 외의 영역이 므로 닫기
        }
        else {
            eid = myTarget.id.split(/_AX_/g);
            if (eid.last() == "option") {
                var selectedIndex = eid[eid.length - 2];
                obj.config.selectedIndex = selectedIndex;
                obj.config.focusedIndex = selectedIndex;
                obj.config.selectedObject = obj.config.options[selectedIndex];
                obj.config.isChangedSelect = true;
                obj.config.isSelectorClick = true;
                this.bindSelectorClose(objID, objSeq, event, "bindTarget_onchange"); // 값 전달 후 닫기
            }
        }
    },
    bindSelectorKeyup: function (objID, objSeq, event) {
        var obj = this.objects[objSeq], _this = this;
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (obj.inProgress) {
            obj.inProgressReACT = true;
            return;
        }

        if (event.keyCode == AXUtil.Event.KEY_TAB) {
            this.bindSelectorClose(objID, objSeq, event); // 닫기
            this.stopEvent(event);
            return;
        }

        if (event.keyCode == AXUtil.Event.KEY_UP) {
            if (!obj.config.options) return;
            if (obj.config.options.length == 0) return;
            var focusIndex = obj.config.options.length - 1;
            if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == 0) {
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            else {
                focusIndex = (obj.config.focusedIndex) - 1;
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            this.bindSelectorSelect(objID, objSeq, focusIndex);
            this.stopEvent(event);
        }
        else if (event.keyCode == AXUtil.Event.KEY_DOWN) {
            if (!obj.config.options) return;
            if (obj.config.options.length == 0) return;
            var focusIndex = 0;
            if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == obj.config.options.length - 1) {
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            else {
                focusIndex = (obj.config.focusedIndex).number() + 1;
                //trace(obj.config.selectedIndex+"//"+focusIndex);
            }
            this.bindSelectorSelect(objID, objSeq, focusIndex);
            this.stopEvent(event);
        }
        else if (event.keyCode == AXUtil.Event.KEY_RETURN) {

            if (obj.config.focusedIndex == null) {
                /*axdom("#" + objID).blur();*/
                _this.bindSelectorClose(objID, objSeq, event); // 닫기
            }
            else {
                //trace(obj.config.focusedIndex);
                obj.config.selectedObject = obj.config.options[obj.config.focusedIndex];
                obj.config.selectedIndex = obj.config.focusedIndex;
                obj.config.isChangedSelect = true;
                axdom("#" + objID).val(obj.config.selectedObject[reserveKeys.optionText]);
                /*axdom("#" + objID).blur();*/
                _this.bindSelectorClose(objID, objSeq, event, "bindTarget_onchange"); // 닫기
            }
            this.stopEvent(event);
        }
        else {
            //1. 반복입력 제어 하기
            var bindSelectorKeyupChargingUp = this.bindSelectorKeyupChargingUp.bind(this);
            if (obj.Observer) clearTimeout(obj.Observer); //명령 제거
            obj.Observer = setTimeout(function () {
                bindSelectorKeyupChargingUp(objID, objSeq, event);
            }, 500);
        }
    },
    bindSelectorKeyupChargingUp: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        var objVal = axdom("#" + objID).val();
        var bindSelectorSearch = this.bindSelectorSearch.bind(this);
        https://github.com/axisj/axisj/issues/781
            if (obj.config.onsearch) {

                var res = obj.config.onsearch.call(
                    {
                        id: objID,
                        value: objVal
                    },
                    objID,
                    objVal,
                    (function (res) {
                        obj.config.options = res.options;
                        obj.config.focusedIndex = null;
                        this.bindSelectorSetOptions(objID, objSeq);
                        this.bindSelectorSearch(objID, objSeq, objVal);
                    }).bind(this)
                );

                /*
                 callBack 함수를 이용하는 경우와 return 하는 두 가지 경우가 존재 하겠다. 아래는 obj.config.onsearch 에서 return 한 경우이고 위의 함수는 callBack 함수인 경우이다.
                 */
                if (res) {
                    res.options = res.options || [];
                    obj.config.options = res.options;
                    obj.config.focusedIndex = null;
                    this.bindSelectorSetOptions(objID, objSeq);
                    this.bindSelectorSearch(objID, objSeq, objVal);
                }

            }
            else if (obj.config.ajaxUrl) {
                // AJAX호출
                // 2. AJAX request
                // 3. AJAX 결과로 bindSelectorSetOptions 처리하기
                //this.bindSelectorSetOptions(objID, objSeq);
                // 4. 입력어로 bindSelectorSearch 실행하기
                obj.inProgress = true; //진행중 상태 변경
                var bindSelectorSetOptions = this.bindSelectorSetOptions.bind(this);
                var bindSelectorKeyupChargingUp = this.bindSelectorKeyupChargingUp.bind(this);

                var url = obj.config.ajaxUrl;
                var pars = obj.config.ajaxPars || {};
                var _method = "post";
                var _headers = {};
                var _contentType = AXConfig.AXReq.contentType;
                var _responseType = AXConfig.AXReq.responseType;
                var _dataType = AXConfig.AXReq.dataType;
                var _async = AXConfig.AXReq.async;

                // ajax 옵션 확장
                if (obj.config.method) _method = obj.config.method;
                if (obj.config.headers) _headers = obj.config.headers;
                if (obj.config.contentType) _contentType = obj.config.contentType;
                if (obj.config.responseType) _responseType = obj.config.responseType;
                if (obj.config.dataType) _dataType = obj.config.dataType;
                if (obj.config.ajaxAsync) _async = obj.config.ajaxAsync;

                var selectorName = obj.config.selectorName || axdom("#" + objID).attr("name");
                if (pars == "") {
                    pars = selectorName + "=" + (objVal || "").enc();
                }
                else if ((typeof pars).toLowerCase() == "string") {
                    pars += "&" + selectorName + "=" + objVal.enc();
                }
                else if ((typeof pars).toLowerCase() == "object") {
                    pars[selectorName] = objVal.enc();
                }

                var msgAlert = this.msgAlert.bind(this);
                new AXReq(url, {
                    type: _method,
                    headers: _headers,
                    contentType: _contentType,
                    responseType: _responseType,
                    dataType: _dataType,
                    async: _async,
                    debug: ((typeof obj.config.debug !== "undefined") ? obj.config.debug : false),
                    pars: pars,
                    onsucc: function (res) {
                        if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {

                            //obj.config.options = (res.options || []);
                            obj.config.options = (res[reserveKeys.options] || []);
                            obj.config.focusedIndex = null;

                            bindSelectorSetOptions(objID, objSeq);
                            bindSelectorSearch(objID, objSeq, objVal);

                            if (obj.inProgressReACT) {
                                bindSelectorKeyupChargingUp(objID, objSeq, event);
                            }
                        }
                        else {
                            msgAlert(res);
                        }
                        obj.inProgress = false;
                        obj.inProgressReACT = false;
                    }
                });
            }
            else {
                // 입력어로 bindSelectorSearch 실행하기

                bindSelectorSearch(objID, objSeq, objVal);
            }
    },
    bindSelectorInputChange: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (axdom("#" + objID).val() != obj.config.selectedObject[reserveKeys.optionText]) {
            if (!obj.config.appendable) axdom("#" + objID).val("");
            obj.config.selectedObject = null;
            obj.config.selectedIndex = null;
            obj.config.focusedIndex = null;
            if (obj.config.onChange) {
                obj.config.onChange(null);
            }
        }
    },
    bindSelectorSetValue: function (objID, objSeq, value) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;

        if (!obj.config.options) return;

        var selectedIndex = null;
        axf.each(obj.config.options, function (oidx, opt) {
            if (opt[reserveKeys.optionValue] == value) selectedIndex = oidx;
        });

        if (selectedIndex != null) {
            obj.config.focusedIndex = selectedIndex;
            obj.config.selectedObject = obj.config.options[selectedIndex];
            obj.config.isChangedSelect = true;
            axdom("#" + objID).val(obj.config.selectedObject[reserveKeys.optionText]);

            if (obj.config.onChange || obj.config.onchange) {
                var sendObj = {
                    targetID: objID,
                    options: obj.config.options,
                    selectedIndex: obj.config.selectedIndex,
                    selectedOption: obj.config.selectedObject
                };
                if (obj.config.onChange) obj.config.onChange.call(sendObj);
                else if (obj.config.onchange) obj.config.onchange.call(sendObj);
            }
        }
    },
    bindSelectorSearch: function (objID, objSeq, kword) { // 입력된 값으로 검색 하기
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (kword == "") {
            this.bindSelectorSelectClear(objID, objSeq);
            return;
        }
        kword = kword.replace(/\//g, "\\\/");
        var sw = AXUtil.consonantKR((kword || "").dec());
        var reAt = new RegExp("^" + sw + ".*", "i");

        var ix = null;
        for (var a = 0; a < obj.config.options.length; a++) {
            if (reAt.test((obj.config.options[a][reserveKeys.optionText] || ""))) {
                ix = a;
                break;
            }
        }
        if (ix != null) {
            this.bindSelectorSelect(objID, objSeq, ix, "dont change value");
        }
        else {
            this.bindSelectorSelectClear(objID, objSeq);
        }
    },
    bindSelectorSelect: function (objID, objSeq, index, changeValue) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (obj.config.focusedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option").addClass("on");
        obj.config.focusedIndex = index;
        //obj.config.selectedObject = obj.config.options[index];
        //obj.config.isChangedSelect = true;
        //if(!changeValue) axdom("#"+objID).val(obj.config.selectedObject.optionText.dec());
        obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option"); //focus
    },
    bindSelectorSelectClear: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var reserveKeys = obj.config.reserveKeys;
        if (obj.config.selectedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option").removeClass("on");
        }
        obj.config.selectedIndex = null;
        obj.config.focusedIndex = null;
        obj.config.selectedObject = null;
        obj.config.isChangedSelect = true;
    },

    // slider
    bindSlider: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBox").remove();

        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        //trace(h);
        var objVal = obj.bindTarget.val().number().money();
        if (objVal.number() < obj.config.min.number()) objVal = obj.config.min;
        else if (objVal.number() > obj.config.max.number()) objVal = obj.config.max;

        if (!obj.config.unit) obj.config.unit = "";

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBox\" class=\"" + cfg.anchorSliderBoxClassName + "\" style=\"left:0px;width:" + w + "px;height:" + h + "px;\">");
        po.push("	<div class=\"AXanchorSliderMinTitle\">" + obj.config.min.number().money() + obj.config.unit + "</div>");
        po.push("	<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar\" class=\"AXanchorSliderBar\">");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside\" class=\"AXanchorSliderBarInside\"><div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle\" class=\"AXanchorSliderHandleTitle\">" + objVal.number().money() + obj.config.unit + "</div></div>");
        po.push("		<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle\" class=\"AXanchorSliderHandle\">&nbsp;</a>");
        po.push("	</div>");
        po.push("	<div class=\"AXanchorSliderMaxTitle\">" + obj.config.max.number().money() + obj.config.unit + "</div>");
        po.push("</div>");

        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        //obj.bindAnchorTarget.css({ height: h + "px", "position": "relative", display: "inline-block", left: "auto", top: "auto" });
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        //, background:"#eee"

        var maxTitleWidth = axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMaxTitle").outerWidth().number() + 10;
        var minTitleWidth = axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMinTitle").outerWidth().number() + 10;
        if (maxTitleWidth < 30) maxTitleWidth = 30;
        if (minTitleWidth < 30) minTitleWidth = 30;
        axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMinTitle").css({width: minTitleWidth + "px"});
        axdom("#" + cfg.targetID + "_AX_" + objID).find(".AXanchorSliderMaxTitle").css({width: maxTitleWidth + "px"});
        var sliderBarWidth = w - minTitleWidth - maxTitleWidth;
        obj.bindAnchorTarget.find(".AXanchorSliderBar").css({
            width: sliderBarWidth + "px",
            left: minTitleWidth + "px",
            top: h / 2 + 2
        });
        //------------------------------------
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({width: maxTitleWidth});
        obj.config._maxTitleWidth = maxTitleWidth;
        obj.config._handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").width();
        obj.config._trackWidth = sliderBarWidth;
        this.bindSliderSetValue(objID, objSeq);

        var onmousedown = this.bindSliderMouseDown.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").unbind("mousedown.AXInput").bind("mousedown.AXInput", function () {
            onmousedown(objID, objSeq);
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").unbind("dragstart.AXInput").bind("dragstart.AXInput", function (event) {
            event.stopPropagation(); // disable  event
            return false;
        });

        //add touch event
        if (document.addEventListener) {
            var ontouchstart = this.sliderTouchStart.bind(this);
            obj.bindSliderTouchStart = function (event) {
                ontouchstart(objID, objSeq);
            }

            AXgetId(cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").addEventListener("touchstart", obj.bindSliderTouchStart, false);
        }

        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();

    },
    bindSliderMouseDown: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.isMoving) {
            var bindSliderMouseMove = this.bindSliderMouseMove.bind(this);
            obj.bindSliderMouseMove = function (event) {
                bindSliderMouseMove(objID, objSeq, event);
            };
            var bindSliderMouseUp = this.bindSliderMouseUp.bind(this);
            obj.bindSliderMouseUp = function (event) {
                bindSliderMouseUp(objID, objSeq, event);
            };
            axdom(document.body).unbind("mousemove.AXInput").bind("mousemove.AXInput", obj.bindSliderMouseMove);
            axdom(document.body).unbind("mouseup.AXInput").bind("mouseup.AXInput", obj.bindSliderMouseUp);
            obj.config.isMoving = true;
        }

    },
    bindSliderMouseMove: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var eX = event.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;

        var rX = eX - cX;

        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (typeof snap == "undefined") snap = 1;

        if (snap >= 1) {
            objVal = (objVal.number() + obj.config.min.number()).round();
            objVal = (parseInt(objVal / (snap), 10) * (snap));
        }
        else {
            objVal = (objVal.number() + obj.config.min.number()).round((snap.toString().length - 2));
            objVal = (parseFloat(objVal / (snap)) * (snap)).round((snap.toString().length - 2));
        }

        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;

        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;

        var sX = rX - (obj.config._handleWidth / 2);
        var stX = rX - (obj.config._maxTitleWidth / 2);

        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").css({left: sX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({left: stX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").text(objVal.number().money() + obj.config.unit);
        axdom("#" + objID).val(objVal);
    },
    bindSliderMouseUp: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var objVal = axdom("#" + objID).val();
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }

        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();

        axdom(document.body).unbind("mousemove.AXInput");
        axdom(document.body).unbind("mouseup.AXInput");
        obj.config.isMoving = false;
    },
    bindSliderSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (value != undefined) {
            var objVal = value;
        }
        else {
            var objVal = axdom("#" + objID).val();
        }

        if (objVal.number() < obj.config.min.number()) objVal = obj.config.min;
        else if (objVal.number() > obj.config.max.number()) objVal = obj.config.max;
        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var pixelLeft = ((objVal - obj.config.min) * pixelWidth) / valueWidth;

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").css({left: pixelLeft - (obj.config._handleWidth / 2)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: pixelLeft});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({left: pixelLeft - (obj.config._maxTitleWidth / 2)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").text(objVal.number().money() + obj.config.unit);

        axdom("#" + objID).val(objVal);
    },
    sliderTouchStart: function (objID, objSeq) {
        //alert(objID+"_"+ objSeq);
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.isMoving) {
            var bindSliderTouchMove = this.sliderTouchMove.bind(this);
            obj.bindSliderTouchMove = function (event) {
                bindSliderTouchMove(objID, objSeq, event);
            };
            var bindSliderTouchEnd = this.sliderTouchEnd.bind(this);
            obj.bindSliderTouchEnd = function (event) {
                bindSliderTouchEnd(objID, objSeq, event);
            };

            if (document.addEventListener) {
                document.addEventListener("touchmove", obj.bindSliderTouchMove, false);
                document.addEventListener("touchend", obj.bindSliderTouchEnd, false);

            }
            obj.config.isMoving = true;

        }

    },
    sliderTouchMove: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        event.preventDefault();
        var touch = event.touches[0];

        var eX = touch.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;
        var rX = eX - cX;

        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (!snap) snap = 1;
        objVal = (objVal.number() + obj.config.min.number()).round();
        objVal = parseInt(objVal / (snap)) * (snap);
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;

        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;

        var sX = rX - (obj.config._handleWidth / 2);
        var stX = rX - (obj.config._maxTitleWidth / 2);

        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandle").css({left: sX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").css({left: stX});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleTitle").text(objVal.number().money() + obj.config.unit);
        axdom("#" + objID).val(objVal);
        if (obj.config.onChange) obj.config.onChange(objID, objVal);
        else if (obj.config.onchange) obj.config.onchange(objID, objVal);

        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    sliderTouchEnd: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var objVal = axdom("#" + objID).val();

        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();

        if (document.addEventListener) {
            document.removeEventListener("touchmove", obj.bindSliderTouchMove, false);
            document.removeEventListener("touchend", obj.bindSliderTouchEnd, false);
        }
        obj.config.isMoving = false;
    },

    // twinSlider
    bindTwinSliderGetVals: function (objValString, separator) {
        var objVals = objValString.split(separator);
        var objVal = {min: 0, max: 0};
        if (objVals.length < 2) {
            objVal = {min: objVals[0], max: objVals[0]};
        }
        else {
            objVal = {min: objVals[0], max: objVals[1]};
        }
        return objVal;
    },
    bindTwinSlider: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        var objValString = obj.bindTarget.val();
        var separator = obj.config.separator || "~";
        var objVal = this.bindTwinSliderGetVals(objValString, separator);
        obj.vals = objVal;

        if (objVal.min.number() < obj.config.min.number()) objVal.min = obj.config.min;
        else if (objVal.min.number() > obj.config.max.number()) objVal.min = obj.config.max;
        if (objVal.max.number() < obj.config.min.number()) objVal.max = obj.config.min;
        else if (objVal.max.number() > obj.config.max.number()) objVal.max = obj.config.max;

        if (!obj.config.unit) obj.config.unit = "";

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBox\" class=\"" + cfg.anchorSliderBoxClassName + "\" style=\"left:0px;width:" + w + "px;height:" + h + "px;\">");
        po.push("	<a " + obj.config.href + " class=\"AXanchorSliderMinTitle\">" + obj.config.min.number().money() + obj.config.unit + "</a>");
        po.push("	<a " + obj.config.href + " class=\"AXanchorSliderMaxTitle\">" + obj.config.max.number().money() + obj.config.unit + "</a>");
        po.push("	<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar\" class=\"AXanchorSliderBar\">");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside\" class=\"AXanchorSliderBarInside\"></div>");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle\" class=\"AXanchorSliderHandleMinTitle\">" + objVal.min.number().money() + obj.config.unit + "</div>");
        po.push("		<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle\" class=\"AXanchorSliderHandleMaxTitle\">" + objVal.max.number().money() + obj.config.unit + "</div>");
        po.push("		<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin\" class=\"AXanchorSliderHandleMin\">&nbsp;</a>");
        po.push("		<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax\" class=\"AXanchorSliderHandleMax\">&nbsp;</a>");
        po.push("	</div>");
        po.push("</div>");

        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        //, background:"#eee"
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();

        var maxTitleWidth = obj.bindAnchorTarget.find(".AXanchorSliderMaxTitle").outerWidth().number() + 10;
        var minTitleWidth = obj.bindAnchorTarget.find(".AXanchorSliderMinTitle").outerWidth().number() + 10;
        obj.bindAnchorTarget.find(".AXanchorSliderMinTitle").css({width: minTitleWidth + "px"});
        obj.bindAnchorTarget.find(".AXanchorSliderMaxTitle").css({width: maxTitleWidth + "px"});
        var sliderBarWidth = w - minTitleWidth - maxTitleWidth;
        obj.bindAnchorTarget.find(".AXanchorSliderBar").css({
            width: sliderBarWidth + "px",
            left: minTitleWidth + "px",
            top: h / 2 + 2
        });
        //------------------------------------
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({width: maxTitleWidth});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({width: maxTitleWidth});
        obj.config._maxTitleWidth = maxTitleWidth;
        obj.config._handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").width();
        obj.config._trackWidth = sliderBarWidth;
        this.bindTwinSliderSetValue(objID, objSeq);

        var onmousedown = this.bindTwinSliderMouseDown.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").unbind("mousedown.AXInput").bind("mousedown.AXInput", function () {
            onmousedown(objID, objSeq, "min");
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").unbind("mousedown.AXInput").bind("mousedown.AXInput", function () {
            onmousedown(objID, objSeq, "max");
        });

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").unbind("dragstart.AXInput").bind("dragstart.AXInput", function (event) {
            event.stopPropagation(); // disable  event
            return false;
        });
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").unbind("dragstart.AXInput").bind("dragstart.AXInput", function (event) {
            event.stopPropagation(); // disable  event
            return false;
        });

        //add touch event
        if (document.addEventListener) {
            var ontouchstart = this.twinSliderTouchStart.bind(this);
            obj.bindTwinSliderTouchStartMin = function (event) {
                ontouchstart(objID, objSeq, "min");
            }
            obj.bindTwinSliderTouchStartMax = function (event) {
                ontouchstart(objID, objSeq, "max");
            }

            AXgetId(cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").addEventListener("touchstart", obj.bindTwinSliderTouchStartMin, false);
            AXgetId(cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").addEventListener("touchstart", obj.bindTwinSliderTouchStartMax, false);
        }

    },
    bindTwinSliderMouseDown: function (objID, objSeq, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }
        if (!obj.config.isMoving) {
            var bindTwinSliderMouseMove = this.bindTwinSliderMouseMove.bind(this);
            obj.bindTwinSliderMouseMove = function (event) {
                bindTwinSliderMouseMove(objID, objSeq, event, handleName);
            };
            var bindTwinSliderMouseUp = this.bindTwinSliderMouseUp.bind(this);
            obj.bindTwinSliderMouseUp = function (event) {
                bindTwinSliderMouseUp(objID, objSeq, event, handleName);
            };
            axdom(document.body).unbind("mousemove.AXInput").bind("mousemove.AXInput", obj.bindTwinSliderMouseMove);
            axdom(document.body).unbind("mouseup.AXInput").bind("mouseup.AXInput", obj.bindTwinSliderMouseUp);
            obj.config.isMoving = true;
        }

    },
    bindTwinSliderMouseMove: function (objID, objSeq, event, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var eX = event.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;

        var rX = eX - cX;

        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (!snap) snap = 1;
        objVal = (objVal.number() + obj.config.min.number()).round();
        objVal = parseInt(objVal / (snap)) * (snap);
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;

        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;

        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});
        if (handleName == "min") {
            if (objVal > obj.vals.max) {
                objVal = obj.vals.max;
                rX = obj.handleMaxLeft;
            }
            var sX = rX - (obj.config._handleWidth);
            var stX = rX - (obj.config._maxTitleWidth);
            obj.handleMinLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.min = objVal;
        }
        else {
            if (objVal < obj.vals.min) {
                objVal = obj.vals.min;
                rX = obj.handleMinLeft;
            }
            var sX = rX;
            var stX = rX;
            obj.handleMaxLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.max = objVal;
        }
        var separator = obj.config.separator || "~";
        axdom("#" + objID).val(obj.vals.min + separator + obj.vals.max);

    },
    bindTwinSliderMouseUp: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var objVal = axdom("#" + objID).val();
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();

        axdom(document.body).unbind("mousemove.AXInput");
        axdom(document.body).unbind("mouseup.AXInput");
        obj.config.isMoving = false;
    },
    bindTwinSliderSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (value != undefined) {
            var objValString = value;
        }
        else {
            var objValString = axdom("#" + objID).val();
        }

        var separator = obj.config.separator || "~";
        var objVal = this.bindTwinSliderGetVals(objValString, separator);
        obj.vals = objVal;

        if (objVal.min.number() < obj.config.min.number()) objVal.min = obj.config.min;
        else if (objVal.min.number() > obj.config.max.number()) objVal.min = obj.config.max;
        if (objVal.max.number() < obj.config.min.number()) objVal.max = obj.config.min;
        else if (objVal.max.number() > obj.config.max.number()) objVal.max = obj.config.max;

        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var pixelMinLeft = ((objVal.min - obj.config.min) * pixelWidth) / valueWidth;
        var pixelMaxLeft = ((objVal.max - obj.config.min) * pixelWidth) / valueWidth;

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").css({left: pixelMinLeft - (obj.config._handleWidth)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({left: pixelMinLeft - (obj.config._maxTitleWidth)});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").text(objVal.min.number().money() + obj.config.unit);

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").css({left: pixelMaxLeft});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({left: pixelMaxLeft});
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").text(objVal.max.number().money() + obj.config.unit);

        obj.handleMinLeft = pixelMinLeft;
        obj.handleMaxLeft = pixelMaxLeft;
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
            left: pixelMinLeft,
            width: pixelMaxLeft - pixelMinLeft
        });

        axdom("#" + objID).val(obj.vals.min + separator + obj.vals.max);
    },
    // -- add touch event
    twinSliderTouchStart: function (objID, objSeq, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        if (!obj.config.isMoving) {
            var bindTwinSliderTouchMove = this.twinSliderTouchMove.bind(this);
            obj.bindTwinSliderTouchMove = function (event) {
                bindTwinSliderTouchMove(objID, objSeq, event, handleName);
            };
            var bindTwinSliderTouchEnd = this.twinSliderTouchEnd.bind(this);
            obj.bindTwinSliderTouchEnd = function (event) {
                bindTwinSliderTouchEnd(objID, objSeq, event, handleName);
            };

            if (document.addEventListener) {
                document.addEventListener("touchmove", obj.bindTwinSliderTouchMove, false);
                document.addEventListener("touchend", obj.bindTwinSliderTouchEnd, false);

            }
            obj.config.isMoving = true;

        }

    },
    twinSliderTouchMove: function (objID, objSeq, event, handleName) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        event.preventDefault();
        var touch = event.touches[0];

        //var eX = event.pageX;
        var eX = touch.pageX;
        var cX = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderBar").offset().left;
        var rX = eX - cX;

        var valueWidth = obj.config.max.number() - obj.config.min.number();
        var pixelWidth = obj.config._trackWidth;
        var objVal = (rX * valueWidth) / pixelWidth;
        var snap = obj.config.snap;
        if (!snap) snap = 1;
        objVal = (objVal.number() + obj.config.min.number()).round();
        objVal = parseInt(objVal / (snap)) * (snap);
        var rX = ((objVal - obj.config.min) * pixelWidth) / valueWidth;

        if (objVal < obj.config.min) {
            objVal = obj.config.min;
            rX = 0;
        }
        else if (objVal > obj.config.max) {
            objVal = obj.config.max;
            rX = pixelWidth;
        }
        if (rX > pixelWidth) rX = pixelWidth;

        //trace({rX:rX, pixelWidth:pixelWidth, objVal:objVal, valueWidth:valueWidth});

        if (handleName == "min") {
            if (objVal > obj.vals.max) {
                objVal = obj.vals.max;
                rX = obj.handleMaxLeft;
            }
            var sX = rX - (obj.config._handleWidth);
            var stX = rX - (obj.config._maxTitleWidth);
            obj.handleMinLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMin").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMinTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({width: rX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.min = objVal;
        }
        else {
            if (objVal < obj.vals.min) {
                objVal = obj.vals.min;
                rX = obj.handleMinLeft;
            }
            var sX = rX;
            var stX = rX;
            obj.handleMaxLeft = rX;
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMax").css({left: sX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").css({left: stX});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderHandleMaxTitle").text(objVal.number().money() + obj.config.unit);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SliderInside").css({
                left: obj.handleMinLeft,
                width: obj.handleMaxLeft - obj.handleMinLeft
            });
            //axdom("#"+objID).val(objVal);
            obj.vals.max = objVal;
        }
        var separator = obj.config.separator || "~";
        axdom("#" + objID).val(obj.vals.min + separator + obj.vals.max);
        if (obj.config.onChange) obj.config.onChange(objID, obj.vals.min + separator + obj.vals.max);
        else if (obj.config.onchange) obj.config.onchange(objID, obj.vals.min + separator + obj.vals.max);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    twinSliderTouchEnd: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var objVal = axdom("#" + objID).val();
        if (obj.config.onChange || obj.config.onchange) {
            var onchange = obj.config.onChange || obj.config.onchange;
            onchange.call({id: objID, value: objVal}, objID, objVal);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
        document.removeEventListener("touchmove", obj.bindTwinSliderTouchMove, false);
        document.removeEventListener("touchend", obj.bindTwinSliderTouchEnd, false);

        obj.config.isMoving = false;
    },

    // switch
    bindSwitch: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        var objVal = obj.bindTarget.val();
        var switchValue = obj.config.on;
        if (objVal == switchValue) {
            obj.switchValue = "on";
        }
        else {
            switchValue = obj.config.off;
            obj.switchValue = "off";
        }
        obj.bindTarget.val(switchValue);

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox\" class=\"" + cfg.anchorSwitchBoxClassName + "\" style=\"left:0px;top:0px;width:" + w + "px;height:" + h + "px;\">");
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay\" class=\"AXanchorSwitchDisplay\" style=\"height:" + h + "px;line-height:" + h + "px;\">" + switchValue + "</div>");
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SwitchHandle\" class=\"AXanchorSwitchHandle\" style=\"height:" + h + "px;\">&nbsp;</a>");
        po.push("</div>");

        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });

        obj.bindTarget_switchBox = obj.bindAnchorTarget.find("." + cfg.anchorSwitchBoxClassName);
        obj.bindTarget_switchDisplay = obj.bindAnchorTarget.find(".AXanchorSwitchDisplay");
        obj.bindTarget_switchHandle = obj.bindAnchorTarget.find(".AXanchorSwitchHandle");

        if (obj.switchValue == "on") {
            obj.bindAnchorTarget.find("." + cfg.anchorSwitchBoxClassName).addClass("on");
        }

        //, background:"#eee"
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();

        var bindSwitchClick = this.bindSwitchClick.bind(this);
        obj.bindSwitchClick = function (event) {
            bindSwitchClick(objID, objSeq, event);
        };
        obj.bindAnchorTarget.find("." + cfg.anchorSwitchBoxClassName).unbind("click.AXInput").bind("click.AXInput", obj.bindSwitchClick);

    },
    bindSwitchClick: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        if (obj.switchValue == "on") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").removeClass("on");
            obj.switchValue = "off";
            axdom("#" + objID).val(obj.config.off);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.off);
        }
        else {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").addClass("on");
            obj.switchValue = "on";
            axdom("#" + objID).val(obj.config.on);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.on);
        }
        if (obj.config.onChange || obj.config.onchange) {
            var sendObj = {
                targetID: objID,
                on: obj.config.on,
                off: obj.config.off,
                value: axdom("#" + objID).val()
            }
            if (obj.config.onChange) obj.config.onChange.call(sendObj);
            if (obj.config.onchange) obj.config.onchange.call(sendObj);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    bindSwitchSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var objVal = value;
        var switchValue = obj.config.on;
        if (objVal == switchValue) {
            obj.switchValue = "on";
        }
        else {
            switchValue = obj.config.off;
            obj.switchValue = "off";
        }
        axdom("#" + objID).val(switchValue);

        if (obj.switchValue == "off") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").removeClass("on");
            obj.switchValue = "off";
            axdom("#" + objID).val(obj.config.off);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.off);
        }
        else {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchBox").addClass("on");
            obj.switchValue = "on";
            axdom("#" + objID).val(obj.config.on);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SwitchDisplay").html(obj.config.on);
        }
        if (obj.config.onChange || obj.config.onchange) {
            var sendObj = {
                targetID: objID,
                on: obj.config.on,
                off: obj.config.off,
                value: axdom("#" + objID).val()
            }
            if (obj.config.onChange) obj.config.onChange.call(sendObj);
            else if (obj.config.onchange) obj.config.onchange.call(sendObj);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },
    bindSwitch_touchstart: function () {

    },
    bindSwitch_touchMove: function () {

    },
    bindSwitch_touchEnd: function () {

    },

    // segment
    bindSegment: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        var w = obj.bindAnchorTarget.width();
        var h = obj.bindAnchorTarget.data("height");
        var objVal = obj.bindTarget.val();
        var segmentOptions = obj.config.options;
        obj.selectedSegmentIndex = null;
        axf.each(segmentOptions, function (idx, seg) {
            //trace({optionValue:this.optionValue, objVal:objVal});
            if (this.optionValue == objVal) {
                obj.selectedSegmentIndex = idx;
                obj.selectedSegment = seg;
            }
        });
        if (obj.selectedSegmentIndex == null) {
            obj.selectedSegmentIndex = 0;
            obj.selectedSegment = segmentOptions[0];
        }
        obj.bindTarget.val(obj.selectedSegment.optionValue);

        var handleWidth = (w / segmentOptions.length).round() - 2;
        var po = [];
        var theme = obj.config.theme || cfg.anchorSegmentBoxClassName;
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SegmentBox\" class=\"" + theme + "\" style=\"left:0px;top:0px;width:" + w + "px;\">");
        axf.each(segmentOptions, function (idx, seg) {
            var addClass = "";
            if (idx == 0) addClass = " segmentLeft";
            else if (idx == segmentOptions.length - 1) addClass = " segmentRight";
            if (obj.selectedSegmentIndex == idx) addClass += " on";
            if (seg.addClass) addClass += " " + seg.addClass;
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + idx + "\" class=\"AXanchorSegmentHandle" + addClass + "\" style=\"width:" + handleWidth + "px;\">" + seg.optionText + "</a>");
        });
        po.push("</div>");

        //append to anchor
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.css({
            height: h + "px",
            "position": "relative",
            display: "inline-block",
            left: "auto",
            top: "auto"
        });
        var borderTop = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-top-width").number();
        var borderBot = obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css("border-bottom-width").number();
        obj.bindAnchorTarget.find(".AXanchorSegmentHandle").css({
            height: (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px",
            "line-height": (obj.bindAnchorTarget.innerHeight() - borderTop - borderBot) + "px"
        });

        //, background:"#eee"
        obj.bindAnchorTarget.show();
        obj.bindTarget.hide();

        var bindSegmentClick = this.bindSegmentClick.bind(this);
        obj.bindSegmentClick = function (event) {
            bindSegmentClick(objID, objSeq, event);
        };

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentBox").find(".AXanchorSegmentHandle").unbind("click.AXInput").bind("click.AXInput", obj.bindSegmentClick);
    },
    bindSegmentClick: function (objID, objSeq, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        var segmentOptions = obj.config.options;

        var myTarget = axf.get_event_target(event.target, {tagname: "a", clazz: "AXanchorSegmentHandle"});
        if (myTarget) {

            var seq = myTarget.id.split(/_AX_/g).last();
            if (obj.selectedSegmentIndex != seq) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + obj.selectedSegmentIndex).removeClass("on");
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + seq).addClass("on");
                obj.selectedSegmentIndex = seq;
                obj.selectedSegment = segmentOptions[seq];
            }
            //strace(obj.selectedSegment.optionValue);
            axdom("#" + objID).val(obj.selectedSegment.optionValue);
            //trace(axdom("#"+objID).val());
            if (obj.config.onChange || obj.config.onchange) {
                var sendObj = {
                    targetID: objID,
                    options: segmentOptions,
                    selectedIndex: obj.selectedSegmentIndex,
                    selectedOption: obj.selectedSegment
                };
                if (obj.config.onChange) obj.config.onChange.call(sendObj);
                else if (obj.config.onchange) obj.config.onchange.call(sendObj);
            }
            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.change();
        }
    },
    bindSegmentSetValue: function (objID, objSeq, value) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        var selectedSegmentIndex = obj.selectedSegmentIndex;

        var objVal = value;
        var segmentOptions = obj.config.options;
        obj.selectedSegmentIndex = null;
        axf.each(segmentOptions, function (idx, seg) {
            if (this.optionValue == objVal) {
                obj.selectedSegmentIndex = idx;
                obj.selectedSegment = seg;
            }
        });
        if (obj.selectedSegmentIndex == null) {
            obj.selectedSegmentIndex = 0;
            obj.selectedSegment = segmentOptions[0];
        }
        axdom("#" + objID).val(obj.selectedSegment.optionValue);

        if (selectedSegmentIndex != obj.selectedSegmentIndex) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + selectedSegmentIndex).removeClass("on");
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SegmentHandle_AX_" + obj.selectedSegmentIndex).addClass("on");
        }

        if (obj.config.onChange || obj.config.onchange) {
            var sendObj = {
                targetID: objID,
                options: segmentOptions,
                selectedIndex: obj.selectedSegmentIndex,
                selectedOption: obj.selectedSegment
            };
            if (obj.config.onChange) obj.config.onChange.call(sendObj);
            else if (obj.config.onchange) obj.config.onchange.call(sendObj);
        }
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTarget.change();
    },

    // date
    bindDate: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

        var h = obj.bindAnchorTarget.data("height");
        var po = [];
        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle\" class=\"" + cfg.anchorDateHandleClassName + "\"" +
            " style=\"right:0px;top:0px;width:" + h + "px;height:" + h + "px;\">&nbsp;</a>");
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();

        var bindDateExpand = this.bindDateExpand.bind(this);
        var bindDateExpandClose = this.bindDateExpandClose.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").unbind("click.AXInput").bind("click.AXInput", function (event) {
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                bindDateExpandClose(objID, objSeq, event);
            }
            else {
                var isReadOnly = obj.bindTarget.attr("readonly");
                var isDisabled = obj.bindTarget.attr("disabled");
                if (isReadOnly) isReadOnly = (isReadOnly.lcase() == "true") || (isReadOnly.lcase() == "readonly");
                if (isDisabled) isDisabled = (isDisabled.lcase() == "true") || (isDisabled.lcase() == "disabled");
                if (!isReadOnly && !isDisabled) bindDateExpand(objID, objSeq, true, event);
            }
        });
        obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            setTimeout(function () {
                obj.bindTarget.select();
            }, 1);
        });

        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

        //trace(obj.config);

        obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function (event) {
            var _this = this;
            setTimeout(function () {
                if (event.keyCode == axf.Event.KEY_RETURN) {
                    //bindDateInputBlur(objID, objSeq, event);
                    _this.blur();
                }
                else if (event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
                    var va = _this.value.replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
                    if (obj.config.selectType == "y") {
                        if (va.length > 4) _this.value = va.left(4);
                    }
                    else if (obj.config.selectType == "m") {
                        if (va.length == 4) {
                            va = va + separator;
                            _this.value = va;
                        }
                        else if (va.length > 4) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2);
                            _this.value = va;
                        }
                    }
                    else {
                        if (va.length < 4) {
                            _this.value = va;
                        }
                        else if (va.length == 4) {
                            va = va + separator;
                            _this.value = va;
                        }
                        else if (va.length <= 6) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator;
                            _this.value = va;
                        }
                        else if (va.length <= 8) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                            if (obj.config.expandTime) va += " ";
                            _this.value = va;
                        }
                        else {
                            if (obj.config.expandTime) {
                                if (va.length <= 10) {
                                    va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2) + ":";
                                    _this.value = va;
                                }
                                else if (va.length > 12) {
                                    va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2) + ":" + va.substr(10, 2);
                                    _this.value = va;
                                }
                            }
                            else {
                                va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                                _this.value = va;
                            }
                        }
                    }
                }
            });
        });

        var bindDateInputBlur = this.bindDateInputBlur.bind(this);
        obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindDateInputBlur(objID, objSeq, event);
        });

        // config.expand : true, 속성 bindDateExpand
        if (obj.config.expand === true) {
            bindDateExpand(objID, objSeq, true, event);
            setTimeout(function () {
                obj.bindTarget.focus();
            }, 100);
        }
    },
    bindDateExpand: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        for (var OO, oidx = 0, __arr = this.objects; (oidx < __arr.length && (OO = __arr[oidx])); oidx++) {
            if (OO.expandBox_axdom) {
                OO.expandBox_axdom.remove();
                OO.expandBox_axdom = null;
            }
        }

        if (AXUtil.clientWidth() < cfg.responsiveMobile) {
            this.bindDateExpandMobile(objID, objSeq, isToggle, event);
            return;
            /* 클라이언트 너비가 모바일 너비이면 프로세스 중지 */
        }
        var obj = this.objects[objSeq];
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리

        //Expand Box 생성 구문 작성
        var objVal = axdom("#" + objID).val(), objHours = "";
        if (obj.config.expandTime) obj.config.selectType == "d"; //시간 확장 시 selectType : d 로 고정

        var today = new Date();
        if (obj.config.selectType == "y") {
            if (objVal != "") {
                objVal = objVal.left(4) + separator + "01" + separator + "01";
            }
        }
        else if (obj.config.selectType == "m") {
            if (objVal != "") {
                objVal = objVal + separator + "02";
            }
        }

        var dfDate = (obj.config.defaultDate || "").date();
        var myDate = objVal.date(separator, dfDate);

        var myYear = myDate.getUTCFullYear();
        var myMonth = (myDate.getUTCMonth() + 1).setDigit(2);

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"" + cfg.bindDateExpandBoxClassName + "\" style=\"z-index:5100;\">");
        po.push("	<div>");
        po.push("		<div class=\"dateControlBox\">");
        po.push("			<a " + obj.config.href + " class=\"yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear\">" + myYear + "년</a>");
        po.push("			<a " + obj.config.href + " class=\"monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth\">" + myMonth + "월</a>");
        po.push("			<a " + obj.config.href + " class=\"prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev\">P</a>");
        po.push("			<a " + obj.config.href + " class=\"nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext\">N</a>");
        po.push("		</div>");
        po.push("		<div class=\"dateDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayBox\"></div>");
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            po.push("		<div class=\"timeDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox\"></div>");
        }
        po.push("	</div>");
        po.push("</div>");

        axdom(document.body).append(po.join('')); // bindDateExpandBox append
        //axdom("#"+cfg.targetID + "_AX_" + objID+"_AX_Handle").addClass("on");

        // AXCalendar display
        obj.nDate = myDate;
        obj.mycalendar = new AXCalendar();
        obj.mycalendar.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox",
            basicDate: myDate,
            href: obj.config.href,
            minDate: obj.config.minDate,
            maxDate: obj.config.maxDate,
            onBeforeShowDay: obj.config.onBeforeShowDay
        });
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            obj.nDate = myDate;
            var mycalendartimeChange = this.bindDateTimeChange.bind(this);
            obj.mycalendartimeChange = function (myTime) {
                mycalendartimeChange(objID, objSeq, myTime);
            };
            obj.mycalendartime = new AXCalendar();
            obj.mycalendartime.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox",
                onChange: obj.mycalendartimeChange
            });
            var apm = "AM";
            var myTimes = myDate.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];

            if (myHH == 12 && myMI > 0) {
                apm = "PM";
            }
            else if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
        }

        var printDate = "";
        if (obj.config.selectType == "y") {
            obj.mycalendarPageType = "y";
            obj.mycalendar.printYearPage(myDate.print("yyyy"));
            printDate = myDate.print("yyyy");
        }
        else if (obj.config.selectType == "m") {
            obj.mycalendarPageType = "m";
            obj.mycalendar.printMonthPage(myDate);
            printDate = myDate.print("yyyy" + separator + "mm");
        }
        else {
            if (obj.config.defaultSelectType) {
                if (obj.config.defaultSelectType == "y") {
                    obj.mycalendarPageType = "y";
                    obj.mycalendar.printYearPage(myDate.print("yyyy"));
                }
                else if (obj.config.defaultSelectType == "m") {
                    obj.mycalendarPageType = "m";
                    obj.mycalendar.printMonthPage(myDate);
                }
                else {
                    obj.mycalendarPageType = "d";
                    obj.mycalendar.printDayPage(myDate);
                }
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
            }
            else {
                obj.mycalendarPageType = "d";
                obj.mycalendar.printDayPage(myDate);
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }

            }
        }
        if (obj.config.expandSetValue) {
            axdom("#" + objID).val(printDate);
        }
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AXCalendar display

        // expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var expBoxWidth = expandBox.outerWidth();
        var expBoxHeight = expandBox.outerHeight();
        var offset = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").offset();
        var handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").width();
        var handleHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").height();

        var css = {};
        if (obj.config.align == "left") {
            css.left = offset.left.number() - expBoxWidth;
        }
        else if (obj.config.align == "center") {
            css.left = offset.left.number() - expBoxWidth / 2 + handleWidth;
        }
        else if (obj.config.align == "right") {
            css.left = offset.left.number() + handleWidth;
        }
        else {
            css.left = offset.left.number() + handleWidth;
        }
        if (obj.config.valign == "top") {
            css.top = offset.top;
        }
        else if (obj.config.valign == "middle") {
            css.top = offset.top.number() - expBoxHeight / 2 + handleWidth / 2;
        }
        else if (obj.config.valign == "bottom") {
            css.top = offset.top.number() - expBoxHeight + handleWidth;
        }
        else {
            css.top = offset.top;
        }

        if (obj.config.customPos != undefined) {
            css.top = css.top + obj.config.customPos.top;
            css.left = css.left + obj.config.customPos.left;
        }

        var pElement = expandBox.offsetParent();
        var pBox = {width: pElement.width(), height: pElement.height()};

        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = {width: expandBox.outerWidth() + 10, height: expandBox.outerHeight() + 10};

        if ((_box.height.number() + css.top.number()) > pBox.height) {
            css.top = css.top - ((_box.height.number() + css.top.number()) - pBox.height);
        }
        if (css.top < 0) {
            css.top = 0;
        }

        if ((_box.width.number() + css.left.number()) > pBox.width) {
            css.left = css.left - ((_box.width.number() + css.left.number()) - pBox.width);
        }
        if (css.left < 0) {
            css.left = 0;
        }

        expandBox.css(css);
        obj.expandBox_axdom = expandBox;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~ expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~

        var bindDateExpandBoxClick = this.bindDateExpandBoxClick.bind(this);
        obj.documentclickEvent = function (event) {
            //trace(objID);
            bindDateExpandBoxClick(objID, objSeq, event);
        }
        var bindDateKeyup = this.bindDateKeyup.bind(this);
        obj.inputKeyup = function (event) {
            bindDateKeyup(objID, objSeq, event);
        }
        if (obj.config.selectType == "y") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").css({left: "70px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth").hide();
        }

        //trace("event bind");
        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        axdom("#" + objID).bind("keydown.AXInput", obj.inputKeyup);
    },
    // -- bindDate for mobile
    bindDateExpandMobile: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", obj.inputKeyup);

        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (obj.modal && obj.modal.opened) {
                obj.modal.close();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }

        /* mobile modal ready */
        obj.modal = new AXMobileModal();
        obj.modal.setConfig({
            addClass: "",
            height: (obj.config.expandTime) ? 532 : 388,
            width: 300,
            head: {},
            onclose: function () {
            }
        });

        var initBindDateMobileModal = this.initBindDateMobileModal.bind(this);
        var onLoad = function (modalObj) {
            initBindDateMobileModal(objID, objSeq, modalObj);
        };
        obj.modal.open(null, onLoad);
    },
    initBindDateMobileModal: function (objID, objSeq, modalObj) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

        //Expand Box 생성 구문 작성
        var objVal = axdom("#" + objID).val();
        if (obj.config.expandTime) obj.config.selectType == "d"; //시간 확장 시 selectType : d 로 고정			

        var today = new Date();
        if (obj.config.selectType == "y") {
            if (objVal != "") {
                objVal = objVal.left(4) + separator + "01" + separator + "01";
            }
        }
        else if (obj.config.selectType == "m") {
            if (objVal != "") {
                objVal = objVal + separator + "01";
            }
        }

        var dfDate = (obj.config.defaultDate || "").date();
        var myDate = objVal.date(separator, dfDate);

        var myYear = myDate.getFullYear();
        var myMonth = (myDate.getMonth() + 1).setDigit(2);

        /* head 만들기 */
        var headPo = [];
        /* 현재 선택된 메뉴 선택 하는 기능구현 필요 */
        headPo.push("<div class=\"AXDateControlBox\">");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear\">" + (AXConfig.AXInput.yearText || "{year}년").replace("{year}", myYear) + "</a>");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth\">" + (AXConfig.AXInput.monthText || "{month}월").replace("{month}", myMonth) + "</a>");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev\">P</a>");
        headPo.push("	<a " + obj.config.href + " class=\"AXDateControl nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext\">N</a>");
        headPo.push("</div>");

        var bodyPo = [];
        bodyPo.push('<div class="AXDateContainer">');
        bodyPo.push('<div class="AXDateDisplayBox" id="' + cfg.targetID + '_AX_' + objID + '_AX_displayBox"></div>');
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            bodyPo.push('		<div class="AXTimeDisplayBox" id="' + cfg.targetID + '_AX_' + objID + '_AX_displayTimeBox"></div>');
        }
        bodyPo.push('</div>');

        var footPo = [];
        footPo.push('<div class="AXDateButtonBox" id="' + cfg.targetID + '_AX_' + objID + '_AX_buttonBox">');
        footPo.push('	<button class="AXButtonSmall W80 AXBindDateConfirm" type="button" id="' + cfg.targetID + '_AX_' + objID + '_AX_button_AX_confirm">' + (AXConfig.AXInput.confirmText || "확인") + '</button>');
        footPo.push('</div>');

        /* modal에 캘린더 장착 */
        modalObj.modalHead.empty();
        modalObj.modalHead.append(headPo.join(''));
        modalObj.modalBody.empty();
        modalObj.modalBody.append(bodyPo.join(''));
        modalObj.modalFoot.empty();
        modalObj.modalFoot.append(footPo.join(''));

        /* 캘린더 클래스 로드 */
        // AXCalendar display
        obj.nDate = myDate;
        obj.mycalendar = new AXCalendar();
        obj.mycalendar.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox",
            basicDate: myDate,
            href: obj.config.href
        });
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            obj.nDate = myDate;
            var mycalendartimeChange = this.bindDateTimeChange.bind(this);
            obj.mycalendartimeChange = function (myTime) {
                mycalendartimeChange(objID, objSeq, myTime);
            };
            obj.mycalendartime = new AXCalendar();
            obj.mycalendartime.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox",
                onChange: obj.mycalendartimeChange
            });
            var apm = "AM";
            var myTimes = myDate.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];

            if (myHH == 12 && myMI > 0) {
                apm = "PM";
            }
            else if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
        }

        var printDate = "";
        if (obj.config.selectType == "y") {
            obj.mycalendarPageType = "y";
            obj.mycalendar.printYearPage(myDate.print("yyyy"));
            printDate = myDate.print("yyyy");
            axdom("#" + objID).val(printDate);
        }
        else if (obj.config.selectType == "m") {
            obj.mycalendarPageType = "m";
            obj.mycalendar.printMonthPage(myDate);
            printDate = myDate.print("yyyy" + separator + "mm");
            axdom("#" + objID).val(printDate);
        }
        else {
            if (obj.config.defaultSelectType) {
                if (obj.config.defaultSelectType == "y") {
                    obj.mycalendarPageType = "y";
                    obj.mycalendar.printYearPage(myDate.print("yyyy"));
                }
                else if (obj.config.defaultSelectType == "m") {
                    obj.mycalendarPageType = "m";
                    obj.mycalendar.printMonthPage(myDate);
                }
                else {
                    obj.mycalendarPageType = "d";
                    obj.mycalendar.printDayPage(myDate);
                }
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
                axdom("#" + objID).val(printDate);

            }
            else {
                obj.mycalendarPageType = "d";
                obj.mycalendar.printDayPage(myDate);
                printDate = myDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + myDate.print("hh:mi");
                }
                axdom("#" + objID).val(printDate);
            }
        }
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AXCalendar display

        // control event bind
        var _this = this;
        /*var bindDateMobileModalHeadClick = this.bindDateMobileModalHeadClick.bind(this);*/
        modalObj.modalHead.unbind("click.AXInput").bind("click.AXInput", function (event) {
            _this.bindDateMobileModalHeadClick(objID, objSeq, event);
        });
        /*var bindDateMobileModalBodyClick = this.bindDateMobileModalBodyClick.bind(this);*/
        modalObj.modalBody.unbind("click.AXInput").bind("click.AXInput", function (event) {
            _this.bindDateMobileModalBodyClick(objID, objSeq, event);
        });
        /*var bindDateMobileModalFootClick = this.bindDateMobileModalFootClick.bind(this);*/
        modalObj.modalFoot.unbind("click.AXInput").bind("click.AXInput", function (event) {
            _this.bindDateMobileModalFootClick(objID, objSeq, event);
        });
        // control event bind
    },
    bindDateMobileModalHeadClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXDateControlBox")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("AXDateControl")) ? true : false;
            }
        });
        if (myTarget) {
            var act = myTarget.id.split(/_AX_/g).last();
            var nDate = obj.nDate;

            if (act == "controlYear") {
                this.bindDateChangePage(objID, objSeq, nDate, "y");
            }
            else if (act == "controlMonth") {
                if (obj.config.selectType != "y") {
                    this.bindDateChangePage(objID, objSeq, nDate, "m");
                }
            }
            else if (act == "expandPrev") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-12, "y"), "y");
                }
            }
            else if (act == "expandNext") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(12, "y"), "y");
                }
            }
        }
    },
    bindDateMobileModalBodyClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXDateContainer")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("calendarDate") || axdom(evt).hasClass("calendarMonth")) ? true : false;
            }
        });
        if (myTarget) {
            var ids = myTarget.id.split(/_AX_/g);
            var act = ids.last();
            var nDate = obj.nDate;
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            if (act == "date") {
                //trace(ids[ids.length-2]);
                obj.nDate = ids[ids.length - 2].date();
                var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime.getTime();
                }
                axdom("#" + objID).val(printDate);
                //obj.modal.close();
                this.bindDateExpandClose(objID, objSeq, event);
            }
            else if (act == "month") {
                var myMonth = ids[ids.length - 2].number() - 1;
                if (obj.config.selectType == "m") {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd));
                    //obj.modal.close();
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "d");
                }
            }
            else if (act == "year") {
                var myYear = ids[ids.length - 2];
                if (obj.config.selectType == "y") {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd));
                    //obj.modal.close();
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "m");
                }
            }

        }
    },
    bindDateMobileModalFootClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var eid = event.target.id.split(/_AX_/g);
        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget, evtIDs: eid,
            until: function (evt, evtIDs) {
                return (axdom(evt.parentNode).hasClass("AXDateButtonBox")) ? true : false;
            },
            find: function (evt, evtIDs) {
                return (axdom(evt).hasClass("AXBindDateConfirm")) ? true : false;
            }
        });
        if (myTarget) {
            var act = myTarget.id.split(/_AX_/g).last();
            if (act == "confirm") {
                obj.modal.close();
            }
        }
    },
    // -- bindDate for mobile
    bindDateExpandClose: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;

        if (!obj) {
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            //axdom("#" + objID).unbind("keydown.AXInput");
            return;
        }

        if (obj.modal && obj.modal.opened) { /* mobile modal close */
            var objVal = axdom("#" + objID).val();
            if (objVal == "") {

            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy"));
                }
                else if (obj.config.selectType == "m") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
                }
                else {
                    //axdom("#"+objID).val(obj.nDate.print("yyyy"+separator+"mm"+separator+"dd"));
                    printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime.getTime();
                    }
                    axdom("#" + objID).val(printDate);
                }
            }

            if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;

            if (obj.config.onChange) {
                if (axdom.isFunction(obj.config.onChange)) {
                    obj.config.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val()
                    });
                }
                else {
                    var st_date, ed_date;
                    if (obj.config.onChange.earlierThan) {
                        st_date = axdom("#" + objID).val();
                        ed_date = axdom("#" + obj.config.onChange.earlierThan).val();
                    }
                    else if (obj.config.onChange.laterThan) {
                        ed_date = axdom("#" + objID).val();
                        st_date = axdom("#" + obj.config.onChange.laterThan).val();
                    }
                    if (st_date != "" && ed_date != "") {
                        if (st_date.date().diff(ed_date) < 0) {
                            this.msgAlert(obj.config.onChange.err);
                            axdom("#" + objID).val("");
                            return;
                        }
                    }

                    obj.config.onChange.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val(),
                        eventType: "expandClose"
                    });
                }
            }

            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.trigger("change");

            obj.modal.close();
            //axdom("#" + objID).unbind("keydown.AXInput");

            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            //axdom("#" + objID).unbind("keydown.AXInput");
            return;
        }
        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
            var objVal = axdom("#" + objID).val();

            if (objVal == "") {

            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy"));
                }
                else if (obj.config.selectType == "m") {
                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
                }
                else {
                    //axdom("#"+objID).val(obj.nDate.print("yyyy"+separator+"mm"+separator+"dd"));
                    printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime.getTime();
                    }
                    axdom("#" + objID).val(printDate);
                }
            }

            if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;

            if (obj.config.onChange) {
                if (axdom.isFunction(obj.config.onChange)) {
                    obj.config.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val()
                    });
                }
                else {
                    var st_date, ed_date;
                    if (obj.config.onChange.earlierThan) {
                        st_date = axdom("#" + objID).val();
                        ed_date = axdom("#" + obj.config.onChange.earlierThan).val();
                    }
                    else if (obj.config.onChange.laterThan) {
                        ed_date = axdom("#" + objID).val();
                        st_date = axdom("#" + obj.config.onChange.laterThan).val();
                    }
                    if (st_date != "" && ed_date != "") {
                        if (st_date.date().diff(ed_date) < 0) {
                            this.msgAlert(obj.config.onChange.err);
                            axdom("#" + objID).val("");
                            return;
                        }
                    }
                    if (obj.config.onChange.onChange) {
                        obj.config.onChange.onChange.call({
                            objID: objID,
                            value: axdom("#" + objID).val()
                        });
                    }
                    else if (obj.config.onChange.onchange) {
                        obj.config.onChange.onchange.call({
                            objID: objID,
                            value: axdom("#" + objID).val()
                        });
                    }
                }
            }
            if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
            obj.bindTarget.trigger("change");

            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            obj.expandBox_axdom = null;
            obj.mycalendartime = null;

            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            //axdom("#" + objID).unbind("keydown.AXInput");

            event.stopPropagation(); // disableevent
            return;
        }
    },
    bindDateInputBlur: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var objVal = axdom("#" + objID).val();
        /*
         if(obj.config.expand === true) {
         //return false;
         }
         */

        if (objVal == "") {

        }
        else {
            var clearDate = false;
            var nDate = (obj.nDate || new Date());
            var va = axdom("#" + objID).val().replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
            if (va.search(/\d+/g) == -1) {
                clearDate = true;
            }

            if (clearDate) {
                axdom("#" + objID).val("");
            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {

                    var yy = va.left(4).number();
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    var mm = nDate.getMonth();
                    var dd = nDate.getDate();
                    obj.nDate = new Date(Date.UTC(yy, mm, dd, 12));

                    axdom("#" + objID).val(obj.nDate.print("yyyy"));

                }
                else if (obj.config.selectType == "m") {

                    if (va.length > 4) {
                        var yy = va.left(4).number();
                        var mm = va.substr(4, 2).number() - 1;
                        var dd = 1;
                    }
                    else {
                        var yy = va.left(4).number();
                        var mm = 0;
                        var dd = 1;
                    }
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    obj.nDate = new Date(Date.UTC(yy, mm, dd, 12));

                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));

                }
                else {
                    var needAlert = false;
                    if (va.length > 5) {
                        var yy = va.left(4).number();
                        var mm = va.substr(4, 2).number() - 1;
                        var dd = va.substr(6, 2).number();
                    }
                    else if (va.length > 3) {
                        var yy = "20" + va.substr(0, 2);
                        var mm = va.substr(2, 2).number() - 1;
                        var dd = va.substr(4, 2).number();
                    }
                    else if (va.length > 2) {
                        var yy = nDate.getFullYear();
                        var mm = va.substr(0, 2).number() - 1;
                        var dd = va.substr(2, 2).number();
                    }
                    else {
                        var yy = nDate.getFullYear(); //va.left(4).number();
                        var mm = nDate.getMonth();
                        var dd = va.substr(0, 2).number();
                    }
                    if (yy == 0) needAlert = true;
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;

                    obj.nDate = new Date(Date.UTC(yy, mm, dd, 12));

                    //trace(obj.nDate.getFullYear() != yy.number());
                    //trace(obj.nDate.getMonth() != mm.number());
                    //trace(obj.nDate.getDate(), dd.number());

                    if (obj.nDate.getFullYear() != yy.number()
                        || obj.nDate.getMonth() != mm.number()
                        || obj.nDate.getDate() != dd.number()) {
                        needAlert = true;
                        obj.nDate = new Date();
                    }

                    printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");

                    if (obj.config.expandTime) {
                        var hh, mi;
                        try {
                            printDate += " " + obj.mycalendartime.getTime();
                            trace(printDate);

                        } catch (e) {
                            if (va.length > 11) { // hh,mm
                                hh = va.substr(8, 2).number();
                                mi = va.substr(10, 2).number();
                            }
                            else if (va.length > 9) {
                                hh = va.substr(8, 2).number();
                                mi = "00";
                            }
                            else {
                                hh = "12";
                                mi = "00";
                            }
                            printDate += " " + hh.setDigit(2) + ":" + mi.setDigit(2);
                        }
                    }

                    if (needAlert) {
                        this.msgAlert("날짜 형식이 올바르지 않습니다.");
                    }
                    axdom("#" + objID).val(printDate);
                }
            }
        }

        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        if (obj.config.onChange) {

            if (axdom("#" + objID).data("val") && axdom("#" + objID).data("val") != axdom("#" + objID).val()) {

                if (axdom.isFunction(obj.config.onChange)) {
                    obj.config.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val()
                    });
                }
                else {
                    var st_date, ed_date;
                    if (obj.config.onChange.earlierThan) {
                        st_date = axdom("#" + objID).val();
                        ed_date = axdom("#" + obj.config.onChange.earlierThan).val();
                    }
                    else if (obj.config.onChange.laterThan) {
                        ed_date = axdom("#" + objID).val();
                        st_date = axdom("#" + obj.config.onChange.laterThan).val();
                    }
                    if (st_date != "" && ed_date != "") {
                        if (st_date.date().diff(ed_date) < 0) {
                            this.msgAlert(obj.config.onChange.err);
                            axdom("#" + objID).val("");
                        }
                    }

                    obj.config.onChange.onChange.call({
                        objID: objID,
                        value: axdom("#" + objID).val(),
                        eventType: "blur"
                    });
                }
                axdom("#" + objID).data("val", axdom("#" + objID).val());

            }
        }

        /*
         if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
         obj.bindTarget.trigger("change");
         */

        /* ie10 버그
         axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리

         //비활성 처리후 메소드 종료
         axdom(document).unbind("click.AXInput");
         axdom("#" + objID).unbind("keydown.AXInput");
         */

        event.stopPropagation(); // disableevent
        return;
    },
    unbindDate: function (obj) {
        var cfg = this.config;
        var objID = obj.id;
        var objSeq = null;

        axf.each(this.objects, function (oidx, O) {
            if (this.id == objID) {
                objSeq = oidx;
                return false;
            }
        });

        if (objSeq != null) {
            var obj = this.objects[objSeq];

            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리

            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            axdom("#" + objID).unbind("keydown.AXInput");
        }

        var collect = [];
        var removeAnchorId;
        axf.each(this.objects, function () {
            if (this.id != obj.id) collect.push(this);
            else {
                removeAnchorId = this.anchorID;
            }
        });
        this.objects = collect;

        axdom("#" + removeAnchorId).remove();

    },
    bindDateTimeChange: function (objID, objSeq, myTime) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
        if (obj.config.expandTime) {
            printDate += " " + obj.mycalendartime.getTime();
        }
        axdom("#" + objID).val(printDate);
    },
    bindDateExpandBoxClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var isDateClick = false;

        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget,
            until: function (evt, evtIDs) {
                return (evt.parentNode.tagName == "BODY") ? true : false;
            },
            find: function (evt, evtIDs) {
                if (!evt.id) return false;
                var checkID = cfg.targetID + "_AX_" + objID;
                if (evt.id == objID || evt.id.substr(0, checkID.length) == checkID) {
                    return true;
                }
                else {
                    return false;
                }
            }
        });

        isDateClick = (myTarget) ? true : false;
        if (!isDateClick) {
            this.bindDateExpandClose(objID, objSeq, event);
        }
        else {
            if (axdom(myTarget).hasClass("disabled")) {
                return;
            } // disabled 대상은 선택 불가

            var ids = myTarget.id.split(/_AX_/g);
            var ename = ids.last();

            var nDate = obj.nDate;
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            if (ename == "expandPrev") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(-12, "y"), "y");
                }
            }
            else if (ename == "expandNext") {
                if (obj.mycalendarPageType == "d") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindDateChangePage(objID, objSeq, nDate.add(12, "y"), "y");
                }
            }
            else if (ename == "controlYear") {
                this.bindDateChangePage(objID, objSeq, nDate, "y");
            }
            else if (ename == "controlMonth") {
                if (obj.config.selectType != "y") {
                    this.bindDateChangePage(objID, objSeq, nDate, "m");
                }
            }
            else if (ename == "date") {
                //trace(ids[ids.length-2]);
                obj.nDate = ids[ids.length - 2].date();
                var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime.getTime();
                }
                axdom("#" + objID).val(printDate);
                this.bindDateExpandClose(objID, objSeq, event);
            }
            else if (ename == "month") {
                var myMonth = ids[ids.length - 2].number() - 1;
                if (obj.config.selectType == "m") {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd, 12));
                    axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var yy = nDate.getFullYear();
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(yy, myMonth, dd, 12));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "d");
                }
            }
            else if (ename == "year") {
                var myYear = ids[ids.length - 2];
                if (obj.config.selectType == "y") {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd, 12));
                    axdom("#" + objID).val(obj.nDate.print("yyyy"));
                    this.bindDateExpandClose(objID, objSeq, event);
                }
                else {
                    var mm = 0;
                    var dd = 1;
                    obj.nDate = new Date(Date.UTC(myYear, mm, dd, 12));
                    this.bindDateChangePage(objID, objSeq, obj.nDate, "m");
                }
            }
        }
    },
    bindDateKeyup: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (obj.config.selectType == "y") {

        }
        else if (obj.config.selectType == "m") {

        }
        else {

        }
    },
    bindDateChangePage: function (objID, objSeq, setDate, pageType) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

        if (pageType == "m") {
            //alert(setDate);
            obj.mycalendarPageType = "m";
            obj.nDate = setDate;
            obj.mycalendar.printMonthPage(setDate);
            var myYear = setDate.getFullYear();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").html(myYear + "년");
        }
        else if (pageType == "y") {
            obj.mycalendarPageType = "y";
            obj.nDate = setDate;
            obj.mycalendar.printYearPage(setDate.getFullYear());
            var myYear = setDate.getFullYear();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").html(myYear + "년");
        }
        else {
            obj.mycalendarPageType = "d";
            obj.nDate = setDate;
            obj.mycalendar.printDayPage(setDate);
            var myYear = setDate.getFullYear();
            var myMonth = (setDate.getMonth() + 1).setDigit(2);
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear").html(myYear + "년");
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth").html(myMonth + "월");
        }

        if (obj.config.selectType == "y") {
            axdom("#" + objID).val(obj.nDate.print("yyyy"));
        }
        else if (obj.config.selectType == "m") {
            axdom("#" + objID).val(obj.nDate.print("yyyy" + separator + "mm"));
        }
        else {
            //axdom("#"+objID).val(obj.nDate.print("yyyy"+separator+"mm"+separator+"dd"));
            var printDate = obj.nDate.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate += " " + obj.mycalendartime.getTime();
            }
            axdom("#" + objID).val(printDate);
        }
    },

    // twinDate
    bindTwinDate: function (objID, objSeq, option) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        obj.bindTargetStart = axdom("#" + obj.config.startTargetID);

        var h = obj.bindAnchorTarget.data("height");
        var po = [];
        var handleLeft = 0;
        if (obj.config) handleLeft = (obj.config.handleLeft || 0).number();

        po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle\" class=\"" + cfg.anchorDateHandleClassName + "\" style=\"right:" + (0 - handleLeft) + "px;top:0px;width:" + h + "px;height:" + h + "px;\">&nbsp;</a>");
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();

        var bindDateExpand = this.bindTwinDateExpand.bind(this);
        var bindTwinDateExpandClose = this.bindTwinDateExpandClose.bind(this);

        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").unbind("click.AXInput").bind("click.AXInput", function (event) {
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                bindTwinDateExpandClose(objID, objSeq, event);
            }
            else {
                var isReadOnly = obj.bindTarget.attr("readonly");
                var isDisabled = obj.bindTarget.attr("disabled");
                if (isReadOnly) isReadOnly = (isReadOnly.lcase() == "true") || (isReadOnly.lcase() == "readonly");
                if (isDisabled) isDisabled = (isDisabled.lcase() == "true") || (isDisabled.lcase() == "disabled");
                if (!isReadOnly && !isDisabled) bindDateExpand(objID, objSeq, true, event);
            }
        });
        obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            setTimeout(function () {
                //obj.bindTarget.select();
            }, 1);
            /*
             if(!AXgetId(cfg.targetID + "_AX_"+objID+"_AX_expandBox")){
             bindDateExpand(objID, objSeq, false, event);
             }
             */
        });
        obj.bindTargetStart.unbind("focus.AXInput").bind("focus.AXInput", function (event) {
            setTimeout(function () {
                //obj.bindTargetStart.select();
            }, 1);
            /*
             if(!AXgetId(cfg.targetID + "_AX_"+objID+"_AX_expandBox")){
             bindDateExpand(objID, objSeq, false, event);
             }
             */
        });

        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
        axdom("#" + objID + ", #" + obj.config.startTargetID).unbind("keyup.AXInput").bind("keyup.AXInput", function (event) {
            //alert(this.value);
            if (event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
                var va = this.value.replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
                var _this = this;

                if (obj.config.selectType == "y") {
                    if (va.length > 4) _this.value = va.left(4);
                }
                else if (obj.config.selectType == "m") {
                    if (va.length == 4) {
                        va = va + separator;
                        _this.value = va;
                    }
                    else if (va.length > 4) {
                        va = va.substr(0, 4) + separator + va.substr(4, 2);
                        _this.value = va;
                    }
                }
                else {
                    if (va.length < 4) {
                        _this.value = va;
                    }
                    else if (va.length <= 6) {
                        va = va.substr(0, 4) + separator + va.substr(4, 2);
                        _this.value = va;
                    }
                    else if (va.length <= 8) {
                        va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                        _this.value = va;
                    }
                    else if (va.length <= 10) {
                        if (obj.config.expandTime) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2);
                            _this.value = va;
                        }
                        else {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                            _this.value = va;
                        }
                    }
                    else if (va.length > 10) {
                        if (obj.config.expandTime) {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2) + " " + va.substr(8, 2) + ":" + va.substr(10, 2);
                            _this.value = va;
                        }
                        else {
                            va = va.substr(0, 4) + separator + va.substr(4, 2) + separator + va.substr(6, 2);
                            _this.value = va;
                        }
                    }
                }
            }
        });

        var bindTwinDateInputBlur = this.bindTwinDateInputBlur.bind(this);
        obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindTwinDateInputBlur(objID, objSeq, event, 2);
        });
        axdom("#" + obj.config.startTargetID).unbind("blur.AXInput").bind("blur.AXInput", function (event) {
            bindTwinDateInputBlur(objID, objSeq, event, 1);
        });

        var objVal1 = obj.bindTargetStart.val();
        var objVal2 = obj.bindTarget.val();
        var myDate1 = objVal1.date(separator);
        var myDate2 = objVal2.date(separator);
        obj.nDate1 = myDate1;
        obj.nDate2 = myDate2;
    },
    bindTwinDateExpand: function (objID, objSeq, isToggle, event) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        for (var OO, oidx = 0, __arr = this.objects; (oidx < __arr.length && (OO = __arr[oidx])); oidx++) {
            if (OO.expandBox_axdom) {
                OO.expandBox_axdom.remove();
                OO.expandBox_axdom = null;
            }
        }

        var obj = this.objects[objSeq];

        if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") {
            return false;
        }

        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

        //Selector Option box Expand
        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
                //비활성 처리후 메소드 종료
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
        //axdom("#"+cfg.targetID + "_AX_" + objID+"_AX_Handle").removeClass("on");

        //Expand Box 생성 구문 작성
        var objVal1 = axdom("#" + obj.config.startTargetID).val();
        var objVal2 = axdom("#" + objID).val();

        if (obj.config.expandTime) obj.config.selectType == "d"; //시간 확장 시 selectType : d 로 고정

        var today = new Date();
        var objVal1Empty = false;
        if (obj.config.selectType == "y") {
            if (objVal1 != "") {
                objVal1 = objVal1.left(4) + separator + "01" + separator + "02";
            }
            else {
                objVal1Empty = true;
            }
            if (objVal2 != "") {
                objVal2 = objVal2.left(4) + separator + "01" + separator + "02";
            }
        }
        else if (obj.config.selectType == "m") {
            if (objVal1 != "") {
                objVal1 = objVal1 + separator + "02";
            }
            else {
                objVal1Empty = true;
            }
            if (objVal2 != "") {
                objVal2 = objVal2 + separator + "02";
            }
        }
        if (AXUtil.isEmpty(objVal1)) {
            objVal1 = "";
            objVal1Empty = true;
        }

        /*var myDate1 = (objVal1Empty) ? objVal1.date(separator).add(-1, "m") : objVal1.date(separator);*/
        var myDate1 = objVal1.date(separator);
        var myDate2 = objVal2.date(separator);
        var myYear1 = myDate1.getFullYear();
        var myYear2 = myDate2.getFullYear();
        var myMonth1 = (myDate1.getMonth() + 1).setDigit(2);
        var myMonth2 = (myDate2.getMonth() + 1).setDigit(2);
        var buttonText = obj.config.buttonText || "OK";
        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"" + cfg.bindTwinDateExpandBoxClassName + "\" style=\"z-index:5100;\">");
        po.push("	<div>");
        po.push("		<table cellpadding=\"0\" cellspacing=\"0\">");
        po.push("			<tbody>");
        po.push("				<tr>");
        po.push("					<td style=\"padding-right:3px;\">");
        po.push("					<div class=\"dateTypeName\">START</div>");
        po.push("					<div class=\"dateControlBox\">");
        po.push("						<a " + obj.config.href + " class=\"yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1\">" + myYear1 + "년</a>");
        po.push("						<a " + obj.config.href + " class=\"monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth1\">" + myMonth1 + "월</a>");
        po.push("						<a " + obj.config.href + " class=\"prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev1\">P</a>");
        po.push("						<a " + obj.config.href + " class=\"nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext1\">N</a>");
        po.push("					</div>");
        po.push("					<div class=\"dateDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayBox1\"></div>");
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            po.push("					<div class=\"timeDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox1\"></div>");
        }
        po.push("					</td>");
        po.push("					<td style=\"padding-left:3px;\">");
        po.push("					<div class=\"dateTypeName\">END</div>");
        po.push("					<div class=\"dateControlBox\">");
        po.push("						<a " + obj.config.href + " class=\"yearbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2\">" + myYear2 + "년</a>");
        po.push("						<a " + obj.config.href + " class=\"monthbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth2\">" + myMonth2 + "월</a>");
        po.push("						<a " + obj.config.href + " class=\"prevbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandPrev2\">P</a>");
        po.push("						<a " + obj.config.href + " class=\"nextbutton\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandNext2\">N</a>");
        po.push("					</div>");
        po.push("					<div class=\"dateDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayBox2\"></div>");
        if (obj.config.expandTime) { //시간 선택 기능 확장시
            po.push("					<div class=\"timeDisplayBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox2\"></div>");
        }
        po.push("					</td>");
        po.push("				</tr>");
        po.push("			</tbody>");
        po.push("		</table>");
        po.push("	</div>");
        po.push("	<div style=\"padding-top:5px;\" align=\"center\">");
        po.push("		<input type=\"button\" value=\"" + buttonText + "\" class=\"AXButton Classic W70\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_closeButton\">");
        po.push("	</div>");
        po.push("</div>");
        axdom(document.body).append(po.join('')); // bindDateExpandBox append
        //axdom("#"+cfg.targetID + "_AX_" + objID+"_AX_Handle").addClass("on");

        // AXCalendar display
        obj.nDate1 = myDate1;
        obj.mycalendar1 = new AXCalendar();
        obj.mycalendar1.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox1",
            basicDate: myDate1,
            minDate: obj.config.minDate,
            maxDate: obj.config.maxDate,
            onBeforeShowDay: obj.config.onBeforeShowDay
        });

        obj.nDate2 = myDate2;
        obj.mycalendar2 = new AXCalendar();
        obj.mycalendar2.setConfig({
            targetID: cfg.targetID + "_AX_" + objID + "_AX_displayBox2",
            basicDate: myDate2,
            minDate: obj.config.minDate,
            maxDate: obj.config.maxDate,
            onBeforeShowDay: obj.config.onBeforeShowDay
        });

        if (obj.config.expandTime) { //시간 선택 기능 확장시
            obj.nDate1 = myDate1;
            var mycalendartimeChange1 = this.bindTwinDateTimeChange.bind(this);
            obj.mycalendartimeChange1 = function (myTime) {
                mycalendartimeChange1(objID, objSeq, myTime, 1);
            };
            obj.mycalendartime1 = new AXCalendar();
            obj.mycalendartime1.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox1",
                onChange: obj.mycalendartimeChange1
            });
            var apm = "AM";
            var myTimes = myDate1.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];
            if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime1.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);

            obj.nDate2 = myDate2;
            var mycalendartimeChange2 = this.bindTwinDateTimeChange.bind(this);
            obj.mycalendartimeChange2 = function (myTime) {
                mycalendartimeChange2(objID, objSeq, myTime, 2);
            };
            obj.mycalendartime2 = new AXCalendar();
            obj.mycalendartime2.setConfig({
                targetID: cfg.targetID + "_AX_" + objID + "_AX_displayTimeBox2",
                onChange: obj.mycalendartimeChange2
            });
            var apm = "AM";
            var myTimes = myDate2.print("hh:mi").split(":");
            var myHH = myTimes[0].number();
            var myMI = myTimes[1];
            if (myHH > 12) {
                apm = "PM";
                myHH -= 12;
            }
            obj.mycalendartime2.printTimePage(myHH.setDigit(2) + ":" + myMI.setDigit(2) + " " + apm);
        }

        var printDate1 = "";
        var printDate2 = "";
        if (obj.config.selectType == "y") {
            obj.mycalendarPageType = "y";
            obj.mycalendar1.printYearPage(myDate1.print("yyyy"));
            obj.mycalendar2.printYearPage(myDate2.print("yyyy"));
            printDate1 = myDate1.print("yyyy");
            printDate2 = myDate2.print("yyyy");
        }
        else if (obj.config.selectType == "m") {
            obj.mycalendarPageType = "m";
            obj.mycalendar1.printMonthPage(myDate1);
            obj.mycalendar2.printMonthPage(myDate2);
            printDate1 = myDate1.print("yyyy" + separator + "mm");
            printDate2 = myDate2.print("yyyy" + separator + "mm");
        }
        else {
            obj.mycalendarPageType = "d";
            obj.mycalendar1.printDayPage(myDate1);
            obj.mycalendar2.printDayPage(myDate2);
            printDate1 = myDate1.print("yyyy" + separator + "mm" + separator + "dd");
            printDate2 = myDate2.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate1 += " " + myDate1.print("hh:mi");
                printDate2 += " " + myDate2.print("hh:mi");
            }
        }
        if (obj.config.expandSetValue) {
            axdom("#" + obj.config.startTargetID).val(printDate1);
            axdom("#" + objID).val(printDate2);
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AXCalendar display

        // expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var expBoxWidth = expandBox.outerWidth();
        var expBoxHeight = expandBox.outerHeight();
        var offset = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").offset();
        var handleWidth = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").width();
        var handleHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_dateHandle").height();

        var css = {};
        if (obj.config.align == "left") {
            css.left = offset.left.number() - expBoxWidth;
        }
        else if (obj.config.align == "center") {
            css.left = offset.left.number() - expBoxWidth / 2 + handleWidth;
        }
        else if (obj.config.align == "right") {
            css.left = offset.left.number() + handleWidth;
        }
        else {
            css.left = offset.left.number() + handleWidth;
        }
        if (obj.config.valign == "top") {
            css.top = offset.top;
        }
        else if (obj.config.valign == "middle") {
            css.top = offset.top.number() - expBoxHeight / 2 + handleWidth / 2;
        }
        else if (obj.config.valign == "bottom") {
            css.top = offset.top.number() - expBoxHeight + handleWidth;
        }
        else {
            css.top = offset.top;
        }

        if (obj.config.customPos != undefined) {
            css.top = css.top + obj.config.customPos.top;
            css.left = css.left + obj.config.customPos.left;
        }

        var pElement = expandBox.offsetParent();
        var pBox = {width: pElement.width(), height: pElement.height()};

        var clientHeight = (AXUtil.docTD == "Q") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        var clienWidth = (AXUtil.docTD == "Q") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        if (clienWidth > pBox.width) pBox.width = clienWidth;
        if (clientHeight > pBox.height) pBox.height = clientHeight;
        var _box = {width: expandBox.outerWidth() + 10, height: expandBox.outerHeight() + 10};

        if ((_box.height.number() + css.top.number()) > pBox.height) {
            css.top = css.top - ((_box.height.number() + css.top.number()) - pBox.height);
        }
        if (css.top < 0) {
            css.top = 0;
        }

        if ((_box.width.number() + css.left.number()) > pBox.width) {
            css.left = css.left - ((_box.width.number() + css.left.number()) - pBox.width);
        }
        if (css.left < 0) {
            css.left = 0;
        }

        expandBox.css(css);
        obj.expandBox_axdom = expandBox;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~ expandBox set Position ~~~~~~~~~~~~~~~~~~~~~~~~~

        var bindTwinDateExpandBoxClick = this.bindTwinDateExpandBoxClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindTwinDateExpandBoxClick(objID, objSeq, event);
        }
        var bindTwinDateKeyup = this.bindTwinDateKeyup.bind(this);
        obj.inputKeyup = function (event) {
            bindTwinDateKeyup(objID, objSeq, event);
        }

        if (obj.config.selectType == "y") {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").css({left: "70px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth1").hide();
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").css({left: "70px"});
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth2").hide();
        }

        axdom(document).unbind("click.AXInput").bind("click.AXInput", obj.documentclickEvent);
        axdom("#" + objID).unbind("keydown.AXInput").bind("keydown.AXInput", obj.inputKeyup);
        var bindTwinDateExpandClose = this.bindTwinDateExpandClose.bind(this);
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_closeButton").unbind("click.AXInput").bind("click.AXInput", function (event) {
            bindTwinDateExpandClose(objID, objSeq, event);
        });
    },
    bindTwinDateTimeChange: function (objID, objSeq, myTime, seq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (seq == 1) {
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate += " " + obj.mycalendartime1.getTime();
            }
            axdom("#" + obj.config.startTargetID).val(printDate);
        }
        else {
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
            if (obj.config.expandTime) {
                printDate += " " + obj.mycalendartime2.getTime();
            }
            axdom("#" + objID).val(printDate);
        }
    },
    bindTwinDateExpandClose: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        //trace("bindTwinDateExpandClose");
        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {

            //axdom("#"+cfg.targetID+"_AX_"+objID+"_AX_Handle").removeClass("on");
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
            var objVal1 = axdom("#" + obj.config.startTargetID).val();
            var objVal2 = axdom("#" + objID).val();
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

            if (objVal1 != "" || objVal2 != "") {
                if (obj.config.selectType == "y") {
                    if (objVal1.length < 4) axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy"));
                    else {
                        objVal1 = objVal1.left(4);
                        axdom("#" + obj.config.startTargetID).val(objVal1);
                        axdom("#" + obj.config.startTargetID).trigger("change");
                    }
                    if (objVal2.length < 4) axdom("#" + objID).val(obj.nDate2.print("yyyy"));
                    else {
                        objVal2 = objVal2.left(4);
                        axdom("#" + objID).val(objVal2);
                        axdom("#" + objID).trigger("change");
                    }
                }
                else if (obj.config.selectType == "m") {
                    axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy" + separator + "mm"));
                    axdom("#" + obj.config.startTargetID).trigger("change");
                    axdom("#" + objID).val(obj.nDate2.print("yyyy" + separator + "mm"));
                    axdom("#" + objID).trigger("change");
                }
                else {
                    printDate1 = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                    printDate2 = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate1 += " " + obj.mycalendartime1.getTime();
                        printDate2 += " " + obj.mycalendartime2.getTime();
                    }
                    axdom("#" + obj.config.startTargetID).val(printDate1);
                    axdom("#" + objID).val(printDate2);
                    axdom("#" + obj.config.startTargetID).trigger("change");
                    axdom("#" + objID).trigger("change");
                }

                if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
                if (obj.config.onChange) {
                    obj.config.onChange.call({
                        ST_objID: obj.config.startTargetID,
                        ED_objID: objID,
                        ST_value: axdom("#" + obj.config.startTargetID).val(),
                        ED_value: axdom("#" + objID).val()
                    });
                }
                if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
                obj.bindTarget.trigger("change");
            }

            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리

            obj.expandBox_axdom = null;
            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXInput");
            axdom("#" + objID).unbind("keydown.AXInput");

            event.stopPropagation(); // disableevent
            return;
        }
    },
    bindTwinDateExpandBoxClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var isDateClick = false;

        var eventTarget = event.target;
        var myTarget = this.getEventTarget({
            evt: eventTarget,
            until: function (evt, evtIDs) {
                return (evt.parentNode.tagName == "body") ? true : false;
            },
            find: function (evt, evtIDs) {
                if (evt.id == "" || evt.id == null || evt.id == undefined) return false;
                if (evt.id == objID || evt.id == obj.config.startTargetID || (evt.id.substr(0, cfg.targetID.length) == cfg.targetID && (evt.id.search(objID) != -1 || evt.id.search(obj.config.startTargetID) != -1))) {
                    return true;
                }
                else {
                    return false;
                }
            }
        });

        isDateClick = (myTarget) ? true : false;
        if (!isDateClick) {
            this.bindTwinDateExpandClose(objID, objSeq, event);
        }
        else {
            if (axdom(myTarget).hasClass("disabled")) {
                return;
            } // disabled 대상은 선택 불가

            var ids = myTarget.id.split(/_AX_/g);
            var ename = ids.last();
            var boxType = ids[ids.length - 3];
            var nDate1 = obj.nDate1;
            var nDate2 = obj.nDate2;
            var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
            if (ename == "expandPrev1") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(-12, "y"), "y");
                }
            }
            else if (ename == "expandPrev2") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(-1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(-1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(-12, "y"), "y");
                }
            }
            else if (ename == "expandNext1") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1.add(12, "y"), "y");
                }
            }
            else if (ename == "expandNext2") {
                if (obj.mycalendarPageType == "d") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(1, "m"), "d");
                }
                else if (obj.mycalendarPageType == "m") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(1, "y"), "m");
                }
                else if (obj.mycalendarPageType == "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2.add(12, "y"), "y");
                }
            }
            else if (ename == "controlYear1") {
                this.bindTwinDateChangePage(objID, objSeq, 1, nDate1, "y");
            }
            else if (ename == "controlYear2") {
                this.bindTwinDateChangePage(objID, objSeq, 2, nDate2, "y");
            }
            else if (ename == "controlMonth1") {
                if (obj.config.selectType != "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 1, nDate1, "m");
                }
            }
            else if (ename == "controlMonth2") {
                if (obj.config.selectType != "y") {
                    this.bindTwinDateChangePage(objID, objSeq, 2, nDate2, "m");
                }
            }
            else if (ename == "date") {
                if (boxType == "displayBox1") {
                    obj.nDate1 = ids[ids.length - 2].date();
                    var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime1.getTime();
                    }
                    axdom("#" + obj.config.startTargetID).val(printDate);
                    obj.mycalendar1.dayPageSetDay(obj.nDate1);
                }
                else {
                    obj.nDate2 = ids[ids.length - 2].date();
                    var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + obj.mycalendartime2.getTime();
                    }
                    axdom("#" + objID).val(printDate);
                    obj.mycalendar2.dayPageSetDay(obj.nDate2);
                }

                if (obj.nDate1.diff(obj.nDate2) < 0) {
                    if (boxType == "displayBox1") {
                        obj.nDate2 = obj.nDate1;
                        var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                        if (obj.config.expandTime) {
                            printDate += " " + obj.mycalendartime2.getTime();
                        }
                        axdom("#" + objID).val(printDate);
                        obj.mycalendar2.dayPageSetDay(obj.nDate2);
                    }
                    else {
                        obj.nDate1 = obj.nDate2;
                        var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                        if (obj.config.expandTime) {
                            printDate += " " + obj.mycalendartime1.getTime();
                        }
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        obj.mycalendar1.dayPageSetDay(obj.nDate1);
                    }
                }

            }
            else if (ename == "month") {
                var myMonth = ids[ids.length - 2].number() - 1;
                if (boxType == "displayBox1") {
                    if (obj.config.selectType == "m") {
                        var yy = nDate1.getFullYear();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(yy, myMonth, dd));
                        var printDate = obj.nDate1.print("yyyy" + separator + "mm");
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        //this.bindTwinDateExpandClose(objID, objSeq, event);
                        obj.mycalendar1.monthPageSetMonth(obj.nDate1);
                    }
                    else {
                        var yy = nDate1.getFullYear();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(yy, myMonth, dd));
                        //trace("start ----");
                        this.bindTwinDateChangePage(objID, objSeq, 1, obj.nDate1, "d");
                    }
                }
                else {
                    if (obj.config.selectType == "m") {
                        var yy = nDate2.getFullYear();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(yy, myMonth, dd));
                        var printDate = obj.nDate2.print("yyyy" + separator + "mm");
                        axdom("#" + objID).val(printDate);
                        obj.mycalendar2.monthPageSetMonth(obj.nDate2);
                    }
                    else {
                        var yy = nDate2.getFullYear();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(yy, myMonth, dd));
                        this.bindTwinDateChangePage(objID, objSeq, 2, obj.nDate2, "d");
                    }
                }

                if (obj.config.selectType == "m") {
                    if (obj.nDate1.diff(obj.nDate2) < 0) {
                        obj.nDate2 = obj.nDate1;
                        var printDate = obj.nDate2.print("yyyy" + separator + "mm");
                        axdom("#" + objID).val(printDate);
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        obj.mycalendar2.monthPageSetMonth(obj.nDate2);
                    }
                }

            }
            else if (ename == "year") {
                var myYear = ids[ids.length - 2];
                if (boxType == "displayBox1") {
                    if (obj.config.selectType == "y") {
                        var mm = nDate1.getMonth();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(myYear, mm, dd));
                        var printDate = obj.nDate1.print("yyyy");
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        //this.bindTwinDateExpandClose(objID, objSeq, event);
                        obj.mycalendar1.yearPageSetYear(obj.nDate1);
                    }
                    else {
                        var mm = nDate1.getMonth();
                        var dd = nDate1.getDate();
                        obj.nDate1 = new Date(Date.UTC(myYear, mm, dd));
                        this.bindTwinDateChangePage(objID, objSeq, 1, obj.nDate1, "m");
                    }
                }
                else {
                    if (obj.config.selectType == "y") {
                        var mm = nDate2.getMonth();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(myYear, mm, dd));
                        var printDate = obj.nDate2.print("yyyy");
                        axdom("#" + objID).val(printDate);
                        //this.bindTwinDateExpandClose(objID, objSeq, event);
                        obj.mycalendar2.yearPageSetYear(obj.nDate2);
                    }
                    else {
                        var mm = nDate2.getMonth();
                        var dd = nDate2.getDate();
                        obj.nDate2 = new Date(Date.UTC(myYear, mm, dd));
                        this.bindTwinDateChangePage(objID, objSeq, 2, obj.nDate2, "m");
                    }
                }

                if (obj.config.selectType == "y") {
                    if (obj.nDate1.print("yyyy").number() > obj.nDate2.print("yyyy").number()) {
                        obj.nDate2 = obj.nDate1;
                        var printDate = obj.nDate2.print("yyyy");
                        axdom("#" + obj.config.startTargetID).val(printDate);
                        axdom("#" + objID).val(printDate);
                        obj.mycalendar2.yearPageSetYear(obj.nDate2);
                    }
                }
            }
        }
    },
    bindTwinDateKeyup: function (objID, objSeq, event) {
        //trace(event.keyCode);
        if (obj.config.selectType == "y") {

        }
        else if (obj.config.selectType == "m") {

        }
        else {

        }
    },
    bindTwinDateChangePage: function (objID, objSeq, objType, setDate, pageType) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";

        if (pageType == "m") {
            if (objType == 1) {
                //obj.mycalendarPageType = "m";
                obj.nDate1 = setDate;
                obj.mycalendar1.printMonthPage(setDate);
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").html(myYear + "년");
            }
            else {
                //obj.mycalendarPageType = "m";
                obj.nDate2 = setDate;
                obj.mycalendar2.printMonthPage(setDate);
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").html(myYear + "년");
            }
        }
        else if (pageType == "y") {
            if (objType == 1) {
                //obj.mycalendarPageType = "y";
                obj.nDate1 = setDate;
                obj.mycalendar1.printYearPage(setDate.getFullYear());
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").html(myYear + "년");
            }
            else {
                //obj.mycalendarPageType = "y";
                obj.nDate2 = setDate;
                obj.mycalendar2.printYearPage(setDate.getFullYear());
                var myYear = setDate.getFullYear();
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").html(myYear + "년");
            }
        }
        else {
            //obj.mycalendarPageType = "d";

            //trace({objID:objID, objSeq:objSeq, objType:objType, setDate:setDate, pageType:pageType});

            if (objType == 1) {
                obj.nDate1 = setDate;
                obj.mycalendar1.printDayPage(setDate);
                var myYear = setDate.getFullYear();
                var myMonth = (setDate.getMonth() + 1).setDigit(2);
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear1").html(myYear + "년");
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth1").html(myMonth + "월");
            }
            else {
                obj.nDate2 = setDate;
                obj.mycalendar2.printDayPage(setDate);
                var myYear = setDate.getFullYear();
                var myMonth = (setDate.getMonth() + 1).setDigit(2);
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlYear2").html(myYear + "년");
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_controlMonth2").html(myMonth + "월");
            }
        }

        if (objType == 1) {
            if (obj.config.selectType == "y") {
                axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy"));
            }
            else if (obj.config.selectType == "m") {
                axdom("#" + obj.config.startTargetID).val(obj.nDate1.print("yyyy" + separator + "mm"));
            }
            else {
                var printDate = obj.nDate1.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime1.getTime();
                }
                axdom("#" + obj.config.startTargetID).val(printDate);
            }
        }
        else {
            if (obj.config.selectType == "y") {
                axdom("#" + objID).val(obj.nDate2.print("yyyy"));
            }
            else if (obj.config.selectType == "m") {
                axdom("#" + objID).val(obj.nDate2.print("yyyy" + separator + "mm"));
            }
            else {
                var printDate = obj.nDate2.print("yyyy" + separator + "mm" + separator + "dd");
                if (obj.config.expandTime) {
                    printDate += " " + obj.mycalendartime2.getTime();
                }
                axdom("#" + objID).val(printDate);
            }
        }
    },
    bindTwinDateInputBlur: function (objID, objSeq, event, seq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var objVal, targetObjID;
        if (seq == 1) {
            targetObjID = obj.config.startTargetID;
            objVal = axdom("#" + obj.config.startTargetID).val();
        }
        else {
            targetObjID = objID;
            objVal = axdom("#" + objID).val();
        }

        if (objVal == "") {

        }
        else {
            var clearDate = false;
            var nDate = (obj["nDate" + seq] || new Date());
            var va = axdom("#" + targetObjID).val().replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
            if (va.search(/\d+/g) == -1) {
                clearDate = true;
            }

            if (clearDate) {
                axdom("#" + targetObjID).val("");
            }
            else {
                var separator = obj.config.separator || AXConfig.AXInput.dateSeparator || "-";
                if (obj.config.selectType == "y") {

                    var yy = va.left(4).number();
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    var mm = nDate.getMonth();
                    var dd = nDate.getDate();
                    obj["nDate" + seq] = new Date(Date.UTC(yy, mm, dd, 12));

                    axdom("#" + targetObjID).val(obj["nDate" + seq].print("yyyy"));

                }
                else if (obj.config.selectType == "m") {

                    if (va.length > 5) {
                        var yy = va.left(4).number();
                        var mm = va.substr(4, 2).number() - 1;
                        var dd = 1;
                    }
                    else {
                        var yy = va.left(4).number();
                        var mm = 0;
                        var dd = 1;
                    }
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    obj["nDate" + seq] = new Date(Date.UTC(yy, mm, dd, 12));

                    axdom("#" + targetObjID).val(obj["nDate" + seq].print("yyyy" + separator + "mm"));

                }
                else {
                    var needAlert = false;
                    var yy, mm, dd, hh, mi;
                    if (va.length > 7) {
                        yy = va.left(4).number();
                        mm = va.substr(4, 2).number() - 1;
                        dd = va.substr(6, 2).number();
                    }
                    else if (va.length > 4) {
                        yy = "20" + va.substr(0, 2);
                        mm = va.substr(2, 2).number() - 1;
                        dd = va.substr(4, 2).number();
                    }
                    else if (va.length > 2) {
                        yy = nDate.getFullYear();
                        mm = va.substr(0, 2).number() - 1;
                        dd = va.substr(2, 2).number();
                    }
                    else {
                        yy = nDate.getFullYear(); //va.left(4).number();
                        mm = nDate.getMonth();
                        dd = va.substr(0, 2).number();
                    }

                    if (va.length >= 9) {
                        hh = va.substr(8, 2).number();
                        mi = va.substr(10, 2).number();
                    }
                    else {
                        hh = "00";
                        mi = "00";
                    }

                    if (yy == 0) needAlert = true;
                    if (yy == 0) yy = nDate.getFullYear();
                    if (yy < 1000) yy += 2000;
                    obj["nDate" + seq] = new Date(Date.UTC(yy, mm, dd, 12));

                    if (obj["nDate" + seq].getFullYear() != yy.number()
                        || obj["nDate" + seq].getMonth() != mm.number()
                        || obj["nDate" + seq].getDate() != dd.number()) {
                        needAlert = true;
                        obj["nDate" + seq] = new Date();
                    }

                    printDate = obj["nDate" + seq].print("yyyy" + separator + "mm" + separator + "dd");
                    if (obj.config.expandTime) {
                        printDate += " " + hh.setDigit(2) + ":" + mi.setDigit(2);
                    }

                    if (needAlert) {
                        this.msgAlert("날짜 형식이 올바르지 않습니다.");
                    }
                    axdom("#" + targetObjID).val(printDate);

                    if (obj.nDate1 == undefined) {
                        var va = axdom("#" + obj.config.startTargetID).val().replace(/\D/gi, ""); //숫자 이외의 문자를 제거 합니다.
                        if (va.search(/\d+/g) != -1) {
                            if (va.length > 7) {
                                var yy = va.left(4).number();
                                var mm = va.substr(4, 2).number() - 1;
                                var dd = va.substr(6, 2).number();
                            }
                            else if (va.length > 5) {
                                var yy = va.left(4).number();
                                var mm = va.substr(4, 2).number() - 1;
                                var dd = 1;
                            }
                            else {
                                var yy = va.left(4).number();
                                var mm = nDate.getMonth();
                                var dd = nDate.getDate();
                            }
                            if (yy == 0) needAlert = true;
                            if (yy == 0) yy = nDate.getFullYear();
                            if (yy < 1000) yy += 2000;
                            obj.nDate1 = new Date(Date.UTC(yy, mm, dd, 12));
                        }
                    }
                    if (obj.nDate2 == undefined) {
                        obj.nDate2 = obj.nDate1;
                        printDate = obj["nDate" + 2].print("yyyy" + separator + "mm" + separator + "dd");
                        if (obj.config.expandTime) {
                            if (obj["mycalendartime" + 2]) printDate += " " + obj["mycalendartime" + 2].getTime();
                        }
                        axdom("#" + objID).val(printDate);
                    }

                    if (obj.nDate1.diff(obj.nDate2) < 0) {
                        if (seq == 1) {
                            obj.nDate2 = obj.nDate1;
                            printDate = obj["nDate" + 2].print("yyyy" + separator + "mm" + separator + "dd");
                            if (obj.config.expandTime) {
                                if (obj["mycalendartime" + 2]) printDate += " " + obj["mycalendartime" + 2].getTime();
                            }
                            axdom("#" + objID).val(printDate);
                        }
                        else {
                            obj.nDate1 = obj.nDate2;
                            printDate = obj["nDate" + 1].print("yyyy" + separator + "mm" + separator + "dd");
                            if (obj.config.expandTime) {
                                if (obj["mycalendartime" + 1]) printDate += " " + obj["mycalendartime" + 1].getTime();
                            }
                            axdom("#" + obj.config.startTargetID).val(printDate);
                        }
                    }
                }
            }
        }

        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        if (obj.config.onChange) {
            obj.config.onChange.call({
                event: event,
                ST_objID: obj.config.startTargetID,
                ED_objID: objID,
                ST_value: axdom("#" + obj.config.startTargetID).val(),
                ED_value: axdom("#" + objID).val()
            });
        }
        /*
         if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
         obj.bindTarget.trigger("change");
         */

        /* ie10 버그 픽스
         axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리

         //비활성 처리후 메소드 종료
         axdom(document).unbind("click.AXInput");
         axdom("#" + objID).unbind("keydown.AXInput");
         */
        event.stopPropagation(); // disableevent
        return;
    },

    // checked
    bindChecked: function (objID, objSeq) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];

        if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
        if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
        //var tagName = obj.bindTarget.get(0).tagName.ucase();
        obj.bindTarget.css({opacity: 0});

        var h = obj.bindAnchorTarget.data("height"),
            marginWidth = obj.bindTarget.css("margin-left").number() + obj.bindTarget.css("margin-right").number(),
            marginHeight = obj.bindTarget.css("margin-top").number() + obj.bindTarget.css("margin-bottom").number(),
            chk_size = Math.max((h + marginWidth), (h + marginHeight)) - 1,
            left = (obj.bindTarget.css("margin-left").number() - obj.bindTarget.css("margin-right").number()).abs(),
            anchorHandle, linked_items = [];

        var onchange = function (e) {
            if (obj.bindTarget.get(0).checked) {
                anchorHandle.addClass("checked");
            }
            else {
                anchorHandle.removeClass("checked");
            }
            if (linked_items.length > 0) {
                for (var li = 0; li < linked_items.length; li++) {
                    var aHandle = jQuery(linked_items[li]).next().find("." + cfg.anchorCheckedContainerClassName + "_radio");
                    if (linked_items[li].checked) {
                        aHandle.addClass("checked");
                    }
                    else {
                        aHandle.removeClass("checked");
                    }
                }
            }
        };

        var po = [];
        po.push('<div id="' + cfg.targetID + '_AX_' + objID + '_AX_HandleContainer"');
        if (obj.bindTarget.attr("type") == "radio") {
            po.push(' class="' + cfg.anchorCheckedContainerClassName + '_radio" ');
        }
        else {
            po.push(' class="' + cfg.anchorCheckedContainerClassName + '" ');
        }

        po.push(' style="left:' + left + 'px;top:0px;width:' + chk_size + 'px;height:' + chk_size + 'px;"');
        po.push(' onselectstart="return false;">');
        po.push('<a class="checked-icon"></a>')
        po.push('</div>');
        obj.bindAnchorTarget.append(po.join(''));
        obj.bindAnchorTarget.show();
        if (obj.bindTarget.attr("type") == "radio") {
            anchorHandle = obj.bindAnchorTarget.find("." + cfg.anchorCheckedContainerClassName + "_radio");
        }
        else {
            anchorHandle = obj.bindAnchorTarget.find("." + cfg.anchorCheckedContainerClassName);
        }

        obj.bindTarget.unbind("change.AXInput").bind("change.AXInput", onchange);
        anchorHandle.bind("click", function (e) {
            obj.bindTarget.get(0).checked = !obj.bindTarget.get(0).checked;
            obj.bindTarget.trigger("change");
            _this.stopEvent(e);
        });
        if (obj.bindTarget.attr("type") == "radio") {
            // 이름이 같은 라디오 아이템을 수집하여 링크 합니다.
            var nm = obj.bindTarget.attr("name");
            //trace(nm, objID);
            jQuery("input[name=" + nm + "]").each(function () {
                if (objID != this.id) {
                    linked_items.push(this);
                }
            });
        }
        onchange();
    }
});

var AXInput = new AXInputConverter();
AXInput.setConfig({targetID: "inputBasic", href: AXConfig.anchorHref});

/**
 * @method jQueryExtends.unbindInput
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 컨트롤을 제거합니다.
 * @example
 ```js
 axdom("#AXInputNumber").unbindInput();
 ```
 **/
axdom.fn.unbindInput = function (config) {
    axf.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXInput.unbind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSearch
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에  검색 컨트롤을 바인딩 합니다. IE9 이하에서도 placeholder를 지원합니다.
 * @example
 ```js
 axdom(".AXInputSearch").bindSearch();
 ```
 **/
axdom.fn.bindSearch = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        if (config == undefined) config = {};
        config.id = this.id;
        config.bindType = "search";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindNumber
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 숫자 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    min: 1,   // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100, // {Number} [max=Number.MAX_VALUE] - 최대값 (optional)
    onchange: function(){ // {Function} - 값이 변경되었을 때 이벤트 콜백함수 (optional)
        trace(this);
    }
};
 axdom("#AXInputNumber").bindNumber(config);
 ```
 **/
axdom.fn.bindNumber = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "number";
        config.href = AXConfig.anchorHref;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindMoney
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 통화단위가 입력 되도록 합니다.
 * @example
 ```js
 var config = {
    min: 1,  // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100 // {Number} [max=Number.MAX_VALUE] - 최대값 (optional)
};
 axdom("#AXInputMoney").bindMoney(config);
 ```
 **/
axdom.fn.bindMoney = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "money";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelector
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 selector 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    appendable   : ( true || false ),                      // {Boolean}  - options 에 정해진 값 외의 입력 가능 여부 true 이면 입력이 가능합니다. (optional)
    options      : [{optionValue:"1", optionText:"AXISJ"}] // {Array}    - [{optionValue:"값", optionText:"라벨"}]
    ajaxUrl      : "./data.json",                          // {String}   - AJAX 데이터 호출 URL (optional)
    ajaxPars     : "param1=val1&param2=val2",              // {String}   - AJAX 데이터 호출 URL 파라미터 (optional)
    positionFixed: ( true || false ),                      // {Boolean}  - expandBox position CSS 를 fixed 할지 여부. selector 가 fixed 된 엘리먼트 위에 위치하는 경우 사용하세요 (optional)
    direction    : "bottom",                               // {String}   - expandBox의 위/아래 열리는 방향을 지정합니다. 기본값은 ""이며 "bottom"을 사용하는 경우 expandBox의 방향이 밑에서 위로 열리게 됩니다. (optional)
    onchange     : function() {                            // {Function} - 값 변경 이벤트 콜백함수 (optional)
        trace(this);
    },
    onsearch     : function(objID, objVal, callBack) {               // {Function} - 값 변경시 options 변경 구현 함수(optional) ※ 주의: ajaxUrl과 중복 사용할 수 없습니다. 만약 두 옵션이 같이 선언되면 onsearch가 적용되고 ajaxUrl은 무시됩니다.
        // this = { id: objID, value: objVal }
        // 아래와 같은 형식으로 options 값을 반환해야 합니다.
        return {
            options:[
                {optionValue:1, optionText:"Seoul", desc:"부가설명글"},
                ...
            ]
        }
        // 또는 callBack 함수를 호출합니다.
    }
    finder: {
        onclick: function() { // {Function} - 파인더 버튼 클릭 이벤트 콜백함수 (optional)
            trace(this);
        }
    },
    maxHeight   : {Number} [150] - selector panel height
};

 // 서버에서 리턴하는 JSON 구문 예시
 // 아래 형식을 만족 시켜야 합니다.
 // desc 또는 optionDesc 값을 지정하면 option 라벨 뒤에 부가설명글로 표시됩니다.
 {
	result:"ok",
	options:[
		{optionValue:1, optionText:"Seoul", desc:"부가설명글"},
		{optionValue:2, optionText:"대구"},
		{optionValue:3, optionText:"대전", optionDesc:"부가설명글"},
		{optionValue:8, optionText:"전주"},
		{optionValue:9, optionText:"Gwangju"}
	]
}

 axdom("#AXInputSelector").bindSelector(config);
 ```
 **/
axdom.fn.bindSelector = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "selector";
        config.href = AXConfig.anchorHref;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectorBlur
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description 옵션 목록이 열려있으면 닫습니다.
 * @example
 ```js
 axdom("#AXInputSelector").bindSelectorBlur();
 ```
 **/
axdom.fn.bindSelectorBlur = function (config) {
    axf.each(this, function () {
        AXInput.bindSelectorBlur(this.id);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSlider
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 slider 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    min: 0,    // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100,  // {Number} [min=Number.MAX_VALUE] - 최대값 (optional)
    snap: 100, // {Number} [snap=1] -
    unit: "%", // {String} [unit=""] - 값 뒤에 붙여 표현하는 단위 (optional)
    onchange: function() { // {Function} - 값 변경 이벤트 콜백함수 (optional)
        trace(this);
    }
};
 axdom("#AXInputSlider").bindSlider(config);
 ```
 **/
axdom.fn.bindSlider = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "slider";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindTwinSlider
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 번위 선택이 가능한 slider 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    min: 0,         // {Number} [min=Number.MIN_VALUE] - 최소값 (optional)
    max: 100,       // {Number} [max=Number.MAX_VALUE] - 최대값 (optional)
    separator: "~", // {String} [separator="~"] -두개의 값 사이를 구분 지을 문자열
    snap: 100,      // {Number} [snap=1] -
    unit: "%",      // {String} [unit=""] 값 뒤에 붙여 표현하는 단위 (optional)
    onchange: function() { // {Function} - 값 변경 이벤트 콜백함수 (optional)
        trace(this);
    }
};
 axdom("#AXInputTwinSlider").bindTwinSlider(config);
 ```
 **/
axdom.fn.bindTwinSlider = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "twinSlider";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSwitch
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 스위치 컨트롤을 적용합니다.
 * @example
 ```js
 var config = {
    off: "AM", // {String} switch off value
    on : "PM", // {String} switch on vlaue
    onchange:function(){
        trace(this);
    }
};
 axdom("#AXInputSwitch").bindSwitch(config);
 ```
 **/
axdom.fn.bindSwitch = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "switch";
        AXInput.bind(config);
        return this;
    });
};

/**
 * @method jQueryExtends.bindSegment
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 segment 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    theme:"AXSegmentTest", // {String} CSS 클래스
    options : [            // {String} {optionValue:"옵션의값", optionText:"옵션라벨", addClass:"옵션아이템에 추가될 CSS 클래스"}
        {optionValue:0, optionText:"왼쪽", addClass:"type1"},
        {optionValue:1, optionText:"가운데", addClass:"type2"},
        {optionValue:2, optionText:"오른쪽", addClass:"type3"}
    ],
    onchange:function(){  // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        //this.targetID, this.options, this.selectedIndex, this.selectedOption
        trace(this);
    }
};
 axdom("#AXInputSegment").bindSegment(config);
 ```
 **/
axdom.fn.bindSegment = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "segment";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindDate
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    align            :"right", // {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           :"top",   // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { isEnable: true|false, title:'성탄절', className: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDate").bindDate(config);
 ```
 **/
axdom.fn.bindDate = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "date";
        config.href = AXConfig.anchorHref;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.unbindDate
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 날짜 컨트롤을 제거합니다.
 * @example
 ```js
 axdom("#AXInputDate").unbindDate();
 ```
 **/
axdom.fn.unbindDate = function (config) {
    axf.each(this, function () {
        config = config || {};
        config.id = this.id;
        AXInput.unbindDate(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindDateTime
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜와 시간 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    align            : "right",// {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           : "top",  // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { enable: true|false, title:'성탄절', class: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDate").bindDateTime(config);
 ```
 **/
axdom.fn.bindDateTime = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "date";
        config.expandTime = true;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindTwinDate
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜(start ~ end) 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    startTargetID    : "AXInputDateST", // {String}시작일 input text 아이디
    align            : "right",// {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           : "top",  // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    buttonText       : "OK"    // {String} ["OK"] - 선택 버튼 텍스트 설정
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { enable: true|false, title:'성탄절', class: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDateED").bindTwinDate(config);
 ```
 **/
axdom.fn.bindTwinDate = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "twinDate";
        config.href = AXConfig.anchorHref;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindTwinDateTime
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 날짜와 시간(start ~ end) 컨트롤을 바인딩 합니다.
 * @example
 ```js
 var config = {
    startTargetID    : "AXInputDateST", // {String}시작일 input text 아이디
    align            : "right",// {String} ("left"|"center"|"right") 달력에서 input text 의 위치
    valign           : "top",  // {String} ("top"|"middle"|"bottom") 달력에서 input text 의 위치
    separator        : "-",    // {String} 날짜형식 표시 구분 문자열
    selectType       : "d",    // {String} ("y"|"m"|"d") 날짜선택범위 y 를 지정하면 년도만 선택됩니다.
    defaultSelectType: "d",    // {String} ("y"|"m"|"d") 달력컨트롤의 년월일 선택도구 중에 먼저 보이는 도구타입
    defaultDate      : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 빈값의 달력 기준일을 설정합니다. 지정하지 않으면 시스템달력의 오늘을 기준으로 합니다.
    minDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최소일을 설정합니다.
    maxDate          : "",     // {String} ("yyyy[separator]mm[separator]dd") 날짜 형식의 문자열로 선택할 수 있는 최대일을 설정합니다.
    buttonText       : "OK"    // {String} ["OK"] - 선택 버튼 텍스트 설정
    onBeforeShowDay  : {}      // {Function} 날짜를 보여주기 전에 호출하는 함수. date를 파라미터로 받으며 다음과 같은 형식의 Object를 반환해야 한다. { enable: true|false, title:'성탄절', class: 'holyday', style: 'color:red' }
    onchange: function(){      // {Function} 값이 변경되었을 때 발생하는 이벤트 콜백함수
        trace(this);
    }
};
 axdom("#AXInputDateED").bindTwinDateTime(config);
 ```
 **/
axdom.fn.bindTwinDateTime = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "twinDateTime";
        config.expandTime = true;
        config.href = AXConfig.anchorHref;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindPlaceHolder
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description IE9 이하에서도 input text 엘리먼트에 placeholder를 지원합니다. placeholder를 지원하는 브라우저에서는 브라우저의 native code가 사용됩니다.
 * @example
 ```js
 axdom(".AXInputPlaceholder").bindPlaceHolder();
 ```
 **/
axdom.fn.bindPlaceHolder = function (config) {
    axf.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        config = config || {};
        config.id = this.id;
        config.bindType = "placeHolder";
        config.href = AXConfig.anchorHref;
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindChecked
 * @param {Object} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 체크 컨트롤을 바인딩 합니다.(구현중)
 * @example
 ```js
 axdom(".AXInputChecked").bindChecked();
 ```
 **/
axdom.fn.bindChecked = function (config) {
    axf.each(this, function () {
        config = config || {};
        config.id = (this.id || (this.id = "axchecked-" + axf.getUniqueId()));
        config.bindType = "checked";
        AXInput.bind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.setConfigInput
 * @param {Object} configs
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 config를 할당합니다.
 * @example
 ```js
 axdom(".AXInput").setConfigInput( 100 );
 ```
 **/
axdom.fn.setConfigInput = function (config) {
    axf.each(this, function () {
        AXInput.bindSetConfig(this.id, config);
    });
    return this;
};

/**
 * @method jQueryExtends.setValueInput
 * @param {Object} value - 할당할 값
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 컨트롤에 값을 할당합니다.(아직 search, number, money, date, twinDate 컨트롤은 구현되지 않았습니다.)
 * @example
 ```js
 axdom(".AXInput").setValueInput( 100 );
 ```
 **/
axdom.fn.setValueInput = function (value) {
    axf.each(this, function () {
        AXInput.bindSetValue(this.id, value);
    });
    return this;
};

/**
 * @method jQueryExtends.bindInputDisabled
 * @param {Boolean} [Disabled=true] - 컨트롤을 disabled | enabled 합니다.
 * @returns {jQueryObject}
 * @description input text 엘리먼트에 바인딩된 컨트롤을 비활성화 하거나 활성화 합니다.
 * @example
 ```js
 axdom(".AXInput").bindInputDisabled( true | false );
 ```
 **/
jQuery.fn.bindInputDisabled = function (Disabled) {
    axf.each(this, function () {
        AXInput.bindInputDisabled(this.id, Disabled);
    });
    return this;
};
/* ---------------------------- */
var AXInputConverterPro = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();
		this.objects = [];
		this.inputTypes = [
			{type: "pattern", type: "tagSelector"}
		];
		this.config.anchorClassName = "AXanchor";
		this.config.anchorSelectorExpandBoxClassName = "AXanchorSelectorExpandBox";
		this.config.anchorSelectorExpandScrollClassName = "AXanchorSelectorExpandScroll"

		/* 모바일 반응 너비 */
		this.config.responsiveMobile = AXConfig.mobile.responsiveWidth;
	},
	init: function() {
		axdom(window).resize(this.alignAllAnchor.bind(this));

		// 예약어 초기화
		this.config.reserveKeys = {
			options: (AXConfig.AXInput && AXConfig.AXInput.keyOptions) || "options",
			optionValue: (AXConfig.AXInput && AXConfig.AXInput.keyOptionValue) || "optionValue",
			optionText: (AXConfig.AXInput && AXConfig.AXInput.keyOptionText) || "optionText"
		};
	},
	windowResize: function() {
		// 사용안함
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function() {
			windowResizeApply();
		}, 10);
	},
	windowResizeApply: function() {
		// 사용안함
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.alignAllAnchor();
	},
	alignAllAnchor: function() {
		for (var i = 0; i < this.objects.length; i++) {
			this.alignAnchor(this.objects[i].id, i);
		}
	},
	bindSetConfig: function(objID, configs) {
		var findIndex = null;
		axf.each(this.objects, function(index, O) {
			if (O.id == objID) {
				findIndex = index;
				return false;
			}
		});
		if (findIndex == null) {
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		}
		else {
			var _self = this.objects[findIndex];
			axf.each(configs, function(k, v) {
				_self.config[k] = v;
			});
		}
	},
	bind: function(obj) {
		var cfg = this.config;
		if (!AXgetId(obj.id)) {
			trace("bind 대상이 없어 bind 처리할 수 없습니다.");
			return;
		}

		var objID = obj.id;
		var objSeq = null;
		for (var index = 0; index < this.objects.length; index++) {
			if (this.objects[index].id == objID) {
				objSeq = index;
				break;
			}
		}

		if (obj.href == undefined) obj.href = cfg.href;

		if (objSeq == null) {
			objSeq = this.objects.length;
			this.objects.push({
				id: objID,
				anchorID: cfg.targetID + "_AX_" + objID,
				config: obj,
				bindType: obj.bindType
			});
		}
		else {
			this.objects[objSeq].isDel = undefined;
			this.objects[objSeq].config = obj;
		}

		if (obj.bindType != "checked") {
			this.appendAnchor(objID, objSeq, obj.bindType);
		}
		// bind checked 는 anchor연결 안함.

		if (obj.bindType == "null") {

		}
		else if (obj.bindType == "pattern") {
			this.bindPattern(objID, objSeq);
		}
		else if (obj.bindType == "tagSelector") {
			if (!this.objects[objSeq].config.reserveKeys) {
				this.objects[objSeq].config.reserveKeys = axdom.extend({}, this.config.reserveKeys);
			}
			this.bindTagSelector(objID, objSeq);
		}
	},
	unbind: function(obj) {
		var cfg = this.config;
		var removeAnchorId;
		var removeIdx;
		axf.each(this.objects, function(idx, O) {
			if (O.id != obj.id) {
				// collect.push(this);
			}
			else {
				if (O.isDel != true) {
					removeAnchorId = this.anchorID;
					removeIdx = idx;
				}
			}
		});

		if (removeAnchorId) {
			this.objects[removeIdx].isDel = true;
			axdom("#" + obj.id).removeAttr("data-axbind");
			axdom("#" + removeAnchorId).remove();
			var objID = obj.id;
			var obj = this.objects[removeIdx];
			if (obj.documentclickEvent) axdom(document).unbind("click.AXInput", obj.documentclickEvent);
			axdom("#" + objID).unbind("keydown.AXInput");
			axdom("#" + objID).unbind("keydown.AXInputCheck");

			axdom("#" + objID).unbind("change.AXInput");

			if (obj.bindSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindSliderMouseMove);
			if (obj.bindSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindSliderMouseUp);
			if (obj.bindSliderTouchMove) document.removeEventListener("touchmove.AXInput", obj.bindSliderTouchMove, false);
			if (obj.bindSliderTouchEnd) document.removeEventListener("touchend.AXInput", obj.bindSliderTouchEnd, false);
			if (obj.bindTwinSliderMouseMove) axdom(document.body).unbind("mousemove.AXInput", obj.bindTwinSliderMouseMove);
			if (obj.bindTwinSliderMouseUp) axdom(document.body).unbind("mouseup.AXInput", obj.bindTwinSliderMouseUp);

			if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_Handle").removeClass("on");
			}
		}
	},
	appendAnchor: function(objID, objSeq, bindType) {
		var cfg = this.config;
		var obj = this.objects[objSeq];
		//trace("appendAnchor");
		axdom("#" + cfg.targetID + "_AX_" + objID).remove();
		var anchorNode = axdom("<div id=\"" + cfg.targetID + "_AX_" + objID + "\" class=\"" + cfg.anchorClassName + "\" style=\"display:none;\"></div>");
		var iobj = axdom("#" + objID);
		iobj.attr("data-axbind", bindType);
		iobj.after(anchorNode);

		obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
		obj.bindTarget = iobj;

		//var offSetParent = iobj.offsetParent();
		var iobjPosition = iobj.position();
		var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

		var borderW = iobj.css("border-left-width").number();
		var borderH = iobj.css("border-top-width").number();
		var marginW = iobj.css("margin-left").number();
		var marginH = iobj.css("margin-top").number();
		l = l + marginW;
		/*t = t;*/
		w = iobj.outerWidth();
		h = iobj.outerHeight();

		var css = {left: l, top: t, width: w, height: 0};
		//trace(css);
		obj.bindAnchorTarget.css(css);
		obj.bindAnchorTarget.data("height", h);

		var _this = this;
		setTimeout(function() {
			_this.alignAnchor(objID, objSeq);
		}, 10);
	},
	alignAnchor: function(objID, objSeq) {
		var cfg = this.config;
		var obj = this.objects[objSeq];

		if (!AXgetId(objID)) return;
		/* 엘리먼트 존재 여부 확인 */

		if (obj.bindType == "tagSelector") {
			if (obj.tagList.length > 0) obj.bindTarget.css({"padding-top": obj.tagContainer.height()});
		}
		else {
			var iobjPosition = obj.bindTarget.position();
			var l = iobjPosition.left, t = iobjPosition.top;
			var w = obj.bindTarget.outerWidth();
			var h = obj.bindTarget.outerHeight();
			if (obj.bindTarget.css("display") == "none") {
				h = obj.bindAnchorTarget.data("height");
				var css = {width: w};
			}
			else {
				var css = {left: l, top: t, width: w, height: 0};
			}
			//trace(css);
			obj.bindAnchorTarget.css(css);
			obj.bindAnchorTarget.data("height", h);

			if (obj.bindType == "null") {

			}
			else if (obj.bindType == "pattern") {

			}
		}
	},

	// TODO : pattern명 정의
	/*
	 money, moneyint, date, datetime, bizno, phone, "USER String", [Function]
	 */
	// pattern
	bindPattern: function(objID, objSeq) {
		var obj = this.objects[objSeq], cfg = this.config, _this = this;
		if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
		if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);

		// TODO : 키 입력 제어 구문 시작점 (방법1)
		if (obj.config.pattern == "_custom") { // 커버 개체를 삽입하는 방식.. 실패..

			var h = obj.bindAnchorTarget.data("height");
			obj.bindAnchorTarget.css({"height": h});
			var po = [];
			var inputCoverClass = obj.bindTarget.attr("class");
			//trace();
			var inputCoverFont = obj.bindTarget.css("font-family");
			po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_inputCover\" " +
				"class=\"" + inputCoverClass + "\" " +
				"style=\"background:transparent;cursor:text;font-family:" + inputCoverFont + ";white-space:nowrap;\"" +
				"></div>");

			obj.bindAnchorTarget.append(po.join(''));
			obj.bindAnchorTarget.show();
			obj.bindTarget.css({color: obj.bindTarget.css("background-color")});

			obj.bindTargetCover = obj.bindAnchorTarget.find("#" + cfg.targetID + "_AX_" + objID + "_AX_inputCover");

			obj.bindTargetCover.bind("click", function() {
				obj.bindTarget.focus();
			});

			var val = obj.bindTarget.val().trim();
			if (val != "") {
				val = this.bindPatternGetValue(objID, objSeq, obj.bindTarget.val());
			}
			obj.bindTarget.val(val);

			obj.bindTarget.attr("onselectstart", "return false");
			obj.bindTarget.unbind("keypress.AXInput").bind("keypress.AXInput", function(event) {
				//obj.bindTargetCover.text(event.target.value);
			});
			obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function(event) {
				obj.bindTargetCover.html(_this.bindPatternGetValue(objID, objSeq, event.target.value) + "<div class='edit-input-cursor'>|</div>");
				//obj.bindTargetCover.val( _this.bindPatternGetValue(objID, objSeq, event.target.value) );
			});
			obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function(event) {
				obj.bindTargetCover.html(_this.bindPatternGetValue(objID, objSeq, event.target.value) + "<div class='edit-input-cursor'>|</div>");
				//obj.bindTargetCover.val( _this.bindPatternGetValue(objID, objSeq, event.target.value) );
			});
			obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function(event) {
				obj.bindTargetCover.find(".edit-input-cursor").remove();
			});

			return;
		}

		// TODO : 키 입력 제어 구문 시작점 (방법2)
		if (obj.config.pattern == "_custom") {

			// KEY_BACKSPACE: 8, KEY_TAB: 9, KEY_RETURN: 13, KEY_ESC: 27, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, KEY_DELETE: 46, KEY_HOME: 36, KEY_END: 35, KEY_PAGEUP: 33, KEY_PAGEDOWN: 34,
			// KEY_INSERT: 45, KEY_SPACE: 32

			obj.bindTarget.unbind("keypress.AXInput").bind("keypress.AXInput", function(event) {
				var elem = event.target;
				var elemFocusPosition, elemFocusEndPosition;
				if ('selectionStart' in elem) {
					// Standard-compliant browsers
					elemFocusPosition = elem.selectionStart;
					elemFocusEndPosition = elem.selectionEnd;
				}
				else if (document.selection) {
					// IE
					//elem.focus();
					var sel = document.selection.createRange();
					var selLen = document.selection.createRange().text.length;
					sel.moveStart('character', -elem.value.length);
					elemFocusPosition = sel.text.length - selLen;
					elemFocusEndPosition = elemFocusPosition + selLen;
				}
				obj.DSP = elemFocusPosition;
				obj.DEP = elemFocusEndPosition;

				//키 입력전 입력문자열;
				if (elem.value == "") {
					obj.originalValue = ""; // 오리지널 밸류 초기화
				}
				obj.prevValue = event.target.value;

				//trace("D" + obj.DEP);
			});

			obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function(event) {
				var elem = event.target;
				var elemFocusPosition;
				if ('selectionStart' in elem) {
					// Standard-compliant browsers
					elemFocusPosition = elem.selectionStart;
					elemFocusEndPosition = elem.selectionEnd;
				}
				else if (document.selection) {
					// IE
					//elem.focus();
					var sel = document.selection.createRange();
					var selLen = document.selection.createRange().text.length;
					sel.moveStart('character', -elem.value.length);
					elemFocusPosition = sel.text.length - selLen;
					elemFocusEndPosition = elemFocusPosition + selLen;
				}
				obj.USP = elemFocusPosition;
				obj.UEP = elemFocusEndPosition;

				var v1 = elem.value, v2 = obj.prevValue;
				var editText = v2.substring(obj.DSP, obj.DEP), editedText = v1.substring(obj.DEP, obj.UEP);
				//trace("U" + obj.UEP);

				// case 1 : 한글자씩 타이핑 하는 경우

				if (v1 != v2 && v1.length > v2.length) {
					// 추가입력
					if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP + 1 == obj.USP) {
						if (obj.USP == v1.length) {
							//trace("끝에서 한글자 타이핑");
							obj.originalValue += editedText;
						}
						else if (obj.USP < v1.length) {
							//trace("중간에서 한글자 타이핑");
							//var _v1 = obj.originalValue.split("");
							//var _v2 = editedText.split("");
							var _v2 = "";
							obj.originalValue = obj.originalValue.substring(0, obj.DEP) + editedText + obj.originalValue.substr(obj.DEP);
						}
						// 입력된 문자열의 위치에 패턴을 처리 합니다.

					}
					else {
						if (obj.USP == v1.length) {
							//trace("끝에서 다중문자 타이핑");
							obj.originalValue += editedText;
						}
						else if (obj.USP < v1.length) {
							trace("중간에서 다중문자 타이핑");
						}
					}
					/*
					 trace({
					 nvalue: v1,
					 prevValue: v2,
					 nowText: editText,
					 editedText: editedText,
					 originalValue: obj.originalValue,
					 eD:[obj.DSP, obj.DEP],
					 eU:[obj.USP, obj.UEP]
					 });
					 */
				}
				else if (v1 != v2 && v1.length < v2.length) {
					// 삭제 obj.originalValue의 삭제된 문자열 위치를 찾아 제거 합니다.

					if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP - 1 == obj.USP) {
						if (obj.USP == v1.length) {
							trace("끝에서 한글자 삭제");
						}
						else if (obj.USP < v1.length) {
							trace("중간에서 한글자 삭제");
						}
					}
					else {
						if (obj.USP == v1.length) {
							trace("끝에서 다중문자 삭제");
						}
						else if (obj.USP < v1.length) {
							trace("중간에서 다중문자 삭제");
						}
					}
				}
				else {
					// 커서이동
					if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP + 1 == obj.USP) {
						trace("커서 우로 이동");
					}
					else if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP == obj.USP + 1) {
						trace("커서 좌로 이동");
					}
					else if (obj.DSP == obj.DEP && obj.USP == obj.UEP && obj.DSP == obj.USP) {
						trace("제자리");
					}
				}
			});
			return;
		}
		// TODO : 키 입력 제어 구문 끝점 (방법2)

		var eventStop = function(event) {
			// 이벤트 중지 구문
			if (event.preventDefault) event.preventDefault();
			if (event.stopPropagation) event.stopPropagation();
			event.cancelBubble = true;
			return false;
			// 이벤트 중지 구문 끝
		};
		// 약속된 패턴 형식 구문
		var bindPatternCheck = this.bindPatternCheck.bind(this);
		var val = obj.bindTarget.val().trim();

		// 패턴 적용 값 구하기 함수를 통해 얻어진 val을 input value로 재 설정 합니다.
		if (val != "") {
			val = this.bindPatternGetValue(objID, objSeq, obj.bindTarget.val(), "blur");
		}
		// 패턴 구문에 따라 달라져야 하는 부분 ------------------------------

		obj.bindTarget.val(val);

		obj.bindTarget.unbind("focus.AXInput").bind("focus.AXInput", function(event) {
			if (obj.config.pattern == "custom") {
				if (typeof obj.originalValue === "undefined") obj.originalValue = event.target.value;
				event.target.value = _this.bindPatternGetValue(objID, objSeq, (obj.originalValue), "keyup");
			}
		});
		obj.bindTarget.unbind("keydown.AXInput").bind("keydown.AXInput", function(event) {
			if (
				event.which &&
				(
					event.which > 47 && event.which < 58 ||
					event.which > 36 && event.which < 41 ||
					event.which > 95 && event.which < 106 ||
					event.which == axf.Event.KEY_BACKSPACE ||
					event.which == axf.Event.KEY_TAB ||
					event.which == axf.Event.KEY_RETURN ||
					event.which == axf.Event.KEY_DELETE ||
					event.which == axf.Event.NUMPAD_SUBTRACT ||
					event.which == axf.Event.NUMPAD_DECIMAL ||
					event.which == axf.Event.KEY_MINUS ||
					event.which == axf.Event.KEY_EQUAL ||
					event.which == axf.Event.KEY_PERIOD ||
					event.which == axf.Event.KEY_HOME ||
					event.which == axf.Event.KEY_END
				)
			)
			{

				// 패턴에 따라 제어 소수점 허용안되는 경우 블락
				var isStop = false;

				if (event.which == 190 && (obj.config.pattern == "moneyint" || obj.config.pattern == "numberint")) {
					// 소수점 입력 막기
					isStop = true;
				}
				else if (event.which == axf.Event.KEY_MINUS || event.which == axf.Event.KEY_EQUAL || event.which == axf.Event.KEY_PERIOD) {
					if (
						(
							obj.config.pattern == "money" ||
							obj.config.pattern == "moneyint" ||
							obj.config.pattern == "number" ||
							obj.config.pattern == "numberint"
						) &&
						obj.config.allow_minus
					)
					{

					}
					else {
						isStop = true;
					}
				}
				else if (
					event.which == axf.Event.KEY_BACKSPACE ||
					event.which == axf.Event.KEY_TAB ||
					event.which == axf.Event.KEY_RETURN ||
					event.which == axf.Event.KEY_LEFT ||
					event.which == axf.Event.KEY_RIGHT ||
					event.which == axf.Event.KEY_DELETE ||
					event.which == axf.Event.KEY_HOME ||
					event.which == axf.Event.KEY_END)
				{ // 백스페이스, 탭, 리턴, 좌, 우, delete

					if (event.which == 13) {
						obj.bindTarget.trigger("blur");
					}
				}
				else {

					if (obj.config.pattern.left(8) == "datetime") {
						if (event.target.value.replace(/\D/g, "").length == 14) { // 초까지 입력되게 확장
							isStop = true;
						}
					}
					else if (obj.config.pattern.left(4) == "date") {
						if (event.target.value.replace(/\D/g, "").length == 8) {
							isStop = true;
						}
					}
					else if (obj.config.pattern == "bizno") {
						if (event.target.value.replace(/\D/g, "").length == 10) {
							isStop = true;
						}
					}
					else if (
						obj.config.pattern == "money" ||
						obj.config.pattern == "moneyint" ||
						obj.config.pattern == "number" ||
						obj.config.pattern == "numberint"
					)
					{
						// TODO : 숫자형 패턴에서 문자열의 길이 및, 소수점 자리수 제한 구현
						if (Object.isNumber(obj.config.max_length)) {

							if (event.target.value.replace(/\D/g, "").length >= obj.config.max_length) {
								isStop = true;
							}
						}
						if (!isStop && Object.isNumber(obj.config.max_round)) {
							var dotIndex = 0;
							if ((dotIndex = event.target.value.indexOf(".")) > -1) {
								if (event.target.value.substr(dotIndex + 1).length >= obj.config.max_round) {
									isStop = true;
								}
							}
						}
					}
					else if (Object.isNumber(obj.config.max_length)) {
						if (event.target.value.replace(/[^A-Za-z0-9]/g, "").length == obj.config.max_length.number()) {
							isStop = true;
						}
					}
				}

				if (isStop) eventStop(event);

			}
			else {
				if ((event.ctrlKey || event.metaKey)) {
					obj.bindTarget.data("ctrlKey", "T");
				}
				else {
					obj.bindTarget.data("ctrlKey", "F");

					//trace('block', event.which);
					eventStop(event);
				}
			}
		});
		obj.bindTarget.unbind("keyup.AXInput").bind("keyup.AXInput", function(event) {
			var elem = obj.bindTarget.get(0);
			var elemFocusPosition;
			if ('selectionStart' in elem) {
				// Standard-compliant browsers
				elemFocusPosition = elem.selectionStart;
			}
			else if (document.selection) {
				// IE
				//elem.focus();
				var sel = document.selection.createRange();
				var selLen = document.selection.createRange().text.length;
				sel.moveStart('character', -elem.value.length);
				elemFocusPosition = sel.text.length - selLen;
			}
			//trace(obj.bindTarget.val());

			// 계산된 포커스 위치
			obj.bindTarget.data("focusPosition", elemFocusPosition);
			obj.bindTarget.data("prevLen", elem.value.length);

			var event = window.event || event;
			// ignore tab & shift key 스킵 & ctrl
			if (!event.keyCode || event.keyCode == axf.Event.KEY_TAB || event.keyCode == 16 || event.keyCode == 17 ||
				event.which == axf.Event.KEY_HOME ||
				event.which == axf.Event.KEY_END) return;

			if ((obj.bindTarget.data("ctrlKey") == "T") && (event.keyCode == 65 || event.keyCode == 91)) return;
			if (event.keyCode != AXUtil.Event.KEY_DELETE && event.keyCode != AXUtil.Event.KEY_BACKSPACE && event.keyCode != AXUtil.Event.KEY_LEFT && event.keyCode != AXUtil.Event.KEY_RIGHT) {
				bindPatternCheck(objID, objSeq, "keyup");
			}
			else if (event.keyCode == AXUtil.Event.KEY_DELETE || event.keyCode == AXUtil.Event.KEY_BACKSPACE) {
				bindPatternCheck(objID, objSeq, "keyup");
			}
		});
		obj.bindTarget.unbind("change.AXInput").bind("change.AXInput", function(event) {
			//bindPatternCheck(objID, objSeq, "change");
		});
		obj.bindTarget.unbind("blur.AXInput").bind("blur.AXInput", function(event) {
			bindPatternCheck(objID, objSeq, "blur");
		});
	},
	bindPatternCheck: function(objID, objSeq, eventType) {
		var obj = this.objects[objSeq];
		var val, nval;
		// callback 함수 대소문자 지원
		if (!obj.config.onBlur) obj.config.onBlur = obj.config.onBlur;
		if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;

		if (eventType == "blur") {

			val = obj.bindTarget.val();
			//trace(val);
			nval = this.bindPatternGetValue(objID, objSeq, val, eventType);
			// 패턴 적용
			obj.bindTarget.val(nval);
			if (val != nval) obj.bindTarget.trigger("change");

			if (Object.isFunction(obj.config.onBlur)) {
				obj.config.onBlur.call({objID: objID, objSeq: objSeq, value: nval});
			}

		}
		else {

			val = obj.bindTarget.val();
			nval = this.bindPatternGetValue(objID, objSeq, val, eventType);
			// 패턴 적용
			obj.bindTarget.val(nval);
			if (val != nval) obj.bindTarget.trigger("change");

			if (!axf.isEmpty(obj.bindTarget.data("focusPosition"))) {
				obj.bindTarget.setCaret(
					obj.bindTarget.data("focusPosition").number() + ( obj.bindTarget.val().length - obj.bindTarget.data("prevLen") )
				);
			}
			if (Object.isFunction(obj.config.onChange)) {
				obj.config.onChange.call({objID: objID, objSeq: objSeq, value: nval});
			}

		}
	},
	bindPatternGetValue: function(objID, objSeq, val, eventType) {
		var obj = this.objects[objSeq];
		var regExpPattern, returnValue = "";

		var getFormatterDate = function(_val, _pattern, ynm, mnd, dnt, tnt) {
			var returnValue = "";
			if (_val == "") {

			}
			else if (eventType == "blur") { // 타이핑 완료
				var nDate = new Date(), needAlert = false;
				if (_val.length > 7) {
					var yy = _val.left(4).number();
					var mm = _val.substr(4, 2).number() - 1;
					var dd = _val.substr(6, 2).number();
				}
				else if (_val.length > 4) {
					var yy = "20" + _val.substr(0, 2);
					var mm = _val.substr(2, 2).number() - 1;
					var dd = _val.substr(4, 2).number();
				}
				else if (_val.length > 2) {
					var yy = nDate.getFullYear();
					var mm = _val.substr(0, 2).number() - 1;
					var dd = _val.substr(2, 2).number();
				}
				else {
					var yy = nDate.getFullYear(); //va.left(4).number();
					var mm = nDate.getMonth();
					var dd = _val.substr(0, 2).number();
				}
				if (yy == 0) needAlert = true;
				if (yy == 0) yy = nDate.getFullYear();
				if (yy < 1000) yy += 2000;
				nDate = new Date(yy, mm, dd, 12);

				if (nDate.getFullYear() != yy.number()
					|| nDate.getMonth() != mm.number()
					|| nDate.getDate() != dd.number())
				{
					needAlert = true;
					nDate = new Date();
				}

				printDate = nDate.print("yyyy" + ynm + "mm" + mnd + "dd");

				if (dnt != " ") {
					printDate += dnt;
				}

				if (_pattern.left(8) == "datetime") {
					if (dnt == " ") printDate += dnt;
					var hh, mm, ss = null;
					if (_val.length > 11) { // hh,mm
						hh = _val.substr(8, 2).number().setDigit(2);
						mm = _val.substr(10, 2).number().setDigit(2);
						ss = _val.substr(12, 2).number().setDigit(2);
					}
					else if (_val.length > 8) {
						hh = _val.substr(8, 2).number().setDigit(2);
						mm = "00";
					}
					else {
						hh = "12";
						mm = "00";
					}
					printDate += hh + tnt + mm + (function() {
							if (ss != null) {
								return tnt + ss;
							}
						})();
				}

				if (needAlert) {
					//alert("날짜 형식이 올바르지 않습니다.");
				}
				returnValue = printDate;

			}
			else { // 타이핑 중
				if (_val.length < 5) {
					returnValue = _val;
				}
				else if (_val.length < 7) {
					returnValue = _val.substr(0, 4) + ynm + _val.substr(4);
				}
				else if (_val.length < 9) {
					returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2);
					if (dnt != " ") {
						returnValue += dnt;
					}
				}
				else if (_val.length < 11 && _pattern.left(8) == "datetime") {
					returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2) + dnt + _val.substr(8, 2);
				}
				else {
					if (_pattern.left(8) == "datetime") {
						returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2) + dnt + _val.substr(8, 2) + tnt + _val.substr(10, 2) + (function() {
								if (_val.substr(12, 2) != "") {
									return tnt + _val.substr(12, 2);
								}
								else {
									return "";
								}
							})();
					}
					else {
						returnValue = _val.substr(0, 4) + ynm + _val.substr(4, 2) + mnd + _val.substr(6, 2);
					}
				}
			}
			return returnValue;
		};
		var getNumberApplyConfig = function(_val, valType) {
			if (valType == "float") {
				if (Object.isNumber(obj.config.max_round)) {
					var dotIndex = 0;
					if ((dotIndex = _val.indexOf(".")) > -1) {
						_val = _val.substring(0, dotIndex + 1) +
							_val.substr(dotIndex + 1).replace(/\D/g, "").left(obj.config.max_round);
					}
				}
			}
			var __val = _val.replace(/\D/g, "");
			if (Object.isNumber(obj.config.max_length)) {
				if (__val.length > obj.config.max_length) {
					if (obj.config.allow_minus && val.left(1) == "-") {
						_val = "-" + __val.left(obj.config.max_length);
					}
					else {
						_val = __val.left(obj.config.max_length);
					}
				}
			}
			__val = null;
			return _val;
		};
		var getFormatterTime = function(_val, _pattern, tnt) {
			var returnValue = "";
			if (_val == "") {

			}
			else if (eventType == "blur") { // 타이핑 완료
				var nDate = new Date(), needAlert = false;
				if (_val.length > 2) {
					var hh = _val.substr(0, 2).number();
					var mi = _val.substr(2, 2).number();
				}
				else if (_val.length > 0) {
					var hh = _val.substr(0, 2).number();
					var mi = 0;
				}
				else {
					var hh = 0;
					var mi = 0;
				}

				if (hh > 23) hh = 23;
				if (mi > 59) mi = 59;

				returnValue = hh.setDigit(2) + tnt + mi.setDigit(2);
			}
			else { // 타이핑 중
				if (_val.length < 3) {
					returnValue = _val;
				}
				else {
					returnValue = _val.substr(0, 2) + tnt + _val.substr(2, 2);
				}
			}
			return returnValue;
		};

		if (
			obj.config.pattern == "money" ||
			obj.config.pattern == "moneyint" ||
			obj.config.pattern == "number" ||
			obj.config.pattern == "numberint"
		)
		{

			if (obj.config.pattern == "moneyint") { // 소수점 포함안함
				//val = val.replace(/[\D,]/g, "");
				val = val.replace(/[^0-9^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "int");
				}

				if (val == "") {
					returnValue = "";
				}
				else {
					returnValue = Math.ceil(val).money();
				}
			}
			else if (obj.config.pattern == "money") { // 소수점 포함
				//val = val.replace(/[^0-9^\.]/g, "");
				val = val.replace(/[^0-9^\.^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "float");
				}

				regExpPattern = new RegExp('([0-9])([0-9][0-9][0-9][,.])');

				var arrNumber = val.split('.');
				arrNumber[0] += '.';

				do {
					arrNumber[0] = arrNumber[0].replace(regExpPattern, '$1,$2');
				} while (regExpPattern.test(arrNumber[0]));
				if (arrNumber.length > 1) {
					if (Object.isNumber(obj.config.max_round)) {
						returnValue = arrNumber[0] + arrNumber[1].left(obj.config.max_round);
					}
					else {
						returnValue = arrNumber.join('');
					}
				}
				else {
					returnValue = arrNumber[0].split('.')[0];
				}
				if (eventType == "blur") {
					if (returnValue.right(1) == ".") returnValue = returnValue.replace(/\./g, "");
				}
			}
			else if (obj.config.pattern == "numberint") { // 통화표시 없이 숫자 형태로 입력
				//val = val.replace(/[\D]/g, "");
				val = val.replace(/[^0-9^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "int");
				}

				if (val == "") {
					returnValue = "";
				}
				else {
					returnValue = Math.ceil(val);
				}
			}
			else if (obj.config.pattern == "number") { // 통화표시 없이 숫자 형태로 입력
				//val = val.replace(/[^0-9^\.]/g, "");
				val = val.replace(/[^0-9^\.^\-]/g, "");

				if (eventType == "blur") {
					val = getNumberApplyConfig(val, "float");
				}

				var arrNumber = val.split('.');
				arrNumber[0] += '.';
				if (arrNumber.length > 1) {
					if (Object.isNumber(obj.config.max_round)) {
						returnValue = arrNumber[0] + arrNumber[1].left(obj.config.max_round);
					}
					else {
						returnValue = arrNumber.join('');
					}
				}
				else {
					returnValue = arrNumber[0].split('.')[0];
				}
				if (eventType == "blur") {
					if (returnValue.right(1) == ".") returnValue = returnValue.replace(/\./g, "");
				}
			}
			if (obj.config.allow_minus) {
				// 첫번째 문자열을 제외하고
				returnValue = returnValue.toString().substring(0, 1) + returnValue.toString().substr(1).replace(/\-/g, "");
			}
			else {
				returnValue = returnValue.toString().replace(/\-/g, "");
			}
		}
		else if (obj.config.pattern == "bizno") {
			val = val.replace(/\D/g, "");
			regExpPattern = /^([0-9]{3})\-?([0-9]{1,2})?\-?([0-9]{1,5})?.*$/;
			returnValue = val.replace(regExpPattern, function(a, b) {
				var nval = [arguments[1]];
				if (arguments[2]) nval.push(arguments[2]);
				if (arguments[3]) nval.push(arguments[3]);
				return nval.join("-");
			});
		}
		else if (obj.config.pattern == "phone") {

			val = val.replace(/\D/g, "");
			regExpPattern = /^(010|011|016|017|018|019)(\d+)*$/;
			var regExpPattern2 = /^(070|080|060|050|02|031|032|033|041|042|043|051|052|053|054|055|061|062|063|064)(\d+)*$/;

			if (regExpPattern.test(val)) { // 휴대전화일 경우
				returnValue = val.replace(regExpPattern, function(a, b) {
					var nval = [arguments[1]];
					if (arguments[2]) {
						if (arguments[2].length < 4) {
							nval.push(arguments[2]);
						}
						else if (arguments[2].length < 8) {
							nval.push(arguments[2].substring(0, 3) + "-" + arguments[2].substr(3));
						}
						else if (arguments[2].length > 8) {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4) + ", " + arguments[2].substr(8));
						}
						else {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4));
						}
					}
					return nval.join("-");
				});
			}
			else if (regExpPattern2.test(val)) { // 일반전화일 경우
				returnValue = val.replace(regExpPattern2, function(a, b) {
					var nval = [arguments[1]];
					if (arguments[2]) {
						if (arguments[2].length < 4) {
							nval.push(arguments[2]);
						}
						else if (arguments[2].length < 8) {
							nval.push(arguments[2].substring(0, 3) + "-" + arguments[2].substr(3));
						}
						else if (arguments[2].length > 8) {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4) + ", " + arguments[2].substr(8));
						}
						else {
							nval.push(arguments[2].substring(0, 4) + "-" + arguments[2].substr(4, 4));
						}
					}
					return nval.join("-");
				});
			}
			else { // 확인안됨.
				var regExpPattern3 = /^([0-9]{3})\-?([0-9]{1,4})?\-?([0-9]{1,4})?\-?([0-9]{1,4})?\-?([0-9]{1,4})?/;
				returnValue = val.replace(regExpPattern3, function(a, b) {
					var nval = [arguments[1]];
					if (arguments[2]) nval.push(arguments[2]);
					if (arguments[3]) nval.push(arguments[3]);
					if (arguments[4]) nval.push(arguments[4]);
					if (arguments[5]) nval.push(arguments[5]);
					return nval.join("-");
				});
			}

		}
		else if (obj.config.pattern == "date") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "-", "-", " ", ":");
		}
		else if (obj.config.pattern == "date(/)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "/", "/", " ", ":");
		}
		else if (obj.config.pattern == "date(년월일)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "년", "월", "일", ":");
		}
		else if (obj.config.pattern == "datetime") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "-", "-", " ", ":");
		}
		else if (obj.config.pattern == "datetime(/)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "/", "/", " ", ":");
		}
		else if (obj.config.pattern == "datetime(년월일)") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterDate(val, obj.config.pattern, "년", "월", "일", "시");
		}
		else if (obj.config.pattern == "time") {
			val = val.replace(/\D/g, "");
			returnValue = getFormatterTime(val, obj.config.pattern, ":");
		}
		else if (obj.config.pattern == "custom") {
			// Z, 9, X
			val = val.replace(/[^0-9^a-z^A-Z]/g, "");
			var ess = val.split("");
			//trace(ess);
			var pss = obj.config.patternString.split("");

			if (eventType == "blur") {
				obj.originalValue = val; // 암호화 되기 전 문자열 저장
				//trace(val);
			}

			var newText = "";
			// TODO : 패턴 문자열의 인덱스와 원본 문자열 인덱스 분리
			// TODO : 포커스 되면 암호화된 문자열 원래 문자열로 변환, 블러되면 문자열 암호화 하고 originalValue 에 저장 -> 나중에 getText 에 이용
			var eidx = 0, pidx = 0;
			while (ess[eidx]) {
				if (pss[pidx] == "9") {
					newText += ess[eidx].number();
					pidx++;
					eidx++;
				}
				else if (pss[pidx] == "Z") {
					if (ess[eidx] > 0) {
						newText += ess[eidx];
					}
					else {
						newText += "1";
					}
					pidx++;
					eidx++;
				}
				else if (pss[pidx] == "X") {
					if (eventType == "blur") {
						newText += "*";
					}
					else {
						newText += ess[eidx];
					}
					pidx++;
					eidx++;
				}
				else if (typeof pss[pidx] != "undefined") {
					newText += pss[pidx];
					pidx++;
				}
				else {
					newText += ess[eidx];
					eidx++;
				}
			}
			/*
			 for(var eidx = 0;eidx<ess.length;eidx++){

			 }
			 */
			return newText;

		}
		else if (Object.isFunction(obj.config.pattern)) {
			returnValue = obj.config.pattern.call({val: val, objID: objID, config: obj.config}, val);
		}
		else {
			returnValue = val;
		}

		return returnValue;
	},
	bindPatternGetText: function(objID, objSeq) {

		if (!Object.isNumber(objSeq)) {
			/*
			 axf.each(this.objects, function (index, O) {
			 if (O.id == objID) {
			 objSeq = index;
			 return false;
			 }
			 });
			 */
			for (var index = 0; index < this.objects.length; index++) {
				if (this.objects[index].id == objID) {
					objSeq = index;
					break;
				}
			}
		}
		if (!Object.isNumber(objSeq)) return;
		var obj = this.objects[objSeq], val = obj.bindTarget.val();

		var regExpPattern, returnValue = "";
		if (obj.config.pattern == "moneyint") { // 소수점 포함안함
			returnValue = val.replace(/[\D]/g, "");
		}
		else if (obj.config.pattern == "money") { // 소수점 포함
			returnValue = (val == "") ? "" : val.number();
		}
		else if (obj.config.pattern == "bizno") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "phone") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "date" || obj.config.pattern == "date(/)" || obj.config.pattern == "date(년월일)") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "datetime" || obj.config.pattern == "datetime(/)" || obj.config.pattern == "datetime(년월일)") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "time") {
			returnValue = val.replace(/\D/g, "");
		}
		else if (obj.config.pattern == "custom") {
			returnValue = obj.originalValue;
		}
		else if (Object.isFunction(obj.config.depattern)) {
			returnValue = obj.config.depattern.call({val: val, objID: objID, config: obj.config}, val);
		}
		else {
			returnValue = val;
		}

		return returnValue;
	},
	bindPatternGetDisplayText: function(objID, objSeq) {

		if (!Object.isNumber(objSeq)) {
			/*
			 axf.each(this.objects, function (index, O) {
			 if (O.id == objID) {
			 objSeq = index;
			 return false;
			 }
			 });
			 */
			for (var index = 0; index < this.objects.length; index++) {
				if (this.objects[index].id == objID) {
					objSeq = index;
					break;
				}
			}
		}
		if (!Object.isNumber(objSeq)) return;
		var obj = this.objects[objSeq], val = obj.bindTarget.val();

		var regExpPattern, returnValue = "";
		if (Object.isFunction(obj.config.depattern)) {
			returnValue = obj.config.depattern.call({val: val, objID: objID, config: obj.config}, val);
		}
		else {
			returnValue = val;
		}

		return returnValue;
	},
	bindPatternSetText: function(objID, objSeq, val) {
		if (!Object.isNumber(objSeq)) {
			/*
			 axf.each(this.objects, function (index, O) {
			 if (O.id == objID) {
			 objSeq = index;
			 return false;
			 }
			 });
			 */
			for (var index = 0; index < this.objects.length; index++) {
				if (this.objects[index].id == objID) {
					objSeq = index;
					break;
				}
			}
		}
		if (!Object.isNumber(objSeq)) return;
		var obj = this.objects[objSeq];
		obj.bindTarget.val(this.bindPatternGetValue(objID, objSeq, val, "blur"));
		obj.bindTarget.trigger("change");
	},

	/**
	 * bindTagSelector
	 */
	bindTagSelector: function(objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po, h;

		if (!obj.config.onchange) obj.config.onchange = obj.config.onChange;
		if (!obj.bindAnchorTarget) obj.bindAnchorTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
		if (!obj.bindTarget) obj.bindTarget = axdom("#" + objID);
		if (!obj.bindTarget_paddingTop) obj.bindTarget_paddingTop = obj.bindTarget.css("padding-top");

		obj.bindTarget.css({"box-sizing": "content-box", "padding": obj.bindTarget_paddingTop});

		// 저장된 태그 리스트
		obj.tagList = [];
		obj.deletedTagList = [];

		obj.bindAnchorTarget.show();
		h = obj.bindAnchorTarget.data("height") - 2;

		po = [];
		po.push('<div id="' + cfg.targetID + '_AX_' + objID + '_AX_tagContainer" class="AXTag-selector-tagcontainer">');
		po.push('</div>');
		obj.bindAnchorTarget.html(po.join(''));
		obj.tagContainer = obj.bindAnchorTarget.find('#' + cfg.targetID + '_AX_' + objID + '_AX_tagContainer');

		// 태그 컨테이너 클릭 이벤트 연결

		obj.tagContainer.bind("click", (function(e) {
			var event_type = "";
			e = e || window.event;
			var target = axf.get_event_target(e.target, function(el) {
				if (axdom(el).hasClass("AXTag-selector-tagitem-remove")) {
					event_type = "remove";
					return true;
				}
				else if (axdom(el).hasClass("AXTag-selector-tagitem")) {
					event_type = "item";
					return true;
				}
			});

			if (target && event_type == "remove") {
				this.bindTagSelector_removeItem(objID, objSeq, axdom(target).attr("data-tag-index"));
			}
			else if (!target) obj.bindTarget.focus();

		}).bind(this));

		// 옵션 박스 패널
		obj.tagExpandBoxId = cfg.targetID + "_AX_" + objID + "_AX_expandBox";

		obj.bindTarget.unbind("focus.AXTagSelector").bind("focus.AXTagSelector", function(event) {
			if (obj.keydownTimer) clearTimeout(obj.keydownTimer);
			obj.keydownTimer = setTimeout((function(event) {
				if (event.target.value != "") _this.bindTagSelector_onkeydown(event, objID, objSeq);
			}).bind(_this, event), 100);
		});
		obj.bindTarget.unbind("keydown.AXTagSelector").bind("keydown.AXTagSelector", function(event) {
			if (obj.bindAnchorTarget.attr("disable") == "disable" || obj.bindTarget.attr("disable") == "disable") return false;

			if (obj.keydownTimer) clearTimeout(obj.keydownTimer);
			obj.keydownTimer = setTimeout((function(event) {
				_this.bindTagSelector_onkeydown(event, objID, objSeq);
			}).bind(_this, event), 100);
		});
	},
	bindTagSelector_onkeydown: function(e, objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po,
			anchorWidth, anchorHeight, styles, focusedIndex;

		if (e.type == "keydown") {
			if (e.target.value == "" && e.keyCode == axf.Event.KEY_BACKSPACE) {
				if (obj.tagList.length > 0) {
					if (obj.ready_backspace) {
						this.bindTagSelector_removeItem(objID, objSeq, obj.tagList.length - 1);
						this.bindTagSelector_close(objID, objSeq);
						obj.config.focusedIndex = undefined;
						delete obj.ready_backspace;
					}
					else {
						obj.ready_backspace = true;
					}
				}
				return this;
			}
			else {
				delete obj.ready_backspace;
			}

			if (
				e.keyCode == axf.Event.KEY_RETURN ||
				e.keyCode == axf.Event.KEY_DOWN ||
				e.keyCode == axf.Event.KEY_UP
			)
			{
				if (!AXgetId(obj.tagExpandBoxId)) return this;
				if (e.keyCode == axf.Event.KEY_RETURN) {
					if (typeof obj.config.focusedIndex !== "undefined") {
						this.bindTagSelector_addItem(objID, objSeq, obj.config.focusedIndex);
						this.bindTagSelector_close(objID, objSeq);
						obj.config.focusedIndex = undefined;
					}
				}
				else if (e.keyCode == axf.Event.KEY_DOWN) {
					focusedIndex = 0;
					if (typeof obj.config.focusedIndex !== "undefined") {
						axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
						focusedIndex = Number(obj.config.focusedIndex) + 1;
						if (obj.config.options.length <= focusedIndex) focusedIndex = obj.config.options.length - 1;
					}
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option").addClass("on");
					obj.config.focusedIndex = focusedIndex;
					obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option"); //focus
				}
				else if (e.keyCode == axf.Event.KEY_UP) {
					focusedIndex = 0;
					if (typeof obj.config.focusedIndex !== "undefined") {
						axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
						focusedIndex = Number(obj.config.focusedIndex) - 1;
						if (0 > focusedIndex) focusedIndex = 0;
					}
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option").addClass("on");
					obj.config.focusedIndex = focusedIndex;
					obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + focusedIndex + "_AX_option"); //focus
				}
				return this;
			}
		}

		//console.log(e);
		if (!AXgetId(obj.tagExpandBoxId)) {
			//Expand Box 생성 구문 작성
			anchorWidth = obj.bindAnchorTarget.width() - 2; // anchor width
			anchorHeight = obj.bindAnchorTarget.data("height") - 1;
			styles = [];

			styles.push("top:" + anchorHeight + "px");
			styles.push("width:" + (obj.config.selectorWidth || anchorWidth) + "px");
			styles.push("z-index:10000");

			po = [];
			po.push("<div id=\"" + obj.tagExpandBoxId + "\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandBoxClassName + "\" style=\"" + styles.join(";") + "\">");
			po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll\" class=\"bindSelectorNodes " + cfg.anchorSelectorExpandScrollClassName + "\">");
			po.push("	<div class=\"AXLoadingSmall bindSelectorNodes\"></div>");
			po.push("</div>");
			po.push("</div>");
			axdom(document.body).append(po.join(''));

			obj.tagExpandBox = axdom("#" + obj.tagExpandBoxId);
			obj.tagExpandBoxScroll = obj.tagExpandBox.find("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll");
			if (obj.config.positionFixed) {
				obj.tagExpandBox.css({"position": "fixed"});
			}
			var expBoxHeight = obj.tagExpandBox.outerHeight();
			var offset = (obj.config.positionFixed) ? obj.bindAnchorTarget.position() : obj.bindAnchorTarget.offset();
			if (obj.config.position) {
				offset = obj.bindAnchorTarget.offset();
				if (obj.config.position.top != undefined) {
					offset.top = obj.config.position.top;
				}
			}
			var css = {};
			css.top = offset.top + anchorHeight;
			if (obj.config.direction == "bottom") {
				css.top -= obj.tagExpandBox.outerHeight();
			}

			css.left = offset.left;
			obj.tagExpandBox.css(css);

			// 다른 영역을 클릭했는가?
			axdom(document.body).unbind("click.AXTagSelector").bind("click.AXTagSelector", (function(e) {
				if (obj.blurTimer) clearTimeout(obj.blurTimer);
				obj.blurTimer = setTimeout(function() {
					_this.bindTagSelector_onclick(e || window.event, objID, objSeq);
				}, 100);
			}).bind(this));
			obj.bindTarget.unbind("blur.AXTagSelector").bind("blur.AXTagSelector", (function(e) {
				if (obj.blurTimer) clearTimeout(obj.blurTimer);
				obj.blurTimer = setTimeout(function() {
					_this.bindTagSelector_onclick(e || window.event, objID, objSeq);
				}, 700);
			}).bind(this));
		}
		this.bindTagSelector_setOptions(objID, objSeq, obj.bindTarget.val());
	},
	bindTagSelector_setOptions: function(objID, objSeq, kword) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po,
			maxHeight = obj.config.maxHeight || 130,
			next_fn;

		obj.deletedTagList = [];
		next_fn = function() {
			if (po.length == 0) {
				var selectorOptionEmpty = "";
				if (AXConfig.AXInput) selectorOptionEmpty = (AXConfig.AXInput.selectorOptionEmpty || "empty options");
				po.push("<div class=\"empty\">" + selectorOptionEmpty + "</div>");
			}
			obj.tagExpandBoxScroll.html(po.join(''));

			var expandScrollHeight = obj.tagExpandBoxScroll.outerHeight();
			if (expandScrollHeight > maxHeight) expandScrollHeight = maxHeight;
			obj.tagExpandBox.css({height: expandScrollHeight + "px"});

			if (obj.myUIScroll) obj.myUIScroll.unbind();
			obj.myUIScroll = new AXScroll();
			obj.myUIScroll.setConfig({
				CT_className: "AXScrollSmall",
				targetID: cfg.targetID + "_AX_" + objID + "_AX_expandBox",
				scrollID: cfg.targetID + "_AX_" + objID + "_AX_expandScroll",
				touchDirection: false
			});
			obj.myUIScroll.scrollTop(0);

			if (obj.config.selectedIndex != undefined) {
				axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option").addClass("on");
				obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.selectedIndex + "_AX_option"); //focus
				obj.config.focusedIndex = obj.config.selectedIndex;
			}

			if (obj.config.direction == "bottom") {
				var offset = (obj.config.positionFixed) ? obj.bindAnchorTarget.position() : obj.bindAnchorTarget.offset();
				if (obj.config.position) {
					offset = obj.bindAnchorTarget.offset();
					if (obj.config.position.top != undefined) {
						offset.top = obj.config.position.top;
					}
				}
				obj.tagExpandBox.css({top: offset.top - obj.tagExpandBox.outerHeight()});
			}

			// focus item
			if (typeof kword !== "undefined" && kword != "") {
				kword = kword.replace(/\//g, "\\\/");
				var sw = axf.consonantKR((kword || "").dec());
				var reAt = new RegExp("^" + sw + ".*", "i");

				var ix = null;
				for (var i = 0, l = obj.config.options.length; i < l; i++) {
					if (reAt.test((obj.config.options[i][obj.config.reserveKeys.optionText] || ""))) {
						ix = i;
						break;
					}
				}
				if (ix != null) {
					if (typeof obj.config.focusedIndex !== "undefined") {
						axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
					}
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + ix + "_AX_option").addClass("on");
					obj.config.focusedIndex = ix;
					obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + ix + "_AX_option"); //focus
				}
			}
			else {
				if (obj.config.focusedIndex != undefined) {
					axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
				}
			}
		};

		var get_options = function(options) {
			var npo = [];
			for (var i = 0, l = options.length; i < l; i++) {
				var O = options[i];
				// options의 optionText, optionDesc의 참조값을 디코딩해서 디코딩은 한 번만 사용하도록 변경
				O[obj.config.reserveKeys.optionText] = (O[obj.config.reserveKeys.optionText] ? O[obj.config.reserveKeys.optionText].dec() : "");
				O.desc = (O.desc ? O.desc.dec() : "");
				O.optionDesc = (O.optionDesc ? O.optionDesc.dec() : "");

				var descStr = O.desc || O.optionDesc, styles;
				if (descStr != "") descStr = "<span>" + descStr + "</span>";

				styles = "";
				for (var ti = 0, tl = obj.tagList.length, tag; ti < tl; ti++) {
					tag = obj.tagList[ti];
					//trace(tag[obj.config.reserveKeys.optionValue] == O[obj.config.reserveKeys.optionValue]);
					if (tag[obj.config.reserveKeys.optionValue] == O[obj.config.reserveKeys.optionValue]) {
						styles = ' style="text-decoration: line-through;"';
					}
				}
				npo.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_" + i + "_AX_option\" class=\"bindSelectorNodes\" " + styles + ">"
					+ O[obj.config.reserveKeys.optionText] + descStr + "</a>");
			}
			return npo;
		};

		if (obj.config.ajaxUrl && kword != "") {

			obj.inProgress = true; //진행중 상태 변경
			var url = obj.config.ajaxUrl;
			var pars = obj.config.ajaxPars || {};
			var _method = "post";
			var _headers = {};
			var _contentType = AXConfig.AXReq.contentType;
			var _responseType = AXConfig.AXReq.responseType;
			var _dataType = AXConfig.AXReq.dataType;
			var _async = AXConfig.AXReq.async;

			// ajax 옵션 확장
			if (obj.config.method) _method = obj.config.method;
			if (obj.config.headers) _headers = obj.config.headers;
			if (obj.config.contentType) _contentType = obj.config.contentType;
			if (obj.config.responseType) _responseType = obj.config.responseType;
			if (obj.config.dataType) _dataType = obj.config.dataType;
			if (obj.config.ajaxAsync) _async = obj.config.ajaxAsync;

			var selectorName = obj.config.selectorName || obj.bindTarget.attr("name");
			if (pars == "") {
				pars = selectorName + "=" + (kword || "").enc();
			}
			else if ((typeof pars).toLowerCase() == "string") {
				pars += "&" + selectorName + "=" + kword.enc();
			}
			else if ((typeof pars).toLowerCase() == "object") {
				pars[selectorName] = kword.enc();
			}

			new AXReq(url, {
				type: _method,
				headers: _headers,
				contentType: _contentType,
				responseType: _responseType,
				dataType: _dataType,
				async: _async,
				debug: ((typeof obj.config.debug !== "undefined") ? obj.config.debug : false),
				pars: pars,
				onsucc: function(res) {

					if (!res.error) {

						obj.config.options = (res[obj.config.reserveKeys.options] || []);
						obj.config.focusedIndex = undefined;
						po = get_options(obj.config.options);
						next_fn.call(_this);

					}
					else {
						axf.alert(res.error);
					}
					obj.inProgress = false;
				}
			});

		}
		else if (obj.config.onsearch) {
			var res = obj.config.onsearch.call(
				{
					id: objID,
					value: kword
				},
				objID,
				kword,
				(function(res) {
					obj.config.options = res;
					obj.config.focusedIndex = undefined;
					po = get_options(obj.config.options);
					next_fn.call(_this);
				}).bind(this)
			);
		}
		else {
			//var optionPrintLength = obj.config.optionPrintLength || 100;
			if (!obj.config.options) {
				console.log("config.options is not defined");
				return this;
			}

			po = get_options(obj.config.options);

			//  옵션리스트 구성완료 후 처리
			next_fn.call(this);
		}
	},
	bindTagSelector_onclick: function(e, objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq];

		if (e.type == "blur") {
			this.bindTagSelector_close(objID, objSeq);
		}
		else if (e.type == "click") {
			var click_type = "";
			var target = axf.get_event_target(e.target, function(el) {
				if (axdom(el).hasClass("bindSelectorNodes")) {
					click_type = "option";
					return true;
				}
				else if (el.id == objID) {
					click_type = "input";
					return true;
				}
			});

			if (target) {
				//console.log(target, click_type);
				if (click_type == "option") {
					// get option index
					var ids = target.id.split(/_AX_/g);
					var optionIndex = ids[ids.length - 2];
					this.bindTagSelector_addItem(objID, objSeq, optionIndex);
					this.bindTagSelector_close(objID, objSeq);
				}
				else if (click_type == "input") {
					// 입풋을 누르다니..
				}
			}
			else {
				this.bindTagSelector_close(objID, objSeq);
			}
		}
		//trace(e.type);
		//trace(objID, objSeq);
	},
	bindTagSelector_close: function(objID, objSeq) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq];

		if (obj.tagExpandBox) obj.tagExpandBox.remove();
		axdom(document.body).unbind("click.AXTagSelector");
		obj.bindTarget.unbind("blur.AXTagSelector");
	},
	bindTagSelector_addItem: function(objID, objSeq, optionIndex) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], objName, po, addOption, pass_add;

		if (isNaN(Number(optionIndex))) {
			console.log("optionIndex is NaN");
			return this;
		}

		//obj.tagList 태그저장리스트
		addOption = obj.config.options[optionIndex];
		pass_add = true; // 등록 허용
		for (var i = 0, l = obj.tagList.length, tag; i < l; i++) {
			tag = obj.tagList[i];
			if (tag[obj.config.reserveKeys.optionValue] == addOption[obj.config.reserveKeys.optionValue]) {
				pass_add = false; // 이미 등록된 값이 존재함.
				break;
			}
		}
		if (pass_add) {
			objName = obj.bindTarget.attr("name");
			po = [];
			if (!obj.config.optionValue_inputName) obj.config.optionValue_inputName = objName;
			po.push('<span class="AXTag-selector-tagitem" data-option-value="' + addOption[obj.config.reserveKeys.optionValue] + '">');
			if (obj.config.optionValue_inputName) po.push('<input type="hidden" name="' + obj.config.optionValue_inputName + '" value="' + addOption[obj.config.reserveKeys.optionValue] + '" />');
			if (obj.config.optionText_inputName) po.push('<input type="hidden" name="' + obj.config.optionText_inputName + '" value="' + addOption[obj.config.reserveKeys.optionText] + '" />');

			po.push(addOption[obj.config.reserveKeys.optionText]);
			po.push('<span class="AXTag-selector-tagitem-remove" data-tag-index="' + obj.tagList.length + '"></span>');
			po.push('</span>');
			obj.tagContainer.append(po.join(''));
			obj.tagList.push(addOption);
			//
			obj.bindTarget.css({"padding-top": obj.tagContainer.height()}).val('');
			obj.bindAnchorTarget.data("height", obj.bindTarget.outerHeight());
			axdom(window).resize();
		}
	},
	bindTagSelector_removeItem: function(objID, objSeq, tagIndex) {
		var _this = this, cfg = this.config,
			obj = this.objects[objSeq], po, objName = obj.bindTarget.attr("name");
		;

		if (typeof tagIndex !== "undefined") {
			obj.tagContainer.find('[data-tag-index="' + tagIndex + '"]').remove();
			obj.deletedTagList.push(obj.tagList[tagIndex]);
			obj.tagList.splice(tagIndex, 1);
		}

		po = [];
		for (var i = 0, l = obj.tagList.length, tag; i < l; i++) {
			tag = obj.tagList[i];
			po.push('<span class="AXTag-selector-tagitem" data-option-value="' + tag[obj.config.reserveKeys.optionValue] + '">');
			po.push('<input type="hidden" name="' + objName + '" value="' + tag[obj.config.reserveKeys.optionValue] + '" />');
			po.push(tag[obj.config.reserveKeys.optionText]);
			po.push('<span class="AXTag-selector-tagitem-remove" data-tag-index="' + i + '"></span>');
			po.push('</span>');
		}
		obj.tagContainer.html(po.join(''));

		if (obj.tagList.length == 0) {
			obj.bindTarget.css({"padding-top": obj.bindTarget_paddingTop}).val('');
		}
		else {
			obj.bindTarget.css({"padding-top": obj.tagContainer.height()}).val('');
		}

		obj.bindAnchorTarget.data("height", obj.bindTarget.outerHeight());
		axdom(window).resize();
	},
	bindTagSelector_setItem: function(objID, tags) {
		var cfg = this.config,
			objSeq = null, obj;
		for (var i = 0, l = this.objects.length; i < l; i++) {
			if (this.objects[i].id === objID) {
				objSeq = i;
				break;
			}
		}
		obj = this.objects[objSeq];
		obj.deletedTagList = [];

		if (Object.isArray(tags)) {
			obj.tagList = [];
			for (var i = 0, l = tags.length, tag; i < l; i++) {
				var tag = tags[i];
				if (typeof tag[obj.config.reserveKeys.optionValue] === "undefined") tag[obj.config.reserveKeys.optionValue] = tag.toString();
				if (typeof tag[obj.config.reserveKeys.optionText] === "undefined") tag[obj.config.reserveKeys.optionText] = tag.toString();
				obj.tagList.push(tag);
			}
			this.bindTagSelector_removeItem(objID, objSeq);
		}
		return this;
	},
	bindTagSelector_getItem: function(objID) {
		var cfg = this.config,
			objSeq = null, obj;
		for (var i = 0, l = this.objects.length; i < l; i++) {
			if (this.objects[i].id === objID) {
				objSeq = i;
				break;
			}
		}
		obj = this.objects[objSeq];
		return {list: obj.tagList, deletedList: obj.deletedTagList};
	}
});

var AXInputPro = new AXInputConverterPro();
AXInputPro.setConfig({targetID: "inputBasic"});

/**
 * @method jQueryFns.bindPattern
 * @param config {JSObject} bindConfig
 * @returns jQueryObject
 * @description
 * @example
 ```
 $("#id").bindPattern({
	pattern:"money|bizno|{function}"
});

 //sample
 $("#ax-bind-pattern-custom-target").bindPattern({
    pattern: function(val){
        //trace(this); //전달된 this를 확인 할 수 있습니다.
        return val.ucase();
    }
});
 ```
 */
axdom.fn.bindPattern = function(config) {
	axf.each(this, function() {
		if (!this.id) this.id = "AXInputPro-" + axf.getUniqueId();
		config = config || {};
		config.id = this.id;
		config.bindType = "pattern";
		AXInputPro.bind(config);
	});
	return this;
};

/**
 * @method jQueryFns.bindPatternSetConfig
 * @param config {JSObject} bindPattern config
 * @returns jQueryObject
 * @description
 * @example
 ```
 $("#id").bindPatternSetConfig({
    allow_minus: true,
	max_length: 5
 });
 ```
 */
axdom.fn.bindPatternSetConfig = function(config) {
	axf.each(this, function() {
		AXInputPro.bindSetConfig(this.id, config);
	});
	return this;
};

/**
 * @method jQueryFns.bindPatternGetText
 * @param
 * @returns returnVals {String|Array}
 * @description
 * @example
 ```
 var text = $("#id").bindPatternGetText();
 ```
 */
axdom.fn.bindPatternGetText = function() {
	var returnVals = "";
	axf.each(this, function() {
		var getVal = AXInputPro.bindPatternGetText(this.id);
		if (returnVals == "") {
			returnVals = getVal;
		}
		else {
			if (Object.isString(returnVals)) {
				returnVals = [returnVals]; // 형변환
				returnVals.push(getVal);
			}
			else if (Object.isArray(returnVals)) {
				returnVals.push(getVal);
			}
		}
	});
	return returnVals;
};

/**
 * @method jQueryFns.bindPatternSetText
 * @param val {String}
 * @returns jQueryObject
 * @description
 * @example
 ```
 $("#id").bindPatternSetText("12345.123");
 ```
 */
axdom.fn.bindPatternSetText = function(val) {
	axf.each(this, function() {
		AXInputPro.bindPatternSetText(this.id, null, val);
	});
	return this;
};

/**
 * @method jQueryFns.bindPatternGetDisplayText
 * @param null
 * @returns String
 * @description 표시된 값 가져오는 함수
 * @example
 ```
 $("#id").bindPatternGetDisplayText();
 ```
 */

axdom.fn.bindPatternGetDisplayText = function() {
	var returnVals = "";
	axf.each(this, function() {
		var getVal = AXInputPro.bindPatternGetDisplayText(this.id);
		if (returnVals == "") {
			returnVals = getVal;
		}
		else {
			if (Object.isString(returnVals)) {
				returnVals = [returnVals]; // 형변환
				returnVals.push(getVal);
			}
			else if (Object.isArray(returnVals)) {
				returnVals.push(getVal);
			}
		}

	});
	return returnVals;
};

/**
 * @method jQueryFns.bindTagSelector
 * @param config {JSObject} bindConfig
 * @returns jQueryObject
 * @description
 * @example
 * ```js
 * //sample
 * $("#ax-bind-pattern-custom-target").bindTagSelector({
 *
 * });
 * ```
 */
axdom.fn.bindTagSelector = function(config) {
	axf.each(this, function() {
		if (!this.id) this.id = "AXInputPro-" + axf.getUniqueId();
		config = config || {};
		config.id = this.id;
		config.bindType = "tagSelector";
		AXInputPro.bind(config);
	});
	return this;
};

/**
 * @method jQueryFns.bindTagSelector_setItem
 * @param config {JSObject} bindConfig
 * @returns jQueryObject
 * @description
 * @example
 * ```js
 * //sample
 * $("#ax-bind-pattern-custom-target").bindTagSelector_setItem([
 *  {optionValue:1, optionText:"Seoul"},
 *  {optionValue:2, optionText:"대구"}
 * ]);
 * ```
 */
axdom.fn.bindTagSelector_setItem = function(list) {
	axf.each(this, function() {
		AXInputPro.bindTagSelector_setItem(this.id, list);
	});
	return this;
};

/**
 * @method jQueryFns.bindTagSelector_getItem
 * @returns Object
 * @description
 * @example
 * ```js
 * //sample
 * $("#ax-bind-pattern-custom-target").bindTagSelector_getItem();
 * ```
 */
axdom.fn.bindTagSelector_getItem = function() {
	if (this[0])
		return AXInputPro.bindTagSelector_getItem(this[0].id);
}


/* ---------------------------- */
var AXMobileMenu = Class.create(AXJ, {
    initialize: function(AXJ_super) {
		AXJ_super();
		
		this.moveSens = 0;
		this.config.moveSens = 1;
		this.touchMode;
		this.selectedPoi = null;
		this.config.width = 300;
		this.config.height = 388;
		this.config.reserveKeys = {
			labelKey:"label",
			urlKey:"url",
			targetKey:"target",
			addClassKey:"addClass",
			subMenuKey:"cn"
		};
    },
/**
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @method AXMobileMenu.setConfig
 * @param {Object} Config of Object
 * @example
```js
var myMobileMenu = new AXMobileMenu();
myMobileMenu.setConfig({
	// 사용자 키 정의
	reserveKeys:{
		primaryKey:"menuID",
		labelKey:"label",
		urlKey:"url",
		targetKey:"target",
		addClassKey:"ac",
		subMenuKey:"cn"
	},

	// ac : 메뉴 아이템에 추가하고 싶은 클래스 네임 addClass의 약자
	menu:[
		{menuID:"1", label:"menu 1", ac:"Dashboard", url:"http://www.axisj.com"},
		{menuID:"4", label:"menu 4", ac:"Cashiering", url:"http://www.axisj.com"},
		{menuID:"5", label:"menu 5", ac:"Housekeeping", url:"http://www.axisj.com"},
		{menuID:"6", label:"menu 6", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"2", label:"menu 2", ac:"Reservation", cn:[
			{menuID:"2-1", label:"menu 2-1", url:"http://www.axisj.com"},
			{menuID:"2-2", label:"menu 2-2", cn:[
				{menuID:"2-2-1", label:"menu 2-2-1", url:"http://www.axisj.com"},
				{menuID:"2-2-2", label:"menu 2-2-2", url:"http://www.axisj.com"},
				{menuID:"2-2-3", label:"menu 2-2-3", url:"http://www.axisj.com"}
			]},
			{menuID:"2-3", label:"menu 2-3", url:"http://www.axisj.com"},
			{menuID:"2-4", label:"menu 2-4", url:"http://www.axisj.com"},
			{menuID:"2-5", label:"menu 2-5", url:"http://www.axisj.com"},
			{menuID:"2-6", label:"menu 2-6", url:"http://www.axisj.com"},
			{menuID:"2-7", label:"menu 2-7", url:"http://www.axisj.com"},
			{menuID:"2-8", label:"menu 2-8", url:"http://www.axisj.com"},
			{menuID:"2-9", label:"menu 2-9", url:"http://www.axisj.com"},
			{menuID:"2-10", label:"menu 2-10", url:"http://www.axisj.com"},
			{menuID:"2-11", label:"menu 2-11", url:"http://www.axisj.com"},
			{menuID:"2-12", label:"menu 2-12", url:"http://www.axisj.com"},
			{menuID:"2-13", label:"menu 2-13", url:"http://www.axisj.com"}
		]},
		{menuID:"7", label:"menu 7", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"8", label:"menu 8", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"9", label:"menu 9", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"10", label:"menu 10", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"11", label:"menu 11", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"12", label:"menu 12", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"13", label:"menu 13", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"14", label:"menu 14", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"15", label:"menu 15", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"16", label:"menu 16", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"17", label:"menu 17", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"18", label:"menu 18", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"19", label:"menu 19", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"20", label:"menu 20", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"21", label:"menu 21", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"22", label:"menu 22", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"23", label:"menu 23", ac:"Management", url:"http://www.axisj.com"},
		{menuID:"3", label:"menu 3", ac:"Guest", cn:[
			{menuID:"3-1", label:"menu 3-1", url:"http://www.axisj.com"},
			{menuID:"3-2", label:"menu 3-2", cn:[
				{menuID:"3-2-1", label:"menu 3-2-1", url:"http://www.axisj.com"},
				{menuID:"3-2-2", label:"menu 3-2-2", url:"http://www.axisj.com"},
				{menuID:"3-2-3", label:"menu 3-2-3", url:"http://www.axisj.com"}
			]},
			{menuID:"3-3", label:"menu 3-3", url:"http://www.axisj.com"},
			{menuID:"3-4", label:"menu 3-4", url:"http://www.axisj.com"},
			{menuID:"3-5", label:"menu 3-5", url:"http://www.axisj.com"}
		]},
		{menuID:"24", label:"menu 24", ac:"Configuration", url:"http://www.axisj.com"}
	],
	onclick: function(){ // 메뉴 클릭 이벤트
		myMobileMenu.close();
		//location.href = this.url;
	}
});
```
 */
    init: function() {
		var cfg = this.config;
		
		/* 이벤트 대소문자 확장 */
		if(!cfg.onclick) cfg.onclick = cfg.onClick;


	    if(cfg.menuBoxID){
		    // 메뉴데이터 태그로 부터 가져오기
		    cfg.menu = this.collectMenuItem(cfg.menuBoxID);
	    }

		//var close = this.close.bind(this);
		this.modal = new AXMobileModal();
		this.modal.setConfig({
			addClass:"AXMobileMenu",
			height: cfg.height,
			width: cfg.width,
			head:{
				close:{
					onclick:function(){
						
					}
				}
			},
			onclose: function(){
				//close();
			}
		});
		
    },
/**
 * 모바일 메뉴를 오픈합니다.
 * @method AXMobileMenu.open
 * @returns {AXMobileMenu}
 * @example
```js
 <button class="AXButton" onclick="myMobileMenu.open();">Open the mobile menu</button>
```
 */
    open: function(){
    	var cfg = this.config;
    	/*
    	var obj = this.modal.open();
    	this.initMenu(obj);
    	*/
    	var onLoad = this.initMenu.bind(this);
    	this.modal.open(null, onLoad);
		return this;
    },
    initMenu: function(obj){
    	var cfg = this.config;
    	this.modalObj = obj;
    	this.modalID = obj.jQueryModal.get(0).id;
    	
    	if(this.selectedPoi){
    		var lpoi = this.selectedPoi.last();
    		var apoi = this.selectedPoi.concat();
    		apoi.pop();
    		var menu = cfg.menu;
			axf.each(apoi, function(idx, P){
				if(idx == 0){
					menu = menu[P];
				}else{
					menu = menu[cfg.reserveKeys.subMenuKey][P];
				}
			});
			
			if(menu[cfg.reserveKeys.subMenuKey] && menu[cfg.reserveKeys.subMenuKey][lpoi][cfg.reserveKeys.subMenuKey] && menu[cfg.reserveKeys.subMenuKey][lpoi][cfg.reserveKeys.subMenuKey].length > 0){
				apoi.push(lpoi);
				var tpl = this.getMenu(this.modalID, menu[cfg.reserveKeys.subMenuKey][lpoi], apoi);
			}else{
				var tpl = this.getMenu(this.modalID, menu, apoi);
			}			
    	}else{
    		var tpl = this.getMenu(this.modalID, cfg.menu);
    	}
    	
		if(AXUtil.browser.mobile){
			//obj.modalBody.unbind("touchstart.AXMobileMenu").bind("touchstart.AXMobileMenu", this.touchstart.bind(this));
			var modalBodyID = obj.modalBody.get(0).id;
			var touchstart = this.touchstart.bind(this);
			this.touchstartBind = function () {
				touchstart();
			};
			if (document.addEventListener) {
				AXgetId(modalBodyID).addEventListener("touchstart", this.touchstartBind, false);
			}
		}else{
			obj.modalBody.unbind("mousedown.AXMobileMenu").bind("mousedown.AXMobileMenu", this.touchstart.bind(this));
		}

		obj.modalBody.attr("onselectstart", "return false");
		//obj.modalBody.addClass("AXUserSelectNone");
		obj.modalBody.bind("click.AXMobileMenu", this.onclickModalBody.bind(this));
		
    	/* drag cancle */
    	//obj.modalBody.unbind("dragstart.AXMobileMenu").bind("dragstart.AXMobileMenu", this.cancelEvent.bind(this));
    	this.printMenu(tpl);
    },
    printMenu: function(tpl){
    	var obj = this.modalObj;
    	
    	obj.modalHead.empty();
    	obj.modalHead.append(tpl.headPo);
    	obj.modalBody.empty();
    	obj.modalBody.append(tpl.bodyPo);
    	obj.modalFoot.empty();
    	obj.modalFoot.append(tpl.pagePo);
    	
    	/*
    	obj.modalBody.hide();
    	obj.modalBody.fadeIn("300");
    	*/
    	obj.modalHead.find(".mobileMenuHome").bind("click", this.onclickHome.bind(this));
    	obj.modalHead.find(".mobileMenuPrev").bind("click", this.onclickPrev.bind(this));
    	
		this.menuPageWidth = obj.modalBody.find(".mobileMenuBodyPage").width() + 9;
    	this.mobileMenuBodyScroll = obj.modalBody.find(".mobileMenuBodyScroll");
    	obj.modalBody.find(".mobileMenuBodyScroll").css({width:tpl.pageNum * this.menuPageWidth});
    },
    getMenu: function(modalID, _menu, poi){
    	var cfg = this.config;
    	var countPerBlock = 9;
    	var menu = _menu;
    	var menuTitle = "";
    	if(poi == undefined || poi.length == 0) poi = [];
    	else{
    		menuTitle = menu[cfg.reserveKeys.labelKey];
    		menu = menu[cfg.reserveKeys.subMenuKey];
    	}

    	var headPo = [];
    	/* 현재 선택된 메뉴 선택 하는 기능구현 필요 */
    	headPo.push('<a ' + cfg.href + ' class="mobileMenuHome">home</a>');
    	if(menuTitle != ""){
    		headPo.push('<a ' + cfg.href + ' class="mobileMenuPrev" id="', modalID ,'_AX_menuTitle_AX_', poi.join("_"),'">', menuTitle,'</a>');
    	}
		
    	var bodyPo = [];
    	bodyPo.push('<div class="mobileMenuBody">');
    	bodyPo.push('	<div class="mobileMenuBodyScroll" id="', modalID ,'_AX_bodyScroll">');
    	bodyPo.push('		<div class="mobileMenuBodyPage">');
    	
    	var ppoi = poi.join("_");
    	if(ppoi != "") ppoi += "_";
    	
    	var selectedPoi = "";
    	if(this.selectedPoi){
    		selectedPoi = this.selectedPoi.join("_");
    	}
    	
    	axf.each(menu, function(midx, M){
    		if(midx % countPerBlock == 0 && midx > 0){
    			bodyPo.push('	</div>');
    			bodyPo.push('	<div class="mobileMenuBodyPage">');
    		}
    		var addClass = [];
    		if(this[cfg.reserveKeys.addClassKey]){
    			addClass.push(this[cfg.reserveKeys.addClassKey]);
    		}
    		if(selectedPoi == (ppoi + midx)){
    			addClass.push("selected");
    		}
    		bodyPo.push('<a ' + cfg.href + ' class="mobileMenuItem ' + addClass.join(" ") + '" id="', modalID,'_AX_', ppoi, midx,'">');
    		bodyPo.push(this[cfg.reserveKeys.labelKey]);
    		if(this[cfg.reserveKeys.subMenuKey] && this[cfg.reserveKeys.subMenuKey].length > 0){
    			bodyPo.push('<span class="hasSubMenu"></span>');
    		}
    		bodyPo.push('</a>');
    	});
    	bodyPo.push('		</div>');
    	bodyPo.push('	</div>');
    	bodyPo.push('</div>');

		var pageNum = (menu.length / (countPerBlock)).ceil();
		this.pageNo = 0;
		this.pageNum = pageNum;

    	var pagePo = [];
    	pagePo.push('<div class="mobileMenuFoot">');
    	axf.each(pageNum.rangeFrom(1), function(pidx, p){
    		if(pidx == 0) pagePo.push('<div class="pageNav on" ');
    		else pagePo.push('<div class="pageNav" ');
    		pagePo.push(' id="', modalID ,'_AX_pageNav_AX_', pidx ,'"></div>');
    	});
    	pagePo.push('</div>');

    	return {
    		headPo : headPo.join(''),
    		bodyPo : bodyPo.join(''),
    		pagePo : pagePo.join(''),
    		pageNum : ( pageNum )
    	};
    },
/**
 * 모바일 메뉴를 닫습니다.
 * @method AXMobileMenu.close
 * @returns {AXMobileMenu}
 * @example
 ```js
 myMobileMenu.close();
 ```
 */
    close: function(){
    	var cfg = this.config;
    	this.modal.close();
		return this;
    },
/**
 * 모바일 메뉴 트리 인덱스에 해당하는 메뉴를 선택된 상태로 표시합니다. '-' 는 하위 뎁스표현
 * @method AXMobileMenu.setHighLight
 * @param {String} menuID
 * @returns {AXMobileMenu}
 * @example
```js
 myMobileMenu.setHighLight("2-2");
```
 */
    setHighLight: function(menuID){
    	var cfg = this.config;
		
		var menu = cfg.menu;
		var pois = "";
		
		var treeFn = function(subTree, parentPoi){
			axf.each(subTree, function(idx, M){
				if(M[cfg.reserveKeys.primaryKey] == menuID){
					pois = parentPoi + "_" + idx;
					return false;
				}else{
					if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], parentPoi + "_" + idx);
				}
			});
		};
		
		axf.each(menu, function(idx, M){
			if(M[cfg.reserveKeys.primaryKey] == menuID){
				pois = idx + "";
				return false;
			}else{
				if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], idx);
			}
		});

		var poi;
		if(pois != "") poi = pois.split(/_/g);
		this.selectedPoi = poi;
		return this;
    },
/**
 * 모바일 메뉴 트리 인덱스에 해당하는 메뉴를 선택된 상태로 표시합니다. '-' 는 하위 뎁스표현
 * @method AXMobileMenu.setHighLightMenu
 * @param {String} menuID
 * @returns {AXMobileMenu}
 * @example
 ```js
 myMobileMenu.setHighLightMenu("2-2");
 ```
 */
    setHighLightMenu: function(menuID){
    	return this.setHighLight(menuID);
    },
/**
 * 모바일 메뉴 데이터에 사용자가 정의한 id에 해당하는 메뉴를 선택된 상태로 표시합니다.
 * @method AXMobileMenu.setHighLightOriginID
 * @param {String} menuID
 * @returns {AXMobileMenu}
 * @example
 ```js
 mxMenu.setHighLightOriginID("ID1245");
 ```
 */
	setHighLightOriginID: function(menuID){
		var cfg = this.config;

		var menu = cfg.menu;
		var pois = "";

		var treeFn = function(subTree, parentPoi){
			axf.each(subTree, function(idx, M){
				if(M._id == menuID){
					pois = parentPoi + "_" + idx;
					return false;
				}else{
					if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], parentPoi + "_" + idx);
				}
			});
		};

		axf.each(menu, function(idx, M){
			if(M._id == menuID){
				pois = idx + "";
				return false;
			}else{
				if(M[cfg.reserveKeys.subMenuKey] && M[cfg.reserveKeys.subMenuKey].length > 0) treeFn(M[cfg.reserveKeys.subMenuKey], idx);
			}
		});

		var poi;

		//trace(pois);

		if(pois != "") poi = pois.split(/_/g);
		this.selectedPoi = poi;
	},
    onclickModalBody: function(event){
    	var cfg = this.config;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt : eventTarget, evtIDs : eid,
			until:function(evt, evtIDs){ return (axdom(evt.parentNode).hasClass("mobileMenuBodyScroll")) ? true:false; },
			find:function(evt, evtIDs){ return (axdom(evt).hasClass("mobileMenuItem")) ? true : false; }
		});
		
		if(myTarget){
			//something
			//trace(myTarget.id);
			var poi = myTarget.id.split(/_AX_/g).last();
			var menu = cfg.menu;
			var apoi = poi.split(/_/g);
			axf.each(apoi, function(idx, P){
				if(idx == 0){
					menu = menu[P];
				}else{
					menu = menu[cfg.reserveKeys.subMenuKey][P];
				}
			});
			
			if(menu[cfg.reserveKeys.subMenuKey] && menu[cfg.reserveKeys.subMenuKey].length > 0){
				/* animated menu */
				var menuItem = this.modalObj.modalBody.find("#"+myTarget.id);
				menuItem.css({opacity:0});
				var menuItemPos = menuItem.position();

				var mobileMenuBody = this.modalObj.modalBody.find(".mobileMenuBodyScroll");
				var bodyPos = mobileMenuBody.position();
				var cloneMenuItem = axdom("<div class='mobileMenuItemGhost' id='"+this.modalID+"_AX_cloneMenuItem'>" + menuItem.html() + "</div>");
				mobileMenuBody.append(cloneMenuItem);
				cloneMenuItem.css({
					position:"absolute",
					left:menuItemPos.left,
					top:menuItemPos.top
				});

				var getMenuBind = this.getMenu.bind(this);
				var printMenuBind = this.printMenu.bind(this);
				var modalID = this.modalID;
				cloneMenuItem.animate({left:9 - bodyPos.left, top:0, width:270, height:270}, 300, "backInOut").animate({opacity:0}, 100, "expoOut", function () {
					var tpl = getMenuBind(modalID, menu, apoi);
					printMenuBind(tpl);
				});
				
				return;
			}else{
				if(cfg.onclick){
					cfg.onclick.call(menu, menu);
				}
			}
		}
    },
    onclickHome: function(event){
    	var cfg = this.config;
    	var tpl = this.getMenu(this.modalID, cfg.menu);
    	this.printMenu(tpl);
    },
    onclickPrev: function(event){
    	var cfg = this.config;
    	var poi = event.target.id.split(/_AX_/g).last();
		var menu = cfg.menu;
		var apoi = poi.split(/_/g);
		apoi.pop();
		
		axf.each(apoi, function(idx, P){
			if(idx == 0){
				menu = menu[P];
			}else{
				menu = menu[cfg.reserveKeys.subMenuKey][P];
			}
		});
    	
    	var tpl = this.getMenu(this.modalID, menu, apoi);
    	this.printMenu(tpl);
    },
/**
 * 모바일 메뉴 데이터를 설정합니다.
 * @method AXMobileMenu.setTree
 * @param {Object} tree
 * @returns {AXMobileMenu}
 * @example
```js
 var menuStr = '[{"label":"test", "link":"/index.php?mid=page_XhGM56", "target":"_self", "url":"page_XhGM56", "selected":1, "expand":"N", "isShow":true, "parent_srl":"0", "k":"66", "cn":null}, {"label":"We are...", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"104", "cn":[{"label":"Jowrney & Stacey", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"105", "cn":[{"label":"aaa", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"105", "k":"140", "cn":[{"label":"ddd", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"140", "k":"143", "cn":[{"label":"fff", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"143", "k":"145", "cn":null}], "addClass":"hasSubMenu"}, {"label":"eee", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"140", "k":"144", "cn":null}], "addClass":"hasSubMenu"}, {"label":"bbb", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"105", "k":"141", "cn":null}, {"label":"ccc", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"105", "k":"142", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Bike", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"106", "cn":null}, {"label":"Gear & Stuff", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"107", "cn":null}, {"label":"Media outlet", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"108", "cn":null}, {"label":"Sponsor", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"109", "cn":null}, {"label":"World adventure proposal", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"110", "cn":null}, {"label":"iBooks", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"111", "cn":null}, {"label":"Rewards", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"112", "cn":null}, {"label":"Rancho", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"104", "k":"113", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Route", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"114", "cn":[{"label":"Where we go", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"114", "k":"115", "cn":null}, {"label":"Trace of flybasket", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"114", "k":"116", "cn":null}, {"label":"Cost", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"114", "k":"117", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Travels", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"118", "cn":[{"label":"World Adventure", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"119", "cn":null}, {"label":"2013 Dokdo, Aroound the Ulleun island", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"120", "cn":null}, {"label":"2012 Cross country, along the river", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"121", "cn":null}, {"label":"2011 Around the Jeju island", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"122", "cn":null}, {"label":"2010 Jumujin, Go to the East sea", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"123", "cn":null}, {"label":"2009 We rode the japan honeymoon", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"124", "cn":null}, {"label":"2008 Haenam, the end of the Korea", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"118", "k":"125", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Blog", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"126", "cn":null}, {"label":"Project", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"127", "cn":[{"label":"Experience farm in the world", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"128", "cn":null}, {"label":"Click the shutter for the world", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"129", "cn":null}, {"label":"10 thousands hours playing the violins", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"130", "cn":null}, {"label":"Go to 30,000 km by bike", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"131", "cn":null}, {"label":"On around the earth", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"132", "cn":null}, {"label":"Create UI set by countries", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"127", "k":"133", "cn":null}], "addClass":"hasSubMenu"}, {"label":"Friends", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"134", "cn":null}, {"label":"Guestbook", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"135", "cn":null}, {"label":"Donation", "link":"#", "target":"_self", "url":"#", "selected":0, "expand":"N", "isShow":true, "parent_srl":"0", "k":"136", "cn":null}] ';
 myMobileMenu.setTree( menuStr.object() );
```
 */
    setTree: function(tree){
    	this.config.menu = tree;
		return this;
    },
	collectMenuItem: function(targetID){
		var cfg = this.config;
		var menuBox = axdom("#"+targetID)
		var tree = [];

		//{menuID:"1", label:"menu 1", ac:"Dashboard", url:"http://www.axisj.com"}
		var initChilds = function(EL, cid, _tree){
			var childDiv = jQuery(EL).children("."+cfg.childsMenu.className).get(0);
			if(childDiv) {
				var childDivID = cid.replace("PMA", "PMC");
				if(!childDiv.id) childDiv.id = childDivID;
				else childDivID = childDiv.id;

				jQuery("#"+childDivID+">ul>li").each(function(ci, EL) {
					var citem = {}, c_domEL = axdom(EL);
					if(c_domEL.children("A").attr("data-axmenuid")){
						citem._id = c_domEL.children("A").attr("data-axmenuid");
					}else if(c_domEL.children("A").get(0).id) {
						citem._id = c_domEL.children("A").get(0).id;
					}else {
						c_domEL.children("A").get(0).id = (citem._id = cid + "_" + ci);
					}

					citem[cfg.reserveKeys.primaryKey] = cid + "_" + ci;
					citem[cfg.reserveKeys.labelKey] = c_domEL.children("A").text();
					citem[cfg.reserveKeys.urlKey] = c_domEL.children("A").attr("href");
					citem[cfg.reserveKeys.targetKey] = c_domEL.children("A").attr("target") || "_self";
					citem[cfg.reserveKeys.addClassKey] = c_domEL.children("A").attr("class") || "";
					citem[cfg.reserveKeys.subMenuKey] = [];
					_tree[cfg.reserveKeys.subMenuKey].push(citem);

					//trace(pi,  ci);
					initChilds(EL, citem[cfg.reserveKeys.primaryKey], _tree[cfg.reserveKeys.subMenuKey][ci]);
				});
			}
		};

		menuBox.find("." + cfg.parentMenu.className).each(function(pi, EL){
			if(!EL.id) EL.id = cfg.menuBoxID + "_PM_" + pi;
			var item = {}, domEL = axdom(EL), nid = "";
			if(domEL.children("A").attr("data-axmenuid")){
				item._id = domEL.children("A").attr("data-axmenuid");
			}else if(domEL.children("A").get(0).id) {
				item._id = domEL.children("A").get(0).id;
			}else {
				domEL.children("A").get(0).id = (item._id = cfg.menuBoxID + "_PMA_" + pi);
			}

			if(domEL.children("A").get(0).id) {
				nid = domEL.children("A").get(0).id;
			}else {
				nid = cfg.menuBoxID + "_PMA_" + pi;
			}

			item._child_id = nid.replace("PMA", "PMC");
			item[cfg.reserveKeys.primaryKey] = targetID + "_PM_" + pi;
			item[cfg.reserveKeys.labelKey] = domEL.children("A").text();
			item[cfg.reserveKeys.urlKey] = domEL.children("A").attr("href");
			item[cfg.reserveKeys.targetKey] = domEL.children("A").attr("target") || "_self";
			item[cfg.reserveKeys.addClassKey] = domEL.children("A").attr("class") || "";
			item[cfg.reserveKeys.subMenuKey] = [];
			tree.push(item);

			var child = domEL.children("."+cfg.childMenu.className).get(0);
			if(child){
				if(!child.id) child.id = item._child_id;
				jQuery("#"+item._child_id+">ul>li").each(function(ci, EL) {
					var citem = {}, c_domEL = axdom(EL);

					if(c_domEL.children("A").attr("data-axmenuid")){
						citem._id = c_domEL.children("A").attr("data-axmenuid");
					}else if(c_domEL.children("A").get(0).id) {
						citem._id = c_domEL.children("A").get(0).id;
					}else {
						c_domEL.children("A").get(0).id = (citem._id = item._child_id.replace("PMC", "PMA") + "_" + ci);
					}

					citem[cfg.reserveKeys.primaryKey] = item._child_id.replace("PMC", "PMA") + "_" + ci;
					citem[cfg.reserveKeys.labelKey] = c_domEL.children("A").text();
					citem[cfg.reserveKeys.urlKey] = c_domEL.children("A").attr("href");
					citem[cfg.reserveKeys.targetKey] = c_domEL.children("A").attr("target") || "_self";
					citem[cfg.reserveKeys.addClassKey] = c_domEL.children("A").attr("class") || "";
					citem[cfg.reserveKeys.subMenuKey] = [];
					tree[pi][cfg.reserveKeys.subMenuKey].push(citem);

					//trace(pi,  ci);
					initChilds(EL, citem[cfg.reserveKeys.primaryKey], tree[pi][cfg.reserveKeys.subMenuKey][ci]);
				});
			}else{

			}
		});

		return tree;
	},
    /* 메뉴 터치 이동관련 함수 - s */
	touchstart: function (e) {
		var cfg = this.config;

		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX, 
				pageY : e.pageY
			};
		}
		
		this.touchStartXY = {
			sTime: ((new Date()).getTime() / 1000),
			sLeft:  this.mobileMenuBodyScroll.position().left,
			x: touch.pageX,
			y: touch.pageY
		};

		if(AXUtil.browser.mobile){
			var event = window.event;
			var touchEnd = this.touchEnd.bind(this);
			this.touchEndBind = function () {
				touchEnd(event);
			};	
			var touchMove = this.touchMove.bind(this);
			this.touchMoveBind = function () {
				touchMove(event);
			};
			if (document.addEventListener) {
				document.addEventListener("touchend", this.touchEndBind, false);
				document.addEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{
			axdom(document.body).bind("mouseup.AXMobileMenu", this.touchEnd.bind(this));
			axdom(document.body).bind("mousemove.AXMobileMenu", this.touchMove.bind(this));
		}
		
		this.mobileMenuBodyScroll.stop();
	},
	touchMove: function (e) {
		if (this.touhEndObserver) clearTimeout(this.touhEndObserver); //닫기 명령 제거
		var cfg = this.config;
		
		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX, 
				pageY : e.pageY
			};
		}
		
		if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.y - touch.pageY) <= 0) ? "up" : "dn"; /* 위아래 이동 */
		} else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.x - touch.pageX) <= 0) ? "lt" : "rt"; /* 좌우 이동 */
			
			this.moveBlock(touch.pageX - this.touchStartXY.x);
			if (event.preventDefault) event.preventDefault();
			else return false;
			
		}
		if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
			//this.touchSelecting = true;
		}
	},
	touchEnd: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		//this.moveSens = 0;
		//this.touchMode = false;
		
		if(AXUtil.browser.mobile){
			if (document.removeEventListener) {
				document.removeEventListener("touchend", this.touchEndBind, false);
				document.removeEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{
			axdom(document.body).unbind("mouseup.AXMobileMenu");
			axdom(document.body).unbind("mousemove.AXMobileMenu");
		}
		
		var moveEndBlock = this.moveEndBlock.bind(this);
		this.touhEndObserver = setTimeout(function () {
			moveEndBlock();
		}, 10);
	},
	moveBlock: function(moveX){
		//trace(this.mobileMenuBodyScroll.width());
		var cfg = this.config;
		var newLeft = (this.touchStartXY.sLeft + (moveX * 1));
		if(newLeft > this.menuPageWidth*0.5){
			newLeft = this.menuPageWidth*0.5;
		}else if(newLeft < ( - this.mobileMenuBodyScroll.width()) * 1.5){
			newLeft = ( - this.mobileMenuBodyScroll.width()) * 1.5;
		}
		this.mobileMenuBodyScroll.css({left: newLeft});
	},
	moveEndBlock: function(){
		/* 관성발동여부 체크 */
		if(!this.touchStartXY) return;
		var sTime = this.touchStartXY.sTime;
		var eTime = ((new Date()).getTime() / 1000);
		var dTime = eTime - sTime;
		var eLeft = this.mobileMenuBodyScroll.position().left;
		var dLeft = eLeft - this.touchStartXY.sLeft;
		var velocity = Math.ceil((dLeft/dTime)/10); // 속력= 거리/시간
		var endLeft = Math.ceil(eLeft + velocity); //스크롤할때 목적지
		/*trace({eLeft: eLeft, velocity:velocity, endLeft:endLeft});*/
		if(endLeft > 0){
			endLeft = 0;
		}		
		var calLeft = (endLeft.abs() % this.menuPageWidth);
		var absPage = (endLeft.abs() / this.menuPageWidth).floor();
		var newLeft = 0;
		if(calLeft < this.menuPageWidth/2){
		}else{
			absPage += 1;
		}
		if(absPage > this.pageNum-1) absPage = this.pageNum - 1;
		newLeft = this.menuPageWidth * absPage;
		
		//trace(absPage);
		this.touchStartXY.sLeft = -newLeft;

		this.mobileMenuBodyScroll.animate({left: -newLeft}, (this.mobileMenuBodyScroll.position().left + newLeft).abs(), "cubicOut", function () {});
		this.modalObj.modalFoot.find('#' + this.modalID + '_AX_pageNav_AX_' + this.pageNo).removeClass("on");
		this.modalObj.modalFoot.find('#' + this.modalID + '_AX_pageNav_AX_' + absPage).addClass("on");
		
		this.pageNo = absPage;
		
		this.touchStartXY = null;
	},
	/* 메뉴 터치 이동관련 함수 - e */
	
	cancelEvent: function (event) {
		event.stopPropagation(); // disable  event
		return false;
	}
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */


/**
 * @class AXModal
 * @classdesc 모달창을 생성하고 제어 합니다. 모달창은 window, iframe, div 세 가지로 생성할 수 있습니다.
 * @extends AXJ
 * @version v1.40
 * @author tom@axisj.com
 * @logs
 "2013-02-13 오전 10:39:17 - axmods 에서 컨버트 : tom ",
 "2013-04-08 오전 12:15:17 - resize 메소스 추가 및 버그 픽스 : tom ",
 "2013-06-20 오후 5:21:24 - open 메소드 속성에 width 조건 추가 : tom ",
 "2013-07-09 오후 4:41:48 - animateDuration 속성 추가  : tom ",
 "2013-08-21 오후 4:46:51 - openNew 버그 픽스 : tom ",
 "2013-08-22 오전 10:56:20 - resize 버그 픽스 : tom ",
 "2013-08-24 - openNew 메소드 기능 확장 : tom ",
 "2013-10-14 오전 6:54:40 - resize 기능 보강 : tom ",
 "2013-11-15 오후 4:01:29 - tom : openDiv scroll 버그 패치",
 "2013-11-18 오후 5:16:02 - tom resize 버그 패치",
 "2014-05-21 - tom : AXModal mediaQuery 속성 추가"
 "2014-06-09 tom : mediaQuery bugfix"
 "2014-08-04 tom : fix resize error"
 "2014-09-17 tom : 'add Config' scrollLock"
 "2014-11-16 tom : openDiv 메소드에 verticalAlign 속성 확장"
 "2015-03-25 root : 각 open 메소드에 closeButton 속성 확장"
 "2015-04-22 root : axdom 독립 우회 코드 변경"
 "2015-05-08 tom : loaded 메소드 추가"

 */
var AXModal = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.config.maskCss = "AXMask";
        this.config.windowBoxCss = "AXModalBox";
        this.config.padding = "0";
        this.config.defaultTop = 10;
        this.config.animateDuration = 300;
        this.config.autoHide = false;
        this.config.windowID = "AXModal" + AXUtil.timekey();
        this.config.contentDivClass = (AXConfig.AXModal) ? AXConfig.AXModal.contentDivClass : "bodyHeightDiv";
        this.config.displayLoading = true;
        this.config.viewMode = "dx";
        this.config.opendModalID = "";
        this.config.scrollLock = false;
        this.config.closeButton = true;
    },
    /**
     * 모달의 기본 환경설정값을 셋팅합니다.
     * @method AXModal.setConfig
     * @param {Object} modalConfig
     * @example
     * ```js
     * var myModal = new AXModal();
     * var modalConfig = {
     *     animateDuration: {Number} [300],
     *     contentDivClass: {String} ["bodyHeightDiv"] - iframe 모달의 창이 오픈된 경우 iframe 의 높이를 정확히 제어하기 위해 컨텐츠 전체를 감싸는 대상에 지정한 className 값,
     *     defaultTop: {Number} [10] - 모달창 포지션 top,
     *     displayLoading: {Boolean} [true] - 모달이 오픈될 때 로딩 표시 여부,
     *     maskCss: "AXMask" - 배경 mask div의 css,
     *     opendModalID: {String} - 모달 ID,
     *     padding: {(String|Number)} ["0"] - 모달 padding 값,
     *     viewMode: {String} ["dx"],
     *     width: {(String|Number)} - 모달의 기본 너비,
     *     windowBoxCss: {String} ["AXModalBox"] - 모달을 감싸는 제일 바깥쪽 div의 css,
     *     windowID: {String} ["AXModal" + timekey] - 모달 식별 아이디,
     *     onclose: {Function} - 모달창이 닫힐 때 이벤트,
     *     closeButton: {Boolean} [true] - 모달창 닫기버튼의 노출 여부
     * };
     * myModal.setConfig(modalConfig);
     * ```
     */
    init: function () {
        var cfg = this.config;
        this.mask = axdom("<div class=\"" + cfg.maskCss + "\"></div>");
        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

    },
    /**
     * @method AXModal.setWidth
     * @param {(String|Number)} - 모달의 기본 너비 pixel({Number}) or percent({String})
     * @description 모달의 기본 너비 속성을 변경하고 창이 열려있는 상태이면 동적으로 창의 크기도 변경합니다. (단, openDIV 로 모달이 오픈된 경우는 해당사항 없음)
     * @example
     * ```js
     * myModal.setWidth(800);
     * myModal.setWidth("80%");
     * ```
     */
    setWidth: function (width) {
        var cfg = this.config;
        if (width) {
            cfg.width = width;
            this.config.fixedWidth = true;
        } else {
            cfg.width = undefined;
            this.config.fixedWidth = false;
        }

        axdom("#" + cfg.windowID).css({ width: width });
        var maskWidth = axdom("#" + cfg.windowID).outerWidth();
        var maskLeft = (axdom(document.body).width() / 2) - (maskWidth / 2);
        if (maskLeft < 0) maskLeft = 0;
        axdom("#" + cfg.windowID).css({ left: maskLeft });
    },
    /**
     * @method AXModal.open
     * @param {Object} - configs
     * @description iframe 을 내장하는 모달 창을 오픈합니다.
     * @example
     * ```js
     * var configs = {
     *     url: {String} - 모달창의 URL,
     *     pars: {(Object|Array)} - 모달창 URL 에 전달 될 파라미터,
     *     method: {String} ["post"] -파라미터 전달방식,
     *     top: {Number} [scrollTop + 100] - 모달창 포지션 top,
     *     width: {(String|Number)} - 모달창 너비,
     *     closeByEscKey: {Boolean} [false] - 모달창 닫기를 esc 키로 닫을 지 여부,
     *     closeButton: {Boolean} [true] - 모달창 닫기버튼의 노출 여부
     * }
     * myModal.open(configs);
     * ```
     */
    open: function (http) {
        var cfg = this.config;

        if (this._windowOpend) return;

        mask.open();
        this.winID = "mdw" + AXUtil.timekey();
        this.frmID = "frm" + AXUtil.timekey();

        var maskWidth, maskLeft;
        if (this.config.width) {
            maskWidth = this.config.width;
            maskLeft = (axdom(document.body).width() / 2) - (this.config.width / 2);
            this.config.fixedWidth = true;
        } else {
            maskWidth = axdom(document.body).width() - 50;
            maskLeft = 10;
            this.config.fixedWidth = false;
        }

        if (http.width) {
            maskWidth = http.width;
            maskLeft = (axdom(document.body).width() / 2) - (http.width / 2);
            this.config.fixedWidth = true;
        }

        var maskTop = this.config.defaultTop;
        if (http.top != undefined) {
            maskTop = http.top;
        } else {
            maskTop = axdom(window).scrollTop() + 100;
        }
        if (maskLeft < 0) maskLeft = 0;

        var po = [];
        po.push("<div id='" + this.config.windowID + "' class='" + this.config.windowBoxCss + "' style='top:" + maskTop + "px;left:" + maskLeft + "px;width:" + maskWidth + "px;'>");
        po.push("	<div class='windowbox' id='" + this.winID + "_box' style='padding:" + this.config.padding + "px'>");
        if (cfg.displayLoading) {
            po.push("		<div id='" + this.config.windowID + "_loading' style='position:absolute;left:0px;top:0px;width:100%;padding:50px 0px 0px 0px;' align='center'>");
            po.push("		<div class=\"AXLoading\"></div>");
            po.push("		<br/><br><span class='blue'>페이지를 로딩 중입니다. 잠시만 기다려 주세요.</span></div>");
        }


        var closeButton = (http.closeButton == undefined) ? cfg.closeButton : http.closeButton;
        if (closeButton){
            po.push("		<a id='" + this.config.windowID + "_close' class='closeBtn'>닫기</a>");
        }

        po.push("		<form name='" + this.frmID + "' method='" + (http.method || "post") + "' target='" + this.winID + "' action='" + http.url + "'>");
        po.push("		<input type='hidden' name='winID' value='" + this.winID + "' />");

        if (isNaN(http.pars.length)) {
            axdom.each(http.pars, function (key, val) {
                po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        } else {
            axdom.each(http.pars, function () {
                axdom.each(this, function (key, val) {
                    po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
                });
            });
        }

        if(AXConfig.AXModal.pars){
            var appendPars = {};
            if(Object.isString(AXConfig.AXModal.pars)){
                appendPars = AXConfig.AXModal.pars.queryToObject();
            }
            axdom.each(appendPars, function (key, val) {
                po.push("<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        }

        po.push("		</form>");
        po.push("		<iframe src='' name='" + this.winID + "' id='" + this.winID + "' frameborder='0' class='windowboxFrame' style='width:100%;overflow:-y:hidden;' scrolling='no'></iframe>");
        po.push("	</div>");
        po.push("</div>");

        if (this.config.appendTargetID) {
            axdom("#" + this.config.appendTargetID).append(po.join(''));
        } else {
            axdom(document.body).append(po.join(''));
        }

        axdom("#" + cfg.windowID).data("width", maskWidth);
        axdom("#" + cfg.windowID).data("top", maskTop);

        if(cfg.viewMode == "mx"){
            axdom("#" + cfg.windowID).css({ left: 0, top:axdom(window).scrollTop(), width:"100%" });
        }

        var loadingID = this.config.windowID + "_loading";
        var _winID = this.winID;
        var _frmID = this.frmID;

        document[_frmID].submit();
        var keydown = this.keydown.bind(this);

        axdom("#" + this.winID).bind("load", function () {
            var myIframe = window[_winID];

            var bodyHeight = axdom(myIframe.document).innerHeight();
            if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
                bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
            }
            axdom(this).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            if (cfg.displayLoading) axdom("#" + loadingID).fadeOut("slow");
            axdom("#" + _winID).addClass("loaded");

            if (http.closeByEscKey) {
                axdom(myIframe.document.body).bind("keydown.AXModal", keydown);
            }
        });

        axdom("#" + this.config.windowID + "_close").bind("click", this.close.bind(this));

        if (http.closeByEscKey) {
            axdom(document.body).bind("keydown.AXModal", keydown);
        }

        this._windowOpend = true;

        axdom(window).unbind("resize.AXModal");
        axdom(window).bind("resize.AXModal", this.onDocResize.bind(this));

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'hidden'});
        }
    },
    /**
     * @deprecated AXModal.openI
     * @see AXModal.open
     */
    openI: function (http) {
        var cfg = this.config;

        if (this._windowOpend) return;

        mask.open();
        this.winID = "mdw" + AXUtil.timekey();
        this.frmID = "frm" + AXUtil.timekey();

        var maskWidth, maskLeft;
        if (this.config.width) {
            maskWidth = this.config.width;
            maskLeft = (axdom(document.body).width() / 2) - (this.config.width / 2);
            this.config.fixedWidth = true;
        } else {
            maskWidth = axdom(document.body).width() - 50;
            maskLeft = 10;
            this.config.fixedWidth = false;
        }

        if (http.width) {
            maskWidth = http.width;
            maskLeft = (axdom(document.body).width() / 2) - (http.width / 2);
            this.config.fixedWidth = true;
        }

        var maskTop = this.config.defaultTop;
        if (http.top != undefined) {
            maskTop = http.top;
        } else {
            maskTop = axdom(window).scrollTop() + 100;
        }

        if (maskLeft < 0) maskLeft = 0;

        var po = [];
        po.push("<div id='" + this.config.windowID + "' class='" + this.config.windowBoxCss + "' style='top:" + maskTop + "px;left:" + maskLeft + "px;width:" + maskWidth + "px;'>");
        po.push("	<div class='windowbox' id='" + this.winID + "_box' style='padding:" + this.config.padding + "px'>");
        po.push("		<div id='" + this.config.windowID + "_loading' style='position:absolute;left:0px;top:0px;width:" + maskWidth + "px;padding:50px 0px 0px 0px;' align='center'>");
        po.push("		<div class=\"AXLoading\"></div>");
        po.push("		<br/><br><span class='blue'>페이지를 로딩 중입니다. 잠시만 기다려 주세요.</span></div>");

        var closeButton = (http.closeButton == undefined) ? cfg.closeButton : http.closeButton;
        if (closeButton){
            po.push("		<a href='#modsExecption' id='" + this.config.windowID + "_close' class='closeBtn'>닫기</a>");
        }

        po.push("		<form name='" + this.frmID + "' method='post' target='" + this.winID + "' action='" + http.url + "'>");
        po.push("		<input type='hidden' name='winID' value='" + this.winID + "' />");

        if (isNaN(http.pars.length)) {
            axdom.each(http.pars, function (key, val) {
                po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        } else {
            axdom.each(http.pars, function () {
                axdom.each(this, function (key, val) {
                    po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
                });
            });
        }

        if(AXConfig.AXModal.pars){
            var appendPars = {};
            if(Object.isString(AXConfig.AXModal.pars)){
                appendPars = AXConfig.AXModal.pars.queryToObject();
            }
            axdom.each(appendPars, function (key, val) {
                po.push("<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        }

        po.push("		</form>");

        if (http.maxHeight) {
            po.push("		<iframe src='' name='" + this.winID + "' id='" + this.winID + "' frameborder='0' class='windowboxFrame' style='width:100%;overflow:-y:hidden;' scrolling='auto'></iframe>");
        } else {
            po.push("		<iframe src='' name='" + this.winID + "' id='" + this.winID + "' frameborder='0' class='windowboxFrame' style='width:100%;overflow:-y:hidden;' scrolling='no'></iframe>");
        }

        po.push("	</div>");
        po.push("</div>");


        if (this.config.appendTargetID) {
            axdom("#" + this.config.appendTargetID).append(po.join(''));
        } else {
            axdom(document.body).append(po.join(''));
        }

        var loadingID = this.config.windowID + "_loading";
        var _winID = this.winID;
        var _frmID = this.frmID;

        document[_frmID].submit();

        axdom("#" + this.winID).bind("load", function () {
            var myIframe = window[_winID];

            var bodyHeight = axdom(myIframe.document).innerHeight();
            if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
                bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
            }
            if (http.maxHeight) {
                if (http.maxHeight < (bodyHeight.number() + maskTop.number() + 10)) {
                    bodyHeight = http.maxHeight - maskTop.number() - 10;
                }
            }

            axdom(this).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            axdom("#" + loadingID).fadeOut("slow");
            axdom("#" + _winID).addClass("loaded");
        });
        axdom("#" + this.config.windowID + "_close").bind("click", this.close.bind(this));

        /*
         if (this.mask) {
         if (this.config.autoHide) this.mask.bind("click", this.close.bind(this));
         }
         */
        //window.scroll(0, 0);
        this._windowOpend = true;

        axdom(window).unbind("resize.AXModal");
        axdom(window).bind("resize.AXModal", this.onDocResize.bind(this));

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'hidden'});
        }
    },
    windowResizeApply: function(){
        this.onDocResize();
    },
    /**
     * @method AXModal.openDiv
     * @param {Object} - configs
     * @description div 모달 창을 오픈합니다.
     * @example
     * ```js
     * var configs = {
     *     modalID: {String} - 모달창의 식별자,
     *     targetID: {String} - 모달창 타켓 엘리먼트 아이디,
     *     top: {Number} [scrollTop + 100] - 모달창 포지션 top,
     *     width: {(String|Number)} - 모달창 너비,
     *     closeByEscKey: {Boolean} [false] - 모달창 닫기를 esc 키로 닫을 지 여부,
     *     verticalAlign: {Boolean} [false] - 모달창 가운데 표시 여부,
     *     closeButton: {Boolean} [true] - 모달창 닫기버튼의 노출 여부
     * }
     * myModal.openDiv(configs);
     * ```
     */
    openDiv: function (args) {
        var cfg = this.config;
        mask.open();

        var modalID = cfg.opendModalID = args.modalID;

        if (AXgetId(modalID)) {
            var modalTarget = $("#" + modalID);
            modalTarget.show();

            var maskTop = this.config.defaultTop;
            if (args.top != undefined) {
                maskTop = axdom(window).scrollTop() + args.top;
            } else {
                maskTop = axdom(window).scrollTop() + 50;
            }

            if(cfg.viewMode == "mx"){
                maskTop = axdom(window).scrollTop();
            }

            if( args.verticalAlign ){
                modalTarget.css({top: axf.clientHeight() / 2 - modalTarget.height()/2 + axdom(window).scrollTop() })
            }else{
                modalTarget.css({ "top": maskTop });
            }

            if (args.closeByEscKey) {
                var keydown = this.keydown.bind(this);
                var keydownBind = function () {
                    keydown(event, modalID);
                };
                axdom(document.body).bind("keydown.AXModal", keydownBind);
            }
            return;
        }

        var maskWidth, maskLeft;
        if (this.config.width) {
            maskWidth = this.config.width;
            maskLeft = (axdom(document.body).width() / 2) - (this.config.width / 2);
            this.config.fixedWidth = true;
        } else {
            maskWidth = axdom(document.body).width() - 50;
            maskLeft = 10;
            this.config.fixedWidth = false;
        }

        if (args.width) {
            maskWidth = args.width;
            maskLeft = (axdom(document.body).width() / 2) - (args.width / 2);
            this.config.fixedWidth = true;
        }

        var maskTop = this.config.defaultTop;
        if (args.top != undefined) {
            maskTop = axdom(window).scrollTop() + args.top;
        } else {
            maskTop = axdom(window).scrollTop() + 50;
        }

        if (maskLeft < 0) maskLeft = 0;

        var po = [];
        po.push("<div id='" + modalID + "' class='" + this.config.windowBoxCss + "' style='top:" + maskTop + "px;left:" + maskLeft + "px;width:" + maskWidth + "px;'>");
        po.push("	<div class='windowbox' style='padding:" + this.config.padding + "px'>");

        var closeButton = (args.closeButton == undefined) ? cfg.closeButton : args.closeButton;
        if (closeButton){
            po.push("		<a href='#modsExecption' id='" + modalID + "_close' class='closeBtn'>닫기</a>");
        }

        po.push("		<div id='" + modalID + "_content'></div>");
        po.push("	</div>");
        po.push("</div>");

        axdom(document.body).append(po.join(''));

        axdom("#" + modalID + "_content").append(axdom("#" + args.targetID));

        axdom("#" + cfg.opendModalID).data("width", maskWidth);
        axdom("#" + cfg.opendModalID).data("top", maskTop);

        if(cfg.viewMode == "mx"){
            axdom("#" + cfg.opendModalID).css({ left: 0, top:axdom(window).scrollTop(), width:"100%" });
        }

        var loadingID = modalID + "_loading";

        var closeBind = this.close.bind(this);
        var closeModal = function (event) {
            closeBind(event, modalID);
        };
        axdom("#" + modalID + "_close").bind("click", closeModal);

        if (args.closeByEscKey) {
            var keydown = this.keydown.bind(this);
            var keydownBind = function () {
                keydown(event, modalID);
            };
            axdom(document.body).bind("keydown.AXModal", keydownBind);
        }

        /*
         if (this.mask) {
         if (this.config.autoHide) this.mask.bind("click", close);
         }
         */

        axdom(window).unbind("resize.AXModal");
        axdom(window).bind("resize.AXModal", this.onDocResize.bind(this));

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'hidden'});
        }

        if( args.verticalAlign ){
            var modalTarget = $("#" + modalID);
            $("#" + modalID).css({top: axf.clientHeight() / 2 - modalTarget.height()/2 + axdom(window).scrollTop() })
        }
    },
    /**
     * @method AXModal.openNew
     * @param {Object} - configs
     * @description 새로운 창으로 모달 창을 오픈 합니다.
     * @example
     * ```js
     * var configs = {
     *     url: {String} - 새창 오픈 URL,
     *     pars: {(Object|Array)} - 새창 오픈 URL 전달 파라미터,
     *     name: {String} ["mdw" + timekey]- 새창이름,
     *     options: {String} - 새창 오픈 옵션 window.open 속성과 동일합니다.
     * }
     * myModal.openNew(configs);
     * ```
     */
    openNew: function (http) {
        this.winID = "mdw" + AXUtil.timekey();
        this.frmID = "frm" + AXUtil.timekey();

        if (this.openWindow) {
            //top.mask.close();
            this.openWindow.close();
        }

        this.openWindow = window.open("", (http.name || this.winID), http.options);
        this.openWindow.focus();

        if (http.title != undefined){
            this.openWindow.document.title = http.title;
        }

        if (AXgetId(this.config.windowID)) axdom("#" + this.config.windowID).remove();

        var po = [];
        po.push("<div id='" + this.config.windowID + "'>");
        po.push("		<form name='" + this.frmID + "' method='" + (http.method || "post") + "' target='" + (http.name || this.winID) + "' action='" + http.url + "'>");
        po.push("		<input type='hidden' name='winID' value='" + this.winID + "' />");

        if (isNaN(http.pars.length)) {
            axdom.each(http.pars, function (key, val) {
                po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
            });
        } else {
            axdom.each(http.pars, function () {
                axdom.each(this, function (key, val) {
                    po.push("		<input type='hidden' name='" + key + "' value='" + val + "' />");
                });
            });
        }
        po.push("		</form>");
        po.push("</div>");
        axdom(document.body).append(po.join(''));
        document[this.frmID].submit();

        axdom("#" + this.config.windowID).remove();
    },
    keydown: function (event, modalID) {
        if (event.keyCode == AXUtil.Event.KEY_ESC) {
            this.close(event, modalID);
        }
    },
    /**
     * @method AXModal.close
     * @param {String} - modalID
     * @description 오픈된 모달 창을 닫습니다.
     * @example
     * ```js
     * myModal.close("modalDiv01");
     * parent.myModal.close(); // iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    close: function (event, modalID) {
        var cfg = this.config;
        if (this.openWindow) {
            this.openWindow.close();
        }

        if (event) {
            if (event.type == undefined) {
                modalID = event;
            }
        }

        if (modalID) {
            axdom("#" + modalID).hide();
            this.config.opendModalID = "";
            mask.close();
        } else {
            if (window[this.winID]) {
                window[this.winID].location.href = "about:blank";
                var windowID = this.config.windowID;

                setTimeout(function () {
                    axdom("#" + windowID).remove();
                }, 1);

                mask.close();
                this._windowOpend = false;
            }
        }

        axdom(document.body).unbind("keydown.AXModal");

        if(this.config.onclose){
            this.config.onclose.call(
                {
                    winID: this.winID,
                    windowID: this.config.windowID,
                    modalID: modalID
                }
            );
        }

        if (cfg.scrollLock == true) {
            axdom(document.body).css({'overflow':'auto'});
        }
    },
    /**
     * @method AXModal.remove
     * @description 오픈된 모달 창을 제거합니다.
     * @example
     * ```js
     * myModal.remove();
     * parent.myModal.remove(); //iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    remove: function (event) {
        var windowID = this.config.windowID;
        setTimeout(function () {
            axdom("#" + windowID).remove();
        }, 1);
        mask.close();
        axdom(document.body).css({'overflow':'auto'});
        this._windowOpend = false;
        /*
         try {
         this.mask.remove();
         } catch (e) { }
         */
    },
    /**
     * @method AXModal.resize
     * @description 열려진 iframe modal 의 높이를 iframe 창의 높이 만큼 리사이즈 합니다. contentDivClass 가 정의된 경우 contentDivClass 높이값으로 resize 합니다.
     * @example
     * ```js
     * myModal.resize();
     * parent.myModal.resize(); //iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    resize: function (event) {
        var cfg = this.config;
        var _winID = this.winID;
        setTimeout(function () {

            try {
                var myIframe = window[_winID];
                var bodyHeight = axdom(myIframe.document).innerHeight();
                if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
                    bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
                }
                axdom("#" + _winID).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
                axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
            }catch(e){

            }

            try {
                parent.fcObj.contentResetHeight();
            } catch (e) {
                //trace(e);
            }

            try {
                parent.fnObj.contentResetHeight(null, bodyHeight + 100);
            } catch (e) {
                //trace(e);
            }
        }, 50);
    },
    onDocResize: function () {
        var cfg = this.config;

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();

            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

        if(cfg.viewMode == "dx"){
            try {
                if (cfg.fixedWidth) {
                    var maskWidth, maskLeft;
                    if(cfg.opendModalID != ""){
                        maskWidth = axdom("#" + cfg.opendModalID).outerWidth();
                        if(maskWidth != axdom("#" + cfg.opendModalID).data("width")) {
                            axdom("#" + cfg.opendModalID).css({
                                top: axdom("#" + cfg.opendModalID).data("top"),
                                width: axdom("#" + cfg.opendModalID).data("width")
                            });
                        }
                        maskLeft = (axdom(document.body).width() / 2) - (maskWidth / 2);
                        if (maskLeft < 0) maskLeft = 0;
                        axdom("#" + cfg.opendModalID).css({ left: maskLeft });
                    }else{
                        maskWidth = axdom("#" + cfg.windowID).outerWidth();
                        if(maskWidth != axdom("#" + cfg.windowID).data("width")) {
                            axdom("#" + cfg.windowID).css({
                                top: axdom("#" + cfg.windowID).data("top"),
                                width: axdom("#" + cfg.windowID).data("width")
                            });
                        }
                        maskLeft = (axdom(document.body).width() / 2) - (maskWidth / 2);
                        if (maskLeft < 0) maskLeft = 0;
                        axdom("#" + cfg.windowID).css({ left: maskLeft });
                    }
                } else {
                    if(cfg.opendModalID != "") {
                        maskWidth = axdom(".container").width() - 50;
                        axdom("#" + cfg.opendModalID).css({ width: maskWidth });
                    }else{
                        maskWidth = axdom(".container").width() - 50;
                        axdom("#" + cfg.windowID).css({ width: maskWidth });
                    }
                }
            } catch (e) {

            }
        }else if(cfg.viewMode == "mx"){
            if(cfg.opendModalID != "") {
                axdom("#" + cfg.opendModalID).css({ left: 0, top: axdom(window).scrollTop(), width: "100%" });
            }else {
                axdom("#" + cfg.windowID).css({ left: 0, top: axdom(window).scrollTop(), width: "100%" });
            }
        }

    },
    /**
     * @method AXModal.loaded
     * @description 모달의 로딩중 상태를 강제로 로드 완료 처리 합니다.
     * @example
     * ```js
     * myModal.loaded();
     * parent.myModal.loaded(); //iframe 모달창을 오픈한 경우 열려진 iframe 안에서 호출 합니다.
     * ```
     */
    loaded: function () {
        var cfg = this.config, _winID = this.winID;
        var loadingID = this.config.windowID + "_loading";
        var myIframe = window[this.winID];

        var bodyHeight = axdom(myIframe.document).innerHeight();
        if (axdom(myIframe.document.body).find("." + cfg.contentDivClass).get(0)) {
            bodyHeight = axdom(myIframe.document.body).find("." + cfg.contentDivClass).outerHeight();
        }
        axdom(this).css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
        axdom("#" + _winID + "_box").css({ height: (bodyHeight) }, cfg.animateDuration, "cubicInOut");
        if (cfg.displayLoading) axdom("#" + loadingID).fadeOut("slow");
        axdom("#" + _winID).addClass("loaded");
    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXModelControl = Class.create(AXJ, {
    version: "AXModelControl V0.1",
    author: "tom@axisj.com",
	logs: [
		"2013-12-03 오후 5:27:18"
	],
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.theme = "";
        this.config.collectSelector = "";
        this.config.subModelDetectClassName = "AXModelDetect";
        this.config.excludeClassName = "";
        this.config.cursorFocus = false;
        this.returnJSData = {};
    },
    init: function() {
		var cfg = this.config;
		if(Object.isUndefined(cfg.targetID)){
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		this.target = jQuery("#"+cfg.targetID);
		//trace(this.collectItem);
		
    },
    collectModelItem: function(){
    	var cfg = this.config;
    	var finderCSS = "";
		if(cfg.collectSelector != ""){
			finderCSS = cfg.collectSelector;
		}else{
			finderCSS = "input[type=text], input[type=hidden], input[type=radio], input[type=checkbox], select, textarea";
		}
		var _this = this;
		var getParentSubModel = function(ele){
			var result = false;
			var checkEle = ele;
			var rooping = true;
			while (rooping) {
				if(!checkEle.get(0)){
					rooping = false;
					break;
				}
				if(checkEle.get(0).id == cfg.targetID){
					rooping = false;
					break;
				}else if(checkEle.parent().hasClass(cfg.subModelDetectClassName)){
					result = true;
					rooping = false;
					break;
				}else{
					checkEle = checkEle.parent();
				}
			}
			return {
				result:result,
				parents:ele.parentsUntil("#"+cfg.targetID)
			};
		};

		var collectItem = [];
		var oncursorKeyup = this.oncursorKeyup.bind(this);
		
		/*trace(finderCSS);*/		
		this.target.find(finderCSS).each(function(){
			var jQueryObj = axdom(this);
			var getSubModel = getParentSubModel(axdom(this));
			if(!getSubModel.result){
				var collectOk = false;
				if(cfg.excludeClassName != ""){
					collectOk = !jQueryObj.hasClass(cfg.excludeClassName);
				}else{
					collectOk = true;
				}
				
				if(collectOk){
					jQueryObj.attr("data-axisjModelId", collectItem.length);
					collectItem.push({
						keys:[this.name],
						jQueryObj:jQueryObj,
						axisjModelId:collectItem.length,
						name:this.name,
						type:this.type
					});
				}
			}else{
				
				jQueryObj.attr("data-axisjModelId", collectItem.length);
				
				var relationKey = [];
				axdom.each(getSubModel.parents, function(){
					if(this.id != ""){
						if(this.id.left(cfg.subModelDetectClassName.length) == cfg.subModelDetectClassName){
							var myKey = this.id.substr(this.id.lastIndexOf("_").number()+1);
							relationKey.push(myKey);
						}
					}
				});
				relationKey.push(this.name);

				collectItem.push({
					keys:relationKey,
					jQueryObj:jQueryObj,
					axisjModelId:collectItem.length,
					name:this.name,
					type:this.type
				});
			}
			jQueryObj = null;
		});		
		
		this.collectItem = collectItem;
		
		
		
		var returnJSData = {};
		axdom.each(this.collectItem, function(itemIndex, item){
			var keys = item.keys;
			var targetJS = returnJSData;
			
			var key;
			for(var kidx=0;kidx<keys.length-1;kidx++){
				key = keys[kidx];
				if(targetJS[key] == undefined){
					targetJS[key] = {};
				}
				targetJS = targetJS[key];
			}
			key = keys.last();
			
			var nVal = "";
			if(targetJS[key] == undefined){
				if(this.type == "checkbox"){
					var keyLength = 0;
					axdom.each(collectItem, function(){
						if(this.keys.join(".") == keys.join(".")) keyLength++;
					});
					if(keyLength == 1){
						targetJS[key] = "";
					}else{
						targetJS[key] = [];
					}
				}else{
					targetJS[key] = "";
				}
				this.keySeq = 0;
			}else{
				if(Object.isArray(targetJS[key])){
					if(this.type != "checkbox"){
						targetJS[key].push(nVal);
						this.keySeq = targetJS[key].length-1;
						//this.keys[this.keys.length-1] += "["+ this.keySeq +"]";
					}
				}else{
					var oVal = targetJS[key];
					if(this.type == "radio"){
						
					}else if(this.type == "checkbox"){
						var keyLength = 0;
						axdom.each(collectItem, function(){
							if(this.keys.join(".") == keys.join(".")) keyLength++;
						});
						if(keyLength == 1){
							targetJS[key] = oVal;
						}else{
							targetJS[key] = [oVal];
							targetJS[key].push(nVal);
							this.keySeq = targetJS[key].length-1;
						}
					}else{
						targetJS[key] = [oVal];
						targetJS[key].push(nVal);
						this.keySeq = targetJS[key].length-1;
						//this.keys[this.keys.length-1] += "["+ this.keySeq +"]";
					}
				}
			}
			
			
			
			if(cfg.cursorFocus){
	
				var jQueryObj = item.jQueryObj;

				//trace(jQueryObj.attr("data-axbind"));

				if(jQueryObj.attr("data-axbind") == "select"){
					jQueryObj.bindSelectGetAnchorObject().unbind("keydown.AXModelControl").bind("keydown.AXModelControl", function(event){
						setTimeout(function(){
							oncursorKeyup(jQueryObj, event, itemIndex);
						}, 10);
					});
				}else{
					jQueryObj.unbind("keydown.AXModelControl").bind("keydown.AXModelControl", function(event){
						setTimeout(function(){
							oncursorKeyup(jQueryObj, event, itemIndex);
						}, 10);
						//if (event.preventDefault) event.preventDefault();
						//if (event.stopPropagation) event.stopPropagation();
						//event.cancelBubble = true;
						//return false;						
					});
				}

			}
		});
		this.returnJSData = returnJSData;
    },
    sync: function(){
		var cfg = this.config;
		if(!this.collectItem) this.collectModelItem();
    },
    clearCollect: function(){
    	this.collectItem = undefined;
    },
    getData: function(){
		var cfg = this.config;
		this.sync();
		var getElementValue = function(jQueryObj, type){
			if(type == "radio" || type == "checkbox"){
				if(jQueryObj.get(0).checked){
					return jQueryObj.val();
				}
			}else{
				return jQueryObj.val();
			}
		};
		
		var returnJSData = this.returnJSData;
		
		var collectItem = this.collectItem;
		axdom.each(this.collectItem, function(){
			var keys = this.keys;
			var targetJS = returnJSData;
			var key;
			for(var kidx=0;kidx<keys.length-1;kidx++){
				key = keys[kidx];
				if(targetJS[key] == undefined){
					targetJS[key] = {};
				}
				targetJS = targetJS[key];
			}
			key = keys.last();
			if(this.type == "checkbox"){
				var keyLength = 0;
				axdom.each(collectItem, function(){
					if(this.keys.join(".") == keys.join(".")) keyLength++;
				});
				if(keyLength > 1) targetJS[key] = [];
				else targetJS[key] = "";
			}
		});
		
		axdom.each(this.collectItem, function(){
			var keys = this.keys;
			var targetJS = returnJSData;
			
			var key;
			for(var kidx=0;kidx<keys.length-1;kidx++){
				key = keys[kidx];
				if(targetJS[key] == undefined){
					targetJS[key] = {};
				}
				targetJS = targetJS[key];
			}
			key = keys.last();
			
			var nVal = getElementValue(this.jQueryObj, this.type);
			if(this.type == "checkbox"){
				if(!AXUtil.isEmpty(nVal)){
					var keyLength = 0;
					axdom.each(collectItem, function(){
						if(this.keys.join(".") == keys.join(".")) keyLength++;
					});
					if(keyLength > 1) targetJS[key].push(nVal);
					else targetJS[key] = nVal;
				}
			}else if(this.type == "radio"){
				if(!AXUtil.isEmpty(nVal)){
					targetJS[key] = nVal;
				}
			}else{
				if(Object.isArray(targetJS[key])){
					targetJS[key][this.keySeq] = nVal;
				}else{
					targetJS[key] = nVal;
				}
			}
		});
		this.returnJSData = returnJSData;
		return Object.clone(this.returnJSData);
    },
    setData: function(jsPathObj, val){
		if(Object.isString(val) || Object.isArray(val) || Object.isNumber(val) ){
			this.applyValue(jsPathObj, val);
		}else{
			var applyValue = this.applyValue.bind(this);
			var fnApplyValue = function(prefixKey, _val, depth){
				if(depth > 5) return; /* 만약의 경우를 대비하여 10 뎁스 이상 연산 처리 하지 않습니다. 무한 루프를 방지 */
				if(prefixKey != "") prefixKey += ".";
				axf.each(_val, function(k, v){
					if(Object.isString(v) || Object.isArray(v) || AXUtil.isEmpty(v) || Object.isNumber(v) ){
						applyValue({key:prefixKey + k}, v);
					}else{
						fnApplyValue(prefixKey+k, v, (depth+1));
					}
				});
			};
			fnApplyValue("", val, 0);
		}
		return true;
    },
    applyValue: function(jsPathObj, val){
		var cfg = this.config;
		this.getData();
		var returnJSData = this.returnJSData;
		if(jsPathObj.key){
			try{
				eval("returnJSData = returnJSData." + jsPathObj.key);
			}catch(e){
				trace(e);
			}
		}
		
		if(returnJSData != undefined){
			if(Object.isString(val) || Object.isNumber(val)){
				
				var findedItem = false;
				axdom.each(this.collectItem, function(){
					if(this.keys.join(".") == jsPathObj.key){
						if(jsPathObj.keySeq != undefined){
							if(jsPathObj.keySeq == this.keySeq){
								this.jQueryObj.val(val);
								findedItem = true;
								return false;
							}
						}else{
							if(this.type == "radio" || this.type == "checkbox"){
								if(this.jQueryObj.get(0).value == val){
									this.jQueryObj.get(0).checked = true;
									findedItem = true;
								}else{
									this.jQueryObj.get(0).checked = false;
									findedItem = true;
								}
							}else{
								this.jQueryObj.val(val);
								findedItem = true;
								return false;	
							}
						}
					}
				});

				if(!findedItem){
					return {error:"not found keySeq"};
				}

			}else if(Object.isArray(val)){
				
				var findedItem = false;
				axdom.each(this.collectItem, function(){
					if(this.keys.join(".") == jsPathObj.key){
						if(jsPathObj.keySeq != undefined){
							if(jsPathObj.keySeq == this.keySeq){
								this.jQueryObj.val(val.join(","));
								findedItem = true;
								return false;
							}else{
								
							}
						}else{
							if(this.type == "checkbox" || this.type == "radio"){
								var jQueryObj = this.jQueryObj;
								if(val.length == 0){
									jQueryObj.get(0).checked = false;
								}else{
									jQueryObj.get(0).checked = false;
									axf.each(val, function(){
										if(jQueryObj.get(0).value == this){
											jQueryObj.get(0).checked = true;
										}
									});
								}
								findedItem = true;
							}else{

								if(val[this.keySeq] != undefined){
									this.jQueryObj.val(val[this.keySeq]);
									findedItem = true;
								}
								//return false;
							}
						}
					}
				});

				if(!findedItem){
					return {error:"not found keySeq"};
				}
				
			}
		}
		
		return true;
    },
    
    /* cursorFocus */
    oncursorKeyup: function(jQueryObj, event, itemIndex){
    	var cfg = this.config;
    	if(event.ctrlKey) return;
    	if(cfg.oncursor){
    		// AXBind 된 경우에는 위아래 사용을 제한 해야함. 2014-01-04 오후 5:57:24
    		var axbind = jQueryObj.attr("data-axbind");
    		var htmlTag = jQueryObj.get(0).type;
    		var direction = "";
    		if(event.keyCode == AXUtil.Event.KEY_UP) direction = "U";
    		else if(event.keyCode == AXUtil.Event.KEY_DOWN) direction = "D";
    		else if(event.keyCode == AXUtil.Event.KEY_LEFT) direction = "L";
    		else if(event.keyCode == AXUtil.Event.KEY_RIGHT) direction = "R";
    		else if(event.keyCode == AXUtil.Event.KEY_RETURN && axbind != "select" && htmlTag != "textarea") direction = "E";	
    		if(cfg.oncursor.call(
    			{
    				event:event,
    				direction:direction,
    				itemIndex:itemIndex,
    				jQueryObj:jQueryObj
    			}
    		) === false) return false;
			if(direction == "") return;
			
			//trace(jQueryObj.get(0).tagName);
			//if(axbind) return;
			if(direction == "U" || direction == "D" || direction == "L" || direction == "R") return;
			else if(direction == "E" && (event.shiftKey || event.metaKey)){
				if(itemIndex == 0){
					if(cfg.oncursorEmpty){
						cfg.oncursorEmpty({type:"indexOver", index:-1});
					}
					return;
				}
				this.blurItem(jQueryObj);
				//this.focusItem(this.collectItem[(itemIndex-1)].jQueryObj);
				
				var nextItemIndex = itemIndex-1;
				for(var ii=nextItemIndex;ii>-1;ii--){
					if(!this.collectItem[ii].jQueryObj.get(0).disabled){
						nextItemIndex = ii;
						break;
					}
				}
				this.focusItem(this.collectItem[nextItemIndex].jQueryObj);
			}else if(direction == "E"){
				if(itemIndex >= this.collectItem.length-1){
					if(cfg.oncursorEmpty){
						cfg.oncursorEmpty({type:"indexOver", index:1});
					}
					return;
				}
				this.blurItem(jQueryObj);
				
				var nextItemIndex = itemIndex+1;
				for(var ii=nextItemIndex;ii<this.collectItem.length;ii++){
					if(!this.collectItem[ii].jQueryObj.get(0).disabled){
						nextItemIndex = ii;
						break;
					}
				}
				this.focusItem(this.collectItem[nextItemIndex].jQueryObj);
			}
			
    	}
    },
    blurItem: function(jQueryObj){
    	var cfg = this.config;
    	
    	var axbind = jQueryObj.attr("data-axbind");
    	if(axbind){
    		if(axbind == "select"){
    			jQueryObj.bindSelectBlur();
    		}else if(axbind == "selector"){
    			jQueryObj.bindSelectorBlur();
    		}
    	}else{
    		//trace(jQueryObj.get(0).type);
    	}
    },
    focusItem: function(jQueryObj){
    	var cfg = this.config;
    	var axbind = jQueryObj.attr("data-axbind");
    	if(axbind){
    		if(axbind == "select") jQueryObj.bindSelectFocus();
    		else if(axbind == "selector") jQueryObj.focus();
    		else jQueryObj.focus();
    	}else{
    		//trace(jQueryObj.get(0).id);
    		jQueryObj.focus();
    	}
    },
    focus: function(focusIndex){
    	var cfg = this.config;
    	
    	if(focusIndex == undefined) focusIndex = 0;
    	//trace(Object.isString(focusIndex));
    	if(Object.isString(focusIndex)){
    		if(focusIndex == "first") focusIndex = 0;
    		else if(focusIndex == "last") focusIndex = this.collectItem.length-1;
    	}else{
    		if(focusIndex < 0) focusIndex = 0;
    		if(focusIndex >= this.collectItem.length) focusIndex = this.collectItem.length-1;
    	}
    	this.focusItem(this.collectItem[focusIndex].jQueryObj);
    }
});
/* ---------------------------- */
var AXModelControlGrid = Class.create(AXJ, {
	initialize: function(AXJ_super) {
		AXJ_super();
		this.config.theme = "AXModelControlGrid";
		this.removedList = [];
	},
	init: function() {
		var cfg = this.config;
		if(Object.isUndefined(cfg.targetID)){
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		this.target = jQuery("#"+cfg.targetID);

		var theme = cfg.theme;
		/* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */
		var ol = [];
		ol.push("<div class=\"" + theme + "\" id=\"" + cfg.targetID + "_AX_grid\" style=\"\">");
		ol.push("	<div class=\"AXgridScrollBody\" id=\"" + cfg.targetID + "_AX_gridScrollBody\" style=\"z-index:2;\">");
		ol.push("		<div class=\"AXGridColHead AXUserSelectNone\" id=\"" + cfg.targetID + "_AX_gridColHead\" onselectstart=\"return false;\"></div>");
		ol.push("		<div class=\"AXGridBody\" id=\"" + cfg.targetID + "_AX_gridBody\"></div>");
		//ol.push("		<div style=\"height:13px;\"></div>");
		ol.push("	</div>");
		this.target.empty();
		this.target.append(ol.join(''));
		/* grid 뼈대 그리기 ----------------------------------------------------------------------------------------------------- */

		this.gridBody = jQuery("#" + cfg.targetID + "_AX_grid");
		this.scrollBody = jQuery("#" + cfg.targetID + "_AX_gridScrollBody");
		this.colHead = jQuery("#" + cfg.targetID + "_AX_gridColHead");
		this.body = jQuery("#" + cfg.targetID + "_AX_gridBody");

		/*colHead setting */
		this.setColHead();
		//this.scrollBody.css({height:this.scrollBody.outerHeight()+13});

		this.myUIScroll = new AXScroll(); // 스크롤 인스턴스 선언
		this.myUIScroll.setConfig({
			targetID : cfg.targetID + "_AX_grid",
			scrollID : cfg.targetID + "_AX_gridScrollBody",
			touchDirection : false,
			yscroll:false,
			xscroll:true
		});

		jQuery(window).bind("resize", this.windowResize.bind(this));
	},
	windowResizeApply: function () {
		var cfg = this.config;
		var bodyWidth = this.gridBody.width() - 2;
		var colWidth = 0;
		var astricCount = 0;

		axdom.each(cfg.colGroup, function (cidx, CG) {
			if(CG.widthAstric){
				CG.width = 0;
				CG._owidth = CG.width;
				astricCount++;
			}
			colWidth += (CG._owidth||0).number();
		});
		this.colWidth = colWidth;

		var newColWidth = 0;
		/* width * 예외처리 구문 ------------ s */
		if ((bodyWidth) > (colWidth + 100 * astricCount)) {
			var remainsWidth = (bodyWidth) - colWidth;
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = remainsWidth / astricCount;
					CG.width = CG._owidth;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}else{
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = 200;
					CG.width = 200;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}
		this.colWidth = newColWidth;

		axdom.each(cfg.colGroup, function (cidx, CG) {
			axdom("#" + cfg.targetID + "_AX_col_AX_" + cidx + "_AX_head").attr("width", this.width);
			axdom("#" + cfg.targetID + "_AX_col_AX_" + cidx + "_AX_body").attr("width", this.width);
		});

		this.scrollBody.css({width:this.colWidth});

		this.colHead.find("table").css({width:this.colWidth});
		this.body.find("table").css({width:this.colWidth});
		this.myUIScroll.resizeScroll();
		this.myUIScroll.moveTo(0);
	},
	getColGroup: function (subfix) {
		var cfg = this.config;
		var po = [];
		po.push("<colgroup>");
		axdom.each(cfg.colGroup, function (cidx, CG) {
			po.push("<col width=\"" + CG.width + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + cidx + "_AX_" + subfix + "\" />");
		});
		po.push("</colgroup>");
		return po.join('');
	},
	getHeadItem: function (arg) {

		var cfg = this.config;
		var po = [];
		po.push("<td class=\"colHeadTd\">");
		po.push("	<div class=\"tdRelBlock\" style=\"text-align:" + (arg.align||"left") + ";\">");

		if(arg.html){
			var html = arg.html.call({
				rowIndex: arg.rowIndex,
				colIndex: arg.colIndex,
				data: arg.data
			});
			po.push(html);
		}else{
			po.push(arg.label);
		}

		po.push("	</div>");
		po.push("</td>");

		return po.join('');
	},
	setColHead: function(rewrite){
		var cfg = this.config;
		var bodyWidth = this.gridBody.width()-2;
		var colWidth = 0;
		var astricCount = 0;

		axdom.each(cfg.colGroup, function (cidx, CG) {
			if (!rewrite){
				if(CG.width == "*"){
					CG.width = 0;
					CG.widthAstric = true;
					astricCount++;
				}
				CG._owidth = CG.width; /* 최초의 너비값 기억 하기 */
			}else{
				if(CG.widthAstric){
					CG.width = 0;
					CG._owidth = CG.width;
					astricCount++;
				}
			}
			colWidth += (CG._owidth||0).number();
		});
		this.colWidth = colWidth;

		var newColWidth = 0;
		/* width * 예외처리 구문 ------------ s */
		if ((bodyWidth) > (colWidth + 100 * astricCount)) {
			var remainsWidth = (bodyWidth) - colWidth;
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = remainsWidth / astricCount;
					CG.width = CG._owidth;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}else{
			axdom.each(cfg.colGroup, function (cidx, CG) {
				if (CG.widthAstric) {
					CG._owidth = 200;
					CG.width = 200;
					colWidth += (CG._owidth||0).number();
				}
				newColWidth += CG.width.number();
			});
		}

		this.colWidth = newColWidth;
		this.scrollBody.css({width:this.colWidth});

		var getHeadItem = this.getHeadItem.bind(this);

		var po = [];
		po.push("<table class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
		po.push(this.getColGroup("head")); /*colGroup 삽입 */
		po.push("<tbody>");
		po.push("<tr>");
		var colCount = 0;
		axdom.each(cfg.colGroup, function (CHidx, CH) {
			po.push(getHeadItem({
				rowIndex:0, colIndex:CHidx,
				align: CH.align,
				label:CH.label, html:CH.html, data:CH.data
			}));
			colCount += CH.colspan;
		});
		po.push("</tr>");
		po.push("</tbody>");
		po.push("</table>");

		this.colHead.empty();
		this.colHead.append(po.join(''));
	},
	setList: function(list, setType){
		var cfg = this.config;
		if (typeof setType == "undefined") {
			this.list = list;
			this.removedList = []; // 그리드가 초기화 되어 삭제된 리스트도 초기화 됩니다.
		} else {
			this.list = list;
			//this.removedList = []; // 그리드가 초기화 되어 삭제된 리스트도 초기화 됩니다.
		}

		this.printList();
		//this.scrollBody.css({height:this.scrollBody.outerHeight()+13});

		this.myUIScroll.resizeScroll();
	},
	appendList: function(item){
		var cfg = this.config;

		item._CUD = "C";

		this.list.push(item);

		//trace(this.list);

		var lidx = this.list.length-1;
		this.printItem(lidx, this.list[lidx]);
		this.printFootItem();

		this.myUIScroll.resizeScroll();
	},
	getItem: function(arg, update){
		var cfg = this.config;
		var po = [];


		if(update == undefined) po.push("<td class=\"bodyTd\">");
		po.push("	<div class=\"tdRelBlock\" style=\"text-align:" + (arg.align||"left") + ";\">");

		if(arg.html){
			var html = arg.html.call({
				rowIndex: arg.rowIndex,
				colIndex: arg.colIndex,
				data: arg.data,
				item:this.list[arg.rowIndex], list:this.list
			});
			po.push(html);
		}else{
			po.push("&nbsp;");
		}

		po.push("	</div>");;
		if(update == undefined) po.push("</td>");

		return po.join('');
	},
	printList: function(){
		var cfg = this.config;
		var printItem = this.printItem.bind(this);

		var po = [];
		po.push("<table class=\"gridBodyTable\" style=\"width:" + this.colWidth + "px;\">");
		po.push(this.getColGroup("body")); /*colGroup 삽입 */
		po.push("<tbody>");
		po.push("</tbody>");
		po.push("<tfoot>");
		po.push("</tfoot>");
		po.push("</table>");

		this.body.empty();
		this.body.append(po.join(''));

		axdom.each(this.list, function (lidx, L) {
			printItem(lidx, L);
		});

		this.printFootItem();
	},
	printItem: function(lidx, L, update, event){
		var cfg = this.config;
		var getItem = this.getItem.bind(this);
		var AXbindOnchange = this.AXbindOnchange.bind(this);
		var _body = this.body.find("tbody");

		if (!L) return;

		var tr = [];
		if(update == undefined) tr.push("<tr class='modelControlTR' id='" + cfg.targetID + "_tbodyTR_" + lidx + "'>");

		axdom.each(cfg.body.form, function (fidx, form) {
			if (form) {
				tr.push(getItem({
					rowIndex: lidx, colIndex: fidx,
					align: (form.align || "left"),
					html: form.html, data: form.data
				}));
			}
		});
		if(update == undefined) tr.push("</tr>");
		if(update == undefined){
			_body.append(tr.join(''));
		}else{
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).html(tr.join(''));
		}

		var oncursorKeyup = this.oncursorKeyup.bind(this);

		axdom.each(cfg.body.form, function (fidx, form) {
			if (form) {
				if (form.AXBind) {
					var bindID = form.AXBind.id.replace(/@rowIndex/g, lidx);
					var myConfig = AXUtil.copyObject(form.AXBind.config);
					axdom.each(myConfig, function (k, v) {
						if (Object.isString(v)) myConfig[k] = v.replace(/@rowIndex/g, lidx);
					});

					myConfig.onchange = function () {
						AXbindOnchange(lidx, fidx, this);
					};

					if (form.AXBind.type == "TwinDate") {
						jQuery("#" + bindID).bindTwinDate(myConfig);
					} else if (form.AXBind.type == "Date") {
						jQuery("#" + bindID).bindDate(myConfig);
					} else if (form.AXBind.type == "Select") {
						jQuery("#" + bindID).unbindSelect();
						jQuery("#" + bindID).bindSelect(myConfig);
						if (cfg.cursorFocus) {
							jQuery("#" + bindID).bindSelectGetAnchorObject().bind("keydown.AXModelControlGrid", function (event) {
								setTimeout(function () {
									oncursorKeyup(jQuery("#" + bindID), event, lidx);
								}, 10);
							});
						}
					} else if (form.AXBind.type == "Selector") {
						jQuery("#" + bindID).bindSelector(myConfig);
					} else if (form.AXBind.type == "Money") {
						jQuery("#" + bindID).bindMoney(myConfig);
					} else if (form.AXBind.type == "Number") {
						jQuery("#" + bindID).bindNumber(myConfig);
					}
				}
			}
		});

		if(cfg.cursorFocus){
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").unbind("keydown.AXModelControlGrid").bind("keydown.AXModelControlGrid", function(event){
				setTimeout(function(){
					oncursorKeyup(jQuery(event.target), event, lidx);
				}, 10);
			});
		}

		var printFootItem = this.printFootItem.bind(this);
		var _this = this;
		_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").unbind("change.AXModelControlGrid").bind("change.AXModelControlGrid", function(){
			_this.list[lidx][this.name] = axdom(this).val();
			printFootItem();
		});
		//_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=checkbox],input[type=radio]")

		if(update == "update"){
			//printFootItem();
		}
	},
	oncursorKeyup: function(jQueryObj, event, lidx){
		var cfg = this.config;

		if(!event.target) return;
		if(event.shiftKey || event.metaKey || event.ctrlKey) return;
		var eventName = jQueryObj.get(0).name;
		if(cfg.oncursor){
			var axbind = jQueryObj.attr("data-axbind");
			var direction = "";
			if(event.keyCode == AXUtil.Event.KEY_UP) direction = "U";
			else if(event.keyCode == AXUtil.Event.KEY_DOWN) direction = "D";
			else if(event.keyCode == AXUtil.Event.KEY_LEFT) direction = "L";
			else if(event.keyCode == AXUtil.Event.KEY_RIGHT) direction = "R";
			else if(event.keyCode == AXUtil.Event.KEY_RETURN && axbind != "select") direction = "R";
			if(cfg.oncursor.call(
				{
					event:event,
					direction:direction,
					listIndex:lidx,
					jQueryObj:jQueryObj
				}
			) === false) return false;
			if(direction == "") return;

			if(axbind && (direction == "U" || direction == "D")) return;
			if((direction == "U" || direction == "D") && jQueryObj.get(0).tagName == "SELECT") return;
			if(direction == "U"){

				if(lidx == 0) return;
				this.blurItem(jQueryObj);
				var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx-1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				var findItem;
				nextItemList.each(function(){
					if(this.name == eventName) findItem = this;
				});
				this.focusItem(jQuery(findItem));
			}else if(direction == "D"){

				if(lidx >= this.list.length-1) return;
				this.blurItem(jQueryObj);
				var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx+1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				var findItem;
				nextItemList.each(function(){
					if(this.name == eventName) findItem = this;
				});
				this.focusItem(jQuery(findItem));

			}else if(direction == "L"){

				var colIndex;
				var itemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				itemList.each(function(cidx, item){
					if(this.name == eventName) colIndex = cidx;
				});

				if(colIndex == 0){
					if(lidx == 0) return;
					this.blurItem(jQueryObj);
					var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx-1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
					this.focusItem(jQuery(nextItemList.last()));
				}else{
					this.blurItem(jQueryObj);
					this.focusItem(jQuery(itemList[colIndex-1]));
				}

			}else if(direction == "R"){

				var colIndex;
				var itemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
				itemList.each(function(cidx, item){
					if(this.name == eventName) colIndex = cidx;
				});

				if(colIndex >= itemList.length-1){
					if(lidx >= this.list.length-1) return;
					this.blurItem(jQueryObj);
					var nextItemList = this.body.find("#" + cfg.targetID + "_tbodyTR_" + (lidx+1)).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea");
					this.focusItem(jQuery(nextItemList.first()));
				}else{
					this.blurItem(jQueryObj);
					this.focusItem(jQuery(itemList[colIndex+1]));
				}
			}


		}
		//trace(event.target.name, lidx);
	},
	blurItem: function(jQueryObj){
		var cfg = this.config;
		var axbind = jQueryObj.attr("data-axbind");
		if(axbind){
			if(axbind == "select"){
				jQueryObj.bindSelectBlur();
			}else if(axbind == "selector"){
				jQueryObj.bindSelectorBlur();
			}else{

			}
		}
	},
	focusItem: function(jQueryObj){
		var cfg = this.config;

		var axbind = jQueryObj.attr("data-axbind");
		if(axbind){
			if(axbind == "select") jQueryObj.bindSelectFocus();
			else if(axbind == "selector") jQueryObj.focus();
			else jQueryObj.focus();
		}else{
			jQueryObj.focus();
		}
	},
	focusIndex: function(rowIndex, colIndex){
		var cfg = this.config;
		//trace(rowIndex, colIndex);
		var myTd = this.body.find("tbody tr#" + cfg.targetID + "_tbodyTR_" + rowIndex + " td:nth-child(" + (colIndex+1) + ")");
		//trace(myTd.html());
		var item = myTd.find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").get(0);
		item.focus();
	},

	AXbindOnchange: function(lidx, fidx, AXBindThis){
		var cfg = this.config;
		if(!cfg.body.form[fidx].AXBind.onchange) cfg.body.form[fidx].AXBind.onchange = cfg.body.form[fidx].AXBind.onChange;
		if(cfg.body.form[fidx].AXBind.onchange){

			var sendObj = {
				rowIndex: lidx,
				colIndex: fidx,
				data: cfg.body.form[fidx].data,
				item:this.list[lidx], list:this.list
			};

			axf.each(AXBindThis, function(k, v){
				sendObj[k] = v;
			});

			cfg.body.form[fidx].AXBind.onchange.call(sendObj);
		}
	},

	/* foot */
	printFootItem: function(){
		var cfg = this.config;

		if(!cfg.foot) return;
		if(!cfg.foot.form) return;

		var _body = this.body.find("tfoot");
		var _list = this.list;
		var foot = [];
		foot.push("<tr class='modelControlTR' id='" + cfg.targetID + "_tbodyTR_foot'>");

		axdom.each(cfg.foot.form, function(fidx, arg){
			foot.push("<td class=\"bodyTd\" colspan=\"" + (arg.colspan || 1) + "\">");
			foot.push("	<div class=\"tdRelBlock\" style=\"text-align:" + (arg.align||"left") + ";\">");

			if(arg.html){
				var html = arg.html.call({
					rowIndex: 0,
					colIndex: fidx,
					data: arg.data,
					list:_list
				});
				foot.push(html);
			}else{
				foot.push("&nbsp;");
			}

			foot.push("	</div>");
			foot.push("</td>");
		});

		foot.push("</tr>");

		_body.empty();
		_body.append(foot.join(''));

	},
	updateItem: function(lidx, item, onlyDataChane, event){
		var cfg = this.config;
		var getItem = this.getItem.bind(this);

		item._CUD = "U";

		this.list[lidx] = AXUtil.overwriteObject(this.list[lidx], item, true);
		if(!onlyDataChane) this.printItem(lidx, this.list[lidx], "update", event);
		else{


			var _body = this.body;
			axdom.each(cfg.body.form, function (fidx, form) {
				if(form.updateReload){
					var td = getItem({
						rowIndex:lidx, colIndex:fidx,
						align:form.align,
						html:form.html, data:form.data
					}, "update");
					var myTD = jQuery(_body.find("tbody tr#" + cfg.targetID + "_tbodyTR_" + lidx + " td").get(fidx));
					myTD.html(td);
				}
			});

			var oncursorKeyup = this.oncursorKeyup.bind(this);
			if(cfg.cursorFocus){
				_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],input[type=checkbox],input[type=radio],select,textarea").unbind("keyup.AXModelControlGrid").bind("keyup.AXModelControlGrid", function(event){
					oncursorKeyup(jQuery(event.target), event, lidx);
				});
			}

		}


		this.printFootItem();
	},
	removeItem: function(collectIdx){
		var cfg = this.config, _this = this;

		this.list = this.getList();
		var newList = [];

		axf.each(this.list, function(lidx, L){
			if(Object.isArray(collectIdx)){
				var isOk = true;
				axf.each(collectIdx, function(){
					if(this == lidx) isOk = false;
				});
				if (isOk) {
					newList.push(L);
				}
				else {
					if (L._CUD != "C" && L._CUD != "D")
						_this.removedList.push(L);
				}
			}else{
				if (collectIdx != lidx) {
					newList.push(L);
				}
				else {
					if (L._CUD != "C" && L._CUD != "D")
						_this.removedList.push(L);
				}
			}
		});

		this.setList(newList, "update");
	},
	getValue: function(name){
		var cfg = this.config;
		var returnValues = [];
		this.body.find("input[type=checkbox][name="+name+"]").each(function(){
			returnValues.push(this.value);
		});
		return returnValues;
	},
	getCheckedValue: function(name){
		var cfg = this.config;
		var returnValues = [];
		this.body.find("input[type=checkbox][name="+name+"]:checked").each(function(){
			returnValues.push(this.value);
		});
		return returnValues;
	},
	getList: function(){
		var cfg = this.config;

		var _body = this.body.find("tbody");
		axf.each(this.list, function(lidx, L){

			var item = {};
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=text],select,textarea").each(function(){
				item[this.name] = axdom(this).val();
			});

			var checkNames = {};
			_body.find("#" + cfg.targetID + "_tbodyTR_" + lidx).find("input[type=checkbox],input[type=radio]").each(function(){
				if(this.type == "checkbox"){
					if(checkNames[this.name]){
						checkNames[this.name].count += 1;
					}else{
						checkNames[this.name] = {name:this.name, count:1};
						item[this.name] = "";
					}
				}
				if(this.checked){
					if(this.type == "checkbox"){
						if(item[this.name]){
							item[this.name].push(this.value);
						}else{
							item[this.name] = [this.value];
						}
					}else{
						item[this.name] = this.value;
					}
				}
			});

			axdom.each(checkNames, function(k, v){
				if(v.count == 1){
					if(Object.isArray(item[v.name])){
						item[v.name] = item[v.name].join(",");
					}
				}
			});

			L = AXUtil.overwriteObject(L, item, true);
		});

		return this.list;

		/*
		 this.body.find("tr.modelControlTR").each(function(trIndex, TR){
		 trace(trIndex);
		 });
		 */
	},
	getRemovedList: function () {
		return this.removedList;
	}
});


/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 

var AXMultiSelector = Class.create(AXJ, {
    version: "AXMultiSelector v1.21",
    author: "tom@axisj.com",
    logs: [
		"2013-08-01 오후 3:08:07",
		"2014-03-21 오후 2:19:52 : tom multiselect 기본값 설정 함수 추가"
	],
    initialize: function (AXJ_super) {
        AXJ_super();

    },
    init: function () {
    	var cfg = this.config;
    	axdom("#"+cfg.targetID).bind("click", this.expandOptionBox.bind(this));
    },
    expandOptionBox: function(){
    	var cfg = this.config;
    	
    	axdom.each(cfg.optionGroup, function (gidx, G) {
    		if (G.getOptionValue) {
    			axdom.each(cfg.optionGroup[gidx].options, function (oidx, O) {
    				cfg.optionGroup[gidx].options[oidx].selected = false;
    			});
    		}
    	});

		var po = [];
		po.push("<div id=\""+cfg.targetID + "_AX_expandBox\" class=\"AXMultiSelector_expandBox\">");
		var boxWidth = 0;
		axdom.each(cfg.optionGroup, function(gidx, G){
			po.push("<div id=\""+cfg.targetID + "_AX_expandScrollBox_AX_"+gidx+"\" class=\"AXMultiSelector_scrollBox\" style=\"width:"+this.width+"px;\">");
			po.push("	<div id=\""+cfg.targetID + "_AX_expandScroll_AX_"+gidx+"\" class=\"AXMultiSelector_scroll\">");
			axdom.each(this.options, function(index, O){
				var selectedClass = (O.selected) ? " on" : "";
				po.push("<a href=\"#AXexec\" id=\""+cfg.targetID + "_AX_"+gidx+"_AX_option_AX_"+index+"\" class=\"bindSelectorNodes "+selectedClass+"\">"+ O.optionText +"</a>");
			});
			po.push("	</div>");
			po.push("</div>");
			boxWidth += (this.width + 2);
		});
		po.push("<div style=\"clear:both\"></div>");
		po.push("<div align=\"center\" style=\"padding-top:5px;\">");
		po.push("	<input type=\"button\" value=\"확인\" class=\"AXButton\" id=\""+cfg.targetID + "_AX_expandScrollBox_AX_confirm\" />");
		po.push("	<input type=\"button\" value=\"취소\" class=\"AXButton\" id=\""+cfg.targetID + "_AX_expandScrollBox_AX_cancel\" />");
		po.push("</div>");
		po.push("</div>");
		axdom(document.body).append(po.join(''));
		
		boxWidth = boxWidth + (cfg.optionGroup.length * 5) + 5;
		axdom("#"+cfg.targetID + "_AX_expandBox").css({width:boxWidth});
		
    	var css = {};
    	var offset = axdom("#"+cfg.targetID).offset();
    	css.top = offset.top;
    	//css.left = offset.left - boxWidth + axdom("#"+cfg.targetID).outerWidth();
    	css.left = offset.left;
    	axdom("#"+cfg.targetID + "_AX_expandBox").css(css);


		axdom.each(cfg.optionGroup, function(gidx, G){
			G.myUIScroll = new AXScroll();
			G.myUIScroll.setConfig({
				CT_className:"AXScrollSmall",
				targetID:cfg.targetID + "_AX_expandScrollBox_AX_"+gidx,
				scrollID:cfg.targetID + "_AX_expandScroll_AX_"+gidx,
				touchDirection:false
			});
			
			var selectedValue = "";
			if (G.getOptionValue) selectedValue = G.getOptionValue.call(G);

			axdom.each(cfg.optionGroup[gidx].options, function (oidx, O) {
				if (G.getOptionValue) {
					if (O.optionValue == selectedValue) {
						O.selected = true;
						axdom("#" + cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx).addClass("on");
						G.myUIScroll.focusElement(cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx); //focus
					}
				}else if(O.selected){
					O.selected = true;
					axdom("#" + cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx).addClass("on");
					G.myUIScroll.focusElement(cfg.targetID + "_AX_" + gidx + "_AX_option_AX_" + oidx); //focus
				} else {
					cfg.optionGroup[gidx].options[oidx].selected = false;
				}
			});
			
		});
		
		axdom("#"+cfg.targetID + "_AX_expandScrollBox_AX_confirm").bind("click", function(){
			if(cfg.onChange){
				var selectObj = {};
				axdom.each(cfg.optionGroup, function(gidx, G){
					selectObj[G.name] = {};
					axdom.each(cfg.optionGroup[gidx].options, function(oidx, O){
						if(O.selected){
							selectObj[G.name] = O;
						}
					});
				});
				cfg.onChange.call(selectObj);
			}
			axdom("#"+cfg.targetID + "_AX_expandBox").remove(); // 개체 삭제 처리
		});
		axdom("#"+cfg.targetID + "_AX_expandScrollBox_AX_cancel").bind("click", function(){
			axdom("#"+cfg.targetID + "_AX_expandBox").remove(); // 개체 삭제 처리
		});
		
		axdom("#"+cfg.targetID + "_AX_expandBox").find(".bindSelectorNodes").bind("click", function(event){
			var idx = event.target.id.split(/_AX_/g);
			var gidx = idx[idx.length-3];
			var index = idx[idx.length-1];
			
			axdom("#"+cfg.targetID + "_AX_"+gidx+"_AX_option_AX_"+index).addClass("on");
			
			axdom.each(cfg.optionGroup[gidx].options, function(oidx, O){
				if(O.selected){
					axdom("#"+cfg.targetID + "_AX_"+gidx+"_AX_option_AX_"+oidx).removeClass("on");
					delete O.selected;
				}
			});
			cfg.optionGroup[gidx].options[index].selected = true;
			
		});
    },
    setValue: function(obj){
    	var cfg = this.config;
    	axdom.each(cfg.optionGroup, function(gidx, G){
    		axdom.each(obj, function(k, v){
    			if(G.name == k){
    				axdom.each(G.options, function(){
    					if(this.optionValue+"" == v+""){
    						this.selected = true;
    					}else{
    						delete this.selected;
    					}
    				});
    				
    			}
    		});
    	});
    	
    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
/**
 * AXProgress
 * @class AXProgress
 * @extends AXJ
 * @version v1.1
 * @author tom@axisj.com
 * @logs
 "2012-12-19 오후 5:47:58",
 "2014-02-03 오후 9:29:34 : tom count 표시문제 해결"
 "2014-10-15 groovedk : 주석추가"
 */

var AXProgress = Class.create(AXJ, {
/**
 * @method AXProgress.initialize
 * @param {fn} -
 * @param {jsObject} [options] - config.options 에 할당 / 추가
 * @description
 * 프로그래스바를 시작합니다. options 를 지정하지 않으면 setConfig에 지정한 속성을 이용하여 프로그래스바를 시작합니다.
 * @example
 ```
var myProgress = new AXProgress();

myProgress.setConfig({
	theme:"AXlineProgress", //[String = "AXlineProgress"] - 프로그래스 CSS Class 이름 AXlineProgress, AXCircleProgress 클래스가 기본 제공됩니다.
	totalCount:100,         //{number} - 프로그래스 전체 카운트 수
	width:400,              //{number} - 프로그래스바 너비
	top:100,                //{number} - 프로그래스바 표시 위치
	title:"AXProgress BAR", //{String} - 프로그래스바 제목
	duration:50             //{number = 50} - 프로그래스바의 애니메이션 속도 값 입니다.
});

 ```
 */
	initialize: function(AXJ_super) {
		AXJ_super();
		this.Observer = null;
		//this.config.easing = {duration:10, easing:""};
		this.config.duration = 50;
		this.config.theme = "AXlineProgress";
	},
	init: function(){
		
	},

/**
 * @method AXProgress.start
 * @param {fn} - callBack function
 * @param {jsObject} [options] - config.options 에 할당 / 추가
 * @description
 * 프로그래스바를 시작합니다. options 를 지정하지 않으면 setConfig에 지정한 속성을 이용하여 프로그래스바를 시작합니다.
 * @example
 ```
var myProgress = new AXProgress();

myProgress.start(function(){
	trace(this);
	if(this.isEnd){
		myProgress.close();
		mask.close();
		toast.push("progress end");
	}else{
		// 무언가 처리를 해줍니다.	대부분 비동기 AJAX 통신 처리 구문을 수행합니다.
		myProgress.update(); // 프로그레스의 다음 카운트를 시작합니다.
	}
});

// options 지정방식
mask.open();
myProgress.start(function(){
    if(this.isEnd){
		myProgress.close();
		mask.close();
		toast.push("progress end");
	}else{
		// 무언가 처리를 해줍니다.	대부분 비동기 AJAX 통신 처리 구문을 수행합니다.
		myProgress.update(); // 프로그레스의 다음 카운트를 시작합니다.
	}},
    {
        totalCount:10,
        width:500,
        top:200,
        title:"Set Options Type Progress"
    }
);

 ```
 */
	start: function(callBack, options){
		var config = this.config;
		config.callBack = callBack;
		
		config.options = options;
		
		var totalCount = config.totalCount || 100;
		this.loadedCount = 0;
		var loadedCount = this.loadedCount;
		var loadedRate = (loadedCount / totalCount * 100).round(1);
		var progressWidth = config.width || 200;
		var progressTitle = config.title || "";
		var progressTop = config.top || 0;
		this.progressID = "progress_AX_"+AXUtil.timekey();
		var progressID = this.progressID;
		this.progressStop = false;
		var theme = config.theme;
		
		var hasCancel = false;
		
		if(config.options){
			if(config.options.totalCount) totalCount = config.options.totalCount;
			if(config.options.width) progressWidth = config.options.width;
			if(config.options.top) progressTop = config.options.top;
			if(config.options.title) progressTitle = config.options.title;
			if(config.options.cancel) hasCancel = config.options.cancel;
			if(config.options.theme) theme = config.options.theme;
		}

		var po = [];
		po.push("<div class=\"AXprogressTray "+theme+"\" id=\""+progressID+"_AX_tray\" align=\"center\" style=\"top:"+progressTop+"px;\">");
		if(progressTitle != ""){
			po.push("	<div class=\"AXprogressTitle\" id=\""+progressID+"_AX_title\" style=\"width:"+progressWidth+"px;\" align=\"left\">"+progressTitle+"</div>");
		}
		po.push("<div class=\"AXprogress\" id=\""+progressID+"\" style=\"width:"+progressWidth+"px;\">");
		po.push("	<div class=\"AXprogressContainer\" id=\""+progressID+"_AX_container\" align=\"left\" style=\"overflow:hidden;\">");
		if(theme == "AXlineProgress") po.push("		<div class=\"AXprogressBar\" id=\""+progressID+"_AX_bar\" style=\"width:"+loadedRate+"%;\"></div>");
		else  po.push("		<div class=\"AXprogressBar\" id=\""+progressID+"_AX_bar\"></div>");

		po.push("	</div>");

        po.push("    <div class=\"AXprogressLoadedText\" id=\""+progressID+"_AX_loadedText\">"+loadedRate+"%</div>");

		if(hasCancel){
			po.push(" <a href=\"#axexec\" id=\""+progressID+"_AX_cancel\" class=\"AXprogressCancel\">Cancel</a>");
		}

		po.push("</div>");
				
		po.push("</div>");
		this.progress = axdom(po.join(''));
		axdom(document.body).append(this.progress);
		
		axdom("#"+progressID+"_AX_cancel").bind("click", this.cancel.bind(this));
        this.loadedCount = 1;
		this.update();
	},

/**
 * @method AXProgress.update
 * @description - 프로그레스바 진행 상태를 업데이트 합니다.
 * @example
 ```
myProgress.update();
 ```
 */
	update: function(){
		var config = this.config;
		var theme = config.theme;
		
		if(this.progressStop) return;

		var totalCount = config.totalCount || 100;

		if(config.options){
			if(config.options.totalCount) totalCount = config.options.totalCount;
			if(config.options.theme) theme = config.options.theme;
		}
		
		var loadedCount = this.loadedCount;
		
		var progressID = this.progressID;
		var loadedRate = ((loadedCount-1) / (totalCount.number()) * 100).round(1);
		if(loadedRate > 100) loadedRate = 100;
		axdom("#"+progressID+"_AX_loadedText").html(loadedRate+"%<span>"+(loadedCount-1).money()+"/"+totalCount.money()+"</span>");
		
		if(theme == "AXlineProgress"){
			axdom("#"+progressID+"_AX_bar").animate(
				{width:loadedRate+"%"},
				config.duration, "", 
				function(){
					if(config.callBack){
						config.callBack.call({
							totalCount:totalCount,
							loadedCount:loadedCount,
							loadedRate:(loadedCount / (totalCount.number()+1) * 100).round(1),
							isEnd:((loadedCount-1) == totalCount)
						});
					}
				}
			);
		}else{
			//circle
			setTimeout(function(){
				axdom("#"+progressID+"_AX_bar").addClass("percent"+((loadedCount / (totalCount.number()) * 100).round(0) / 5).round() * 5);
				if(config.callBack){
					config.callBack.call({
						totalCount:totalCount,
						loadedCount:loadedCount-1,
						loadedRate:(loadedCount / (totalCount.number()+1) * 100).round(1),
						isEnd:((loadedCount-1) == totalCount)
					});
				}				
			}, config.duration);
		}
		this.loadedCount++;
	},

/**
 * @method AXProgress.cancel
 * @description - 프로그래스바 진행을 중지합니다.
 * @example
 ```
myProgress.cancel();
 ```
 */
	cancel: function(){
		var config = this.config;
		var progressID = this.progressID;
		var cancelMSg = AXConfig.AXProgress.cancelMsg;
		if(config.options){
			var cancel = config.options.cancel;
			if(cancel.confirmMsg) cancelMSg = cancel.confirmMsg;
			if(confirm(cancelMSg)){
				this.progressStop = true;
				var totalCount = config.totalCount || 100;
				var loadedCount = this.loadedCount;
				cancel.oncancel.call({
					totalCount:totalCount,
					loadedCount:loadedCount,
					loadedRate:(loadedCount / totalCount * 100).round(1),
					isEnd:(loadedCount == totalCount)
				});
			}else{
				
			}
		}
	},

/**
 * @method AXProgress.restart
 * @description - 중지된 프로그레스바 진행상태를 재시작 합니다.
 * @example
 ```
myProgress.restart();
 ```
 */
	restart: function(){
		this.progressStop = false;
		this.update();
    },

/**
 * @method AXProgress.close
 * @description - 프로그레스바 창을 닫습니다.
 * @example
 ```
myProgress.close();
 ```
 */
	close: function(){
		var config = this.config;
		var progressID = this.progressID;
		axdom("#"+progressID+"_AX_tray").remove();
	}
});
/* ---------------------------- */
/**
 * @method AXSearch.setConfig
 * @param {Object} config - searchConfig
 * @description
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @example
 * ```js
 * var mySearch = new AXSearch();
 * mySearch.setConfig({
 *     targetID:"AXSearchTarget",  //{string} - AXSearch 클래스 코딩이 처리될 HTML 엘리먼트 타겟아이디
 *     theme : "AXSearch",         //[string = "AXSearch"] - AXSearch 에 적용될 CSS Class 이름
 *     onsubmit: function(){       //[fn] - Function AXSearch 가 onsubmit 이벤트 발생되었을 때 연결되는 콜백함수
 *         fnObj.search1(); // 버튼이 선언되지 않았거나 submit 개체가 있는 경우 발동 합니다.
 *     },
 *     rows:[  //AXSearch 의 각 row는 배열로 정의합니다.
 *         {
 *             display:true,       //[boolean=true] - 해당 줄의 노출 여부. 숨겨진 row의 경우 사용자의 선택으로 활성화 처리할 수 있습니다.
 *             addClass:"gray",    //[string] - row에 추가될 CSS 클래스
 *             style:"",           //[string] - row에 추가될 CSS style
 *             list:[
 *                 {
 *                     label:"공개설정",   //[string] - 아이템 라벨
 *                     labelWidth:"100",   //[number] - 라벨너비
 *                     type:"link",        //[string] - 아이템 타입 ( link | checkBox | radioBox | selectBox | inputText | button | submit )
 *                     width:"",           //[number] - 아이템 너비
 *                     key:"openType",     //[string] - 아이템 유니크 키
 *                     addClass:"",        //[string] - 아이템 엘리먼트에 추가될 CSS 클래스
 *                     valueBoxStyle:"",   //[string] - 아이템 엘리먼트에 추가될 CSS style
 *                     value:"open",       //[string] - 아이템 value ( options 가 정의되는 아이템 link | checkBox | radioBox | selectBox 에는 정의할 수 없습니다 )
 *                     options:[       //select options
 *                         {optionValue:"all", optionText:"전체보기"},
 *                         {optionValue:"open", optionText:"공개"},
 *                         {optionValue:"close", optionText:"비공개"},
 *                         {optionValue:"close2", optionText:"비공개2", display:false},
 *                         {optionValue:"close3", optionText:"비공개3", display:false},
 *                         {optionValue:"close4", optionText:"비공개4", display:false}
 *                     ],
 *                     onChange: function(selectedObject, value){  //[fn] - onchange 이벤트 바인드
 *                     },
 *                     onClcik: function(selectedObject, value){  //[fn] - onclick 이벤트 바인드
 *                     }
 *                 }
 *             ]
 *         }
 *     ]
 * });
 * ```
 */

var AXSearch = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
        this.formbindMethod = "script";
        this.config.theme = "AXSearch";
        this.config.viewMode = "dx";
    },
    init: function() {
        var cfg = this.config;
        if(Object.isUndefined(cfg.targetID)){
            trace("need targetID - setConfig({targetID:''})");
            return;
        }

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }

        this.target = axdom("#"+cfg.targetID);

        // 스크립트 바인드 방식
        if(cfg.rows)
        {
            this.formbindMethod = "script";
            this.setBody();
            axdom(window).bind("resize", this.windowResize.bind(this));
        }

        // tagBind 방식
        else
        if(this.target.get(0).tagName.lcase() == "form")
        {
            this.formbindMethod = "tag";
            this.target.bind("submit", function(event){
                cfg.onsubmit();
                return false;
            });

            if(cfg.onkeydown) {
                if(cfg.keydown_check_classname){
                    this.target.find("."+cfg.keydown_check_classname).bind("keydown.axsearch", function (event) {
                        cfg.onkeydown(event);
                    });
                }
                else
                {
                    this.target.bind("keydown", function (event) {
                        cfg.onkeydown(event);
                    });
                }
            }
            if(cfg.onkeyup) {
                if(cfg.keyup_check_classname){
                    this.target.find("."+cfg.keyup_check_classname).bind("keyup.axsearch", function (event) {
                        cfg.onkeyup(event);
                    });
                }
                else
                {
                    this.target.bind("keyup", function (event) {
                        cfg.onkeyup(event);
                    });
                }
            }
            if(cfg.onreturn) {
                if(cfg.return_check_classname){
                    this.target.find("."+cfg.return_check_classname).bind("keydown.axsearch", function (event) {
                        if(event.keyCode == axf.Event.KEY_RETURN) cfg.onreturn(event);
                    });
                }
                else
                {
                    this.target.bind("keydown", function (event) {
                        if(event.keyCode == axf.Event.KEY_RETURN) cfg.onreturn(event);
                    });
                }
            }
            // onchange 연결
            if(cfg.onchange){
                if(cfg.change_check_classname){
                    this.target.find("."+cfg.change_check_classname).bind("change.axsearch", function (event) {
                        cfg.onchange(event);
                    });
                }
                else
                {
                    this.target.find("input, select, textarea").bind("change.axsearch", function(event){
                        cfg.onchange(event);
                    });
                }
            }
            // onfocus 연결
            if(cfg.onfocus){
                if(cfg.focus_check_classname){
                    this.target.find("."+cfg.focus_check_classname).bind("focus.axsearch", function (event) {
                        cfg.onfocus(event);
                    });
                }
                else
                {
                    this.target.find("input, select, textarea").bind("focus.axsearch", function(event){
                        cfg.onfocus(event);
                    });
                }
            }
        }
    },
    windowResizeApply: function () {
        var cfg = this.config;

        if (cfg.mediaQuery) {
            var _viewMode = "", clientWidth = axf.clientWidth();
            axf.each(cfg.mediaQuery, function (k, v) {
                if (Object.isObject(v)) {

                    if(v.min != undefined && v.max != undefined){
                        if (v.min <= clientWidth && clientWidth <= v.max) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }else{
                        if (v.min <= clientWidth) {
                            _viewMode = (k == "dx") ? "dx" : "mx";
                            return false;
                        }
                    }
                }
            });
            if (_viewMode != "") {
                cfg.viewMode = _viewMode;
            }
        }
        this.target.find("."+cfg.theme).removeClass("dx");
        this.target.find("."+cfg.theme).removeClass("mx");
        this.target.find("."+cfg.theme).addClass(cfg.viewMode);
    },
    getItemHtml: function(gr, itemIndex, item){
        var cfg = this.config;
        var po = [];
        var itemAddClass = [];
        var itemAddStyles = [];
        var poAttr = [];
        if(item.addClass) itemAddClass.push(item.addClass);
        if(item.style) itemAddStyles.push(item.style);
        if(item.addAttr){
            axdom.each(item.addAttr, function(idx, attr){
                poAttr.push(attr.attrKey + "=" + attr.attrValue);
            });
        }
        if(item.type == "label"){

            po.push("<div class=\"searchItem searchLabel ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push(item.value);
            po.push("</div>");

        }
        else
        if(item.type == "link"){

            po.push("<div class=\"searchItem searchLink ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<input type=\"hidden\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" value=\"", item.value,"\" />");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            axdom.each(item.options, function(idx, Opt){
                if(idx > 0) po.push(" | ");
                var classOn = "";
                if(item.value == Opt.optionValue){
                    classOn = " on";
                    item.selectedIndex = idx;
                }
                po.push("<a href=\"#Axexec\" class=\"searchLinkItem", classOn, "\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key + "_AX_" + idx, "\" title=\"", (Opt.title||""),"\">", Opt.optionText,"</a>");
            });
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }
        else
        if(item.type == "checkBox"){

            po.push("<div class=\"searchItem searchCheckbox ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<span class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");

            var values = item.value.split(/,/g);
            axdom.each(item.options, function(idx, Opt){
                var isCheck = false;
                axdom.each(values, function(){
                    if(this == Opt.optionValue){
                        isCheck = true;
                        return false;
                    }
                });
                po.push("<input type=\"checkbox\" class=\"searchCheckboxItem ", itemAddClass.join(" "),"\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx, "\" title=\"", (Opt.title||""),"\" value=\"", Opt.optionValue,"\" ");
                if(isCheck) po.push(" checked=\"checked\" ");
                po.push(">");
                po.push("<label for=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx, "\">", Opt.optionText," </label>");
            });

            po.push("</span>");
            po.push("</span>");
            po.push("</div>");

        }
        else
        if(item.type == "radioBox"){

            po.push("<div class=\"searchItem searchCheckbox ", itemAddClass.join(" "),"\" style=\"width:", (item.width||""),"px;text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");

            var values = item.value.split(/,/g);
            axdom.each(item.options, function(idx, Opt){
                var isCheck = false;
                axdom.each(values, function(){
                    if(this == Opt.optionValue){
                        isCheck = true;
                        return false;
                    }
                });
                po.push("<input type=\"radio\" class=\"searchCheckboxItem ", itemAddClass.join(" "),"\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx,"\" title=\"", (item.title||""),"\" value=\"", Opt.optionValue,"\" ");
                if(isCheck) po.push(" checked=\"checked\" ");
                po.push(">");
                po.push("<label for=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key,"_AX_", idx,"\">", Opt.optionText," </label>");
            });

            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }else if(item.type == "selectBox"){

            po.push("<div class=\"searchItem searchSelectbox ", itemAddClass.join(" "),"\" style=\"text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td selectBox\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            var selectWidth = (item.width) ? item.width+"px" : "auto";
            po.push("	<select name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" title=\"", (item.title||""),"\" class=\"AXSelect searchSelectboxItem ", itemAddClass.join(" "),"\" style=\"width:", selectWidth,";\" "+poAttr.join(' ')+" >");

            var values = item.value.split(/,/g);
            axdom.each(item.options, function(idx, Opt){
                var isCheck = false;
                axdom.each(values, function(){
                    if(this == Opt.optionValue){
                        isCheck = true;
                        return false;
                    }
                });

                po.push("<option value=\"", Opt.optionValue,"\"");
                if(isCheck) po.push(" selected=\"selected\"");
                po.push(">", Opt.optionText, "</option>");
            });
            po.push("	</select>");
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }else if(item.type == "inputText"){

            po.push("<div class=\"searchItem ", itemAddClass.join(" "),"\" style=\"text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td inputText\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            var inputWidth = (item.width||100).number();
            po.push("				<input type=\"text\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" title=\"", (item.title||""),"\" placeholder=\""+ (item.placeholder||"") +"\" value=\"", item.value,"\" class=\"AXInput searchInputTextItem ", itemAddClass.join(" "),"\" style=\"width:", inputWidth,"px;\" "+poAttr.join(' ')+" />");
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");

        }else if(item.type == "hidden"){
            po.push("<input type=\"hidden\" name=\"", item.key,"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" value=\"", item.value,"\" />");
        }else if(item.type == "button" || item.type == "submit"){
            po.push("<div class=\"searchItem ", itemAddClass.join(" "),"\" style=\"text-align:", (item.align||"center"),";", itemAddStyles.join(''),"\">");
            po.push("<label class=\"itemTable\">");
            if(item.label) {
                po.push("<span class=\"th\" style=\"min-width:", (item.labelWidth || 100), "px;\">");
                po.push(item.label);
                po.push("</span>");
            }else{
                //po.push("<span class=\"th none\">&nbsp;</span>");
            }
            po.push("<span class=\"td button\" style=\"",(item.valueBoxStyle||""),"\" title=\"", (item.title||""),"\">");
            var inputWidth = (item.width||100).number();
            po.push("<button type=\""+ item.type +"\" id=\"", cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key, "\" title=\"", (item.title||""),"\" placeholder=\"", (item.placeholder||""),"\" style=\"width:", inputWidth,"px;\" class=\"AXButton searchButtonItem ", itemAddClass.join(" "),"\">", item.value,"</button>");
            po.push("</span>");
            po.push("</label>");
            po.push("</div>");
        }
        return po.join('');
    },
    setBody: function(){
        var cfg = this.config;
        var getItemHtml = this.getItemHtml.bind(this);
        var po = [];
        var AXBinds = [];

        po.push("<div class=\"" + cfg.theme + " " + cfg.viewMode + "\">");
        po.push("<form name=\"", cfg.targetID+"_AX_form", "\" onsubmit=\"return false;\">");
        var gr = 0;
        var hasHide = false;
        for(;gr<cfg.rows.length;){
            var styles = [];
            var classs = [];
            if(!cfg.rows[gr].display){
                styles.push("display:none;");
                classs.push("expandGroup");
                hasHide = true;
            }
            if(cfg.rows[gr].addClass) classs.push(cfg.rows[gr].addClass);
            po.push("<div class=\"searchGroup ", classs.join(" "),"\" style=\"", styles.join(";"),"\">");
            axdom.each(cfg.rows[gr].list, function(itemIndex, item){
                po.push(getItemHtml(gr, itemIndex, item));
                if(item.AXBind){
                    AXBinds.push({display:cfg.rows[gr].display, gr:gr, itemIndex:itemIndex, item:item});
                }
                po.push("<div class=\"itemClear\"></div>");
            });
            po.push("<div class=\"groupClear\"></div>");
            po.push("</div>");
            gr++;
        }
        if(hasHide){
            po.push("<a href=\"#axexec\" class=\"expandHandle\" id=\"",cfg.targetID,"_AX_expandHandle\">");
            po.push("상세검색");
            po.push("</a>");
        }
        po.push("</form>");
        po.push("</div>");

        this.target.html(po.join(''));

        if(cfg.onsubmit){
            document[cfg.targetID+"_AX_form"].onsubmit = function(){
                cfg.onsubmit();
                return false;
            };
        }

        axdom("#"+cfg.targetID+"_AX_expandHandle").bind("click", this.expandToggle.bind(this));
        this.target.find(".searchLinkItem").bind("click", this.onclickLinkItem.bind(this));
        this.target.find(".searchCheckboxItem").bind("click", this.onclickCheckboxItem.bind(this));
        this.target.find(".searchSelectboxItem").bind("change", this.onChangeSelect.bind(this));
        this.target.find(".searchInputTextItem").bind("change", this.onChangeInput.bind(this));
        this.target.find(".searchButtonItem").bind("click", this.onclickButton.bind(this));

        this.target.find(".searchInputTextItem").bind("focus", this.onFocusInput.bind(this));
	    this.target.find(".searchInputTextItem").bind("keydown", this.onKeyDownInput.bind(this));
	    this.target.find(".searchInputTextItem").bind("keyup", this.onKeyUpInput.bind(this));

        this.AXBinds = AXBinds;

        var _this = this;
        setTimeout(function(){
            _this.AXBindItems();
        }, 10);
    },
    AXBindItems: function(){
        var cfg = this.config;
        axdom.each(this.AXBinds, function(){
            var gr = this.gr, itemIndex = this.itemIndex, item = this.item;
            var display = this.display;
            var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;

            if(display){
                if(item.AXBind.type == "selector"){
                    axdom("#"+itemID).bindSelector(item.AXBind.config);
                }else if(item.AXBind.type == "select"){
                    try{
                        axdom("#"+itemID).bindSelect(item.AXBind.config);
                    }catch(e){
                    }
                }else if(item.AXBind.type == "date"){
                    axdom("#"+itemID).bindDate(item.AXBind.config);
                }else if(item.AXBind.type == "twinDate"){
                    var startTargetID = item.AXBind.config.startTargetID;
                    var findItemID = "";
                    axdom.each(cfg.rows, function(gidx, G){
                        axdom.each(this.list, function(itemIndex, item){
                            if(item.key == startTargetID){
                                findItemID = cfg.targetID + "_AX_" + gidx + "_AX_" + itemIndex + "_AX_" + item.key;
                            }
                        });
                    });
                    item.AXBind.config.startTargetID = findItemID;
                    axdom("#"+itemID).bindTwinDate(item.AXBind.config);
                }
            }
        });
    },
    expandToggle: function(){
        var cfg = this.config;
        if(this.expanded){
            axdom("#"+cfg.targetID+"_AX_expandHandle").html("상세검색");
            this.target.find(".expandGroup").hide();
            this.expanded = false;
        }else{
            axdom("#"+cfg.targetID+"_AX_expandHandle").html("상세검색창 닫기");
            this.target.find(".expandGroup").show();
            this.expanded = true;

            axdom.each(this.AXBinds, function(){
                var gr = this.gr, itemIndex = this.itemIndex, item = this.item;
                var display = this.display;
                var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                if(!display){
                    if(item.AXBind.type == "selector"){
                        axdom("#"+itemID).bindSelector(item.AXBind.config);
                    }else if(item.AXBind.type == "select"){
                        axdom("#"+itemID).bindSelect(item.AXBind.config);
                    }else if(item.AXBind.type == "date"){
                        axdom("#"+itemID).bindDate(item.AXBind.config);
                    }else if(item.AXBind.type == "twinDate"){

                        var startTargetID = item.AXBind.config.startTargetID.split(/_AX_/g).last();
                        var findItemID = "";
                        axdom.each(cfg.rows, function(gidx, G){
                            axdom.each(this.list, function(itemIndex, item){
                                if(item.key == startTargetID){
                                    findItemID = cfg.targetID + "_AX_" + gidx + "_AX_" + itemIndex + "_AX_" + item.key;
                                }
                            });
                        });

                        item.AXBind.config.startTargetID = findItemID;
                        axdom("#"+itemID).bindTwinDate(item.AXBind.config);

                    }
                }
            });

        }
    },
    onclickLinkItem: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var index = ids.pop();
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];
        //trace({itemIndex:itemIndex, item:item});

        var targetID = "";
        axdom.each(ids, function(ii, io){
            if(ii > 0) targetID += "_AX_";
            targetID += this;
        });
        //trace(item.options[index].optionValue);

        if(item.selectedIndex != undefined){
            axdom("#"+targetID+"_AX_"+item.selectedIndex).removeClass("on");
        }

        item.selectedIndex = index;
        item.value = item.options[index].optionValue;
        axdom("#"+targetID+"_AX_"+index).addClass("on");
        axdom("#"+targetID).val(item.options[index].optionValue);

        if(item.onChange){
            item.onChange.call(item, item.options[index], item.options[index].optionValue);
        }
    },
    onclickCheckboxItem: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var index = ids.pop();
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var selectedIndex = 0;
        var selectedValue = "";

        if(isNaN(frm[item.key].length)){
            if(frm[item.key].checked){
                selectedValue = frm[item.key].value;
            }
        }else{
            for(var i=0;i<frm[item.key].length;i++){
                if(frm[item.key][i].checked){
                    selectedValue += (selectedValue == "") ? frm[item.key][i].value : "," + frm[item.key][i].value;
                }
            }
        }

        item.selectedIndex = index;
        item.value = selectedValue;

        if(item.onChange){
            item.onChange.call(item, item.options[index], selectedValue);
        }
    },
    onChangeSelect: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var selectedIndex = frm[item.key].selectedIndex;
        var selectedValue = frm[item.key].options[selectedIndex].value;

        if(item.onChange){
            item.onChange.call(item, item.options[selectedIndex], selectedValue);
        }
    },
    onChangeInput: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var changeValue = frm[item.key].value;

        if(item.onChange){
            item.onChange.call(item, changeValue);
        }
    },
    onFocusInput: function(event){
        var cfg = this.config;
        var ids = (event.target.id).split(/_AX_/g);
        var gr = ids[ids.length-3];
        var itemIndex = ids[ids.length-2];
        var item = cfg.rows[gr].list[itemIndex];

        var frm = document[cfg.targetID+"_AX_form"];
        var focusValue = frm[item.key].value;

        if(item.onFocus){
            item.onFocus.call(item, focusValue, frm[item.key]);
        }
    },
    onclickButton: function(event){
        var cfg = this.config;
        var target = axf.get_event_target(event.target, function(el){
            if((el.tagName||"").ucase() == "BUTTON"){
                return true;
            }
        });
        if(target){
            var ids = (target.id).split(/_AX_/g);
            var gr = ids[ids.length-3];
            var itemIndex = ids[ids.length-2];
            var item = cfg.rows[gr].list[itemIndex];

            if(item.onclick){
                item.onclick.call(item);
            }
        }
    },
	onKeyDownInput: function(event){
		var cfg = this.config;
		var ids = (event.target.id).split(/_AX_/g);
		var gr = ids[ids.length-3];
		var itemIndex = ids[ids.length-2];
		var item = cfg.rows[gr].list[itemIndex];

		var frm = document[cfg.targetID+"_AX_form"];
		var changeValue = frm[item.key].value;

		if(item.onkeydown){
			item.onkeydown.call(item, event, changeValue);
		}
	},
	onKeyUpInput: function(event){
		var cfg = this.config;
		var ids = (event.target.id).split(/_AX_/g);
		var gr = ids[ids.length-3];
		var itemIndex = ids[ids.length-2];
		var item = cfg.rows[gr].list[itemIndex];

		var frm = document[cfg.targetID+"_AX_form"];
		var changeValue = frm[item.key].value;

		if(item.onkeyup){
			item.onkeyup.call(item, event, changeValue);
		}
	},
    /**
     * @method AXSearch.getParam
     * @returns {string}
     * @description 파라미터 형태로 값을 반환합니다.
     * @example
     * ```js
     * var pars = mySearch.getParam();
     * trace(pars);
     * // a=11&b=22&c=33
     * ```
     */
    getParam: function(){
        var cfg = this.config;
        var frm = (this.formbindMethod == "script") ? document[cfg.targetID+"_AX_form"] : this.target;
        return axdom(frm).serialize();
    },
    /**
     * @method AXSearch.reset
     * @returns {AXSearch}
     * @description search폼 입력 정보를 리셋합니다.
     * @example
     * ```js
     * mySearch.reset();
     * ```
     */
    reset: function(){
        var cfg = this.config;
        var frm = (this.formbindMethod == "script") ? document[cfg.targetID+"_AX_form"] : this.target;
        axdom(frm).get(0).reset();

        axdom(frm).find("[data-axbind=select]").bindSelectUpdate();
        //.trigger("change");

        return this;
    },

    /**
     * @method AXSearch.getItemId
     * @param {String} key - item key name
     * @description AXSearch내 엘리먼트 id를 반환합니다.
     * @example
     * ```js
     * mySearch.getItemId("type");
     * // element id;
     * ```
     */
    getItemId: function(key, value){
        var cfg = this.config;
        var gr = 0;
        var itemID;
        for(;gr<cfg.rows.length;){
            axdom.each(cfg.rows[gr].list, function(itemIndex, item){
                if(item.key == key){
                    if(item.type == "checkBox" || item.type == "radioBox"){
                        itemID = [];
                        axdom.each(item.options, function(idx, Opt){
                            itemID.push(cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key + "_AX_" + idx);
                        });
                    }else{
                        itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                        return false;
                    }
                }
            });
            gr++;
        }
        return itemID;
    },
    /**
     * @method AXSearch.setItemValue
     * @param {String} key - item key name
     * @param {String|Array} value - item key name
     * @description 단일 속성인 대상에는 String, 다중 속성인 대상에는 Array 로 값을 지정할 수 있습니다. value 가 지정되지 않은 경우 빈 값으로 처리합니다.
     * @example
     * ```js
     * mySearch.setItemValue("checkbox", ["all","open"]);
     * mySearch.setItemValue("radiobox");
     * mySearch.setItemValue("inputText2"); // 빈값을 입력함으로써 입력된 값을 지울 수 있습니다.
     * ```
     */
    setItemValue: function(key, value){
        var cfg = this.config;
        var gr = 0;
        for(;gr<cfg.rows.length;){
            axdom.each(cfg.rows[gr].list, function(itemIndex, item){
                if(item.key == key){
                    if(item.type == "checkBox" || item.type == "radioBox"){
                        var values = [];
                        if(Object.isArray(value)){
                            values = value;
                        }else if(value == ""){

                        }else{
                            values.push(value);
                        }
                        axdom.each(item.options, function(idx, Opt){
                            var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key + "_AX_" + idx;
                            var isCheck = false;
                            axdom.each(values, function(){ if(this == Opt.optionValue){ isCheck = true; return false; } });
                            AXgetId(itemID).checked = isCheck;
                            itemID = null;
                        });
                    }
                    else
                    if(item.type == "selectBox"){
                        var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                        var item_dom = axdom("#"+itemID);
                        if(item_dom.attr("data-axbind")){
                            item_dom.bindSelectSetValue((value||""));
                        }else{
                            item_dom.val((value||""));
                        }
                    }
                    else
                    {
                        var itemID = cfg.targetID + "_AX_" + gr + "_AX_" + itemIndex + "_AX_" + item.key;
                        axdom("#"+itemID).val((value||""));
                        itemID = null;
                    }
                }
            });
            gr++;
        }
    },

	/**
	 * @method AXSearch.submit
	 */
	submit: function(){
		var cfg = this.config;
		if(cfg.onsubmit) cfg.onsubmit();
		return this;
	}
});
/* ---------------------------- */
var AXSelectConverter = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.objects = [];
        this.config.anchorClassName = "AXanchor";
        this.config.anchorSelectClassName = "AXanchorSelect";
    },
    init: function () {
        var browser = AXUtil.browser;
        this.isMobile = browser.mobile;
        //axdom(window).resize(this.windowResize.bind(this));
        axdom(window).resize(this.alignAllAnchor.bind(this));

        this.config.reserveKeys = {
            options: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptions) || "options",
            optionValue: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionValue) || "optionValue",
            optionText: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionText) || "optionText",
            optionData: (AXConfig.AXSelect && AXConfig.AXSelect.keyOptionData) || "optionData"
        };
    },
    windowResize: function () {
        // 사용안함
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 10);
    },
    windowResizeApply: function () {
        // 사용안함
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.alignAllAnchor();
    },
    alignAllAnchor: function () {
        for (var i = 0; i < this.objects.length; i++) {
            this.alignAnchor(this.objects[i].id, i);
        }
    },
    bindSetConfig: function (objID, configs) {
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
        } else {
            var _self = this.objects[findIndex];
            axdom.each(configs, function (k, v) {
                _self.config[k] = v;
            });
        }
    },
    unbind: function (obj) {
        //var collect = [];
        var removeAnchorId;
        var removeIdx;
        //trace(this.objects);
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id != obj.id) {
                // collect.push(this);

            } else {
                if (O.isDel != true) {
                    removeAnchorId = O.anchorID;
                    removeIdx = index;
                }
            }
        }
        //this.objects = collect;

        if (removeAnchorId) {
            var objDom = axdom("#" + obj.id), objAnchorDom = axdom("#" + removeAnchorId);
            this.objects[removeIdx].isDel = true;
            objDom.removeAttr("data-axbind");
            objDom.css({visibility: "visible"});

            if (this.isMobile) {
                objAnchorDom.before(axdom("#" + obj.id));
                objAnchorDom.remove();
            } else {
                objAnchorDom.remove();
                objDom.show();
            }
        }
    },
    bind: function (obj) {
        var cfg = this.config;
        if (!AXgetId(obj.id)) {
            obj.id = "AXSelect-" + axf.getUniqueId();
        }

        var objID = obj.id, objSeq = null, objConfig = {}, reserveKeys = jQuery.extend({}, cfg.reserveKeys);
        objConfig = jQuery.extend(objConfig, obj, true);
        if (typeof objConfig.reserveKeys == "undefined") objConfig.reserveKeys = {};
        objConfig.reserveKeys = jQuery.extend(reserveKeys, objConfig.reserveKeys, true);

        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                objSeq = index;
                break;
            }
        }

        if (typeof objConfig.href == "undefined") objConfig.href = cfg.href;

        if (objSeq == null) {
            objSeq = this.objects.length;
            this.objects.push({id: objID, anchorID: cfg.targetID + "_AX_" + objID, config: objConfig});
        } else {
            this.objects[objSeq].isDel = undefined;
            this.objects[objSeq].config = objConfig;
        }

        this.appendAnchor(objID, objSeq);
        this.bindSelect(objID, objSeq);
        this.windowResize();
    },
    appendAnchor: function (objID, objSeq) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];

        if (AXgetId(cfg.targetID + "_AX_" + objID)) {
            axdom("#" + cfg.targetID + "_AX_" + objID).remove();
        }
        var anchorNode = axdom("<div id=\"" + cfg.targetID + "_AX_" + objID + "\" class=\"" + cfg.anchorClassName + "\" style=\"display:none;\"></div>");
        var iobj = axdom("#" + objID);
        iobj.attr("data-axbind", "select");
        if (this.isMobile) iobj.before(anchorNode);
        else iobj.after(anchorNode);

        var iobjPosition = iobj.position();
        var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

        w = iobj.outerWidth();
        h = iobj.outerHeight();

        var css = {left: l, top: t, width: w, height: h}, objDom = axdom("#" + cfg.targetID + "_AX_" + objID);
        objDom.css(css);
        objDom.data("height", h);

        obj.iobj = iobj;
        obj.objDom = objDom;
        // TODO : obj에 iobj, objDom 연결
    },
    alignAnchor: function (objID, objSeq) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];

        var iobj = obj.iobj;
        var iobjPosition = iobj.position();
        var l = iobjPosition.left, t = iobjPosition.top, w = 0, h = 0;

        var borderW = iobj.css("border-left-width").number();
        var borderT = iobj.css("border-top-width").number();
        var borderB = iobj.css("border-bottom-width").number();
        var marginW = iobj.css("margin-left").number();
        var marginH = iobj.css("margin-top").number();
        l = l + marginW;

        //t = t;
        w = iobj.outerWidth();
        h = iobj.outerHeight();

        var css = {left: l, top: t, width: w, height: h};
        obj.objDom.css(css);
        obj.objDom.data("height", h);

        obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBox").css({width: w, height: h});
        obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").css({height: (h - (borderT + borderB)) + "px"});

        obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectText").css({"line-height": (h - (borderT + borderB)) + "px"});
        obj.objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").css({height: h});
    },
    bindSelect: function (objID, objSeq) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq], options, sendObj;

        var iobj = obj.iobj;
        var objDom = obj.objDom;

        if (!obj.config.onChange) obj.config.onChange = obj.config.onchange;
        if (!obj.config.onLoad) obj.config.onLoad = obj.config.onload;

        var w = objDom.width();
        var h = objDom.data("height");
        var borderT = iobj.css("border-top-width").number();
        var borderB = iobj.css("border-bottom-width").number();
        //trace(obj.config);

        var fontSize = iobj.css("font-size").number();
        var tabIndex = iobj.attr("tabindex");

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectBox\" class=\"" + cfg.anchorSelectClassName + "\" style=\"width:" + w + "px;height:" + h + "px;\">");
        po.push("<a " + obj.config.href + " class=\"selectedTextBox\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox\" style=\"height:" + (h - (borderT + borderB)) + "px;\"");
        po.push(" data-ax-anchor=\"axselect\" ");
        if (iobj.attr("data-return-tab-next-focus-id")) po.push(" data-return-tab-next-focus-id = \"" + iobj.attr("data-return-tab-next-focus-id") + "\"");
        if (iobj.attr("data-return-tab-prev-focus-id")) po.push(" data-return-tab-prev-focus-id = \"" + iobj.attr("data-return-tab-prev-focus-id") + "\"");
        if (tabIndex != undefined) po.push(" tabindex=\"" + tabIndex + "\"");
        po.push(">");
        po.push("	<div class=\"selectedText\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectText\" style=\"line-height:" + (h - (borderT + borderB)) + "px;padding:0px 4px;font-size:" + fontSize + "px;\"></div>");
        po.push("	<div class=\"selectBoxArrow\" id=\"" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow\" style=\"height:" + h + "px;\"></div>");
        po.push("</a>");
        po.push("</div>");

        //append to anchor
        objDom.empty();
        objDom.append(po.join(''));
        objDom.show();

        var objDom_selectTextBox = objDom.find("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox");

        obj.selectedIndex = AXgetId(objID).options.selectedIndex;
        var options = [];
        for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
            options.push({optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc()});
        }
        obj.options = AXUtil.copyObject(options);

        if (this.isMobile) {

            // mobile 브라우저인 경우
            iobj.css({opacity: 0});
            var bindSelectChange = this.bindSelectChange.bind(this);
            obj.objOnChange = function () {
                bindSelectChange(objID, objSeq);

                if (obj.config.onChange) {
                    obj.selectedIndex = AXgetId(objID).options.selectedIndex;
                    AXgetId(objID).options[obj.selectedIndex].selected = true;
                    obj.config.selectedObject = obj.options[obj.selectedIndex];

                    options = AXgetId(objID).options[obj.selectedIndex];
                    sendObj = {
                        optionIndex: obj.selectedIndex, optionValue: options.value, optionText: options.text,
                        value: options.value, text: options.text
                    };
                    obj.config.onChange.call(sendObj, sendObj);
                }

            };
            objDom_selectTextBox.unbind("click.AXSelect").bind("click.AXSelect", function (event) {
                axdom("#" + objID).click();
            });

            iobj.addClass("rootSelectBox");
            iobj.bind("change.AXSelect", obj.objOnChange);

        } else {
            //AXUtil.alert(obj.options);

            // PC 브라우저인 경우
            iobj
                .css({visibility: "hidden"});

            var bindSelectExpand = this.bindSelectExpand.bind(this);
            var bindSelectClose = this.bindSelectClose.bind(this);
            var bindSelectFocus = this.bindSelectFocus.bind(this);
            var bindSelectBlur = this.bindSelectBlur.bind(this);

            objDom_selectTextBox.bind("click.AXSelect", function (event) {
                axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").focus();
                bindSelectExpand(objID, objSeq, true, event);
            });

            objDom_selectTextBox.bind("keydown.AXSelect", function (event) {
                if (event.keyCode == AXUtil.Event.KEY_SPACE) {
                    bindSelectExpand(objID, objSeq, true, event);
                    _this.stopEvent(event);
                }
                if (event.keyCode == AXUtil.Event.KEY_TAB || event.keyCode == AXUtil.Event.KEY_RETURN) return;
                //trace(String.fromCharCode(event.keyCode));

                if (_this.selectTextBox_onkeydown_obj) {
                    clearTimeout(_this.selectTextBox_onkeydown_obj);
                    _this.selectTextBox_onkeydown_data += String.fromCharCode(event.keyCode);
                } else {
                    _this.selectTextBox_onkeydown_data = String.fromCharCode(event.keyCode);
                }

                _this.selectTextBox_onkeydown_obj = setTimeout(function () {
                    _this.selectTextBox_onkeydown(objID, objSeq, event);
                }, 300);
            });

            objDom_selectTextBox.bind("focus.AXSelect", function (event) {
                bindSelectFocus(objID);
            });

            objDom_selectTextBox.bind("blur.AXSelect", function (event) {
                bindSelectBlur(objID);
            });
        }

        if (obj.config.ajaxUrl) {

            var bindSelectChangeBind = this.bindSelectChange.bind(this);
            var bindSelectChange = function () {
                bindSelectChangeBind(objID, objSeq, "load");
            };

            var url = obj.config.ajaxUrl;
            var pars = obj.config.ajaxPars;
            var _method = "post";
            var _headers = {};
            var _contentType = AXConfig.AXReq.contentType;
            var _responseType = AXConfig.AXReq.responseType;
            var _dataType = AXConfig.AXReq.dataType;
            var _async = AXConfig.AXReq.async;

            // ajax 옵션 확장
            if (obj.config.method) _method = obj.config.method;
            if (obj.config.headers) _headers = obj.config.headers;
            if (obj.config.contentType) _contentType = obj.config.contentType;
            if (obj.config.responseType) _responseType = obj.config.responseType;
            if (obj.config.dataType) _dataType = obj.config.dataType;
            if (obj.config.ajaxAsync) _async = obj.config.ajaxAsync;

            obj.selectedIndex = null;

            iobj.html("<option></option>");

            obj.inProgress = true; //진행중 상태 변경


            new AXReq(url, {
                type: _method,
                headers: _headers,
                contentType: _contentType,
                responseType: _responseType,
                dataType: _dataType,
                async: _async,
                debug: ((typeof obj.config.debug !== "undefined") ? obj.config.debug : false),
                pars: pars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {

                        var po = [], adj = 0;
                        //obj.config.options = res.options;
                        obj.config.options = res[obj.config.reserveKeys.options];

                        if (obj.config.isspace) {
                            po.push("<option value='" + (obj.config.isspaceValue || "") + "'");
                            if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
                            po.push(">" + (obj.config.isspaceTitle || "&nbsp;") + "</option>");
                            adj = -1;
                        }
                        for (var opts, oidx = 0; (oidx < res[obj.config.reserveKeys.options].length && (opts = res[obj.config.reserveKeys.options][oidx])); oidx++) {
                            //trace(opts);
                            po.push("<option value=\"" + opts[obj.config.reserveKeys.optionValue] + "\" data-option=\"" + opts[obj.config.reserveKeys.optionData] + "\" ");
                            if (obj.config.setValue == opts[obj.config.reserveKeys.optionValue] || opts.selected || (obj.selectedIndex || 0).number() + adj == oidx) po.push(" selected=\"selected\"");
                            po.push(">" + opts[obj.config.reserveKeys.optionText].dec() + "</option>");
                        }
                        axdom("#" + objID).html(po.join(''));

                        var options = [];
                        for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
                            options.push({
                                optionValue: AXgetId(objID).options[oi].value,
                                optionText: AXgetId(objID).options[oi].text.enc(),
                                optionData: AXgetId(objID).options[oi].getAttribute("data-option")
                            });
                        }
                        obj.options = AXUtil.copyObject(options);
                        obj.selectedIndex = AXgetId(objID).options.selectedIndex;

                        if (obj.config.onChange && obj.config.alwaysOnChange) {
                            obj.config.focusedIndex = obj.selectedIndex;
                            obj.config.selectedObject = obj.options[obj.selectedIndex];
                            sendObj = {
                                optionIndex: obj.selectedIndex,
                                optionValue: obj.options[obj.selectedIndex].optionValue,
                                optionText: obj.options[obj.selectedIndex].optionText,
                                optionData: obj.options[obj.selectedIndex].optionData,
                                value: obj.options[obj.selectedIndex].optionValue,
                                text: obj.options[obj.selectedIndex].optionText,
                                data: obj.options[obj.selectedIndex].optionData
                            };
                            obj.config.onChange.call(sendObj, sendObj, "isPostBack");
                        }
                        bindSelectChange();

                        if (obj.config.onLoad) {
                            sendObj = {
                                selectedIndex: obj.selectedIndex,
                                selectedObject: obj.options[obj.selectedIndex],
                                options: obj.options,
                                response: res
                            };
                            obj.config.onLoad.call(sendObj, sendObj);
                        }
                        _this.alignAnchor(objID, objSeq);
                    } else {
                        //trace(res);
                    }
                    obj.inProgress = false;
                }
            });
        }
        else if (obj.config.options) {

            iobj.html("<option></option>");

            var po = [], adj = 0;
            if (obj.config.isspace) {
                po.push("<option value='" + (obj.config.isspaceValue || "") + "'");
                if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
                po.push(">" + (obj.config.isspaceTitle || "&nbsp;") + "</option>");
                adj = -1;
            }

            for (var opts, oidx = 0; (oidx < obj.config.options.length && (opts = obj.config.options[oidx])); oidx++) {
                //[obj.config.reserveKeys.optionValue]
                //[obj.config.reserveKeys.optionText]
                var optionText = (opts[obj.config.reserveKeys.optionText] || "").dec();
                po.push("<option value=\"" + opts[obj.config.reserveKeys.optionValue] + "\"");
                if (obj.config.setValue == opts[obj.config.reserveKeys.optionValue] || opts.selected || obj.selectedIndex.number() + adj == oidx) po.push(" selected=\"selected\"");
                po.push(">" + optionText + "</option>");
            }
            iobj.html(po.join(''));

            var options = [];
            for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
                options.push({optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc()});
            }
            obj.options = AXUtil.copyObject(options);
            obj.selectedIndex = AXgetId(objID).options.selectedIndex;

            this.bindSelectChange(objID, objSeq, "load");

            if (obj.config.onChange && obj.config.alwaysOnChange) {
                obj.config.focusedIndex = obj.selectedIndex;
                obj.config.selectedObject = obj.options[obj.selectedIndex];

                options = AXgetId(objID).options[obj.selectedIndex];
                if (!options) {
                    options = {value: "", text: ""};
                }
                sendObj = {
                    optionIndex: obj.selectedIndex, optionValue: options.value, optionText: options.text,
                    value: options.value, text: options.text
                };
                obj.config.onChange.call(sendObj, sendObj, "isPostBack");
            }

            if (obj.config.onLoad) {
                var selectedOption = this.getSelectedOption(objID, objSeq);
                obj.config.onLoad.call({selectedIndex: obj.selectedIndex, selectedObject: {optionValue: selectedOption.value, optionText: selectedOption.text}});
            }
            this.alignAnchor(objID, objSeq);
        }
        else {
            this.bindSelectChange(objID, objSeq, "load");
            if (obj.config.onChange && obj.config.alwaysOnChange) {
                var selectedOption = this.getSelectedOption(objID, objSeq);
                if (selectedOption) {
                    sendObj = {
                        optionIndex: selectedOption.index,
                        optionValue: selectedOption.value,
                        optionText: selectedOption.text,
                        value: selectedOption.value,
                        text: selectedOption.text
                    };
                    obj.config.onChange.call(sendObj, sendObj, "isPostBack");
                }
            }
            if (obj.config.onLoad) {
                var selectedOption = this.getSelectedOption(objID, objSeq);
                obj.config.onLoad.call({selectedIndex: obj.selectedIndex, selectedObject: {optionValue: selectedOption.value, optionText: selectedOption.text}});
            }
            this.alignAnchor(objID, objSeq);
        }
    },
    selectTextBox_onkeydown: function (objID, objSeq, event) {
        var cfg = this.config, _this = this;
        var obj = this.objects[objSeq];

        var bindSelectClose = this.bindSelectClose.bind(this);
        var chkVal = (_this.selectTextBox_onkeydown_data || ""), chkIndex = null;

        for (var O, index = 0; (index < obj.options.length && (O = obj.options[index])); index++) {
            if (O.optionValue.left(chkVal.length).lcase() == chkVal.lcase() || O.optionText.left(chkVal.length).lcase() == chkVal.lcase()) {
                chkIndex = index;
                break;
            }
        }
        ;
        if (chkIndex != null) {
            obj.selectedIndex = chkIndex;
            obj.config.focusedIndex = chkIndex;
            obj.config.selectedObject = obj.options[chkIndex];
            obj.config.isChangedSelect = true;
            bindSelectClose(objID, objSeq, event); // 값 전달 후 닫기
        }
        _this.selectTextBox_onkeydown_data = "";
    },
    getSelectedOption: function (objID, objSeq) {
        var cfg = this.config;
        var obj = this.objects[objSeq];

        if (AXgetId(objID) && AXgetId(objID).options.selectedIndex > -1) {
            try {
                if (obj.selectedIndex != AXgetId(objID).options.selectedIndex) obj.selectedIndex = AXgetId(objID).options.selectedIndex;
            } catch (e) {
            }
            var options = AXgetId(objID).options[AXgetId(objID).options.selectedIndex];
            return {
                value: options.value, text: options.text, data: options.getAttribute("data-option"), index: AXgetId(objID).options.selectedIndex
            }
        } else {
            obj.selectedIndex = 0;
            var options = AXgetId(objID).options[0];
            options = (options) ? {value: options.value, text: options.text, data: options.getAttribute("data-option")} : {value: "", text: "", data: ""};
            return {
                value: options.value, text: options.text, data: options.data, index: 0
            }
        }

    },
    bindSelectChange: function (objID, objSeq, isLoad) {
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var selectedOption = this.getSelectedOption(objID, objSeq);
        if (selectedOption) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectText").html(selectedOption.text);
        }
        if (obj && !this.isMobile) {
            if (!obj.iobj) obj.iobj = axdom("#" + objID);
            if (isLoad != "load") obj.iobj.trigger("change"); // change 이벤트 발생
        }
    },
    bindSelectExpand: function (objID, objSeq, isToggle, event) {
        var _this = this;
        var cfg = this.config;
        var obj = this.objects[objSeq];
        var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
        //Selector Option box Expand

        if (jqueryTargetObjID.data("disabled")) return;


        if (isToggle) { // 활성화 여부가 토글 이면
            if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
                if (obj.config.isChangedSelect) {
                    this.bindSelectClose(objID, objSeq, event); // 닫기
                } else {
                    axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
                    axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").removeClass("on");
                    //비활성 처리후 메소드 종료
                    axdom(document).unbind("click.AXSelect");
                    axdom(document).unbind("keydown.AXSelect");
                }
                return;
            }
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 활성화 전에 개체 삭제 처리
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").removeClass("on");

        //Expand Box 생성 구문 작성
        var anchorWidth = axdom("#" + cfg.targetID + "_AX_" + objID).width() - 2; // anchor width
        var anchorHeight = axdom("#" + cfg.targetID + "_AX_" + objID).data("height") - 1;
        var styles = [];
        //styles.push("top:"+anchorHeight+"px");
        styles.push("width:" + anchorWidth + "px");

        var po = [];
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandBox\" class=\"AXselectExpandBox\" style=\"" + styles.join(";") + "\">");
        po.push("<div id=\"" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll\" class=\"AXselectExpandScroll\">");
        po.push("	<div class=\"AXLoadingSmall\"></div>");
        po.push("</div>");
        po.push("</div>");
        
        axdom(document.body).append(po.join(''));
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").addClass("on");

        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");

        if (obj.config.positionFixed) {
            expandBox.css({"position": "fixed"});
        }
        var expBoxHeight = expandBox.outerHeight();
        var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();

        if (obj.config.position) {
            offset = jqueryTargetObjID.offset();
            if (obj.config.position.top != undefined) {
                offset.top = obj.config.position.top;
            }
        }
        var css = {};
        css.top = offset.top + anchorHeight;
        //css.top = offset.top;
        css.left = offset.left;

        var bodyHeight;
        (AXUtil.docTD == "Q") ? bodyHeight = document.body.scrollHeight : bodyHeight = document.documentElement.scrollHeight;
        //trace({bodyHeight:bodyHeight, top:css.top});

        if (!obj.config.positionFixed) {
            if (bodyHeight < css.top.number() + expBoxHeight) {
                css = {
                    top: offset.top - expBoxHeight,
                    left: offset.left
                }
            }
        }

        expandBox.css(css);

        // onexpand 함수가 존재 한다면
        if (obj.config.onexpand) {
            obj.config.onexpand.call({
                obj: obj,
                objID: objID,
                objSeq: objSeq
            }, function (args) {
                if (typeof args != "undefined") {
                    obj.options = obj.config.options = axf.copyObject(args.options);

                    var po = [], adj = 0;
                    if (obj.config.isspace) {
                        po.push("<option value='" + (obj.config.isspaceValue || "") + "'");
                        if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
                        po.push(">" + (obj.config.isspaceTitle || "&nbsp;") + "</option>");
                        adj = -1;
                    }
                    for (var opts, oidx = 0; oidx < obj.options.length; oidx++) {
                        var opts = obj.options[oidx];
                        po.push("<option value=\"" + opts[obj.config.reserveKeys.optionValue] + "\" data-option=\"" + opts[obj.config.reserveKeys.optionData] + "\" ");
                        if (obj.config.setValue == opts[obj.config.reserveKeys.optionValue] || opts.selected || (obj.selectedIndex || 0).number() + adj == oidx) po.push(" selected=\"selected\"");
                        po.push(">" + opts[obj.config.reserveKeys.optionText].dec() + "</option>");
                    }
                    axdom("#" + objID).html(po.join(''));

                    _this.bindSelectSetOptions(objID, objSeq);
                    _this.alignAnchor(objID, objSeq);
                }
            });
        } else {
            this.bindSelectSetOptions(objID, objSeq);
        }
    },
    bindSelectClose: function (objID, objSeq, event) {
        var obj = this.objects[objSeq], options, sendObj;
        //trace("bindSelectorClose");

        var cfg = this.config;
        if (AXgetId(cfg.targetID + "_AX_" + objID + "_AX_expandBox")) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").remove(); // 개체 삭제 처리
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectBoxArrow").removeClass("on");

            //비활성 처리후 메소드 종료
            axdom(document).unbind("click.AXSelect");
            //axdom(document.body).unbind("focus.AXSelect", obj.documentclickEvent);
            axdom(document).unbind("keydown.AXSelect");
            axdom(document.body).off("focus.AXSelect", "input,select,button,a,textarea");

            if (obj.config.isChangedSelect) {
                AXgetId(objID).options[obj.selectedIndex].selected = true;
                if (obj.config.onChange) {
                    options = AXgetId(objID).options[obj.selectedIndex];
                    sendObj = {
                        optionIndex: obj.selectedIndex, optionValue: options.value, optionText: options.text, optionData: options.getAttribute("data-option"),
                        value: options.value, text: options.text, data: options.data
                    };
                    obj.config.onChange.call(sendObj, sendObj);
                }
                obj.config.isChangedSelect = false;
                this.bindSelectChange(objID, objSeq);
            }

            if (event) event.stopPropagation(); // disableevent
            return;
        } else {
            if (obj.config.isChangedSelect) {
                AXgetId(objID).options[obj.selectedIndex].selected = true;
                if (obj.config.onChange) {
                    options = AXgetId(objID).options[obj.selectedIndex];
                    sendObj = {
                        optionIndex: obj.selectedIndex, optionValue: options.value, optionText: options.text, optionData: options.getAttribute("data-option"),
                        value: options.value, text: options.text, data: options.data
                    };
                    obj.config.onChange.call(sendObj, sendObj);
                }
                obj.config.isChangedSelect = false;

                this.bindSelectChange(objID, objSeq);
            }
        }
    },
    bindSelectSetOptions: function (objID, objSeq) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var jqueryTargetObjID = axdom("#" + cfg.targetID + "_AX_" + objID);
        var maxHeight = obj.config.maxHeight || 200;

        if (!obj.options) return;
        if (obj.options.length == 0) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").hide();
        }

        var po = [];
        for (var O, index = 0; (index < obj.options.length && (O = obj.options[index])); index++) {
            po.push("<a " + obj.config.href + " id=\"" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option\">" + O.optionText.dec() + "</a>");
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").html(po.join(''));

        var expandScrollHeight = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandScroll").height();
        if (expandScrollHeight > maxHeight) expandScrollHeight = maxHeight;
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox").css({height: expandScrollHeight + "px"});

        var bindSelectOptionsClick = this.bindSelectOptionsClick.bind(this);
        obj.documentclickEvent = function (event) {
            bindSelectOptionsClick(objID, objSeq, event);
        };
        var bindSelectKeyup = this.bindSelectKeyup.bind(this);
        obj.documentKeyup = function (event) {
            bindSelectKeyup(objID, objSeq, event);
        };
        axdom(document).unbind("click.AXSelect").bind("click.AXSelect", obj.documentclickEvent);
        /*
        axdom(document.body).bind("focus.AXSelect", function(e){
            console.log(e);
        });
        */
        axdom(document).unbind("keydown.AXSelect").bind("keydown.AXSelect", obj.documentKeyup);
        axdom(document.body).off("focus.AXSelect").on("focus.AXSelect", "input,select,button,a,textarea", obj.documentclickEvent);

        if (obj.myUIScroll) obj.myUIScroll.unbind();
        obj.myUIScroll = new AXScroll();
        obj.myUIScroll.setConfig({
            CT_className: "AXScrollSmall",
            targetID: cfg.targetID + "_AX_" + objID + "_AX_expandBox",
            scrollID: cfg.targetID + "_AX_" + objID + "_AX_expandScroll",
            touchDirection: false
        });

        if (obj.selectedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.selectedIndex + "_AX_option").addClass("on");
            obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + obj.selectedIndex + "_AX_option"); //focus
            obj.config.focusedIndex = obj.selectedIndex;
        }

        // 위치 재 정의 필요하면 정의 할 것 ----------------------------------
        var bodyHeight;
        (AXUtil.docTD == "Q") ? bodyHeight = document.body.clientHeight : bodyHeight = document.documentElement.clientHeight;

        var anchorHeight = jqueryTargetObjID.data("height") - 1;
        var expandBox = axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_expandBox");
        var expBoxHeight = expandBox.outerHeight();

        var offset = (obj.config.positionFixed) ? jqueryTargetObjID.position() : jqueryTargetObjID.offset();

        if (obj.config.position) {
            offset = jqueryTargetObjID.offset();
            if (obj.config.position.top != undefined) {
                offset.top = obj.config.position.top;
            }
        }

        var css = {};
        css.top = offset.top + anchorHeight;
        if (!obj.config.positionFixed) {
            if (bodyHeight < css.top.number() + expBoxHeight) {
                css = {
                    top: offset.top - expBoxHeight,
                    left: offset.left
                }
                expandBox.css(css);
            }
        }
        // 위치 재 정의 필요하면 정의 할 것 ----------------------------------

    },
    bindSelectOptionsClick: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        var isSelectorClick = false;
        var eid = event.target.id.split(/_AX_/g);
        var tgid = event.target.id;

        if (event.target.id == "") isSelectorClick = false;
        else {
            if (event.target.id == objID || (eid[0] == cfg.targetID && tgid.substr(eid[0].length + 4, objID.length) == objID)) {
                isSelectorClick = true;
            }
        }

        if (!isSelectorClick) {
            this.bindSelectClose(objID, objSeq, event); // 셀럭터 외의 영역이 므로 닫기
        } else {
            if (eid.last() == "option") {
                var selectedIndex = eid[eid.length - 2];
                obj.selectedIndex = selectedIndex;
                obj.config.focusedIndex = selectedIndex;
                obj.config.selectedObject = obj.options[selectedIndex];

                obj.config.isChangedSelect = true;
                this.bindSelectClose(objID, objSeq, event); // 값 전달 후 닫기
            }
        }
    },
    bindSelectKeyup: function (objID, objSeq, event) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (event.keyCode == AXUtil.Event.KEY_TAB || event.keyCode == AXUtil.Event.KEY_ESC) {
            this.bindSelectClose(objID, objSeq, event); // 닫기
            return;
        } else if (event.keyCode == AXUtil.Event.KEY_UP) {
            if (!obj.options) return;
            if (obj.options.length == 0) return;
            var focusIndex = obj.options.length - 1;
            if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == 0) {

            } else {
                focusIndex = (obj.config.focusedIndex) - 1;
            }
            this.bindSelectorSelect(objID, objSeq, focusIndex);

            this.stopEvent(event);
        } else if (event.keyCode == AXUtil.Event.KEY_DOWN) {
            if (!obj.options) return;
            if (obj.options.length == 0) return;
            var focusIndex = 0;
            if (obj.config.focusedIndex == undefined || obj.config.focusedIndex == obj.options.length - 1) {

            } else {
                focusIndex = (obj.config.focusedIndex).number() + 1;
            }
            this.bindSelectorSelect(objID, objSeq, focusIndex);

            this.stopEvent(event);
        } else if (event.keyCode == AXUtil.Event.KEY_RETURN) {
            //alert("RETURN");
            /*
             axdom(document).unbind("click", obj.documentclickEvent);
             axdom(document).unbind("keydown", obj.documentKeyup);
             */
            /*
             var selectedIndex = eid[eid.length - 2];
             obj.selectedIndex = selectedIndex;
             obj.config.focusedIndex = selectedIndex;
             obj.config.selectedObject = obj.options[selectedIndex];

             obj.config.isChangedSelect = true;
             this.bindSelectClose(objID, objSeq, event); // 값 전달 후 닫기
             */

        }
    },
    /* ~~~~~~~~~~~~~ */

    bindSelectorSelect: function (objID, objSeq, index, changeValue) {
        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (obj.config.focusedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.config.focusedIndex + "_AX_option").removeClass("on");
        }
        axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option").addClass("on");
        obj.config.focusedIndex = index;
        obj.selectedIndex = index;
        obj.config.selectedObject = obj.options[index];
        obj.config.isChangedSelect = true;
        obj.myUIScroll.focusElement(cfg.targetID + "_AX_" + objID + "_AX_" + index + "_AX_option"); //focus
    },
    bindSelectorSelectClear: function (objID, objSeq) {

        var obj = this.objects[objSeq];
        var cfg = this.config;
        if (obj.selectedIndex != undefined) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_" + obj.selectedIndex + "_AX_option").removeClass("on");
        }
        obj.selectedIndex = null;
        obj.config.focusedIndex = null;
        obj.config.selectedObject = null;
        obj.config.isChangedSelect = true;
    },

    /* ~~~~~~~~~~~~~ */
    bindSelectChangeValue: function (objID, value, onEnd) {
        var findIndex = null;

        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        ;

        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        } else {

            var obj = this.objects[findIndex], options, sendObj;
            var cfg = this.config;

            if (this.isMobile) {
                for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
                    if (AXgetId(objID).options[oi].value == value) {
                        var selectedIndex = oi;
                        AXgetId(objID).options[oi].selected = true;
                        obj.config.selectedObject = {optionIndex: oi, optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc()};
                        this.bindSelectChange(objID, findIndex);
                        if (obj.config.onChange) {
                            options = AXgetId(objID).options[oi];
                            sendObj = {
                                optionIndex: oi, optionValue: options.value, optionText: options.text,
                                value: options.value, text: options.text
                            };
                            obj.config.onChange.call(sendObj, sendObj);
                        }
                        break;
                    }
                }
            } else {

                var selectedIndex = null;
                for (var O, oidx = 0; (oidx < obj.options.length && (O = obj.options[oidx])); oidx++) {
                    if ((O.optionValue || O.value || "") == value) {
                        selectedIndex = oidx;
                        break;
                    }
                }
                ;

                if (selectedIndex != null) {

                    obj.selectedIndex = selectedIndex;
                    obj.config.focusedIndex = selectedIndex;

                    AXgetId(objID).options[obj.selectedIndex].selected = true;
                    obj.config.selectedObject = obj.options[selectedIndex];
                    this.bindSelectChange(objID, findIndex);

                    if (obj.config.onChange) {
                        options = AXgetId(objID).options[selectedIndex];
                        sendObj = {
                            optionIndex: selectedIndex, optionValue: options.value, optionText: options.text,
                            value: options.value, text: options.text
                        };
                        obj.config.onChange.call(sendObj, sendObj);
                    }

                } else {
                    //trace("일치하는 값을 찾을 수 없습니다.");
                }
            }
        }
    },
    bindSelectDisabled: function (objID, _disabled) {
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        ;

        if (findIndex == null) {
            //trace("바인드 된 오브젝트를 찾을 수 없습니다.");
            return;
        } else {
            var obj = this.objects[findIndex];
            var cfg = this.config;

            if (typeof _disabled == "boolean") {
                axf.getId(objID).disabled = _disabled;
            } else {
                axf.getId(objID).disabled = !AXgetId(objID).disabled;
            }

            if (this.isMobile) {

            } else {

                var bindTarget = axdom("#" + cfg.targetID + "_AX_" + objID);
                bindTarget.data("disabled", axf.getId(objID).disabled);

                if (axf.getId(objID).disabled) {
                    bindTarget.find(".AXanchorSelect").addClass("disable");
                } else {
                    bindTarget.find(".AXanchorSelect").removeClass("disable");

                }
            }
        }
    },
    bindSelectUpdate: function (objID) {
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }

        if (findIndex != null) {
            var obj = this.objects[findIndex], selectedIndex, options, sendObj;
            if (obj.config.onChange) {
                selectedIndex = AXgetId(objID).options.selectedIndex;
                options = AXgetId(objID).options[selectedIndex];
                sendObj = {
                    optionIndex: selectedIndex,
                    optionValue: options.value, optionText: options.text,
                    value: options.value,
                    text: options.text
                };
                obj.config.onChange.call(sendObj, sendObj);
            }
            this.bindSelectChange(objID, findIndex);
        }
    },
    bindSelectFocus: function (objID, elFocus) {
        var cfg = this.config;
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        if (findIndex != null) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").addClass("focus");
            if(elFocus) axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").focus();
        }
    },
    bindSelectBlur: function (objID) {
        var cfg = this.config;
        var findIndex = null;
        var _this = this;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }

        if (findIndex != null) {
            axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox").removeClass("focus");
        }
    },
    bindSelectGetAnchorObject: function (objID) {
        var cfg = this.config;
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        ;
        if (findIndex != null) {
            return axdom("#" + cfg.targetID + "_AX_" + objID + "_AX_SelectTextBox");
        }
    },
    bindSelectGetValue: function (objID, onEnd) {
        var findIndex = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                findIndex = index;
                break;
            }
        }
        ;

        if (findIndex == null) {
            return {optionValue: null, optionText: null, error: "바인드 된 오브젝트를 찾을 수 없습니다."};
        } else {
            var obj = this.objects[findIndex];
            var cfg = this.config;

            if (obj.selectedIndex != undefined) {
                var options = AXgetId(objID).options[obj.selectedIndex];
                return {optionValue: options.value, optionText: options.text, optionData: options.getAttribute("data-option")};
            } else {
                return {optionValue: null, optionText: null};
            }
        }
    },

    /**
     * @method AXSelectConverter.bindSelectAddOptions
     * @param {String} objID - element select id
     * @param {Array} options - 추가하려는 옵션 배열
     * @returns {Array} options
     * @description 설명
     * @example
     ```
     mySelect.bindSelectAddOptions("objID", [{optionValue:"1", optionText:"액시스제이"}]);
     ```
     */
    bindSelectAddOptions: function (objID, options) {
        var cfg = this.config, _this = this;
        var objSeq = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                objSeq = index;
                break;
            }
        }
        if (objSeq == null) {
            trace("not found element id");
            return;
        }
        var obj = this.objects[objSeq];
        var iobj = obj.iobj;

        if (!Object.isArray(options)) {
            trace("options 아규먼트가 없습니다.");
            return;
        }

        var newOptions = obj.options;
        for (var i = 0; i < options.length; i++) {
            var hasValue = false;
            for (var oi = 0; oi < obj.options.length; oi++) {
                if (obj.options[oi].optionValue == options[i].optionValue) {
                    hasValue = true;
                }
            }
            if (!hasValue) {
                newOptions.push({optionText: options[i].optionText.enc(), optionValue: options[i].optionValue});
            }
        }
        obj.options = newOptions;

        iobj.css({opacity: 100});
        //trace(obj.options);
        var po = [];
        for (var opts, oidx = 0; (oidx < obj.options.length && (opts = obj.options[oidx])); oidx++) {
            var optionText = (opts.optionText || "").dec();
            po.push("<option value=\"" + opts.optionValue + "\"");
            if (obj.selectedIndex == oidx) po.push(" selected=\"selected\"");
            po.push(">" + optionText + "</option>");
        }
        iobj.empty();
        iobj.append(po.join(''));

        //this.bindSelectChangeValue(objID, obj.config.setValue);
        this.alignAnchor(objID, objSeq);

        return obj.options;
    },

    /**
     * @method AXSelectConverter.bindSelectRemoveOptions
     * @param objID {String} element select id
     * @param options {Array} 추가하려는 옵션 배열
     * @returns {Array} options
     * @description 설명
     * @example
     ```
     mySelect.bindSelectRemoveOptions("objID", [{optionValue:"1", optionText:"액시스제이"}]);
     ```
     */
    bindSelectRemoveOptions: function (objID, options) {
        var cfg = this.config, _this = this;
        var objSeq = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                objSeq = index;
                break;
            }
        }
        if (objSeq == null) {
            trace("not found element id");
            return;
        }
        var obj = this.objects[objSeq];
        var iobj = obj.iobj;

        if (!Object.isArray(options)) {
            trace("options 아규먼트가 없습니다.");
            return;
        }

        var newOptions = [];

        for (var oi = 0; oi < obj.options.length; oi++) {
            var hasValue = false;
            for (var i = 0; i < options.length; i++) {
                if (obj.options[oi].optionValue == options[i].optionValue) {
                    hasValue = true;
                }
            }
            if (!hasValue) {
                newOptions.push({optionText: obj.options[oi].optionText, optionValue: obj.options[oi].optionValue});
            }
        }
        obj.options = newOptions;

        //trace(obj.options);
        iobj.css({opacity: 100});
        var po = [];
        for (var opts, oidx = 0; (oidx < obj.options.length && (opts = obj.options[oidx])); oidx++) {
            var optionText = (opts.optionText || "").dec();
            po.push("<option value=\"" + opts.optionValue + "\"");
            if (obj.selectedIndex == oidx) po.push(" selected=\"selected\"");
            po.push(">" + optionText + "</option>");
        }
        iobj.empty();
        iobj.append(po.join(''));

        this.alignAnchor(objID, objSeq);

        return obj.options;
    },


    /**
     * @method AXSelectConverter.bindSelectUpdateOptions
     * @param {String} objID - element select id
     * @param {Array|Object} options - 옵션 배열
     * @param {Number} optionIndex - 변경하려는 옵션 인덱스
     * @returns {AXSelectConverter}
     * @description 설명
     * @example
     ```
     jQuery("#AXSelect1").bindSelectUpdateOptions([
     {optionValue:1, optionText:"abc-1 : ABCDEFG"},
     {optionValue:2, optionText:"abc-2 : 09123123"},
     {optionValue:3, optionText:"abc-3 : 1222"},
     {optionValue:4, optionText:"abc-4 : AXISJ"},
     {optionValue:5, optionText:"abc-5 : 액시스 제이"}
     ]);

     jQuery("#AXSelect1").bindSelectUpdateOptions({optionValue:3, optionText:"특별한 값으로 변경"}, 3);
     ```
     */
    bindSelectUpdateOptions: function (objID, options, optionIndex) {
        var cfg = this.config, _this = this;
        var objSeq = null;
        for (var O, index = 0; (index < this.objects.length && (O = this.objects[index])); index++) {
            if (O.id == objID && O.isDel != true) {
                objSeq = index;
                break;
            }
        }
        if (objSeq == null) {
            trace("not found element id");
            return;
        }
        var obj = this.objects[objSeq];
        var iobj = obj.iobj;

        if (typeof optionIndex === "undefined" && !Object.isArray(options)) {
            trace("options 아규먼트가 없습니다.");
            return;
        }

        var newOptions = [];
        if (typeof optionIndex === "undefined") {
            for (var i = 0; i < options.length; i++) {
                newOptions.push(jQuery.extend({optionText: options[i].optionText.enc(), optionValue: options[i].optionValue}, options[i]));
            }
            obj.selectedIndex = 0;
        } else {
            var _adj = 0;
            if (obj.config.isspace) _adj = 1;
            for (var i = 0; i < obj.config.options.length; i++) {
                if (i + _adj == optionIndex) {
                    newOptions.push(jQuery.extend({optionText: options.optionText.enc(), optionValue: options.optionValue}, options));
                } else {
                    newOptions.push(obj.config.options[i]);
                }
            }
        }

        obj.config.options = newOptions;
        iobj.css({opacity: 100});
        iobj.html("<option></option>");

        var po = [], adj = 0;
        if (obj.config.isspace) {
            po.push("<option value='" + (obj.config.isspaceValue || "") + "'");
            if (obj.selectedIndex == 0) po.push(" selected=\"selected\"");
            po.push(">" + (obj.config.isspaceTitle || "&nbsp;") + "</option>");
            adj = -1;
        }

        for (var opts, oidx = 0; (oidx < obj.config.options.length && (opts = obj.config.options[oidx])); oidx++) {
            var optionText = (opts.optionText || "").dec();
            po.push("<option value=\"" + opts.optionValue + "\"");
            if (obj.config.setValue == opts.optionValue || opts.selected || (obj.selectedIndex || 0).number() + adj == oidx) po.push(" selected=\"selected\"");
            po.push(">" + optionText + "</option>");
        }

        iobj.html(po.join(''));

        var options = [];
        for (var oi = 0; oi < AXgetId(objID).options.length; oi++) {
            options.push({optionValue: AXgetId(objID).options[oi].value, optionText: AXgetId(objID).options[oi].text.enc()});
        }
        obj.options = AXUtil.copyObject(options);
        obj.selectedIndex = AXgetId(objID).options.selectedIndex;

        this.bindSelectChange(objID, objSeq, "load");

        if (obj.config.onChange && obj.config.alwaysOnChange) {
            obj.config.focusedIndex = obj.selectedIndex;
            obj.config.selectedObject = obj.options[obj.selectedIndex];

            options = AXgetId(objID).options[obj.selectedIndex];
            sendObj = {
                optionIndex: obj.selectedIndex, optionValue: options.value, optionText: options.text,
                value: options.value, text: options.text
            };
            obj.config.onChange.call(sendObj, sendObj, "isPostBack");
        }

        this.alignAnchor(objID, objSeq);
        iobj.css({opacity: 0});

        return this;
    }
});

var AXSelect = new AXSelectConverter();
AXSelect.setConfig({targetID: "AXselect"});

/**
 * @method jQueryExtends.unbindSelect
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description select 엘리먼트에 select 콘트롤을 언바인드(제거) 합니다.
 * @example
 ```js
 axdom("Selector").unbindSelect();
 ```
 **/
axdom.fn.unbindSelect = function (config) {
    axdom.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXSelect.unbind(config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelect
 * @param {JSObject} configs
 * @returns {jQueryObject}
 * @description
 * select 엘리먼트에 select 콘트롤을 바인드 합니다.
 * @example
 ```
 axdom("Selector").bindSelect(configs);
 ```
 */
axdom.fn.bindSelect = function (config) {
    axdom.each(this, function () {
        if (!this.id) this.id = "AXInput-" + axf.getUniqueId();
        if (config == undefined) config = {};
        config.id = this.id;
        AXSelect.bind(config);
    });
    return this;
};
/**
 * @method jQueryExtends.setConfigSelect
 * @param {jsObject} config - select 설정
 * @returns {jQueryObject}
 * @description
 * select 콘트롤에 설정을 변경합니다.
 * @example
 ```
 axdom("Selector").bindSelect(configs);
 ```
 */
axdom.fn.setConfigSelect = function (config) {
    axdom.each(this, function () {
        AXSelect.bindSetConfig(this.id, config);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectSetValue
 * @param {String} value
 * @param {fn} [onEnd] - 끝나고 실행될 함수 / 예정
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤에 값을 입력하고 onEnd 함수가 있는 경우 실행합니다.
 * @example
 ```
 axdom("Selector").bindSelectSetValue('test');
 ```
 */

axdom.fn.bindSelectSetValue = function (value, onEnd) {
    axdom.each(this, function () {
        AXSelect.bindSelectChangeValue(this.id, value, onEnd);
    });
    return this;
};

axdom.fn.bindSelectGetValue = function (onEnd) {
    return AXSelect.bindSelectGetValue(this[0].id, onEnd);
};

//SetText

//getText
/**
 * @method jQueryExtends.setValueSelect
 * @param {String} value
 * @param {fn} [onEnd] - 끝나고 실행될 함수 / 예정
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤에 값을 입력하고 onEnd 함수가 있는 경우 실행합니다.
 * @example
 ```
 axdom("Selector").setValueSelect('test');
 ```
 */

axdom.fn.setValueSelect = function (value, onEnd) {
    axdom.each(this, function () {
        AXSelect.bindSelectChangeValue(this.id, value, onEnd);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectDisabled
 * @param {Boolean} Disabled
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤의 Disabled 속성을 컨트롤 합니다.
 * @example
 ```
 axdom("Selector").bindSelectDisabled(true);
 ```
 */
axdom.fn.bindSelectDisabled = function (Disabled) {
    axdom.each(this, function () {
        AXSelect.bindSelectDisabled(this.id, Disabled);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectUpdate
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤의 view 를 value 기준으로 변경합니다.
 * @example
 ```
 axdom("Selector").bindSelectUpdate();
 ```
 */
axdom.fn.bindSelectUpdate = function () {
    axdom.each(this, function () {
        AXSelect.bindSelectUpdate(this.id);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectFocus
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤에 focus를 줍니다.
 * @example
 ```
 axdom("Selector").bindSelectFocus();
 ```
 */
axdom.fn.bindSelectFocus = function () {
    axdom.each(this, function () {

        AXSelect.bindSelectFocus(this.id, true);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectBlur
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤을 blur 상태로 변경합니다.(비활성 처리후 메소드 종료)
 * @example
 ```
 axdom("Selector").bindSelectBlur();
 ```
 */
axdom.fn.bindSelectBlur = function () {
    axdom.each(this, function () {
        AXSelect.bindSelectBlur(this.id);
    });
    return this;
};

/**
 * @method jQueryExtends.bindSelectGetAnchorObject
 * @returns {jQueryObject}
 * @description
 * 해당 셀렉트 컨트롤의 view html element를 반환합니다.
 * @example
 ```
 axdom("Selector").bindSelectGetAnchorObject();
 ```
 */

axdom.fn.bindSelectGetAnchorObject = function () {
    var returnObj;
    axdom.each(this, function () {
        returnObj = AXSelect.bindSelectGetAnchorObject(this.id);
    });
    return returnObj;
};

/**
 * @method jQueryExtends.bindSelectAddOptions
 * @param {Array} options - 추가하려는 옵션 배열
 * @description 배열로 지정한 객체를 해당 셀렉트의 option 에 추가합니다.
 * @example
 ```
 $("#mySelect").bindSelectAddOptions([
 {optionValue:"1", optionText:"액시스제이"}
 ]);
 ```
 */
axdom.fn.bindSelectAddOptions = function (options) {
    var returnObj;
    axdom.each(this, function () {
        returnObj = AXSelect.bindSelectAddOptions(this.id, options);
    });
    return returnObj;
};

/**
 * @method jQueryExtends.bindSelectRemoveOptions
 * @param {Array} options - 삭제하려는 옵션 배열
 * @description 배열로 지정한 객체를 해당 셀렉트의 option 에서 제거합니다.
 * @example
 ```

 ```
 */
axdom.fn.bindSelectRemoveOptions = function (options) {
    var returnObj;
    axdom.each(this, function () {
        returnObj = AXSelect.bindSelectRemoveOptions(this.id, options);
    });
    return returnObj;
};


/**
 * @method jQueryExtends.bindSelectUpdateOptions
 * @param {Array} options - 삭제하려는 옵션 배열
 * @description 배열로 지정한 객체를 해당 셀렉트의 option 에서 제거합니다.
 * @example
 ```
 jQuery("#AXSelect1").bindSelectUpdateOptions([
 {optionValue:1, optionText:"abc-1 : ABCDEFG"},
 {optionValue:2, optionText:"abc-2 : 09123123"},
 {optionValue:3, optionText:"abc-3 : 1222"},
 {optionValue:4, optionText:"abc-4 : AXISJ"},
 {optionValue:5, optionText:"abc-5 : 액시스 제이"}
 ]);

 jQuery("#AXSelect1").bindSelectUpdateOptions({optionValue:3, optionText:"특별한 값으로 변경"}, 3);
 ```
 */
axdom.fn.bindSelectUpdateOptions = function (options, oidx) {
    var returnObj;
    axdom.each(this, function () {
        returnObj = AXSelect.bindSelectUpdateOptions(this.id, options, oidx);
    });
    return returnObj;
};
/* ---------------------------- */
var AXSlideViewer = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
		this.config.theme = "AXSlideViewer";
		/*this.uniqueId = axf.getUniqueId();*/
		this.config.id = axf.getUniqueId();
		this.config.fitToHeight = false;
		var _parent = this, cfg = this.config;
		this.touchUpdater = {
			firstTouch:{}, firstBoxModel:{}, moveType:"", item:{}, lastTouch:{},
			watch: function(){
				var _this = this;
				
				if(axf.browser.mobile){
					axdom(document.body).bind("touchmove.axsliderviewer", function(){
						_this.update(window.event);
					});
					axdom(document.body).bind("touchend.axsliderviewer", function(){
						_this.watchEnd(window.event);
					});
				}else{
					axdom(document.body).bind("mousemove.axsliderviewer", function(event){
						_this.update(event);
					});
					axdom(document.body).bind("mouseup.axsliderviewer", function(event){
						_this.watchEnd(event);
					});
					axdom(document.body).bind("mouseleave.axsliderviewer", function(event){
						_this.watchEnd(event);
					});
				}
			},
			update: function(event){
				var touch = {};
				
				if(axf.browser.mobile){
					touch.pageX1 = event.touches[0].pageX - this.item._boxModel.dL;
					touch.pageY1 = event.touches[0].pageY - this.item._boxModel.dT;
	
					if(event.touches.length == 2){
						touch.pageX2 = event.touches[1].pageX - this.item._boxModel.dL;
						touch.pageY2 = event.touches[1].pageY - this.item._boxModel.dT;
						touch.centerX = (touch.pageX2 + touch.pageX1) / 2;
						touch.centerY = (touch.pageY2 + touch.pageY1) / 2;
					}else{
						touch.centerX = touch.pageX1;
						touch.centerY = touch.pageY1;
					}
						
	
					this.lastTouch = touch;
					_parent.imgTouchUpdate( {firstTouch:this.firstTouch, firstBoxModel:this.firstBoxModel, touch:touch, moveType:this.moveType, item:this.item}, event );
	
					if (event.stopPropagation) event.stopPropagation();
					if (event.preventDefault) event.preventDefault();
					return false;
					
				}else{
					touch.pageX1 = event.pageX - this.item._boxModel.dL;
					touch.pageY1 = event.pageY - this.item._boxModel.dT;
					touch.centerX = touch.pageX1;
					touch.centerY = touch.pageY1;

					this.lastTouch = touch;
					_parent.imgTouchUpdate( {firstTouch:this.firstTouch, firstBoxModel:this.firstBoxModel, touch:touch, moveType:this.moveType, item:this.item}, event );

				}
				
			},
			watchEnd: function(event){				
				if(axf.browser.mobile){
					axdom(document.body).unbind("touchmove.axsliderviewer");
					axdom(document.body).unbind("touchend.axsliderviewer");
				}else{
					axdom(document.body).unbind("mousemove.axsliderviewer");
					axdom(document.body).unbind("mouseup.axsliderviewer");
					axdom(document.body).unbind("mouseleave.axsliderviewer");
				}
				//관성 적용 법칙...
				_parent.imgTouchEnd( {firstTouch:this.firstTouch, firstBoxModel:this.firstBoxModel, moveType:this.moveType, item:this.item}, event );	
			}
		};
		this.touchClicked = false;
		this.touchDblClicked = false;
		this.touchAndMoved = false;
    },
/**
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @method AXSliderViewer.setConfig
 * @param {Object} Config of Class
 * @example
```js
var myViewer = new AXSlideViewer();
myViewer.setConfig({
	id:"myViewer01", // 뷰어 이름
	fitToHeight: false, // 이미지의 높이를 브라우저 높이에 맞추기. 브라우저보다 작은 이미지를 늘리는 효과가 있습니다.
	reserveKeys: { // 이미지 아이템의 키이름 사용자 정의
		title: "title",
		description: "description",
		url: "url"
	}
});
```
 */
    init: function() {
		var cfg = this.config;
		var reserveKeys = {
			title: "title",
			description: "description",
			url: "url"
		};
		if (cfg.reserveKeys) {
			axf.overwriteObject(reserveKeys, cfg.reserveKeys, true);
			cfg.reserveKeys = reserveKeys;
		} else {
			cfg.reserveKeys = reserveKeys;
		}
    },
/**
 * 슬라이더에 이미지 아이템과 오픈할 이미지 인덱스 정보를 전달합니다.
 * @method AXSliderViewer.open
 * @param {Object} slideObject
 * @example
```js
 var mySliderObj = {}
 jQuery(".sliderIcons").each(function(){
    // 클래스 sliderIcons 노드를 찾아요
    var thisId = this.id;
    mySliderObj[thisId] = []; //배열을 만들었어요.

    jQuery(this).find(".findImg").each(function(fidx, F){
        // 배열에 수집된 정보를 연결 해요.
        var imgNode = jQuery(F);
        // 만약 부모에 접근 한다면 parent() 로 해결
		mySliderObj[thisId].push(
			{
				title: imgNode.attr("title")||"untitle", // alt ? title ? 적당히
				description: imgNode.attr("longDesc")||"..", // alt ? title ? 적당히
				url: F.src.replace("/thumb", "").replace("\.png", ".jpg"),
				thumb: F.src
			}
		);
		// 클릭이벤트 장착~
		jQuery(F).bind("click", function(){
			myViewer.open({id:"myViewer01", list:mySliderObj[thisId], selectedIndex:fidx});
		});
	});
 });
```
 */
    open: function(jsObject){ // jsArray, jsObject
     	var cfg = this.config, _this = this;
     	
     	this.isOpend = true;
     	
     	axdom(document.body).data("scrollTop", axdom(document.body).scrollTop());
     	//axdom(document.body).children().hide();
     	//this.bodyElement = axdom(document.body).children().not("script");
     	//axdom(document.body).children().not("script").remove();
     	
		this.screenSize = {
			width:axf.clientWidth(),
			height:axf.clientHeight()
		};
     	var po = [];
     	po.push('<div id="'+ cfg.id +'_AX_viewer" class="' + cfg.theme + ' AXUserSelectNone" onselectstart="return false">');
     	
     		po.push('<div class="background" id="'+ cfg.id +'_AX_background"></div>');
     		
     		po.push('<div class="slideItemGroup" id="'+ cfg.id +'_AX_slideItemGrop">');
	     	po.push('</div>');	
     		
     		po.push('<div class="controller" id="'+ cfg.id +'_AX_controller">');
	     			
	     			po.push('<div class="hgroup">');
	     				po.push('<h1></h1>');
	     				po.push('<span></span>');
	     			po.push('</div>');

	     			po.push('<div class="navigation"></div>');

     				po.push('<div class="buttonGroup">');
	     				po.push('<a class="ToggleHandle" type="button">Toggle</a>');
	     				po.push('<a class="Prev" type="button">Prev</a>');
		     			po.push('<a class="Next" type="button">Next</a>');
		     			po.push('<a class="ZoomIn" type="button">Next</a>');
		     			po.push('<a class="ZoomOut" type="button">Next</a>');
		     		po.push('</div>');

	     			po.push('<a class="Close" type="button">Close</a>');
     		po.push('</div>');
     		
     	po.push('</div>');
     	
     	axdom(document.body).append( po.join('') );
     	
     	this.target = axdom( '#' + cfg.id +'_AX_viewer' );
     	this.background = axdom( '#' + cfg.id +'_AX_background' );
     	this.slideItemGrop = axdom( '#' + cfg.id +'_AX_slideItemGrop' );
     	this.controller = axdom( '#' + cfg.id +'_AX_controller' );
     	
     	this.controller.find(".Close").bind("click.AXSlideViewer", function(event){
     		_this.close();
     	});

     	this.controller.find(".ToggleHandle").bind("click.AXSlideViewer", function(event){
     		_this.controller.find(".buttonGroup").toggleClass("open");
     	});
     	this.controller.find(".Prev").bind("click.AXSlideViewer", function(event){
     		_this.prev();
     	});
     	this.controller.find(".Next").bind("click.AXSlideViewer", function(event){
     		_this.next();
     	});
     	
     	this.controller.find(".ZoomIn").bind("click.AXSlideViewer", function(event){
     		_this.zoomIn();
     	});
     	this.controller.find(".ZoomOut").bind("click.AXSlideViewer", function(event){
     		_this.zoomOut();
     	});
     	
     	this.list = jsObject.list;
     	this.selectedIndex = (jsObject.selectedIndex || 0);

     	this.openImage(this.selectedIndex);
     	axdom(window).bind("resize.AXSliderViewer", this.windowResize.bind(this));
     	
		if(axf.browser.mobile){
			
			var eventBodyID = cfg.id +'_AX_slideItemGrop';
			if (document.addEventListener) { // 터치 이벤트 시작
				AXgetId(eventBodyID).addEventListener("touchstart", function(event){
					var touch = {};
					var item = _this.list[_this.selectedIndex];
					
					if (_this.touhEndObserver) clearTimeout(_this.touhEndObserver);
					_this.velocityDX = 0;
					_this.velocityDY = 0;
					touch.pageX1 = event.touches[0].pageX - item._boxModel.dL;
					touch.pageY1 = event.touches[0].pageY - item._boxModel.dT;
					if(event.touches.length == 2){
						touch.pageX2 = event.touches[1].pageX - item._boxModel.dL;
						touch.pageY2 = event.touches[1].pageY - item._boxModel.dT;
						touch.centerX = (touch.pageX2 + touch.pageX1) / 2;
						touch.centerY = (touch.pageY2 + touch.pageY1) / 2;
						_this.touchUpdater.moveType = "zoom";
					}else{
						touch.centerX = touch.pageX1;
						touch.centerY = touch.pageY1;
						_this.touchUpdater.moveType = "move";
					}
					_this.touchUpdater.firstTouch = touch;
					_this.touchUpdater.firstBoxModel = axf.copyObject(item._boxModel);
					_this.touchUpdater.item = item;
					_this.touchUpdater.watch();
				}, false);
			}
			
		}else{ // deskTop
			
			var eventBodyID = cfg.id +'_AX_slideItemGrop';

				axdom("#" +eventBodyID).bind("mousedown.axsliderviewer", function(event){
					var touch = {};
					var item = _this.list[_this.selectedIndex];
					
					if (_this.touhEndObserver) clearTimeout(_this.touhEndObserver);
					_this.velocityDX = 0;
					_this.velocityDY = 0;
					touch.pageX1 = event.pageX - item._boxModel.dL;
					touch.pageY1 = event.pageY - item._boxModel.dT;

					touch.centerX = touch.pageX1;
					touch.centerY = touch.pageY1;
					
					_this.touchUpdater.moveType = "move";

					_this.touchUpdater.firstTouch = touch;
					_this.touchUpdater.firstBoxModel = axf.copyObject(item._boxModel);
					_this.touchUpdater.item = item;
					_this.touchUpdater.watch();
				});
				
				var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
				var contentScrollScrollWheel = function(){
					if (_this.wheelEndObserver) clearTimeout(_this.wheelEndObserver);
					var event = window.event;
					var delta = event.detail ? event.detail * (-1) : event.wheelDelta;
			    	var item = _this.list[_this.selectedIndex];
			    	
			    	var cx = event.pageX  - item._boxModel.dL;
			    	var cy = event.pageY  - item._boxModel.dT;
			    	var dLen = (delta > 0) ? 50 : -50;
			    	_this.imgResize(item, item._boxModel, dLen, cx, cy);
			    	_this.wheelEndObserver = setTimeout(function(){
						var pos = item._axdom.position();						
				    	var sL = 0, eL = 0, sT = 0, eT = 0, scW = _this.screenSize.width, scH = _this.screenSize.height, iW = item._axdom.width(), iH = item._axdom.height();
				    	
				    	var imgAnmate = false;
				    	var css = {left:pos.left, top:pos.top, opacity:1};
				    	var __left = css.left, __top = css.top;
				    	
				    	if(iW < scW && iH < scH){
				    		iW = css.width = item._boxModel.width;
				    		iH = css.height  = item._boxModel.height;
				    	}
				
				    	if(iW < scW){
				    		sL = (scW - iW) / 2;
				    		eL = sL;
				    	}else{
				    		sL = 0;
				    		eL = scW - iW;
				    	}
				    	if(iH < scH){
				    		sT = (scH - iH) / 2;
				    		eT = sT;
				    	}else{
				    		sT = 0;
				    		eT = scH - iH;
				    	}
				
				    	if(css.left > sL ){
				    		css.left = sL;
				    		imgAnmate = true;
				    	}else if(css.left < eL ){
				    		css.left = eL;
				    		imgAnmate = true;
				    	}
				    	if(css.top > sT ){
				    		css.top = sT;imgAnmate = true;
				    	}else if(css.top < eT ){
				    		css.top = eT;imgAnmate = true;
				    	}
				    	if(imgAnmate){
				    		item._axdom.stop();
				    		item._axdom.animate(css);
					    	if(!isNaN(css.left)) item._boxModel.dL = css.left;
					    	if(!isNaN(css.top)) item._boxModel.dT = css.top;

					    	if(!isNaN(css.width)) item._boxModel.dW = css.width;
					    	if(!isNaN(css.height)) item._boxModel.dH = css.height;
				    	}

			    		
			    	}, 300);
				};
				if (document.attachEvent) { /*if IE (and Opera depending on user setting) */
					AXgetId(eventBodyID).attachEvent("on" + mousewheelevt, contentScrollScrollWheel);
				} else if (document.addEventListener) { /*WC3 browsers */
					AXgetId(eventBodyID).addEventListener(mousewheelevt, contentScrollScrollWheel, false);
				}
				
			
		}
    },
	windowResizeApply: function () {
		var cfg = this.config, _this = this;
		this.screenSize = {
			width:axf.clientWidth(),
			height:axf.clientHeight()
		};
		
		var selectedIndex = this.selectedIndex;
		if(selectedIndex > 0){
			axdom('#' + cfg.id +'_AX_slide_AX_' + (selectedIndex-1)).css({left:-this.screenSize.width});
		}
		if(selectedIndex < this.list.length-1){
			axdom('#' + cfg.id +'_AX_slide_AX_' + (selectedIndex.number()+1)).css({left:this.screenSize.width});
		}
		
		var item = this.list[selectedIndex];
		_this.renderImage( axdom('#' + cfg.id +'_AX_slide_AX_' + selectedIndex), item);
	},
    openImage: function(selectedIndex){
    	var cfg = this.config, _this = this;
    	selectedIndex = selectedIndex.number();
    	var item = this.list[selectedIndex];

		//this.slideItemGrop
		var slides = [];
		if(selectedIndex > 0) slides.push( {id:cfg.id +'_AX_slide_AX_' + (selectedIndex-1), index:(selectedIndex-1), left:-this.screenSize.width} );
		slides.push( {id:cfg.id +'_AX_slide_AX_' + (selectedIndex), index:(selectedIndex), left:0} );
		if(selectedIndex < this.list.length-1) slides.push( {id:cfg.id +'_AX_slide_AX_' + (selectedIndex.number()+1), index:(selectedIndex.number()+1), left:this.screenSize.width} );	
		
		this.slideItemGrop.find(".slideItem").each(function(){
			for (var ii, i = 0; (i < slides.length && (ii = slides[i])); i++) {
				if(ii.id != this.id) axdom(this).remove();
			}
		});
		
		for (var ii, i = 0; (i < slides.length && (ii = slides[i])); i++) {
			if( !AXgetId(ii.id) ) this.slideItemGrop.append( '<div class="slideItem AXLoadingBlack" id="'+ ii.id +'" style="left:'+ ii.left +'px;"></div>' );
		}
		
		var hgroup = this.controller.find(".hgroup");
		hgroup.find("h1").html( item[cfg.reserveKeys.title] );
		hgroup.find("span").html( item[cfg.reserveKeys.description] );
		
		if(selectedIndex == 0){
			this.controller.find(".Prev").addClass("disabled");
			this.controller.find(".Next").removeClass("disabled");
		}else if(selectedIndex == this.list.length-1){
			this.controller.find(".Prev").removeClass("disabled");
			this.controller.find(".Next").addClass("disabled");
		}else{
			this.controller.find(".Prev").removeClass("disabled");
			this.controller.find(".Next").removeClass("disabled");
		}
		
		this.controller.find(".navigation").html( (selectedIndex+1) + " / " + this.list.length  );
		
		var mySlide = axdom('#' + cfg.id +'_AX_slide_AX_' + (selectedIndex));
		var myImg = new Image();

		if(!item._boxModel){
			myImg.onload = function(){
				item._boxModel = {originalWidth:this.width, originalHeight:this.height};
				_this.renderImage( mySlide , item);
			}
			myImg.src = item[cfg.reserveKeys.url];
		}else{
			myImg.src = item[cfg.reserveKeys.url];
			_this.renderImage( mySlide, item);
		}
    },
    renderImage: function( target, item ){
    	
		var cfg = this.config, _this = this;
		var imgRatio = (item._boxModel.originalHeight / item._boxModel.originalWidth).round(2);
		var imgWidth = item._boxModel.originalWidth; imgHeight = item._boxModel.originalHeight;
		
		if(cfg.fitToHeight == true){
			imgHeight = this.screenSize.height; imgWidth = imgHeight / imgRatio;
			if(this.screenSize.width > imgWidth){
				imgWidth = this.screenSize.width; imgHeight = imgWidth * imgRatio;
			}
		}else{
			if(imgRatio < 1){
				if(this.screenSize.width < imgWidth){
					imgWidth = this.screenSize.width; imgHeight = imgWidth * imgRatio;
				}
				if(this.screenSize.height < imgHeight){
					imgHeight = this.screenSize.height; imgWidth = imgHeight / imgRatio;
				}
			}else{
				if(this.screenSize.height < imgHeight){
					imgHeight = this.screenSize.height; imgWidth = imgHeight / imgRatio;
				}
				if(this.screenSize.width < imgWidth){
					imgWidth = this.screenSize.width; imgHeight = imgWidth * imgRatio;
				}
			}
		}
		
		item._boxModel.width = item._boxModel.dW = imgWidth;
		item._boxModel.height = item._boxModel.dH = imgHeight;
		
		var styles = [];
		styles.push("width:"+imgWidth+"px");
		styles.push("height:"+imgHeight+"px");

		item._boxModel.left = item._boxModel.dL = (this.screenSize.width / 2 - imgWidth / 2);
		item._boxModel.top = item._boxModel.dT = (this.screenSize.height / 2 - imgHeight / 2);
		
		styles.push("left:"+ item._boxModel.left +"px");
		styles.push("top:"+ item._boxModel.top +"px");
		
		var po = [];
		po.push('<div class="img" style="' + styles.join(";") + '">');
		po.push('<img src="' + item[cfg.reserveKeys.url] + '" style="width:100%;" ondragstart="return false;" />');
		po.push('</div>');
		
		target.empty();
		target.append( po.join('') );
		
		target.find(".img").fadeIn();
		target.removeClass("AXLoadingBlack");
		
		item._axdom = target.find(".img");
    },

/**
 * 이미지 슬라이더를 닫습니다.
 * @method AXSliderViewer.close
 */
    close: function(){
        var cfg = this.config, _this = this;
    	//axdom(document.body).children().show(); //테스트 필요
    	axdom(document.body).scrollTop( axdom(document.body).data("scrollTop") );
        if(cfg.onClose) cfg.onClose.call(cfg);
    	this.target.fadeOut(function(){
    		_this.target.remove();
    	});
    	this.isOpend = false;
    	axdom(window).unbind("resize.AXSliderViewer");
    },
/**
 * 이전 이미지로 이동합니다.
 * @method AXSliderViewer.prev
 * @returns {Boolean}
 */
    prev: function(){
   		var cfg = this.config, _this = this;
    	var screenWidth = this.screenSize.width;
    	var selectedIndex = this.selectedIndex;
    	if(selectedIndex <= 0) return false;
    	var prevIndex = selectedIndex.number() - 1;
    	
    	var nowDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + selectedIndex);
    	var prevDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + prevIndex);

    	nowDomTarget.animate({left:screenWidth}, 500, "expoOut", function(){
    		
    	});
    	prevDomTarget.animate({left:0}, 300, "expoOut", function(){
			_this.selectedIndex = prevIndex;
			_this.openImage(prevIndex);
    	});
    	return true;
    },
/**
 * 다음 이미지로 이동합니다.
 * @method AXSliderViewer.next
 * @returns {Boolean}
 */
    next: function(){
    	var cfg = this.config, _this = this;
    	var screenWidth = this.screenSize.width;
    	var selectedIndex = this.selectedIndex;
    	if(selectedIndex >= this.list.length-1) return false;
    	var nextIndex = selectedIndex.number() + 1;
    	
    	var nowDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + selectedIndex);
    	var nextDomTarget = axdom('#' + cfg.id +'_AX_slide_AX_' + nextIndex);

    	nowDomTarget.animate({left:-screenWidth}, 500, "expoOut", function(){
    		
    	});
    	nextDomTarget.animate({left:0}, 300, "expoOut", function(){
			_this.selectedIndex = nextIndex;
			_this.openImage(nextIndex);
    	});
    	 return true;
    },
	/**
	 * 현재 이미지를 확대 합니다.
	 * @method AXSliderViewer.zoomIn
	 * @returns {AXSliderViewer}
	 */
    zoomIn: function(){
    	var cfg = this.config, _this = this;
    	var item = this.list[this.selectedIndex];
    	
    	var cx = this.screenSize.width/2  - item._boxModel.dL;
    	var cy = this.screenSize.height/2  - item._boxModel.dT;
    	var dLen = (this.screenSize.width>this.screenSize.height) ? this.screenSize.height : this.screenSize.width;
    	this.imgResize(item, item._boxModel, dLen, cx, cy, "animate");
		return this;
    },
	/**
	 * 현재 이미지를 축소 합니다.
	 * @method AXSliderViewer.zoomOut
	 * @returns {AXSliderViewer}
	 */
    zoomOut: function(){
    	var cfg = this.config, _this = this;
    	var item = this.list[this.selectedIndex];
    	var cx = this.screenSize.width/2  - item._boxModel.dL;
    	var cy = this.screenSize.height/2  - item._boxModel.dT;
    	var dLen = (this.screenSize.width>this.screenSize.height) ? this.screenSize.height : this.screenSize.width;
    	this.imgResize(item, item._boxModel, -dLen, cx, cy, "animate");
		return this;
    },
    
    imgResize: function(item, firstBoxModel, dLen, cx, cy, animate){
		//trace(firstBoxModel.dW);
    	//trace(item._boxModel.dW, item._boxModel.dH, item._boxModel.dL, item._boxModel.dT); 조작해야할 변수들
    	var cfg = this.config, _this = this;
    	var css = {}, newW, newH, newL, newT, imgRatio = (item._boxModel.originalHeight / item._boxModel.originalWidth).round(3);
    	
    	if(dLen == null){
    		
    		newL = item._boxModel.left
    		newT = item._boxModel.top
    		newW = item._boxModel.width
    		newH = item._boxModel.height
    		
    	}else{
	    	newW = firstBoxModel.dW + dLen;
	    	newH = newW * imgRatio;
	    	
	    	//firstBoxModel.dW : newW = cx : newL
	    	if(cx == null){
	    		newL = (this.screenSize.width/2);
	    		mewT = (this.screenSize.width/2);
		    	//newL = -(newW * cx / firstBoxModel.dW - cx) + firstBoxModel.dL;
		    	//newT = -(newH * cy / firstBoxModel.dH - cy) + firstBoxModel.dT;
	    	}else{
		    	newL = -(newW * cx / firstBoxModel.dW - cx) + firstBoxModel.dL;
		    	newT = -(newH * cy / firstBoxModel.dH - cy) + firstBoxModel.dT;
		    }
	    }
    	
    	// 영역을 벗어나는 변경에 대해서 감지
    	
    	css = {left:newL, top:newT, width:newW, height:newH, opacity:1};
    	if( this.changeImgCss(item._axdom, css, animate) ){	
	    	//현재아이템에 이동정보 기록
	    	item._boxModel.dL = newL;
	    	item._boxModel.dT = newT;
	    	item._boxModel.dW = newW;
	    	item._boxModel.dH = newH;
	    }
    },
    imgTouchUpdate: function(args){
    	var cfg = this.config;
    	this.touchAndMoved = true;
    	if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
		if(args.moveType == "zoom"){
			var l1dx, l1dy, l2dx, l2dy, l1, l2, dLen;
			l1dx = (args.firstTouch.pageX2 > args.firstTouch.pageX1) ? args.firstTouch.pageX2 - args.firstTouch.pageX1 : args.firstTouch.pageX1 - args.firstTouch.pageX2;
			l1dy = (args.firstTouch.pageY2 > args.firstTouch.pageY1) ? args.firstTouch.pageY2 - args.firstTouch.pageY1 : args.firstTouch.pageY1 - args.firstTouch.pageY2;
			
			l2dx = (args.touch.pageY2 > args.touch.pageY1) ? args.touch.pageY2 - args.touch.pageY1 : args.touch.pageY1 - args.touch.pageY2;
			l2dy = (args.touch.pageY2 > args.touch.pageY1) ? args.touch.pageY2 - args.touch.pageY1 : args.touch.pageY1 - args.touch.pageY2;
			
	    	l1 = Math.sqrt(Math.pow(l1dx, 2) + Math.pow(l1dy, 2)); // 첫번째 터치의 선분의 길이
	    	l2 = Math.sqrt(Math.pow(l2dx, 2) + Math.pow(l2dy, 2)); // 이동중인 터치의 선분의 길이
			
			dLen = ((l2-l1)*1.2).round(3); // 크기 변화량
			if(!isNaN(dLen)){
				//이동량 만큼 이미지를 크게 하거나 줄이기.
				//trace(args.firstTouch.centerX, args.firstTouch.centerY);
				this.imgResize(args.item, args.firstBoxModel, dLen, args.firstTouch.centerX, args.firstTouch.centerY);
			}
	    }else{
	    	var mx, my, newL, newT;
    		mx = (args.firstTouch.centerX - args.touch.centerX).round();
    		my = (args.firstTouch.centerY - args.touch.centerY).round();
    		
    		if(this._mx == null){
    			this.velocityDX = 0;
				this.velocityDY = 0;
    		}else{
				this.velocityDX = this._mx - mx;
				this.velocityDY = this._my - my;
			}
    		
    		this._mx = mx;
    		this._my = my;
    		
    		if(args.item._boxModel.width == args.item._boxModel.dW){ // zoom 이 되지 않았을 때
    			if(mx.abs() > my.abs()){
					newL = args.firstBoxModel.dL - mx;
					newT = args.firstBoxModel.dT;
    			}else{
					newL = args.firstBoxModel.dL;
					newT = args.firstBoxModel.dT - my;
    			}
    		}else{
				newL = args.firstBoxModel.dL - mx;
				newT = args.firstBoxModel.dT - my;
    		}
			
			if( this.changeImgCss(args.item._axdom, {left:newL, top:newT}) ){
				
			}
	    }
    },
    imgTouchEnd: function(args, event){
    	var cfg = this.config, _this = this;
    	var pos = args.item._axdom.position();
    	
    	args.item._boxModel.dL = pos.left;
    	args.item._boxModel.dT = pos.top;
    	
    	var sL = 0, eL = 0, sT = 0, eT = 0, scW = this.screenSize.width, scH = this.screenSize.height, iW = args.item._axdom.width(), iH = args.item._axdom.height();
    	
    	//trace(pos.left, this.velocityDX);
    	
    	var imgAnmate = false;
    	if(args.moveType == "move"){
    		var css = {left:pos.left + (this.velocityDX||0)*10, top:pos.top + (this.velocityDY||0)*10, opacity:1};
    	}else{
    		var css = {left:pos.left, top:pos.top, opacity:1};
    	}
    	var __left = css.left, __top = css.top;
    	
    	if(iW < scW && iH < scH){
    		iW = css.width = args.item._boxModel.width;
    		iH = css.height  = args.item._boxModel.height;
    	}

    	if(iW < scW){
    		sL = (scW - iW) / 2;
    		eL = sL;
    	}else{
    		sL = 0;
    		eL = scW - iW;
    	}
    	if(iH < scH){
    		sT = (scH - iH) / 2;
    		eT = sT;
    	}else{
    		sT = 0;
    		eT = scH - iH;
    	}

    	if(css.left > sL ){
    		if(args.moveType == "move"){
    			if( (css.left + iW) - scW > scW * 0.35 ){
    				if(this.prev()) return "prev";
    			}
    		}
    		css.left = sL;
    		imgAnmate = true;
    	}else if(css.left < eL ){
    		if(args.moveType == "move"){
    			if( (css.left + iW) < scW * 0.35 ){
    				if(this.next()) return "next";
    			}
    		}
    		css.left = eL;
    		imgAnmate = true;
    	}
    	if(css.top > sT ){
    		if(args.moveType == "move" && args.item._boxModel.width == args.item._boxModel.dW){
    			if( (css.top + iH) - scH > scH * 0.35 ){
    				this.close();
    				return "close";
    			}
    		}
    		css.top = sT;imgAnmate = true;
    	}else if(css.top < eT ){
    		if(args.moveType == "move" && args.item._boxModel.width == args.item._boxModel.dW){
    			if( (css.top + iH) < scH * 0.35 ){
    				this.close();
    				return "close";
    			}
    		}
    		css.top = eT;imgAnmate = true;
    	}
    	if(imgAnmate){
    		args.item._axdom.stop();
    		args.item._axdom.animate(css);
	    	if(!isNaN(css.left)) args.item._boxModel.dL = css.left;
	    	if(!isNaN(css.top)) args.item._boxModel.dT = css.top;
	    	if(args.moveType == "zoom"){
		    	if(!isNaN(css.width)) args.item._boxModel.dW = css.width;
		    	if(!isNaN(css.height)) args.item._boxModel.dH = css.height;
	    	}
    	}
    	
    	this._mx = null;
    	this._my = null;

		if( !this.touchAndMoved ){
			if(this.touchClicked){
				//trace("dbl click");
				this.imgDblClick(args.item, event);
				this.touchDblClicked = true;
			}else{
				this.touchClicked = true;
			}
		}

		this.touhEndObserver = setTimeout(function () {
	    	if( !_this.touchAndMoved && !_this.touchDblClicked && _this.touchClicked){
	    		_this.imgClick(args.item, event);
	    	}
			_this.touchClicked = false; // 0.3후에 이전 터치 상태 해제
			_this.touchDblClicked = false;
			_this.touchAndMoved = false;
		}, 200);
    },
    changeImgCss: function(img, css, animate){
    	if(css.width != undefined && css.width < 100) return;
    	//img.stop();
    	if(animate){
    		img.animate(css);
    	}else{
    		img.css(css);
    	}
    	return css;
    },
    imgClick: function(item, event){
    	//trace("imgClick");
    	var cfg = this.config;
    	this.controller.toggle();
		this.touchClicked = false; // 0.3후에 이전 터치 상태 해제
		this.touchDblClicked = false;
    },
    imgDblClick: function(item, event){
    	//trace("imgDblClick");
    	var cfg = this.config;
    	
    	if(item._boxModel.dW > this.screenSize.width){
    		this.imgResize(item, this.touchUpdater.firstBoxModel, null, this.touchUpdater.firstTouch.centerX, this.touchUpdater.firstTouch.centerY, "animate");
    		//this.renderImage( axdom('#' + cfg.id +'_AX_slide_AX_' + this.selectedIndex), item);
    	}else{
	    	var dLen = this.screenSize.width * 2;
	    	this.imgResize(item, this.touchUpdater.firstBoxModel, dLen, this.touchUpdater.firstTouch.centerX, this.touchUpdater.firstTouch.centerY, "animate");
	    }
		this.touchClicked = false; // 0.3후에 이전 터치 상태 해제
		this.touchDblClicked = false;
    }
});
/* ---------------------------- */
var AXTabClass = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
        this.objects = [];
        this.config.handleWidth = 22;
        this.config.responsiveMobile = AXConfig.mobile.responsiveWidth;
        this.config.bounces = true;
        this.config.closable = ( (AXConfig && AXConfig.AXTab && AXConfig.AXTab.closable) ? AXConfig.AXTab.closable : false );
    },
    init: function(){
        axdom(window).bind("resize", this.windowResize.bind(this));
    },
    windowResize: function () {
        var windowResizeApply = this.windowResizeApply.bind(this);
        if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
        this.windowResizeObserver = setTimeout(function () {
            windowResizeApply();
        }, 500);
    },
    windowResizeApply: function(){
        this.resizeCheck();
    },
    /**
     * @method AXTabClass.bind
     * @param {Object} obj - config
     * @description 대상에 탭 속성을 부여 합니다.
     * @returns {AXTab}
     * @example
     * ```js
     * $("#myTab01").bindTab({
     *     theme : "AXTabs",
     *     value:"2",
     *     closable: false,
     *     options:[
     *         {optionValue:"1", optionText:"1살", closable: true},
     *         {optionValue:"2", optionText:"2살", closable: true},
     *         {optionValue:"3", optionText:"3살", addClass:"Red"},
     *         {optionValue:"4", optionText:"4살", addClass:"Blue"},
     *         {optionValue:"5", optionText:"5살", addClass:"Green"},
     *         {optionValue:"6", optionText:"6살", addClass:"Classic"},
     *         {optionValue:"7", optionText:"7살"}
     *     ],
     *     onchange: function(selectedObject, value){
     *         //toast.push(Object.toJSON(this));
     *         //toast.push(Object.toJSON(selectedObject));
     *         toast.push(Object.toJSON(value));
     *     },
     *     onclose: function(selectedObject, value) {
     *         //toast.push(Object.toJSON(this));
     *         //toast.push(Object.toJSON(selectedObject));
     *         toast.push(Object.toJSON(value));
     *     }
     * });
     * ```
     */
    bind: function (obj) {
        var cfg = this.config;

        if (!obj.id) {
            trace("bind 대상 ID가 없어 bind 처리할 수 없습니다.");
            return;
        }
        if (!AXgetId(obj.id)) {
            trace("bind 대상이 없어 bind 처리할 수 없습니다.");
            return;
        }

		var objID = obj.id;
		var objSeq = null;

		obj.theme = (obj.theme || "AXTabs");
		obj.overflow = (obj.overflow || "visible");
		obj.scrollAmount = (obj.scrollAmount || 5);
		obj.options = (obj.options || [{optionValue:"null", optionText:"빈 탭"}]);

        axdom.each(this.objects, function (idx, O) {
            if (this.id == objID){
            	objSeq = idx;
            	return false;
            }
        });
		if (objSeq == null) {
			objSeq = this.objects.length;
			this.objects.push({ id: objID, config: obj});
		}else{
			this.objects[objSeq].isDel = undefined;
			this.objects[objSeq].config = obj;
		}

		if(objSeq != null){
			this.initTab(objID, objSeq);
		}else{
			trace("object find error");
		}
    },
    /**
     * @method AXTabClass.initTab
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
     * @description 탭을 초기화 합니다.
     * @returns {AXTab}
	 */
    initTab: function(objID, objSeq){
    	//trace({objID:objID, objSeq:objSeq});
    	var cfg = this.config, _this = this;
    	var obj = this.objects[objSeq];

		var po = [];
	    var subOptions = [];
		po.push("<div class=\"" + obj.config.theme + "\" id=\"" + objID + "_AX_tabContainer\">");
			po.push("<div class=\"AXTabsTray\" id=\"" + objID + "_AX_tabTray\">");
				if(obj.config.overflow != "visible"){
				po.push("	<div class=\"trayScroll\" id=\"" + objID + "_AX_tabScroll\">");
				}
				po.push("	<div class=\"clear\"></div>");
			if(obj.config.overflow != "visible"){
			po.push("	</div>");
			po.push("	<div class=\"leftArrowHandleBox\" style=\"display:none;\"><a href=\"javascript:;\" class=\"tabArrow\" id=\"" + objID + "_AX_Arrow_AX_Left\">arrow</a></div>");
			po.push("	<div class=\"rightArrowHandleBox\" style=\"display:none;\"><a href=\"javascript:;\" class=\"tabArrow\" id=\"" + objID + "_AX_Arrow_AX_Right\">arrow</a></div>");
			po.push("	<div class=\"rightArrowMoreBox\" style=\"display:none;\"><a href=\"javascript:;\" class=\"tabArrow\" id=\"" + objID + "_AX_Arrow_AX_More\">arrow</a></div>");
			}
			po.push("</div>");

			if(subOptions.length > 0){
				// subOptions :
			}
		po.push("</div>");

		obj.jQueryObjID = axdom("#"+objID);
		obj.jQueryObjID.html(po.join(''));
		obj.jQueryObjID.data("objSeq", objSeq); /* memory objSeq */

		obj.tabTray = axdom("#" + objID + "_AX_tabTray");
		obj.tabScroll = axdom("#" + objID + "_AX_tabScroll");
		obj.tabContainer = axdom("#" + objID + "_AX_tabContainer");

		AXContextMenu.bind({
			id:objID + "_AX_tabMore",
			theme:"AXContextMenu", // 선택항목
			width:"200", // 선택항목
			menu:[]
		});

		this.addTabs(objID, obj.config.options);

		var bindTabMove = this.bindTabMove.bind(this);
		var bindTabMoveClick = this.bindTabMoveClick.bind(this);
		var bindTabMoreClick = this.bindTabMoreClick.bind(this);

		axdom("#" + objID + "_AX_Arrow_AX_Left").bind("mouseover", function(event){
			bindTabMove(objID, objSeq, "left", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Right").bind("mouseover", function(event){
			bindTabMove(objID, objSeq, "right", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Left, #" + objID + "_AX_Arrow_AX_Right").bind("mouseout", function(event){
			if(obj.moveobj) clearTimeout(obj.moveobj);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Left").bind("mousedown", function(event){
			bindTabMoveClick(objID, objSeq, "left", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_Right").bind("mousedown", function(event){
			bindTabMoveClick(objID, objSeq, "right", event);
		});
		axdom("#" + objID + "_AX_Arrow_AX_More").bind("click", function(event){
			bindTabMoreClick(objID, objSeq, "right", event);
		});

		if(obj.overflow != "visible"){
			setTimeout(function(){
				var tabsWidth = (axf.clientWidth() < cfg.responsiveMobile) ? 40 : 30;
				var tabsMargin = (axf.clientWidth() < cfg.responsiveMobile) ? 5 : 5;
				obj.tabContainer.find(".AXTab").each(function(){
					tabsWidth += (axdom(this).outerWidth().number() + axdom(this).css("marginLeft").number() + axdom(this).css("marginRight").number() + tabsMargin);
				});

				obj.tabScroll.css({width:tabsWidth, left:cfg.handleWidth});
				obj.tabTray.css({height:obj.tabScroll.outerHeight()});

				var trayWidth = obj.tabTray.outerWidth();
				var scrollWidth = obj.tabScroll.outerWidth();

				if(trayWidth > scrollWidth){
					obj.tabContainer.find(".leftArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowMoreBox").hide();
					obj.tabScroll.css({left:0});
				}else if(obj.config.selectedIndex != null){
					obj.tabContainer.find(".leftArrowHandleBox").show();
					obj.tabContainer.find(".rightArrowHandleBox").show();
					obj.tabContainer.find(".rightArrowMoreBox").show();
					_this.focusingItem(objID, objSeq, obj.config.selectedIndex);
				}

				if(trayWidth < scrollWidth && AXUtil.clientWidth() < cfg.responsiveMobile){
					obj.tabContainer.find(".leftArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowHandleBox").hide();
					obj.tabScroll.css({left:0});
				}else{

				}

				/* touch event */
				var touchstart = _this.touchstart.bind(_this);
				if(AXUtil.browser.mobile){
					var touchBodyID = obj.tabTray.get(0).id;
					_this.touchstartBind = function () { touchstart(objID, objSeq); };
					if (document.addEventListener) AXgetId(touchBodyID).addEventListener("touchstart", _this.touchstartBind, false);
				}else{
					_this.touchstartBind = function (event) { touchstart(objID, objSeq, event); };
					obj.tabTray.unbind("mousedown.AXMobileTouch").bind("mousedown.AXMobileTouch", _this.touchstartBind);
				}
				obj.tabTray.attr("onselectstart", "return false");
				obj.tabTray.addClass("AXUserSelectNone");

				obj.tabTray.unbind("dragstart.AXMobileTouch").bind("dragstart.AXMobileTouch", _this.cancelEvent.bind(_this));
				/* touch event */
			}, 50);
		}
	},
	/**
	 * @method AXTabClass.addTabs
	 * @param {String} objID - 탭 대상 ID
	 * @param {Array} options - 대상 순서 seq
	 * @description 탭을 추가 합니다.
	 * @returns {AXTab}
	 * @example
	 * ```js
	 * $("#myTab01").addTabs([
	 *     {optionValue:"1", optionText:"1살", closable: true},
	 *     {optionValue:"2", optionText:"2살", closable: true},
	 *     {optionValue:"3", optionText:"3살", addClass:"Red"},
	 *     {optionValue:"4", optionText:"4살", addClass:"Blue"},
	 *     {optionValue:"5", optionText:"5살", addClass:"Green"},
	 *     {optionValue:"6", optionText:"6살", addClass:"Classic"},
	 *     {optionValue:"7", optionText:"7살"}
	 * ]);
	 * ```
	 */
	addTabs: function(objID, options){
		var cfg = this.config;
		var objSeq = axdom("#" + objID).data("objSeq");
		var obj = this.objects[objSeq];
		var po = [];
		var target;
		if(obj.config.overflow == "visible"){
			target = axdom("#" + objID + "_AX_tabTray div.clear");
		}else{
			target = axdom("#" + objID + "_AX_tabScroll div.clear");
		}

		var tabsCnt = obj.tabContainer.find(".AXTab").length;
		var selectedIndex = null;
		axdom.each(options, function(oidx, O){
			var closable = O.closable || obj.config.closable || cfg.closable;
			oidx += tabsCnt;

			po.push("<a href=\"javascript:;\" id=\"" + objID + "_AX_Tabs_AX_"+oidx+"\" class=\"AXTab " + (O.addClass || ""));
			if(closable){
				po.push(" closable");
			}
			if(O.optionValue == obj.config.value){
				selectedIndex = oidx;
				po.push(" on");
			}
			po.push("\">");
			po.push(O.optionText.dec());
			if(closable){
				po.push("<span class=\"AXTabClose\"></span>");
			}
			po.push("</a>");
			//if(AXUtil.browser.mobile){
				po.push("<span class='AXTabSplit'></span>");
			//}
		});

		if(selectedIndex != null){
			obj.config.selectedIndex = selectedIndex;
		}
		target.before(po.join(""));

		var tabsWidth = (axf.clientWidth() < cfg.responsiveMobile) ? 40 : 30;
		var tabsMargin = (axf.clientWidth() < cfg.responsiveMobile) ? 5 : 5;
		obj.tabContainer.find(".AXTab").each(function(){
			tabsWidth += (axdom(this).outerWidth().number() + axdom(this).css("marginLeft").number() + axdom(this).css("marginRight").number() + tabsMargin);
		});
		obj.tabScroll.css({width:tabsWidth});

		var setValueTab = this.setValueTab.bind(this);
		var myMenu = [];
		axdom.each(obj.config.options, function(oidx, O){
			myMenu.push({label:O.optionText, value:O.optionValue, className:"", onclick:function(){
				//trace(this);
				setValueTab(objID, this.menu.value);
			}});
		});

		var tabMoreID = objID + "_AX_tabMore";
		axdom.each(AXContextMenu.objects, function(oidx, O){
			if(O.id == tabMoreID){
				O.menu = myMenu;
				return false; // break;
			}
		});

		var bindTabClick = this.bindTabClick.bind(this);
		obj.tabContainer.find(".AXTab").unbind("click").bind("click", function(event){
			bindTabClick(objID, objSeq, event);
		});

		var closeTab = this.closeTab.bind(this);
		obj.tabContainer.find(".AXTabClose").unbind("click").bind("click", function(event){
			var tabIndex = obj.tabContainer.find(".AXTab").index(axdom(event.target).parent());
			if (tabIndex === -1) { return; }
			closeTab(objID, tabIndex, event);
		});

    this.resizeCheck();
	},
	/**
	 * @method AXTabClass.closeTab
	 * @param {String} objID - 탭 대상 ID
	 * @param {Number|String} [tabIndex or options] - 탭 인덱스(Number) or optionValue(String)
	 * @description 탭을 닫습니다.
	 * @returns {AXTab}
	 * @example
 	 * ```js
 	 * $("#myTab01").closeTab(2);
 	 * $("#myTab01").closeTab("optionValue");
 	 * ```
	 */
	closeTab: function(objID, tabIndex, event) {
		var objSeq = axdom("#" + objID).data("objSeq");
		var obj    = this.objects[objSeq];

        if (!obj.config.options) { return; }

        tabIndex = (tabIndex === undefined ? (obj.config.options.length - 1) : tabIndex);
        // find tabIndex by optionValue
        if (typeof(tabIndex) != "number") {
            axdom.each(obj.config.options, function(oidx, O){
                if (O.optionValue === tabIndex) {
                    tabIndex = oidx;
                    return false;
                }
            });
        }

        var removeTargetOption = obj.config.options.splice(tabIndex, 1)[0]; // remove and store target optoin

        // selected tab update
        if(obj.config.selectedIndex == tabIndex){
            var selectedIndex = tabIndex - 1;
            if (selectedIndex > -1) {
                this.setValueTab(objID, obj.config.options[selectedIndex].optionValue);
            } else {
                this.setValueTab(objID, obj.config.options[0].optionValue);
            }
        }else if(obj.config.selectedIndex > tabIndex){
            var selectedIndex = obj.config.selectedIndex - 1;
            if (selectedIndex > -1) {
                obj.config.selectedIndex = selectedIndex;
            }
        }

        // reinit tabs
		this.initTab(objID, objSeq);

        // fire onclose event
        if (axdom.isFunction(obj.config.onclose)) {
            obj.config.onclose.call({
                options:obj.config.options,
                item:removeTargetOption,
                index:tabIndex
            }, removeTargetOption, removeTargetOption.optionValue);
        }
	},
    /**
     * @method AXTabClass.bindTabClick
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
	 * @param {Event} event - Click event
     * @description 탭을 클릭 할때 처리를 합니다.
     * @returns {AXTab}
	 */
    bindTabClick: function(objID, objSeq, event){
    	//trace({objID:objID, objSeq:objSeq, e:event.target.id});
    	var cfg = this.config;
    	var obj = this.objects[objSeq];

		// event target search -
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXTabsTray")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("AXTab")) ? true : false; }
		});
		// event target search ------------------------


	    if (myTarget) {
		    //colHeadTool ready
		    var targetID = myTarget.id;
		    var itemIndex = targetID.split(/_AX_/g).last();

		    //trace(obj.config.options[itemIndex]);

		    var selectedObject = obj.config.options[itemIndex];
		    if(selectedObject && obj.config.value != selectedObject.optionValue){

			    axdom("#" + objID + "_AX_Tabs_AX_"+obj.config.selectedIndex).removeClass("on");
			    axdom("#" + objID + "_AX_Tabs_AX_"+itemIndex).addClass("on");

			    obj.config.value = selectedObject.optionValue;
			    obj.config.selectedIndex = itemIndex;

			    this.focusingItem(objID, objSeq, obj.config.selectedIndex);
			    if(obj.config.onclick){
				    obj.config.onclick.call({
					    options:obj.config.options,
					    item:obj.config.options[itemIndex],
					    index:itemIndex
				    }, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
			    }

			    if(obj.config.onchange){
				    obj.config.onchange.call({
					    options:obj.config.options,
					    item:obj.config.options[itemIndex],
					    index:itemIndex
				    }, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
			    }
		    }else{
			    if(obj.config.onclick){
				    obj.config.onclick.call({
					    options:obj.config.options,
					    item:obj.config.options[itemIndex],
					    index:itemIndex
				    }, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
			    }
		    }

	    }
    },
    /**
     * @method AXTabClass.setValueTab
     * @param {String} objID - 탭 대상 ID
     * @param {String} value - 값
     * @description 탭의 선택값을 변경 합니다.
     * @returns {AXTab}
     * @example
     * ```js
     * AXTab.setValueTab('myTab01','F');
     * ```
     */
    setValueTab: function(objID, value){
    	//trace({objID:objID, value:value});
		var cfg = this.config;
		var objSeq = null;
		axdom.each(this.objects, function(index, O){
			if(O.id == objID){
				objSeq = index;
				return false;
			}
		});
		if(objSeq == null){
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		}else{

			var obj = this.objects[objSeq];

			var itemIndex = null;
			axdom.each(obj.config.options, function(oidx, O){
				if(O.optionValue == value){
					itemIndex = oidx;
					return false;
				}
			});

			if(itemIndex == null) return;

			var selectedObject = obj.config.options[itemIndex];
			if(obj.config.value != selectedObject.optionValue){

				var tabs = obj.tabContainer.find(".AXTab");
				tabs.eq(obj.config.selectedIndex).removeClass("on");
				tabs.eq(itemIndex).addClass("on");
				/*  */
				this.focusingItem(objID, objSeq, itemIndex);

				obj.config.value = selectedObject.optionValue;
				obj.config.selectedIndex = itemIndex;

				if(obj.config.onchange){
					obj.config.onchange.call({
						options:obj.config.options,
						item:obj.config.options[itemIndex],
						index:itemIndex
					}, obj.config.options[itemIndex], obj.config.options[itemIndex].optionValue);
				}
			}

		}
    },
    /**
     * @method AXTabClass.bindTabMove
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
 	 * @param {String} direction - "left"||"right"
	 * @param {Event} event - "mouseover"
     * @description 탭의 양이 많아질때 생성되는 좌우 이동 화살표의 mouseover 이벤트를 처리 합니다.
     * @returns {AXTab}
	 */
    bindTabMove: function(objID, objSeq, direction, event){
    	//trace({objID:objID, objSeq:objSeq});
    	var cfg = this.config;
    	var obj = this.objects[objSeq];

		var trayWidth = obj.tabTray.outerWidth();
    	if(AXUtil.clientWidth() < cfg.responsiveMobile){
    		var rightMargin = 40;
    	}else{
    		var rightMargin = 29 + cfg.handleWidth;
    	}
    	trayWidth -= rightMargin;
		var scrollWidth = obj.tabScroll.outerWidth();
		var scrollLeft = obj.tabScroll.position().left;

		//trace({trayWidth:trayWidth, scrollWidth:scrollWidth, scrollLeft:scrollLeft});

		var animateStyles = {};
		if(direction == "left"){
			if(scrollLeft < cfg.handleWidth){
				scrollLeft += obj.config.scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{
				return;
			}
			if(scrollLeft > cfg.handleWidth){
				//trace({trayWidth:(trayWidth - cfg.handleWidth), scrollWidth:scrollWidth, scrollLeft:scrollLeft});
				scrollLeft = cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}
		}else{
			if(trayWidth < (scrollWidth + scrollLeft)){
				scrollLeft -= obj.config.scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{

			}

			if((trayWidth) > (scrollWidth + scrollLeft)){
				/*trace({trayWidth:(trayWidth - cfg.handleWidth), scrollWidth:scrollWidth, scrollLeft:scrollLeft}); */
				scrollLeft = trayWidth - scrollWidth - cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}else{
				//return;
			}

		}

		obj.tabScroll.css(animateStyles);

		var bindTabMove = this.bindTabMove.bind(this);

		if(obj.moveobj) clearTimeout(obj.moveobj);

		//trace("move");

		obj.moveobj = setTimeout(function(){
			bindTabMove(objID, objSeq, direction, event);
		}, 20);


		/*
		obj.tabScroll.animate(
			animateStyles,
			500,
			"sineInOut",
			function(){
			}
		);
		*/

    },
    /**
     * @method AXTabClass.bindTabMove
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
 	 * @param {String} direction - "left"||"right"
	 * @param {Event} event - "mousedown"
     * @description 탭의 양이 많아질때 생성되는 좌우 이동 화살표의 mousedown 이벤트를 처리 합니다.
     * @returns {AXTab}
	 */
	bindTabMoveClick: function(objID, objSeq, direction, event){
    	var cfg = this.config;
    	var obj = this.objects[objSeq];

    	if(obj.moveobj) clearTimeout(obj.moveobj);

		var scrollAmount = 500;

		var trayWidth = obj.tabTray.outerWidth();
    	if(AXUtil.clientWidth() < cfg.responsiveMobile){
    		var rightMargin = 40;
    	}else{
    		var rightMargin = 29 + cfg.handleWidth;
    	}
    	trayWidth -= rightMargin;
		var scrollWidth = obj.tabScroll.outerWidth();
		var scrollLeft = obj.tabScroll.position().left;

		//trace({trayWidth:trayWidth, scrollWidth:scrollWidth, scrollLeft:scrollLeft});

		var animateStyles = {};
		if(direction == "left"){
			if(scrollLeft < cfg.handleWidth){
				scrollLeft += scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{
				return;
			}
			if(scrollLeft > cfg.handleWidth){
				scrollLeft = cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}
		}else{
			if(trayWidth < (scrollWidth + scrollLeft)){
				scrollLeft -= scrollAmount;
				animateStyles = {left:scrollLeft};
			}else{

			}

			if((trayWidth-cfg.handleWidth) > (scrollWidth + scrollLeft)){
				//trace({trayWidth:(trayWidth - cfg.handleWidth), scrollWidth:scrollWidth, scrollLeft:scrollLeft});
				scrollLeft = trayWidth - scrollWidth - cfg.handleWidth;
				animateStyles = {left:scrollLeft};
			}else{
				//return;
			}

		}

		obj.tabScroll.stop();
		obj.tabScroll.animate(
			animateStyles,
			500,
			"sineInOut",
			function(){
			}
		);

		if (event.preventDefault) event.preventDefault();
		if (event.stopPropagation) event.stopPropagation();
		event.cancelBubble = true;
		return false;
    },
    /**
     * @method AXTabClass.bindTabMoreClick
     * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
 	 * @param {String} direction - "left"||"right"
	 * @param {Event} event - "click"
     * @description 탭의 양이 많아질때 생성되는 탭 리스트 툴 화살표에 대한 "click" 이벤트를 처리 합니다.
     * @returns {AXContextMenu}
	 */
    bindTabMoreClick: function(objID, objSeq, direction, event){
    	var cfg = this.config;
    	var obj = this.objects[objSeq];
        if(axf.clientWidth() < cfg.responsiveMobile) {
            AXContextMenu.setConfig({responsiveMobile: 640});
            /* mobile 너비 지정 */
        }
    	AXContextMenu.open({id:objID + "_AX_tabMore", title:AXConfig.AXContextMenu.title}, event);
    },
    /**
     * @method AXTabClass.resizeCheck
     * @description 윈도우 창 크기가 변경 되었을때를 감지하여 처리 합니다.
     * @returns {AXTab}
	 */
    resizeCheck: function(){
    	var cfg = this.config;
    	var focusingItem = this.focusingItem.bind(this);

    	axdom.each(this.objects, function(objSeq, O){
    		var objID = this.id;
    		var obj = this;
			var trayWidth = obj.tabTray.outerWidth();
			var scrollWidth = obj.tabScroll.outerWidth();
			if(trayWidth > scrollWidth){
				obj.tabContainer.find(".leftArrowHandleBox").hide();
				obj.tabContainer.find(".rightArrowHandleBox").hide();
				obj.tabContainer.find(".rightArrowMoreBox").hide();
				obj.tabScroll.css({left:0});
			}else{
				if(AXUtil.clientWidth() < cfg.responsiveMobile){
					obj.tabContainer.find(".leftArrowHandleBox").hide();
					obj.tabContainer.find(".rightArrowHandleBox").hide();
				}else{
					obj.tabContainer.find(".leftArrowHandleBox").show();
					obj.tabContainer.find(".rightArrowHandleBox").show();
				}
				obj.tabContainer.find(".rightArrowMoreBox").show();
				if(!AXUtil.isEmpty(obj.config.selectedIndex)) focusingItem(objID, objSeq, obj.config.selectedIndex);
			}
			obj.tabTray.css({height:obj.tabScroll.outerHeight()});
    	});
    },
	/**
	 * @method AXTabClass.focusingItem
	 * @param {String} objID - 탭 대상 ID
	 * @param {Number} objSeq - 대상 순서 seq
	 * @param {Number} optionIndex - 탭 아이템 index
	 * @description 대상의 해당 index에 해당하는 탭에 focus를 줍니다.
	 * @returns {AXTab}
	 */
	focusingItem: function(objID, objSeq, optionIndex){
		var cfg = this.config;
		var obj = this.objects[objSeq];

		if(!obj.tabScroll.position()) return;

		if(obj.tabTray.outerWidth() > obj.tabScroll.outerWidth()){
			return;
		}

		var tabs = obj.tabContainer.find(".AXTab");
		var targetTab = tabs.eq(optionIndex);
		if(AXUtil.clientWidth() < cfg.responsiveMobile){
			var scrollLeft = (targetTab.position().left);
			var itemWidth = (targetTab.outerWidth());
			var handleWidth = 0;
			var rightMargin = 40;
		}else{
			var scrollLeft = (targetTab.position().left - cfg.handleWidth);
			var itemWidth = (targetTab.outerWidth());
			var handleWidth = cfg.handleWidth;
			var rightMargin = 29 + cfg.handleWidth;
		}

		/*trace({scrollLeft:scrollLeft, tsLeft:obj.tabScroll.position().left.abs(), trayWidth:obj.tabTray.outerWidth(), itemWidth:itemWidth, tt:(obj.tabScroll.position().left.abs() + obj.tabTray.outerWidth() - rightMargin - handleWidth	)});*/
		if(scrollLeft > (obj.tabScroll.position().left).abs() && (scrollLeft + itemWidth) <= (obj.tabScroll.position().left.abs() + obj.tabTray.outerWidth() - rightMargin - handleWidth)){
			//trace(11);
		}else{
			//trace(obj.tabTray.outerWidth(), handleWidth, obj.tabScroll.outerWidth(), scrollLeft);
			if(obj.tabTray.outerWidth() - handleWidth > (obj.tabScroll.outerWidth() - scrollLeft)){
				//trace(scrollLeft);
				scrollLeft = (obj.tabScroll.outerWidth() - obj.tabTray.outerWidth()) + rightMargin;
			}
			//trace({left:-scrollLeft});
			setTimeout(function(){
				obj.tabScroll.css({left:-scrollLeft});
			}, 10);
		}
    },

    /* 터치 이동관련 함수 - s */
	touchstart: function (objID, objSeq, e) {
		if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
		if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);

		var cfg = this.config;
		var obj = this.objects[objSeq];

		var trayWidth = obj.tabTray.outerWidth();
		var scrollWidth = obj.tabScroll.outerWidth();

		if(trayWidth > scrollWidth){
			return;
		}

		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX,
				pageY : e.pageY
			};
		}

		this.touchStartXY = {
			sTime: ((new Date()).getTime() / 1000),
			sLeft:  obj.tabScroll.position().left,
			x: touch.pageX,
			y: touch.pageY
		};

		var touchEnd = this.touchEnd.bind(this);
		var touchMove = this.touchMove.bind(this);

		if(AXUtil.browser.mobile){
			var event = window.event;
			this.touchEndBind = function () {
				touchEnd(objID, objSeq);
			};
			this.touchMoveBind = function () {
				touchMove(objID, objSeq);
			};
			if (document.addEventListener) {
				document.addEventListener("touchend", this.touchEndBind, false);
				document.addEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{

			this.touchEndBind = function (event) {
				touchEnd(objID, objSeq, event);
			};
			this.touchMoveBind = function (event) {
				touchMove(objID, objSeq, event);
			};

			axdom(document.body).bind("mouseup.AXMobileTouch", this.touchEndBind);
			axdom(document.body).bind("mousemove.AXMobileTouch", this.touchMoveBind);
		}

		var minLeft = 0;
		var maxLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
		var scrollPosition = obj.tabScroll.position();

		if(scrollPosition.left < minLeft && scrollPosition.left > maxLeft){
			obj.tabScroll.stop();
		}
	},
	touchMove: function (objID, objSeq, e) {
		if (this.touhEndObserver) clearTimeout(this.touhEndObserver);
		if (this.touhMoveObserver) clearTimeout(this.touhMoveObserver);

		var cfg = this.config;
		var obj = this.objects[objSeq];

		var touch;
		var event = window.event;
		if (AXUtil.browser.mobile){
			touch = event.touches[0];
			if (!touch.pageX) return;
		}else{
			var event = e;
			touch = {
				pageX : e.pageX,
				pageY : e.pageY
			};
		}

		if ((this.touchStartXY.x - touch.pageX).abs() < (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.y - touch.pageY) <= 0) ? "up" : "dn"; /* 위아래 이동 */
		} else if ((this.touchStartXY.x - touch.pageX).abs() > (this.touchStartXY.y - touch.pageY).abs()) {
			//this.touchMode = ((this.touchStartXY.x - touch.pageX) <= 0) ? "lt" : "rt"; /* 좌우 이동 */
			this.moveBlock(objID, objSeq, touch.pageX - this.touchStartXY.x);
			if (event.preventDefault) event.preventDefault();
			else return false;
		}
		if (((this.touchStartXY.x - touch.pageX).abs() - (this.touchStartXY.y - touch.pageY).abs()).abs() < 5) {
			//this.touchSelecting = true;
		}

		var touchMoveAfter = this.touchMoveAfter.bind(this);
		this.touhMoveObserver = setTimeout(function () {
			touchMoveAfter(touch, objID, objSeq);
		}, 50);
	},
	touchMoveAfter: function(touch, objID, objSeq){
		var cfg = this.config;
		var obj = this.objects[objSeq];
		try{
			this.touchStartXY.sTime = ((new Date()).getTime() / 1000);
			this.touchStartXY.sLeft = obj.tabScroll.position().left;
			this.touchStartXY.x = touch.pageX;
			this.touchStartXY.y = touch.pageY;
		}catch(e){
			//trace(e);
		}
	},
	touchEnd: function (objID, objSeq, e) {
		var cfg = this.config;
		var obj = this.objects[objSeq];
		var event = window.event || e;

		if(AXUtil.browser.mobile){
			if (document.removeEventListener) {
				document.removeEventListener("touchend", this.touchEndBind, false);
				document.removeEventListener("touchmove", this.touchMoveBind, false);
			}
		}else{
			axdom(document.body).unbind("mouseup.AXMobileTouch");
			axdom(document.body).unbind("mousemove.AXMobileTouch");
		}

		var moveEndBlock = this.moveEndBlock.bind(this);
		this.touhEndObserver = setTimeout(function () {
			moveEndBlock(objID, objSeq);
		}, 10);
	},
	/* 터치 이동관련 함수 - e */

	moveBlock: function(objID, objSeq, moveX){
		var cfg = this.config;
		var obj = this.objects[objSeq];

		var newLeft = (this.touchStartXY.sLeft + (moveX));
		/*
			obj.tabTray
			obj.tabScroll
		*/
		//trace(newLeft);

		var newLeft = (this.touchStartXY.sLeft + (moveX));
		var minLeft = 0;
		var maxLeft = - (this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth);
		if(cfg.bounces){
			minLeft = this.touchStartXY.targetWidth * 0.4;
			maxLeft = -((this.touchStartXY.scrollWidth - this.touchStartXY.targetWidth) * 1.2);
		}

		if(newLeft > minLeft){
			newLeft = minLeft;
		}else if(newLeft < maxLeft){
			newLeft = maxLeft;
		}
		obj.tabScroll.css({left: newLeft});
	},
	moveEndBlock: function(objID, objSeq){
		var cfg = this.config;
		var obj = this.objects[objSeq];

		/* 관성발동여부 체크 */
		if(!this.touchStartXY) return;
		var sTime = this.touchStartXY.sTime;
		var eTime = ((new Date()).getTime() / 1000);
		var dTime = eTime - sTime;
		var eLeft = obj.tabScroll.position().left;
		var dLeft = eLeft - this.touchStartXY.sLeft;

		var velocity = Math.ceil((dLeft/dTime)/5); // 속력= 거리/시간
		var endLeft = Math.ceil(eLeft + velocity); //스크롤할때 목적지
		/*trace({eLeft: eLeft, velocity:velocity, endLeft:endLeft});*/
		if(endLeft > 0) endLeft = 0;
		var newLeft = endLeft.abs();
   		if(AXUtil.clientWidth() < cfg.responsiveMobile){
    		var handleWidth = 0;
    		var rightMargin = 40;
    	}else{
    		var handleWidth = cfg.handleWidth;
    		var rightMargin = 29 + cfg.handleWidth;
    	}
		if(obj.tabTray.outerWidth() - handleWidth > (obj.tabScroll.outerWidth() - newLeft)){
			newLeft = (obj.tabScroll.outerWidth() - obj.tabTray.outerWidth()) + rightMargin;
		}

		//trace(absPage);
		this.touchStartXY.sLeft = -newLeft;
		obj.tabScroll.animate({left: -newLeft}, (obj.tabScroll.position().left + newLeft).abs(), "cubicOut", function () {});
		//trace({left: -newLeft});

		this.touchStartXY = null;
	},
	cancelEvent: function (event) {
		event.stopPropagation(); // disable  event
		return false;
	},
	/**
	 * @method AXTabClass.updateTabOption
	 * @description 입력된 value값과 같은 optionValue를 가진탭의 option 을 입력된 option으로 대체합니다.
	 * @param {String} objID - 탭 대상 ID
	 * @param {String} value - 대상 탭 값
	 * @param {String} option  - 변경될 option
	 * @returns {AXTab}
	 * @example
	 * ```js
	 * AXTab.updateTabOption('myTab01','F',{optionText:"신여성",addClass:"Classic"});
	 * ```
	 */
	updateTabOption: function(objID, value, option){
    	//trace({objID:objID, value:value});
		var cfg = this.config;
		var objSeq = null;
		axdom.each(this.objects, function(index, O){
			if(O.id == objID){
				objSeq = index;
				return false;
			}
		});
		if(objSeq == null){
			//trace("바인드 된 오브젝트를 찾을 수 없습니다.");
			return;
		}else{

			var obj = this.objects[objSeq];

			var itemIndex = null;
			axdom.each(obj.config.options, function(oidx, O){
				if(O.optionValue == value){
					itemIndex = oidx;
					return false;
				}
			});

			if(itemIndex == null) return;

			var OriginalOption = obj.config.options[itemIndex];

			for(var idx in option){
				OriginalOption[idx]=option[idx];
			}

			this.initTab(objID, objSeq);

		}
    }
});

var AXTab = new AXTabClass();
AXTab.setConfig({});

/**
 * @method jQueryExtends.unbindTab
 * @param {Object} [configs]
 * @returns {jQueryObject}
 * @description 탭을 언바인드 합니다.
 * @example
 * ```js
 * axdom("#myTab01").unbindTab();
 * ```
 **/
axdom.fn.unbindTab = function (config) {
    axdom.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXTab.unbind(config);
    });
	return this;
};

/**
 * @method jQueryExtends.bindTab
 * @param {Object} configs
 * @returns {jQueryObject}
 * @description 탭을 바인드 합니다.
 * @example
 * ```js
 * $("#myTab01").bindTab({
 *    theme : "AXTabs",
 *    value:"",
 *    overflow:"scroll", // "visible"
 *    options:[
 *        {optionValue:"M", optionText:"남성", closable:true},
 *        {optionValue:"F", optionText:"여성", closable:true},
 *        {optionValue:"N", optionText:"선택안함"},
 *        {optionValue:"", optionText:"모두"}
 *    ],
 *    onchange: function(selectedObject, value){
 *        //toast.push(Object.toJSON(this));
 *        //toast.push(Object.toJSON(selectedObject));
 *        toast.push("onchange: "+Object.toJSON(value));
 *    },
 *    onclose: function(selectedObject, value){
 *        //toast.push(Object.toJSON(this));
 *        //toast.push(Object.toJSON(selectedObject));
 *        toast.push("onclose: "+Object.toJSON(value));
 *    }
 * });
 * ```
 **/
axdom.fn.bindTab = function (config) {
    axdom.each(this, function () {
        if (config == undefined) config = {};
        config.id = this.id;
        AXTab.bind(config);
    });
	return this;
};

/**
 * @method jQueryExtends.setValueTab
 * @param {String|Number} value
 * @returns {jQueryObject}
 * @description 탭의 value를 지정하고 지정된 value로 탭을 선택합니다.
 * @example
 * ```js
 * $("#"+tabID).setValueTab(tabValue);
 * ```
 **/
axdom.fn.setValueTab = function (value) {
    axdom.each(this, function () {
        AXTab.setValueTab(this.id, value);
    });
	return this;
};

/**
 * @method jQueryExtends.addTabs
 * @param {Array} options
 * @returns {jQueryObject}
 * @description 탭 아이템을 추가합니다.
 * @example
 * ```js
 * var options = [];
 * var index;
 * for(var i = 0; i < addCount; i++){
 *     index = "0" + (i + 1);
 *     options.push({optionText: "add " + index, optionValue: index, closable:true});
 * }
 * $("#" + tabID).addTabs(options);
 * ```
 **/
axdom.fn.addTabs = function (options) {
	axdom.each(this, function () {
		var objSeq = axdom("#" + this.id).data("objSeq");
		if(objSeq == null){
			return;
		}

		var obj = AXTab.objects[objSeq];
		obj.config.options = obj.config.options.concat(options);

		AXTab.addTabs(this.id, options);
	});
	return this;
};

/**
 * @method jQueryExtends.closeTab
 * @param {Number} tabIndex
 * @returns {jQueryObject}
 * @description 탭 아이템을 제거합니다.
 * @example
 * ```js
 * $("#" + tabID).closeTab(tabValue);
 * ```
 **/
axdom.fn.closeTab = function(tabValue) {
	axdom.each(this, function () {
		AXTab.closeTab(this.id, tabValue);
	});
	return this;
};

/**
 * @method jQueryExtends.updateTabs
 * @param {Array} options
 * @returns {jQueryObject}
 * @description 탭 아이템을 재설정합니다.
 * @example
 * ```js
 * var options = [];
 * var index;
 * for(var i = 0; i < addCount; i++){
 *     index = "0" + (i + 1);
 *     options.push({optionText: "O " + index, optionValue: index, closable:true});
 * }
 * $("#" + tabID).updateTabs(options);
 * ```
 **/
axdom.fn.updateTabs = function (options) {
	axdom.each(this, function () {
		var objSeq = axdom("#" + this.id).data("objSeq");
		if(objSeq == null){
			return;
		}

		var obj = AXTab.objects[objSeq];
		//obj.config.options = obj.config.options.concat(options);
		obj.config.options = options;
		obj.config.value = options[0].optionValue;
		AXTab.initTab(this.id, objSeq);
	});
	return this;
};

axdom.fn.updateTabOption = function (value,option) {
	axdom.each(this, function () {
		AXTab.updateTabOption(this.id, value, option);
	});
	return this;
};

/**
 * @method AXTabClass.getOptions
 * @param {String} objID - 탭 대상 ID
 * @returns {AXTab.options}
 * @example
 * ```js
 * AXTab.getOptions('myTab01');
 * ```
 */
axdom.fn.getOptions = function (){
	var returnValue = null;
	axdom.each(this, function(){
		var objSeq = axdom("#" + this.id).data("objSeq");
		if(objSeq == null){
			return;
		}

		var obj = AXTab.objects[objSeq];
		//obj.config.options = obj.config.options.concat(options);
		returnValue = obj.config.options;
	})
	return returnValue;
};

/* ---------------------------- */
var AXToolBar = Class.create(AXJ, {
	initialize: function (AXJ_super) {
		AXJ_super();
		this.config.theme = "AXToolBar";
		this.config.reserveKeys = { "subMenu": "subMenu" };
		this.opened = false; // expand submenu 상태 값
		this.open_midx = null;
	},
/**
 * 툴바의 환경을 설정합니다
 * @method AXToolBar.setConfig
 * @param {Object} config of toolbar
 * @example
```js
 <div class="toolBar" id="tool-bar" style="border-bottom: 1px solid #d6d6d6;border-top: 1px solid #d6d6d6;"></div>
 <script>
 var menu = [
 {
	label   : "<i class='axi axi-axisj'></i> 액시스제이", addClass: "",
	onclick : function (menu, event) {
		//trace("1", menu);
	},
	menu    : [
		{
			label: "<i class=\"axi axi-box\"></i>  Common", onclick: function (event) {},
			menu    : [
				{
					label: "<i class=\"axi axi-box\"></i> AXCore", onclick: function (event) {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXValidator", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXAddress", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> Table CSS Guide", onclick: function () {}
				}
			]
		},
		{
			label: "<i class=\"axi axi-box\"></i>  UI-Unique", onclick: function () {},
			menu    : [
				{
					label: "<i class=\"axi axi-box\"></i> AXButton", onclick: function (event) {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXInput", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXSelect", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXNotification", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXProgress", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXScroll", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXTabs", onclick: function () {}
				},
				{
					label: "<i class=\"axi axi-box\"></i> AXToolBar", onclick: function () {}
				}
			]
		},
		{
			label: "<i class=\"axi axi-box\"></i>  UI-Complex", onclick: function () {},
			underLine: true
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {}
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		}
	]
 },
 {
	label   : "<i class='axi axi-axu'></i> 악수", addClass: "",
	onclick : function (event) {

	},
	menu    : [
		{
			label: "<i class=\"axi axi-box\"></i> Archon", onclick: function (event) {}
		},
		{
			label: "<i class=\"axi axi-box\"></i> Barracks", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-box\"></i> Barracks-2", onclick: function () {}
		}
	]
 },
 {
	label   : "<i class='axi axi-axicon'></i> 액시콘", addClass: "",
	onclick : function (event) {

	},
	menu    : [
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {}
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {},
			underLine: true
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-axicon-o\"></i> AXIcon", onclick: function (event) {}
		},
		{
			label: "<i class='axi axi-accessibility'></i> Material Design Icons", onclick: function () {}
		},
		{
			label: "<i class=\"axi axi-glass\"></i> FontAwesome", onclick: function () {}
		}
	]
 },
 {
	label   : "<i class='axi axi-jsongum'></i> 제이슨껌", addClass: "",
	onclick : function (event) {

	},
	menu    : [
		{
			label: "<i class=\"axi axi-box\"></i> $4.99", onclick: function (event) {}
		},
		{
			label: "껌팔이 앱인데 하나도 안팔리고..", onclick: function () {
				alert(this.menu.label);
			}
		},
		{
			label: "그래도 액시스제이는 포기하지 않아~ 열심히 돈을 벌어서 오픈소스를", onclick: function () {
				alert(this.menu.label);
			}
		}
	]
 }
 ];
 var myToolbar = new AXToolBar();
 myToolbar.setConfig({
    targetID: "tool-bar",
    theme   : "AXToolBar",
    menu    : menu,
    reserveKeys: {
        subMenu: "menu"
    }
 });
 </script>
```
 */
	init: function(){
		var cfg = this.config;
		if (Object.isUndefined(cfg.targetID)) {
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		this.target = jQuery("#" + cfg.targetID);
		this.setBody();
	},
	filter: function (menu) {
		var cfg = this.config, that;
		if (cfg.filter) {
			that = menu;
			return cfg.filter.call(that,  that);
		} else {
			return true;
		}
	},
	setBody: function(){
		var cfg = this.config, _this = this, po = [];

		po.push('<div class="',cfg.theme,'">');
		$.each(cfg.menu, function (midx, M) {
			if(M && _this.filter(M) ) {
				var addClass = [];
				addClass.push(this.addClass);
				if (!this[cfg.reserveKeys.subMenu]) {
					addClass.push("noexpand");
				}

				po.push('<div class="ax-root-menu-item" data-item-idx="', midx, '">');
				po.push('<a href="#axexec" class="ax-menu-item ', addClass.join(" "), '" data-item-idx="', midx, '">', this.label, '</a>');
				if (this[cfg.reserveKeys.subMenu]) {
					po.push('<a href="#axexec" class="ax-menu-handel" data-item-idx="', midx, '"></a>');
				}
				po.push('</div>');
			}
		});
		po.push('<div class="clear"></div>');
		po.push('</div>');

		this.target.html(po.join(''));

		this.target.find(".ax-menu-item").bind("click", function(e){
			var target = axf.get_event_target(e.target, {tagname:"a", clazz:"ax-menu-item"});
			var midx = target.getAttribute("data-item-idx");
			if(cfg.menu[midx].onclick) _this.exec(midx, cfg.menu[midx], e);
			else _this.expand(midx, cfg.menu[midx], e);
		});
		this.target.find(".ax-root-menu-item").bind("mouseover", function(e){
			var target = axf.get_event_target(e.target, {tagname:"div", clazz:"ax-root-menu-item"});
			var midx = target.getAttribute("data-item-idx");
			_this.overitem(midx, cfg.menu[midx], e);
		});
		this.target.find(".ax-root-menu-item").bind("mouseout", function(e){
			//var target = axf.get_event_target(e.target, {tagname:"div", clazz:"ax-root-menu-item"});
			//var midx = target.getAttribute("data-item-idx");
			_this.outitem();
		});
		this.target.find(".ax-menu-handel").bind("click", function(e){
			var target = axf.get_event_target(e.target, {tagname:"a", clazz:"ax-menu-handel"});
			var midx = target.getAttribute("data-item-idx");
			//console.log(cfg.menu[midx]);
			_this.expand(midx, cfg.menu[midx], e);
		});
	},
	reset: function(){
		this.setBody();
	},
	exec: function(midx, menu, event){
		var cfg = this.config,
			that = menu;

		that.targetID = cfg.targetID;
		menu.onclick.call(that, menu, event);
	},
	overitem: function(midx, menu, event){
		var cfg = this.config, _target = this.target.find("[data-item-idx='"+midx+"']");
		this.target.find(".ax-root-menu-item").removeClass("hover");
		_target.addClass("hover");
		if(this.opened){
			this.expand(midx, menu);
		}
	},
	outitem: function(){
		if(this.opened) return;
		var cfg = this.config;
		this.target.find(".ax-root-menu-item").removeClass("hover");
	},
	expand: function(midx, menu, event){

		var cfg = this.config, _this = this,
			that = menu, offset, _target = this.target.find("[data-item-idx='"+midx+"']");

		if(this.closing){
			AXContextMenu.close({id: cfg.targetID + "_AX_expand_AX_" + this.open_midx});
			this.expand_end();
			return;
		}
		else
		if(this.open_midx != midx){
			AXContextMenu.close({id: cfg.targetID + "_AX_expand_AX_" + this.open_midx});
		}

		this.open_midx = midx;
		if(menu[cfg.reserveKeys.subMenu]) {
			if (!menu.context_menu) {

				if(typeof menu.width == "undefined") menu.width = 150;
				menu.context_menu = AXContextMenu.bind({
					id         : cfg.targetID + "_AX_expand_AX_" + midx,
					theme      : "AXContextMenu", // 선택항목
					width      : menu.width, // 선택항목
					reserveKeys: cfg.reserveKeys,
					menu       : menu[cfg.reserveKeys.subMenu],
					onclose    : function () {
						//trace(event.type);
						_this.expand_end(this);
					}
				});
			}
			offset = _target.offset();
			AXContextMenu.open({id: cfg.targetID + "_AX_expand_AX_" + midx, filter:menu.filter}, {
				left: offset.left,
				top : offset.top + _target.outerHeight()
			});
			this.opened = true;
		}else{
			this.opened = false;
		}
	},
	expand_end: function(){
		var _this = this;
		this.opened = false;
		this.open_midx = null;
		this.closing = true;
		this.outitem();
		setTimeout(function(){
			_this.closing = false;
		}, 100);
	}
});
/* ---------------------------- */
var AXTopDownMenu = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();

        this.tree = [];
        this.poi = "";
        this.config.openType = "over";
        this.config.easing = {
            open: {duraing: 200, easing: "expoOut"},
            close: {duration: 200, easing: "expoOut"}
        };
        //this.config.menuBoxID = "menuBox";
        this.config.parentMenu = {
            className: "parentMenu"
        };
        this.config.childMenu = {
            className: "childMenu",
            arrowClassName: "varrow",
            align: "center",
            valign: "top",
            margin: {top: 10, left: 0, bottom: 0},
            arrowMargin: {top: 10, left: 0, bottom: 0}
        };
        this.config.childsMenu = {
            className: "childsMenu",
            arrowClassName: "harrow",
            align: "left",
            valign: "top",
            margin: {top: 10, left: 0, bottom: 0},
            arrowMargin: {top: 10, left: 0, bottom: 0}
        };
        this.config.parentOutResetChild = true;
        this.config.childOutClose = true;
        this.config.childOutCloseTime = 700;
    },
    init: function () {
        var cfg = this.config;

        if (cfg.menuBoxID) {
            this.menuBox = axdom("#" + cfg.menuBoxID);

            //서브 메뉴를 숨김 처리 합니다.
            this.menuBox.find("." + cfg.childMenu.className).hide();
            this.menuBox.find("." + cfg.childsMenu.className).hide();

            this.initParents();
            this.initChild();
            if (cfg.onComplete) cfg.onComplete.call(this);
        }
        else if (cfg.targetID) {

        }
        axdom(window).bind("resize", this.windowResize.bind(this));
    },
    windowResizeApply: function () {
        var cfg = this.config, menuBoxWidth = 0;
        axf.each(this.tree, function () {
            this.width = axdom("#" + this.id).outerWidth();
            this.height = axdom("#" + this.id).outerHeight();
            menuBoxWidth += axdom("#" + this.id).parent().outerWidth().number() + 2;
        });
        //trace(menuBoxWidth);
        //this.menuBox.css({width:menuBoxWidth});
    },
    /**
     * @method AXTopDownMenu.setTree
     * @param {jsObject} obj - example code 참고
     * @description
     * 메뉴타겟 엘리먼트 아이디 안에 메뉴 대상 HTML 엘리먼트가 있는 경우 자동으로 메뉴를 구성합니다. setTree 메소드는 타겟을 빈 노드로 선언하고 setTree 메소드를 통해 동적으로 메뉴를 구성하는 메소드입니다.
     * @example
     ```
     var sampleTreeItem = {
    label: "Bottom Menu",			//{string} - 메뉴의 라벨
    url: "http://www.axisj.com", 	//{string} - 연결URL
    addClass: "myMenuClass", 		//{string} - 메뉴아이템에 추가할 CSS 클래스
    cn: [sampleTreeItem, ...., sampleTreeItem]	//[array] - 자식 메뉴 Array
};

     var myMenu = new AXTopDownMenu();

     var tree = [
     {label:"Bottom Menu", url:"http://www.axisj.com", cn:[
       {label:"valign - bottom", url:"http://www.axisj.com"},
       {label:"margin - bootom", url:"http://www.axisj.com"},
       {label:"margin - top X", url:"http://www.axisj.com"}
   ]},
     {label:"Script Control Way", url:"http://www.axisj.com", cn:[
        {label:"Script Way Use setTree", url:"abhttp://www.axisj.comc"},
        {label:"setHighLightMenu", url:"http://www.axisj.com", cn:[
            {label:"first : String", url:"http://www.axisj.com"},
            {label:"second : Array", url:"http://www.axisj.com"},
            {label:"third : setHighLightOriginID", url:"http://www.axisj.com"}
        ]},
       {label:"myMenu2", url:"http://www.axisj.com"}
   ]},
     {label:"no Expand Menu", url:"http://www.axisj.combc"},
     {label:"no Expand Menu", url:"http://www.axisj.com"},
     {label:"no Expand Menu", url:"http://www.axisj.com"}
     ];
     myMenu.setTree(Tree);

     ```
     */
    setTree: function (tree) {
        var cfg = this.config;
        cfg.menuBoxID = cfg.targetID, _this = this;

        if (!this.menuBox) this.menuBox = axdom("#" + cfg.menuBoxID);

        var po = [];

        var treeFn = function (subTree) {
            axdom.each(subTree, function (pi, T) {
                po.push("<li>");
                var addClass = (T.cn && T.cn.length > 0 ) ? " class = \"" + cfg.childsMenu.hasChildClassName + "\"" : "";
                if (cfg.onclick) {
                    po.push("<a data-href=\"" + (T.url || cfg.href) + "\"" + addClass + " data-id=\"" + (T._id || "") + "\" id=\"" + (T._id || "") + "\" data-label=\"" + (T.label || "").dec().delHtml() + "\">" + (T.label || "").dec() + "</a>");
                }
                else {
                    po.push("<a href=\"" + (T.url || cfg.href) + "\"" + addClass + " id=\"" + (T._id || "") + "\">" + (T.label || "").dec() + "</a>");
                }
                if (T.cn && T.cn.length > 0) {
                    po.push("<div class=\"" + cfg.childsMenu.className + "\">");
                    po.push("	<ul>");
                    po.push(treeFn(T.cn));
                    po.push("	</ul>");
                    po.push("</div>");
                }
                po.push("</li>");
            });
        };

        po.push("<ul>");
        axdom.each(tree, function (pi, T) {
            var addClass = [];
            if (T.addClass) {
                addClass.push(T.addClass);
            }
            po.push("<li>");
            po.push("	<div class=\"" + cfg.parentMenu.className + " " + addClass.join(" ") + "\">");
            var addClass = (T.cn) ? " class = \"" + cfg.childMenu.hasChildClassName + "\"" : "";

            if (cfg.onclick) {
                po.push("<a data-href=\"" + (T.url || cfg.href) + "\"" + addClass + " data-is-top='true' data-id=\"" + (T._id || "") + "\" id=\"" + (T._id || "") + "\" data-label=\"" + (T.label || "").dec().delHtml() + "\">" + (T.label || "").dec() + "</a>");
            }
            else {
                po.push("<a href=\"" + (T.url || cfg.href) + "\"" + addClass + " id=\"" + (T._id || "") + "\">" + (T.label || "").dec() + "</a>");
            }

            if (T.cn && T.cn.length > 0) {
                po.push("<div class=\"" + cfg.childMenu.className + "\">");
                po.push("	<ul>");
                po.push(treeFn(T.cn));
                po.push("	</ul>");
                po.push("</div>");
            }
            po.push("	</div>");
            po.push("</li>");
        });
        po.push("</ul>");
        po.push("<div class=\"clear\"></div>");

        this.menuBox.empty();
        this.menuBox.append(po.join(''));

        if (cfg.onclick) {
            this.menuBox.find('[data-href]').bind("click", function () {
                cfg.onclick({
                    id: this.getAttribute("data-id"),
                    href: this.getAttribute("data-href"),
                    label: this.getAttribute("data-label"),
                    isTop : this.getAttribute("data-is-top")
                });

                if (this.getAttribute("data-href") != "#") {
                    _this.outChild();
                }
            });
        }

        //서브 메뉴를 숨김 처리 합니다.
        this.menuBox.find("." + cfg.childMenu.className).hide();
        this.menuBox.find("." + cfg.childsMenu.className).hide();

        setTimeout(function () {
            _this.initParents();
            _this.initChild();
            if (cfg.onComplete) cfg.onComplete.call(this);
        }, 300);
    },
    initParents: function () {
        var cfg = this.config;
        var parents = [], menuBoxWidth = 0;
        this.menuBox.find("." + cfg.parentMenu.className).each(function (pi, EL) {
            EL.id = cfg.menuBoxID + "_PM_" + pi;
            var _id = "";

            var ELA = axdom(EL).children("A");

            if (ELA.get(0).id) _id = axdom(EL).children("A").get(0).id;
            ELA.get(0).id = cfg.menuBoxID + "_PMA_" + pi;
            ELA.attr("data-axmenuid", _id);

            parents.push({
                _id: _id,
                id: EL.id,
                width: axdom(EL).outerWidth(),
                height: axdom(EL).outerHeight(),
                cn: [],
                coi: ""
            });
            menuBoxWidth += axdom(EL).parent().outerWidth().number() + 2;
        });
        this.tree = parents;
        //this.menuBox.css({width:menuBoxWidth});

        if (cfg.openType == "over") {
            this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("mouseover", this.onoverParent.bind(this));
            this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("focus", this.onoverParent.bind(this));
            this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("click", this.onclickParent.bind(this));

            if (cfg.childOutClose) {
                var onoutChild = this.onoutChild.bind(this);
                this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("mouseout", onoutChild);
            }
        }
        else if (cfg.openType == "click") {
            this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("mouseover", this.onoverParent.bind(this));
            this.menuBox.find("." + cfg.parentMenu.className + ">a").bind("click", this.onclickParent.bind(this));
        }
    },
    onoverParent: function (event) {
        if (!this.active && this.config.openType == "click") return this;

        if (this.childObserver) clearTimeout(this.childObserver); //닫기 명령 제거
        var _this = this, cfg = this.config;

        var target = axf.get_event_target(event.target, {tagname: "a"});
        var poi = target.id.split(/\_/g).last();
        if (this.poi != "" && this.poi != poi) {
            axdom("#" + cfg.menuBoxID + "_PMA_" + this.poi).removeClass("on");
            axdom("#" + cfg.menuBoxID + "_PMC_" + this.poi).hide();
            if (cfg.parentOutResetChild) this.closeSubMenu(this.tree[this.poi]);
        }

        //slideDown check
        if (this.dfPoi != undefined) axdom("#" + cfg.menuBoxID + "_PMA_" + this.dfPoi).removeClass("on");
        axdom("#" + cfg.menuBoxID + "_PMA_" + poi).addClass("on");
        //trace("#" + cfg.menuBoxID + "_PMC_" + poi);

        var tgDiv = axdom("#" + cfg.menuBoxID + "_PMC_" + poi);
        if (this.tree[poi] && !this.tree[poi].divDim) {
            tgDiv.show();
            this.tree[poi].divDim = {width: tgDiv.outerWidth(), height: tgDiv.outerHeight()};
            if (this.tree[poi].height == null) {
                for (var index = 0; index < this.tree.length; index++) {
                    this.tree[index].height = axdom("#" + this.tree[index].id).outerHeight();
                }
                //trace(poi, this.tree[poi]);
            }
            var topDim = {width: this.tree[poi].width, height: this.tree[poi].height};

            /* subMenu positioning */
            if (cfg.childMenu.align == "center") {
                var posLeft = topDim.width / 2 - this.tree[poi].divDim.width / 2 + cfg.childMenu.margin.left;
            }
            else if (cfg.childMenu.align == "left") {
                var posLeft = 0 + cfg.childMenu.margin.left;
            }
            else if (cfg.childMenu.align == "right") {
                var posLeft = topDim.width - this.tree[poi].divDim.width + cfg.childMenu.margin.left;
            }
            if (cfg.childMenu.valign == "top") {
                var posTop = topDim.height + cfg.childMenu.margin.top;
                if (cfg.childMenu.float) {
                    tgDiv.css({top: posTop, left: posLeft});
                }
                else {
                    tgDiv.css({top: posTop, left: posLeft, width: this.tree[poi].divDim.width});
                }
            }
            else if (cfg.childMenu.valign == "bottom") {
                var posTop = topDim.height + cfg.childMenu.margin.bottom;
                if (cfg.childMenu.float) {
                    tgDiv.css({top: posTop, left: posLeft});
                }
                else {
                    tgDiv.css({top: "auto", bottom: posTop, left: posLeft, width: this.tree[poi].divDim.width});
                }
            }
            /* -------------------- */

            /* subMenu Arrow positioning */
            if (cfg.childMenu.arrowClassName) {
                var arrow = tgDiv.find("." + cfg.childMenu.arrowClassName);
                if (cfg.childMenu.align == "center") {
                    var aLeft = tgDiv.outerWidth() / 2 - arrow.outerWidth() / 2 + cfg.childMenu.arrowMargin.left;
                }
                else if (cfg.childMenu.align == "left") {
                    var aLeft = 0 + cfg.childMenu.arrowMargin.left;
                }
                else if (cfg.childMenu.align == "right") {
                    var aLeft = tgDiv.outerWidth() - arrow.outerWidth() + cfg.childMenu.arrowMargin.left;
                }
                if (cfg.childMenu.valign == "top") {
                    var aTop = -arrow.outerHeight() + cfg.childMenu.arrowMargin.top;
                    arrow.css({top: aTop, left: aLeft});
                }
                else if (cfg.childMenu.valign == "bottom") {
                    var aTop = -arrow.outerHeight() + cfg.childMenu.arrowMargin.bottom;
                    arrow.css({bottom: aTop, left: aLeft});
                }
            }
            /* -------------------- */

            tgDiv.hide();
            topDim = null;
            posTop = null;
            posLeft = null;
        }

        _this.overParentAnimate = true;
        tgDiv.show();
        /*
         tgDiv.fadeIn(
         {
         duration: cfg.easing.open.duration,
         easing: cfg.easing.open.easing,
         complete: function() {
         _this.overParentAnimate = false;
         }
         }
         );
         */

        this.poi = poi;
    },
    onclickParent: function (event) {
        var cfg = this.config;
        var target = axf.get_event_target(event.target, {tagname: "a"});
        var poi = target.id.split(/\_/g).last();

        if (!this.active) {

            this.active = true;
            this.activePoi = poi;
            this.onoverParent(event);

        } else {
            if (poi != this.activePoi) {
                this.active = true;
                this.activePoi = poi;
                this.onoverParent(event);
                return this;
            }

            this.active = false;
            axdom("#" + cfg.menuBoxID + "_PMA_" + this.poi).removeClass("on");
            axdom("#" + cfg.menuBoxID + "_PMC_" + this.poi).hide();

        }

    },
    initChild: function () {
        var cfg = this.config;
        var initChilds = this.initChilds.bind(this);
        var tree = this.tree;
        this.menuBox.find("." + cfg.parentMenu.className).each(function (pi, EL) {
            var child = axdom(EL).children("." + cfg.childMenu.className).get(0);
            if (child) {
                child.id = cfg.menuBoxID + "_PMC_" + pi;
                if (cfg.childMenu.arrowClassName) {
                    var arrow = axdom("<div class=\"" + cfg.childMenu.arrowClassName + "\"></div>");
                    axdom(child).prepend(arrow);
                }
                initChilds(child.id, tree[pi]);
            }
            else {

            }
        });
    },
    initChilds: function (cid, rTree) {
        var initChilds = this.initChilds.bind(this);
        var cfg = this.config;
        var tree = rTree.cn;

        var onoverChild = this.onoverChild.bind(this);
        var onoutChild = this.onoutChild.bind(this);
        //trace(cid);
        axdom("#" + cid + ">ul>li").each(function (pi, EL) {
            var linkA = axdom(EL).children("A");
            var _id = "";
            if (linkA.get(0).id) _id = linkA.get(0).id;
            linkA.get(0).id = cid.replace("PMC", "PMA") + "_" + pi;
            linkA.attr("data-axmenuid", _id);
            linkA.bind("mouseover", onoverChild);
            if (cfg.childOutClose && cfg.openType == "over") {
                linkA.bind("mouseout", onoutChild);
            }

            //axdom(EL).children("A").html(cid.replace("PMC", "PMA") + "_" + pi);
            var childDiv = axdom(EL).children("." + cfg.childsMenu.className).get(0);
            if (childDiv) {
                childDiv.id = cid + "_" + pi;

                if (cfg.childsMenu.arrowClassName) {
                    var arrow = axdom("<div class=\"" + cfg.childsMenu.arrowClassName + "\"></div>");
                    axdom(childDiv).prepend(arrow);
                }

                tree.push({
                    _id: _id,
                    id: cid + "_" + pi,
                    cn: [],
                    coi: ""
                });
                initChilds(cid + "_" + pi, tree[pi]);
            }
            else {
                tree.push({
                    _id: _id,
                    id: cid + "_" + pi,
                    cn: [],
                    coi: ""
                });
            }
        });
    },
    closeSubMenu: function (pitem) {
        if (!pitem) return;
        if (pitem.coi == "") return;
        var cfg = this.config;
        axdom("#" + pitem.coi).slideUp(
            {
                duration: cfg.easing.close.duration,
                easing: cfg.easing.close.easing,
                complete: function () {
                }
            }
        );
        pitem.coi = "";
        //하위 자식들의 poi 모두 닫기

        var closeAllSubMenu = function (stree) {
            axdom.each(stree, function () {
                if (this.coi != "") {
                    axdom("#" + this.coi).hide();
                }
                closeAllSubMenu(this.cn);
            });
        };
        closeAllSubMenu(pitem.cn);
    },
    onoverChild: function (event) {
        if (this.childObserver) clearTimeout(this.childObserver); //닫기 명령 제거
        var cfg = this.config;
        var target = axf.get_event_target(event.target, {tagname: "a"});
        var eid = target.id;
        var ids = target.id.split(/\_/g);
        var tree = this.tree;
        var item = {};
        var pitem = {};
        for (var a = 2; a < ids.length; a++) {
            if (a == ids.length - 2) {
                pitem = tree[ids[a]];
            }
            if (tree[ids[a]]) {
                if (tree[ids[a]].cn) {
                    item = tree[ids[a]];
                    tree = tree[ids[a]].cn;
                }
            }
        }

        if (pitem) {
            if (pitem.coi != "" && pitem.coi != item.id) {
                this.closeSubMenu(pitem);
            }
        }

        if (item) {
            if (item.id) {

                var tgDiv = axdom("#" + item.id);

                //slideDown check
                if (!item.divDim) {
                    axdom("#" + item.id).show();
                    item.divDim = {width: tgDiv.outerWidth(), height: tgDiv.outerHeight()};
                    var pDim = {
                        width: axdom("#" + eid).outerWidth(),
                        height: axdom("#" + eid).outerHeight(),
                        pos: axdom("#" + eid).position()
                    };

                    if (cfg.childsMenu.align == "left") {
                        var posLeft = pDim.width + cfg.childsMenu.margin.left;
                    }
                    else {
                        var posLeft = -item.divDim.width + cfg.childsMenu.margin.left;
                    }

                    if (cfg.childsMenu.valign == "top") {
                        var posTop = pDim.pos.top + cfg.childsMenu.margin.top;
                        tgDiv.css({top: posTop, left: posLeft, width: item.divDim.width});
                    }
                    else {
                        var posTop = (pitem.divDim.height - pDim.pos.top) - pDim.height + cfg.childsMenu.margin.bottom;
                        tgDiv.css({bottom: posTop, left: posLeft, width: item.divDim.width});
                    }

                    /* subMenu Arrow positioning */
                    if (cfg.childsMenu.arrowClassName) {

                        var arrow = tgDiv.find("." + cfg.childsMenu.arrowClassName);
                        if (cfg.childsMenu.align == "left") {
                            var aLeft = -arrow.outerWidth() + cfg.childsMenu.arrowMargin.left;
                        }
                        else {
                            var aLeft = tgDiv.outerWidth() - arrow.outerWidth() + cfg.childsMenu.arrowMargin.left;
                        }
                        if (cfg.childsMenu.valign == "top") {
                            var aTop = 0 + cfg.childsMenu.arrowMargin.top;
                            arrow.css({top: aTop, left: aLeft});
                        }
                        else if (cfg.childsMenu.valign == "bottom") {
                            var aTop = 0 + cfg.childsMenu.arrowMargin.bottom;
                            arrow.css({bottom: aTop, left: aLeft});
                        }
                    }
                    /* -------------------- */

                    tgDiv.hide();
                    pDim = null;
                    posTop = null;
                    posLeft = null;
                }

                tgDiv.fadeIn(
                    {
                        duration: cfg.easing.open.duration,
                        easing: cfg.easing.open.easing,
                        complete: function () {
                        }
                    }
                );
                if (pitem) pitem.coi = item.id.replace("PMA", "PMC");
            }

        }

    },
    onoutChild: function (event) {
        var cfg = this.config;
        var outChild = this.outChild.bind(this);
        this.childObserver = setTimeout(function () {
            outChild();
        }, cfg.childOutCloseTime);
    },
    outChild: function () {
        this.active = false;
        var cfg = this.config;
        this.closeSubMenu(this.tree[this.poi]);

        axdom("#" + cfg.menuBoxID + "_PMA_" + this.poi).removeClass("on");
        if (this.dfPoi != undefined) axdom("#" + cfg.menuBoxID + "_PMA_" + this.dfPoi).addClass("on");
        axdom("#" + cfg.menuBoxID + "_PMC_" + this.poi).slideUp(
            {
                duration: cfg.easing.close.duration,
                easing: cfg.easing.close.easing,
                complete: function () {
                }
            }
        );
    },
    setHighLightMenu: function (poi) {
        var cfg = this.config;
        this.menuBox.find(".parentMenu").removeClass("on");
        this.menuBox.find(".parentMenu a").removeClass("on");
        this.menuBox.find(".childMenu a").removeClass("on");

        if (axdom.isArray(poi)) {
            this.poi = this.dfPoi = poi;
            var tree = this.tree;
            axdom.each(poi, function (idx, T) {
                if (idx == 0) tree = tree[T.number()];
                else  tree = tree.cn[T.number()];
                if (tree) {
                    if (idx == 0) {
                        axdom("#" + tree.id).addClass("on");
                        axdom("#" + tree.id).children("A").addClass("on");
                    }
                    else {
                        axdom("#" + tree.id.replace("_PMC_", "_PMA_")).addClass("on");
                    }
                }
            });
        }
        else {
            this.poi = this.dfPoi = poi;
            axdom("#" + cfg.menuBoxID + "_PMA_" + this.dfPoi).addClass("on");
        }
    },
    /**
     * @method AXTopDownMenu.setHighLightOriginID
     * @param {string} - 메뉴 엘리먼트에 사용자가 정의한 ID
     * @description
     * 타겟 엘리먼트안에 Html 엘리먼트로 메뉴를 정의한 경우 엘리먼트 안에 사용자가 정의해 둔 아이디로 메뉴의 하이라이트를 처리해줍니다.
     * @example
     ```
     myMenu.setHighLightOriginID("ID1245");
     ```
     */

    setHighLightOriginID: function (_id) {
        var cfg = this.config;
        var tree = this.tree;
        var findedID = "";

        var treeFn = function (subTree) {
            axdom.each(subTree, function (idx, T) {
                if (T._id == _id) {
                    findedID = T.id;
                    return false;
                }
                else {
                    if (T.cn) treeFn(T.cn);
                }
            });
        };

        axdom.each(this.tree, function (idx, T) {
            if (T._id == _id) {
                findedID = T.id;
                return false;
            }
            else {
                if (T.cn) treeFn(T.cn);
            }
        });

        if (findedID) {
            this.findedID = findedID;
            var pos = findedID.split(/_PM[C]?_/g).last();
            var selectedMenus = pos.split(/_/g);
            this.setHighLightMenu(selectedMenus);
            return selectedMenus;
        } else {
            this.menuBox.find(".parentMenu").removeClass("on");
            this.menuBox.find(".parentMenu a").removeClass("on");
            this.menuBox.find(".childMenu a").removeClass("on");
        }

    },

    /**
     * @method AXTopDownMenu.setHighLightID
     * @param {array} - [0, 1] 와 같이 각 뎁스의 순번을 전달합니다.
     * @description
     * 메뉴의 포지션 값으로 포지션에 해당하는 메뉴를 하이라이트 처리해 줍니다.
     * @example
     ```
     myMenu.setHighLightMenu([2, 1]); // 3번째 아이템(1depth)의 2번째 아이템(2depth)을 하이라이트 처리합니다.
     ```
     */
    setHighLightID: function (_id) {
        var cfg = this.config;
        var tree = this.tree;
        var findedID = "";

        var treeFn = function (subTree) {
            axdom.each(subTree, function (idx, T) {
                if (T.id == _id) {
                    findedID = T.id;
                    return false;
                }
                else {
                    if (T.cn) treeFn(T.cn);
                }
            });
        };
        axdom.each(tree, function (idx, T) {
            if (T.id == _id) {
                findedID = T.id;
                return false;
            }
            else {
                if (T.cn) treeFn(T.cn);
            }
        });

        if (findedID) {
            this.findedID = findedID;
            var pos = findedID.split(/_PM[C]?_/g).last();
            var selectedMenus = pos.split(/_/g);
            this.setHighLightMenu(selectedMenus);
            return selectedMenus;
        }
    }
});
/* ---------------------------- */
var AXTree = Class.create(AXJ, {
	initialize: function (AXJ_super) {
		AXJ_super();
		this.Observer = null;
		this.tree = [];
		this.list = [];

		this.pageActive = false;
		this.page = {}; /*{pageNo:0, pageSize:100, pageCount:"", listCount:0};*/

		this.moveSens = 0;

		this.config.moveSens = 1;
		this.config.formPaddingRight = "11px";
		this.config.sort = true;
		this.config.xscroll = true;
		this.config.showConnectionLine = false;
		this.config.iconWidth = 23;
		this.config.indentWidth = 20;
		this.config.indentRatio = 1;

		this.config.fitToWidth = (AXConfig.AXTree.fitToWidth || false);
		this.config.fitToWidthRightMargin = (AXConfig.AXTree.fitToWidthRightMargin || 10);
		this.config.checkboxRelationFixed = true;

		this.selectedCells = [];
		this.selectedRow = [];
		this.config.hashDigit = 3;

		this.isMobile = AXUtil.browser.mobile;

        this.config.persistExpanded  = (AXConfig.AXTree.persistExpanded || false);
        this.config.persistSelected  = (AXConfig.AXTree.persistSelected || false);
        this.config.cookiePrefix     = (AXConfig.AXTree.cookiePrefix || "axtree-");
        this.config.cookieExpiredays = (AXConfig.AXTree.cookieExpiredays || 7);

        window.AXTree_instances = window.AXTree_instances || [];
		window.AXTree_instances.push(this);
	},
	/* 공통 영역 */
	defineConfig: function (rewrite) {
		var cfg = this.config;
		if (cfg.colGroup.length == 0) {
			trace("colGrpup is empty)");
			return;
		}

		/* col너비 합계 구하기 */
		var colWidth = 0;
		var hasHiddenCell = false;
		var showColLen = 0;
		if (!rewrite) this.fixedColSeq = cfg.fixedColSeq;
		var bodyWidth = this.body.width();
		var astricCount = 0;

		for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
			if (CG.colSeq == undefined) CG.colSeq = cidx;
			if (CG.display == undefined) CG.display = true;
			if (CG.display) {
				if (!rewrite) {
					if (CG.width == "*") {
						CG.width = 0;
						CG.widthAstric = true;
						astricCount++;
					}
					CG._owidth = CG.width;
					/* 최초의 너비값 기억 하기 */
				} else {
					if (CG.widthAstric) {
						CG.width = 0;
						CG._owidth = CG.width;
						astricCount++;
					}
				}

				colWidth += (CG._owidth || 0).number();
				showColLen += 1;
			} else {
				hasHiddenCell = true;
			}
		}
		if (!cfg.fitToWidth) {
			/* width * 예외처리 구문 ------------ s */
			if ((bodyWidth - cfg.fitToWidthRightMargin) > (colWidth + 100 * astricCount)) {
				var remainsWidth = (bodyWidth - cfg.fitToWidthRightMargin) - colWidth;
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					if (CG.display && CG.widthAstric) {
						CG._owidth = (remainsWidth / astricCount).ceil();
						CG.width = CG._owidth;
						colWidth += (CG._owidth || 0).number();
					}
				}
			} else {
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					if (CG.display && CG.widthAstric) {
						CG._owidth = 100;
						CG.width = 100;
						colWidth += (CG._owidth || 0).number();
					}
				}
			}
			/* width * 예외처리 구문 ------------ e */
		} else {
			for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
				if (CG.display && CG.widthAstric) {
					CG.width = 100;
					CG._owidth = 100;
					colWidth += (CG._owidth || 0).number();
				}
			}
		}
		this.colWidth = colWidth;

		if (cfg.fitToWidth) { /*너비 자동 맞춤버전의 경우 */
			if (bodyWidth > this.colWidth) {
				var _bodyWidth = bodyWidth - cfg.fitToWidthRightMargin;
				var zoomRatio = bodyWidth / this.colWidth;
				colWidth = 0;
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					CG.width = (CG._owidth * zoomRatio).ceil();
					if (_bodyWidth > CG.width) _bodyWidth -= CG.width;
					else CG.width = _bodyWidth;
					if (CG.display) colWidth += CG.width.number();
				}
				this.colWidth = colWidth;
			} else {
				colWidth = 0;
				for (var CG, cidx = 0, __arr = cfg.colGroup; (cidx < __arr.length && (CG = __arr[cidx])); cidx++) {
					if (CG._owidth == undefined) CG._owidth = (CG.width || 0).number();
					CG.width = CG._owidth.number();
					if (CG.display) colWidth += CG.width.number();
				}
				this.colWidth = colWidth;
			}
		}

		this.showColLen = showColLen;
		/* col너비 합계 구하기 ~~~~~~~~~~~~~~ 구해진 너비합은 그리드 head, body 의 너비로 지정됨. */

		if (!cfg.colHead) cfg.colHead = { display: false };
		if (!cfg.body) cfg.body = {};

		if (cfg.colHead.rowsEmpty) cfg.colHead.rows = undefined;
		if (cfg.body.rowsEmpty) cfg.body.rows = undefined;

		// colHead rows -----------------------------------------------------------------------------------------------------
		if (cfg.colHead.rows) {
			// colHeadRow 정해진 경우
			cfg.colHead._maps = new Array(cfg.colHead.rows.length);
			var colMaxLen = 0;
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) {
							CH._colspan = CH.colspan;
						} else {
							CH.colspan = CH._colspan;
						}
					}
					if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
					if (cfg.colHeadAlign) CH.align = "center";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.colHead._maps.length; _m++) { cfg.colHead._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToColHeadMap = function (r, c, posR, position) { //
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) {
								isWhile = false;
							} else {
								if (!cfg.colHead._maps[rr][nC]) {
									cfg.colHead._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) {
							isWhile = false;
						}
					}
				}
			}
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) {
						if (rewrite) AXUtil.overwriteObject(CH, myCG, true);
						else AXUtil.overwriteObject(CH, myCG, false);
					} else {
						AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					}
					appendPosToColHeadMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}
			//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
			axf.each(cfg.colHead._maps.last(), function (midx, m) {
				if (m) cfg.colHead.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.colHead._maps.length; a++) {
							var rowPosition = cfg.colHead._maps[a][cidx];
							cfg.colHead.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}
			//trace(cfg.colHead._maps); _maps check

			// colHeadRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		} else {
			// colHeadRow 정해지지 않은 경우
			cfg.colHead._maps = [[]];
			var colHeadRows = [[]];
			axf.each(cfg.colGroup, function (cidx, CG) {
				var adder = {
					key: CG.key,
					colSeq: CG.colSeq,
					label: CG.label,
					align: (CG.align || (cfg.colHeadAlign || "left")), rowspan: 1, colspan: 1,
					valign: "bottom", isLastCell: true, display: CG.display, formatter: CG.formatter, checked: CG.checked,
					sort: CG.sort,
					tooltip: CG.tooltip
				};
				colHeadRows[0].push(adder);
				cfg.colHead._maps[0].push({ r: 0, c: cidx });
			});
			cfg.colHead.rows = colHeadRows;
			cfg.colHead.rowsEmpty = true;
			// colHeadRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		}
		// colHead rows -----------------------------------------------------------------------------------------------------

		// body rows -----------------------------------------------------------------------------------------------------
		if (cfg.body.rows) {
			// bodyRow 정해진 경우

			cfg.body._maps = new Array(cfg.body.rows.length);
			var colMaxLen = 0;
			for (var r = 0; r < cfg.body.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.body.rows[r], function (CHidx, CH) {
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) CH._colspan = CH.colspan;
						else CH.colspan = CH._colspan;
					}
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.valign == undefined || CH.valign == null) CH.valign = "middle";
					//if(CH.align == undefined || CH.align == null) CH.align = "left";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.body._maps.length; _m++) { cfg.body._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToBodyMap = function (r, c, posR, position) {
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) { isWhile = false; } else {
								if (!cfg.body._maps[rr][nC]) {
									cfg.body._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) { isWhile = false; }
					}
				}
			};
			for (var r = 0; r < cfg.body.rows.length; r++) {
				axf.each(cfg.body.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) {
						if (rewrite) AXUtil.overwriteObject(CH, myCG, true);
						else AXUtil.overwriteObject(CH, myCG, false);
					} else {
						AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					}
					appendPosToBodyMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}
			//body._maps 마지막 줄에 해당하는 cfg.body.rows 에 속성부여
			axf.each(cfg.body._maps.last(), function (midx, m) {
				if (m) cfg.body.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.body._maps.length; a++) {
							var rowPosition = cfg.body._maps[a][cidx];
							cfg.body.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}

			// bodyRow 정해진 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		} else {
			// bodyRow 정해지지 않은 경우
			cfg.body._maps = [[]];
			var bodyRows = [[]];
			axf.each(cfg.colGroup, function (cidx, CG) {
				var adder = {
					key: CG.key, colSeq: CG.colSeq, label: CG.label, align: (CG.align || "left"), rowspan: 1, colspan: 1, valign: "middle", isLastCell: true,
					display: CG.display, formatter: CG.formatter, checked: CG.checked, disabled: CG.disabled, indent: CG.indent, getIconClass: CG.getIconClass,
					tooltip: CG.tooltip
				};
				bodyRows[0].push(adder);
				cfg.body._maps[0].push({ r: 0, c: cidx });
			});
			cfg.body.rows = bodyRows;
			cfg.body.rowsEmpty = true;
			// bodyRow 정해지지 않은 경우 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		}
		// body rows -----------------------------------------------------------------------------------------------------

		//marker 관련 데이터 정리
		if (cfg.body.marker) {
			if (cfg.body.marker.rows) {
				this.bodyHasMarker = true;
				cfg.body.marker._maps = new Array(cfg.body.marker.rows.length);
				colMaxLen = 0;
				for (var r = 0; r < cfg.body.marker.rows.length; r++) {
					var colLen = 0;
					axf.each(cfg.body.marker.rows[r], function (CHidx, CH) {
						if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
						if (CH.colspan == undefined || CH.colspan == null) {
							CH.colspan = 1;
							CH._colspan = 1;
						} else {
							if (!rewrite) CH._colspan = CH.colspan;
							else CH.colspan = CH._colspan;
						}
						if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
						colLen += CH.colspan.number();
					});
					if (colMaxLen < colLen) colMaxLen = colLen;
				}
				for (var _m = 0; _m < cfg.body.marker._maps.length; _m++) { cfg.body.marker._maps[_m] = new Array(colMaxLen); }
				// colEndPosition 관련 처리 함수
				var appendPosToEditorMap = function (r, c, posR, position) { //
					var nC = position.c; //시작 컬럼 위치
					for (var rr = posR; rr < (posR + r) ; rr++) {
						var tC = c; //컬럼 루프횟수
						var isWhile = true; // 루프유지변수
						while (isWhile) {
							try {
								if (tC == 0) {
									isWhile = false;
								} else {
									if (!cfg.body.marker._maps[rr][nC]) {
										cfg.body.marker._maps[rr][nC] = position;
										tC--;
									} else { nC++; }
								}
							} catch (e) { isWhile = false; }
						}
					}
				};
				for (var r = 0; r < cfg.body.marker.rows.length; r++) {
					axf.each(cfg.body.marker.rows[r], function (CHidx, CH) {
						if (CH.colSeq != undefined) {
							var myCG = cfg.colGroup.getToSeq(CH.colSeq);
						} else {
							var myCG = cfg.colGroup.searchObject(function () {
								return this.item.key == CH.key;
							}).first();
						}
						if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
						else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
						appendPosToEditorMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
					});
				}
				//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
				axf.each(cfg.body.marker._maps.last(), function (midx, m) {
					if (m) cfg.body.marker.rows[m.r][m.c].isLastCell = true;
				});

				if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
					// colspan 감소 시키기
					axf.each(cfg.colGroup, function (cidx, CG) {
						if (!CG.display) {
							for (var a = 0; a < cfg.body.marker._maps.length; a++) {
								var rowPosition = cfg.body.marker._maps[a][cidx];
								cfg.body.marker.rows[rowPosition.r][rowPosition.c].colspan--;
							}
						}
					});
				}
			}
		}
		//marker 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


		//head 관련 데이터 정리
		if (cfg.head) {
			cfg.head._maps = new Array(cfg.head.rows.length);
			colMaxLen = 0;
			for (var r = 0; r < cfg.head.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.head.rows[r], function (CHidx, CH) {
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) CH._colspan = CH.colspan;
						else CH.colspan = CH._colspan;
					}
					if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
					//if(CH.align == undefined || CH.align == null) CH.align = "left";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.head._maps.length; _m++) { cfg.head._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToHeadMap = function (r, c, posR, position) { //
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) {
								isWhile = false;
							} else {
								if (!cfg.head._maps[rr][nC]) {
									cfg.head._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) {
							isWhile = false;
						}
					}
				}
			};
			for (var r = 0; r < cfg.head.rows.length; r++) {
				axf.each(cfg.head.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
					else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					appendPosToHeadMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}

			//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
			axf.each(cfg.head._maps.last(), function (midx, m) {
				if (m) cfg.head.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.head._maps.length; a++) {
							var rowPosition = cfg.head._maps[a][cidx];
							cfg.head.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}
		}
		//head 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		//foot 관련 데이터 정리
		if (cfg.foot) {
			cfg.foot._maps = new Array(cfg.foot.rows.length);
			colMaxLen = 0;
			for (var r = 0; r < cfg.foot.rows.length; r++) {
				var colLen = 0;
				axf.each(cfg.foot.rows[r], function (CHidx, CH) {
					if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
					if (CH.colspan == undefined || CH.colspan == null) {
						CH.colspan = 1;
						CH._colspan = 1;
					} else {
						if (!rewrite) CH._colspan = CH.colspan;
						else CH.colspan = CH._colspan;
					}
					if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
					colLen += CH.colspan.number();
				});
				if (colMaxLen < colLen) colMaxLen = colLen;
			}
			for (var _m = 0; _m < cfg.foot._maps.length; _m++) { cfg.foot._maps[_m] = new Array(colMaxLen); }
			// colEndPosition 관련 처리 함수
			var appendPosToFootMap = function (r, c, posR, position) { //
				var nC = position.c; //시작 컬럼 위치
				for (var rr = posR; rr < (posR + r) ; rr++) {
					var tC = c; //컬럼 루프횟수
					var isWhile = true; // 루프유지변수
					while (isWhile) {
						try {
							if (tC == 0) {
								isWhile = false;
							} else {
								if (!cfg.foot._maps[rr][nC]) {
									cfg.foot._maps[rr][nC] = position;
									tC--;
								} else {
									nC++;
								}
							}
						} catch (e) {
							isWhile = false;
						}
					}
				}
			};
			for (var r = 0; r < cfg.foot.rows.length; r++) {
				axf.each(cfg.foot.rows[r], function (CHidx, CH) {
					if (CH.colSeq != undefined) {
						var myCG = cfg.colGroup.getToSeq(CH.colSeq);
					} else {
						var myCG = cfg.colGroup.searchObject(function () {
							return this.item.key == CH.key;
						}).first();
					}
					if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
					else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
					appendPosToFootMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
				});
			}
			//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
			axf.each(cfg.foot._maps.last(), function (midx, m) {
				if (m) cfg.foot.rows[m.r][m.c].isLastCell = true;
			});

			if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
				// colspan 감소 시키기
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						for (var a = 0; a < cfg.foot._maps.length; a++) {
							var rowPosition = cfg.foot._maps[a][cidx];
							cfg.foot.rows[rowPosition.r][rowPosition.c].colspan--;
						}
					}
				});
			}
		}
		//foot 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		//editor 관련 데이터 정리
		if (cfg.editor) {
			if (cfg.editor.rows) {
				this.hasEditor = true;
				cfg.editor._maps = new Array(cfg.editor.rows.length);
				colMaxLen = 0;
				for (var r = 0; r < cfg.editor.rows.length; r++) {
					var colLen = 0;
					axf.each(cfg.editor.rows[r], function (CHidx, CH) {
						if (CH.rowspan == undefined || CH.rowspan == null) CH.rowspan = 1;
						if (CH.colspan == undefined || CH.colspan == null) {
							CH.colspan = 1;
							CH._colspan = 1;
						} else {
							if (!rewrite) CH._colspan = CH.colspan;
							else CH.colspan = CH._colspan;
						}
						if (CH.valign == undefined || CH.valign == null) CH.valign = "bottom";
						colLen += CH.colspan.number();
					});
					if (colMaxLen < colLen) colMaxLen = colLen;
				}
				for (var _m = 0; _m < cfg.editor._maps.length; _m++) { cfg.editor._maps[_m] = new Array(colMaxLen); }
				// colEndPosition 관련 처리 함수
				var appendPosToEditorMap = function (r, c, posR, position) { //
					var nC = position.c; //시작 컬럼 위치
					for (var rr = posR; rr < (posR + r) ; rr++) {
						var tC = c; //컬럼 루프횟수
						var isWhile = true; // 루프유지변수
						while (isWhile) {
							try {
								if (tC == 0) {
									isWhile = false;
								} else {
									if (!cfg.editor._maps[rr][nC]) {
										cfg.editor._maps[rr][nC] = position;
										tC--;
									} else { nC++; }
								}
							} catch (e) { isWhile = false; }
						}
					}
				};
				for (var r = 0; r < cfg.editor.rows.length; r++) {
					axf.each(cfg.editor.rows[r], function (CHidx, CH) {
						if (CH.colSeq != undefined) {
							var myCG = cfg.colGroup.getToSeq(CH.colSeq);
						} else {
							var myCG = cfg.colGroup.searchObject(function () {
								return this.item.key == CH.key;
							}).first();
						}
						if (myCG != null) AXUtil.overwriteObject(CH, myCG, false);
						else AXUtil.overwriteObject(CH, { align: "left", valign: "bottom", display: true, rowspan: 1, colspan: 1 }, false);
						appendPosToEditorMap(CH.rowspan, CH.colspan, r, { r: r, c: CHidx });
					});
				}
				//colHead._maps 마지막 줄에 해당하는 cfg.colHead.rows 에 속성부여
				axf.each(cfg.editor._maps.last(), function (midx, m) {
					if (m) cfg.editor.rows[m.r][m.c].isLastCell = true;
				});

				if (hasHiddenCell) { // colGroup 중에 숨겨진 col 이 존재하는 경우
					// colspan 감소 시키기
					axf.each(cfg.colGroup, function (cidx, CG) {
						if (!CG.display) {
							for (var a = 0; a < cfg.editor._maps.length; a++) {
								var rowPosition = cfg.editor._maps[a][cidx];
								cfg.editor.rows[rowPosition.r][rowPosition.c].colspan--;
							}
						}
					});
				}
			}
		}
		//editor 관련 데이터 정리 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		//fixedColSeq가 설정된 경우
		if (cfg.fixedColSeq != undefined && cfg.fixedColSeq != null) {

			var fixedColSeq = this.fixedColSeq;
			axf.each(cfg.colHead._maps, function (midx, m) {
				axf.each(m, function (cidx, c) {
					if (c) {
						if ((fixedColSeq + 1) > cidx) cfg.colHead.rows[c.r][c.c].isFixedCell = true;
					}
				});
			});
			axf.each(cfg.body._maps, function (midx, m) {
				axf.each(m, function (cidx, c) {
					if (c) {
						if (fixedColSeq == cidx) cfg.body.rows[c.r][c.c].isFixedEndCell = true;
						if ((fixedColSeq + 1) > cidx) cfg.body.rows[c.r][c.c].isFixedCell = true;
					}
				});
			});
			if (cfg.head) {
				axf.each(cfg.head._maps, function (midx, m) {
					axf.each(m, function (cidx, c) {
						if (c) {
							if (fixedColSeq == cidx) cfg.head.rows[c.r][c.c].isFixedEndCell = true;
							if ((fixedColSeq + 1) > cidx) cfg.head.rows[c.r][c.c].isFixedCell = true;
						}
					});
				});
			}
			if (cfg.foot) {
				axf.each(cfg.foot._maps, function (midx, m) {
					axf.each(m, function (cidx, c) {
						if (c) {
							if (fixedColSeq == cidx) cfg.foot.rows[c.r][c.c].isFixedEndCell = true;
							if ((fixedColSeq + 1) > cidx) cfg.foot.rows[c.r][c.c].isFixedCell = true;
						}
					});
				});
			}

			if (cfg.body.marker) {
				if (cfg.body.marker.rows) {
					axf.each(cfg.body.marker._maps, function (midx, m) {
						axf.each(m, function (cidx, c) {
							if (c) {
								if (fixedColSeq == cidx) cfg.body.marker.rows[c.r][c.c].isFixedEndCell = true;
								if ((fixedColSeq + 1) > cidx) cfg.body.marker.rows[c.r][c.c].isFixedCell = true;
							}
						});
					});
				}
			}

			if (cfg.editor) {
				if (cfg.editor.rows) {
					axf.each(cfg.editor._maps, function (midx, m) {
						axf.each(m, function (cidx, c) {
							if (c) {
								if (fixedColSeq == cidx) cfg.editor.rows[c.r][c.c].isFixedEndCell = true;
								if ((fixedColSeq + 1) > cidx) cfg.editor.rows[c.r][c.c].isFixedCell = true;
							}
						});
					});
				}
			}
			this.hasFixed = true;
			if (hasHiddenCell) {
				var minusFixedCol = 0;
				var fixedColSeq = this.fixedColSeq;
				axf.each(cfg.colGroup, function (cidx, CG) {
					if (!CG.display) {
						if ((fixedColSeq + 1) > cidx) minusFixedCol++;
					}
				});
				cfg.fixedColSeq = this.fixedColSeq - minusFixedCol;
			} else {
				cfg.fixedColSeq = this.fixedColSeq;
			}

			if (cfg.fixedColSeq == -1) {
				//fixed 제거
				this.hasFixed = false;
			}

			var fixedColSeq = this.fixedColSeq;
			fixedColWidth = 0;
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display && cidx < (fixedColSeq + 1)) {
					fixedColWidth += CG.width.number();
				}
			});
			this.fixedColWidth = fixedColWidth;
		}


	},
	init: function () {
		var cfg = this.config;

		if (Object.isUndefined(cfg.targetID)) {
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		if (!cfg.colGroup) {
			trace("need colGroup - setConfig({colGroup:[]})");
			return;
		}

		cfg.emptyListMSG = cfg.emptyListMSG || AXConfig.AXTree.emptyListMSG;

		var reserveKeys = {
			parentHashKey: "pHash", // 부모 트리 포지션
			hashKey: "hash", // 트리 포지션
			openKey: "open", // 확장여부
			subTree: "subTree", // 자식개체키
			displayKey: "display" // 표시여부
		};
		var relation = {
			parentKey: "pno",
			childKey: "no"
		}
		if (cfg.reserveKeys) {
			AXUtil.overwriteObject(reserveKeys, cfg.reserveKeys, true);
		} else {
			cfg.reserveKeys = reserveKeys;
		}
		if (cfg.relation) {
			AXUtil.overwriteObject(relation, cfg.relation, true);
		} else {
			cfg.relation = relation;
		}

		var targetInnerHeight = axdom("#" + cfg.targetID).innerHeight();
		//if (targetInnerHeight == 0) targetInnerHeight = (AXConfig.AXTree.pageHeight || 400);
		this.theme = (cfg.theme) ? cfg.theme : "AXTree"; // 테마기본값 지정
		cfg.height = (cfg.height) ? cfg.height : targetInnerHeight + "px"; // 그리드 높이 지정

		this.target = axdom("#" + cfg.targetID);
		var theme = this.theme;
		var treeCss = [];

		if (cfg.width) treeCss.push("width:" + cfg.width + ";");
		if (cfg.height) treeCss.push("height:" + cfg.height + ";");

		// tree 뼈대 그리기 -----------------------------------------------------------------------------------------------------
		var ol = [];
		ol.push("<a id=\"" + cfg.targetID + "_AX_tree_focus\" href=\"#axtree\" ></a>");
		ol.push("<div class=\"" + theme + "\" id=\"" + cfg.targetID + "_AX_tree\" style=\"" + treeCss.join('') + "\">");
		ol.push("	<div class=\"AXTreeScrollBody\" id=\"" + cfg.targetID + "_AX_treeScrollBody\" style=\"z-index:2;\">");
		ol.push("		<div class=\"AXTreeColHead AXUserSelectNone\" id=\"" + cfg.targetID + "_AX_treeColHead\" onselectstart=\"return false;\"></div>");
		ol.push("		<div class=\"AXTreeBody\" id=\"" + cfg.targetID + "_AX_treeBody\"></div>");
		ol.push("		<div class=\"AXTreeEditor\" id=\"" + cfg.targetID + "_AX_treeEditor\"></div>");
		ol.push("	</div>");
		ol.push("</div>");
		this.target.html(ol.join(''));
		// tree 뼈대 그리기 -----------------------------------------------------------------------------------------------------

		// 주요 타깃 설정
		this.gridBody = axdom("#" + cfg.targetID + "_AX_tree");
		this.scrollBody = axdom("#" + cfg.targetID + "_AX_treeScrollBody");
		this.colHead = axdom("#" + cfg.targetID + "_AX_treeColHead");
		this.body = axdom("#" + cfg.targetID + "_AX_treeBody");
		this.editor = axdom("#" + cfg.targetID + "_AX_treeEditor");

		/// define part -----------------------------------------------------------------------------------------------------
		this.defineConfig(); // config object define
		/// define part -----------------------------------------------------------------------------------------------------

		if (cfg.colHead.display) {
			//colHead setting
			this.setColHead();
		} else {
			this.colHead.hide();
		}

		//body setting
		this.setBody();

		//editor setting
		this.editor.hide();

		this.treeTargetSetSize();

		/* body event bind */
		if (cfg.height != "auto") {

			var contentScrollTouchstart = this.contentScrollTouchstart.bind(this);
			this.contentScrollTouchstartBind = function (event) {
				contentScrollTouchstart(event);
			};


			var contentScrollScrollWheel = this.contentScrollScrollWheel.bind(this);
			this.contentScrollScrollWheelBind = function (event) {
				contentScrollScrollWheel(event);
			};

			var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
			if (document.attachEvent) { //if IE (and Opera depending on user setting)
				//axf.getId(cfg.targetID+"_AX_treeBody").detachEvent("on"+mousewheelevt, this.contentScrollScrollWheelBind);
				if (axf.getId(cfg.targetID + "_AX_treeBody")) axf.getId(cfg.targetID + "_AX_treeBody").attachEvent("on" + mousewheelevt, contentScrollScrollWheel);
			} else if (document.addEventListener) { //WC3 browsers
				///axf.getId(cfg.targetID+"_AX_treeBody").removeEventListener(mousewheelevt, this.contentScrollScrollWheelBind, false);
				if (axf.getId(cfg.targetID + "_AX_treeBody")) axf.getId(cfg.targetID + "_AX_treeBody").addEventListener(mousewheelevt, contentScrollScrollWheel, false);
			}

			if (document.addEventListener) {
				//axf.getId(cfg.targetID+"_AX_treeBody").removeEventListener("touchstart", this.contentScrollTouchstartBind, false);
				if (axf.getId(cfg.targetID + "_AX_treeBody")) axf.getId(cfg.targetID + "_AX_treeBody").addEventListener("touchstart", contentScrollTouchstart, false);
			}
		}

		axdom("#" + cfg.targetID).bind("click", function(event){
			axdom("#" + cfg.targetID + "_AX_tree_focus").focus();
		});
		axdom("#" + cfg.targetID + "_AX_tree_focus").bind("keyup.axtree", this.onKeydown.bind(this));

		//TODO : 포커스인 상태인지 파악이 필요..

		if (cfg.contextMenu) {
			AXContextMenu.bind({
				id: cfg.targetID + "ContextMenu",
				theme: cfg.contextMenu.theme, // 선택항목
				width: cfg.contextMenu.width, // 선택항목
				menu: cfg.contextMenu.menu
			});
			axdom("#" + cfg.targetID).bind("contextmenu", this.onContextmenu.bind(this));
		}
		/* body event bind */
		axdom(window).bind("resize", this.windowResize.bind(this));
	},
	/**
	 * @method AXTree.setConfig
	 * @param {Object} config - gridConfig
	 * @description
	 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
	 * @example
	 * ```js
	 * var myTree = new AXTree();
	 * myTree.setConfig({
	 *     targetID : "AXTreeTarget",  //{String} - HTML 엘리먼트 타겟아이디
	 *     theme: "AXTree_none",   //[String] - ("AXTree","AXTree_none") CSS Class 이름
	 *     relation:{  //무보자식 키 정의
	 *         parentKey:"pno",    //부모아이디 키
	 *         childKey:"no"   //자식아이디 키
	 *     },
	 *     persistExpanded: true, // 쿠키를 이용해서 트리의 확장된 상태를 유지합니다.
	 *     persistSelected: true, // 쿠키를 이용해서 트리의 선택된 상태를 유지합니다.
	 *     colGroup: [ //트리 헤드정의
	 *         {
	 *             key:"nodeName", //{String} - 컬럼에 매치될 item 의 키
	 *             label:"제목", //{String} - 컬럼에 표시할 라벨
	 *             width:"100%",   //[Number["px", "%"] = "auto"] - "100%", "500px", "auto"지정하면 트리의 너비만큼 단일 컬럼의 너비가 자동 맞춤 처리됩니다.
	 *             align:"left",   //[String = "left"[left, center, right]] - 정렬방식 지정
	 *             indent:true,    //[Boolean = true]
	 *             getIconClass: function(){   // [Function] - indent 속성 정의된 대상에 아이콘을 지정할 수 있습니다.
	 *                 var iconNames = "folder, AXfolder, movie, img, zip, file, fileTxt, fileTag".split(/, /g);
	 *                 var iconName = "";
	 *                 if(this.item.type) iconName = iconNames[this.item.type];
	 *                 return iconName;
	 *             },
	 *             formatter:function(){   // [Function] - 컬럼값의 표현형식 각각 화폐표현식, urlDecode, input.Checkbox, input.radioBox, 사용자 정의 함수
	 *                 return "<b>"+this.item.no.setDigit(2) + "</b> : " + this.item.nodeName + " (" + this.item.writer + ")";
	 *             }
	 *         }
	 *     ],
	 *     body: {
	 *         onclick:function(idx, item){ //[Function] 바디 클릭 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         ondblclick:function(idx, item){ //[Function] 바디 더블클릭 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         oncheck:function(idx, item){ //[Function] 트리 체크박스클릭시 함수연결
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         onexpand:function(idx, item){ //[Function] 트리 아이템 확장 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         oncontract:function(idx, item){ //[Function] 트리 아이템 축소 이벤트 콜백함수
	 *             toast.push(Object.toJSON(item));
	 *         },
	 *         addClass:function(idx, item){ //[Function] 트리 아이템에 사용자 CSS 클래스를 추가할 수 있는 사용자 함수 추가하려는 클래스명을 return 으로 반환하십시요
	 *             toast.push(Object.toJSON(item));
	 *         }
	 *     }
	 * });
	 *
	 * ```
	 */
	windowResize: function () {
		var windowResizeApply = this.windowResizeApply.bind(this);
		if (this.windowResizeObserver) clearTimeout(this.windowResizeObserver);
		this.windowResizeObserver = setTimeout(function () {
			windowResizeApply();
		}, 100);
	},
	windowResizeApply: function () {
		var cfg = this.config;

		if (cfg.mediaQuery) {
			var _viewMode = "", clientWidth = axf.clientWidth();
			axf.each(cfg.mediaQuery, function (k, v) {
				if (Object.isObject(v)) {

					if(v.min != undefined && v.max != undefined){
						if (v.min <= clientWidth && clientWidth <= v.max) {
							_viewMode = (k == "dx") ? "grid" : "mobile";
							return false;
						}
					}else{
						if (v.min <= clientWidth) {
							_viewMode = (k == "dx") ? "grid" : "mobile";
							return false;
						}
					}
				}
			});
			if (_viewMode != "") {
				cfg.viewMode = _viewMode;
			}
		}

		this.redrawGrid();
	},
	treeTargetSetSize: function (react) {
		var cfg = this.config;
		//cfg.height
		if (cfg.height == "auto") {
			this.target.css({ height: "auto", "max-height": "auto" });
			var colHeadHeight = this.colHead.outerHeight();
			var scrollBodyHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
			this.scrollBody.css({ height: scrollBodyHeight + colHeadHeight }); //colhead + body height
			this.body.css({ top: colHeadHeight, height: (scrollBodyHeight) }); // body Height
		} else {
			var colHeadHeight = (cfg.colHead.display) ? this.colHead.outerHeight() : 0;
			var scrollBodyHeight = cfg.height.number();
			//trace({top:colHeadHeight, scrollBodyHeight:scrollBodyHeight});
			this.scrollBody.css({ height: scrollBodyHeight }); //colhead + body height
			this.body.css({ top: colHeadHeight, height: (scrollBodyHeight - colHeadHeight) }); // body Height
		}
		if (!react) axdom(window).bind("resize", this.contentScrollResize.bind(this));
	},
	resetHeight: function () {
		var cfg = this.config;

		var targetInnerHeight = axdom("#" + cfg.targetID).innerHeight();
		//if (targetInnerHeight == 0) targetInnerHeight = 400;
		cfg.height = targetInnerHeight + "px"; // 그리드 높이 지정
		this.gridBody.css({height:targetInnerHeight-2});
		this.redrawGrid("");
	},
	getColGroup: function (suffix) {
		var cfg = this.config;
		var fixedColSeq = this.fixedColSeq;
		//{colID:0, key:"no", label:"번호", width:"100", align:"left", addClassNames:"", style:"", display:true, sort:null}
		var po = [];
		po.push("<colgroup>");
		if (suffix != "FC" && suffix != "FB" && suffix != "FE") {
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display) {
					if (cfg.width == "auto" || cfg.width == "*") {
						po.push("<col style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					} else {
						po.push("<col width=\"" + (CG.width || "") + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					}
				}
			});
			if(cfg.colHead.display) po.push("<col />");

			//if (suffix == "CB") po.push("<col />");
		} else {
			//fixedCol 존재
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display && cidx < (fixedColSeq + 1)) {
					if (cfg.width == "auto" || cfg.width == "*") {
						po.push("<col style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					} else {
						po.push("<col width=\"" + (CG.width || "") + "\" style=\"\" id=\"" + cfg.targetID + "_AX_col_AX_" + CG.colSeq + "_AX_" + suffix + "\" />");
					}
				}
			});
		}
		po.push("</colgroup>");
		return po.join('');
	},
	getColSeqToHead: function (r, c) {
		//trace("getColSeqToHead:"+r+","+c);
		var cfg = this.config;
		var colSeq = null;
		for (var a = cfg.colHead._maps[r].length - 1; a > -1; a--) {
			if (cfg.colHead._maps[r][a].r == r && cfg.colHead._maps[r][a].c == c) {
				colSeq = a;
				break;
			}
		}
		return colSeq;
	},
	redrawGrid: function () {
		var cfg = this.config;
		this.defineConfig(true);
		if (cfg.colHead.display) this.setColHead();
		this.setBody();

		if (cfg.head) this.printHead();
		if (cfg.foot) this.printFoot();

		this.treeTargetSetSize(true);
		this.contentScrollResize();
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 바디 재구성 기능 포함
	},
	checkedColSeq: function (colSeq, checked, itemIndex) {
		var cfg = this.config;
		var gridCheckClick = this.gridCheckClick.bind(this);
		if (typeof itemIndex === "undefined") {
			this.colHead.find(".treeCheckBox_colHead_colSeq" + colSeq).each(function() {
				this.checked = checked;
			});
			axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".treeCheckBox_colHead_colSeq" + colSeq).each(function() {
				this.checked = checked;
			});
			this.body.find(".treeCheckBox_body_colSeq" + colSeq).each(function() {
				this.checked = checked;
			});
		} else {
			if(cfg.colGroup[colSeq].formatter === "radio") {
				var ii= 0, ll = this.list.length;
				for(;ii<ll;ii++) {
					if(typeof _this.list[ii].__checked === "undefined") _this.list[ii].__checked = false;
					_this.list[ii].__checked = false;
				}
			}
			this.body.find(".gridBodyTr_" + itemIndex + " .treeCheckBox_body_colSeq" + colSeq).each(function () {
				if (checked == null) {
					this.checked = !this.checked;
				} else {
					this.checked = checked;
				}
				gridCheckClick(null, this.id);
			});
		}
	},
	/**
	 * @method AXTree.getCheckedList
	 * @param {number} colSeq - checkbox가 있는 colGroup index
	 * @returns {Array} - checked 된 아이템의 배열
	 * @description
	 * colGroup의 배열순번으로 해당 col의 checked 된 아이템을 반환하여 줍니다.
	 * @example
	 ```
	 var myArray = myTree.getCheckedList(0);
	 ```
	 */
	getCheckedList: function (colSeq) {
		var cfg = this.config;
		var collect = [];
		var list = this.list;
		this.body.find(".treeCheckBox_body_colSeq" + colSeq).each(function () {
			if (this.checked) {
				var itemIndex = this.id.split(/_AX_/g).last();
				collect.push(list[itemIndex]);
			}
		});
		return collect;
	},
	onKeydown: function (event) {
		if (event.keyCode == 67 && event.ctrlKey) {
			//this.copyData();
		}
		//TODO 키보드 컨트롤 시작

		if(this.selectedRow.length > 0) {
			var rIndex = this.selectedRow.first().number();
			if (event.keyCode == axf.Event.KEY_RETURN) {
				this.click( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_UP) {
				rIndex -= 1;
				while ( this.list[rIndex] && this.list[rIndex].AXTreeSplit ) {
					rIndex -= 1;
				}
				this.setFocus( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_DOWN) {
				rIndex += 1;
				while ( this.list[rIndex] && this.list[rIndex].AXTreeSplit ) {
					rIndex += 1;
				}
				this.setFocus( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_LEFT) {
				this.expandToggleList(rIndex, this.list[rIndex]);
				this.setFocus( rIndex );
			}
			else if (event.keyCode == axf.Event.KEY_RIGHT) {
				this.expandToggleList(rIndex, this.list[rIndex]);
				this.setFocus( rIndex );
			}
		}
	},
	onBodyKeydown: function (event) {
		//this.readyMoved = true;
		//this.moveTarget = {itemIndex:itemIndex};
		if (event.keyCode == AXUtil.Event.KEY_ESC) {
			if (this.readyMoved) {
				this.cancelMove();
			}
		}
	},
	onContextmenu: function (event) {
		var cfg = this.config;

		if (this.readyMoved) return false;

		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		if (eventTarget.tagName.toLowerCase() == "input") return; //input 인 경우 제외
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("bodyTd") || axdom(evt).hasClass("bodyNodeIndent")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool ready
			var targetID = myTarget.id;
			var itemIndex = targetID.split(/_AX_/g).last();
			var ids = targetID.split(/_AX_/g);

			if (this.selectedCells.length > 0) {
				axf.each(this.selectedCells, function () {
					axdom("#" + this).removeClass("selected");
				});
				this.selectedCells.clear();
			}
			if (this.selectedRow.length > 0) {
				var body = this.body;
				axf.each(this.selectedRow, function () {
					body.find(".gridBodyTr_" + this).removeClass("selected");
				});
			}

			this.selectedRow.clear();
			this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
			this.selectedRow.push(itemIndex);

			var item = this.list[itemIndex];
			AXContextMenu.open({ id: cfg.targetID + "ContextMenu", filter: cfg.contextMenu.filter, sendObj: item }, event); // event 직접 연결 방식
		}
		return false;
	},
	copyData: function () {
		var cfg = this.config;
		var copyOut = [];
		axf.each(this.selectedCells, function (index, n) {
			var html = axdom("#" + n).find(".bodyNode").html();
			copyOut.push(html + '\t');
		});

		if (window.clipboardData) {
			window.clipboardData.setData('Text', copyOut.join(''));
			toast.push("데이터가 복사되었습니다. 원하시는 곳에 붙여넣기 하세요.");
		} else {
			dialog.push({ title: "Copy Data", body: copyOut.join(''), type: "alert" });
		}
	},
	/* 공통 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

	/* colHead 영역  */
	getHeadMousePosition: function (event) {
		var pos = this.colHead.offset();
		var x = (event.pageX - pos.left);
		var y = (event.pageY - pos.top);
		return { x: x, y: y };
	},
	getColHeadTd: function (arg) {
		var cfg = this.config;
		var po = [];

		if (arg.ghost) {
			po.push("<td" + arg.valign + arg.rowspan + arg.colspan + " class=\"colHeadTd" + arg.bottomClass + "\">");
			po.push("<div class=\"tdRelBlock\">");
			po.push("<div class=\"colHeadNode colHeadTdText\">&nbsp;</div>");
			po.push("</div>");
			po.push("</td>");
		} else {

			var colHeadTdText = " colHeadTdText";
			var toolUse = true;

			if (arg.formatter == "html" || arg.formatter == "checkbox" || arg.formatter == "radio") {
				colHeadTdText = " colHeadTdHtml";
				toolUse = false;
				if (arg.formatter == "checkbox") {
					colHeadTdText = " colHeadTdCheck";
					arg.tdHtml = "<input type=\"checkbox\" name=\"checkAll\" class=\"gridCheckBox gridCheckBox_colHead_colSeq" + arg.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkAll_AX_" + arg.r + "_AX_" + arg.CHidx + "\" />";
				}
			}

			var sortClass = ""; if (arg.sort) sortClass = (arg.sort == "desc") ? " sortDesc" : " sortAsc";

			po.push("<td" + arg.valign + arg.rowspan + arg.colspan + " id=\"" + cfg.targetID + "_AX_colHead_AX_" + arg.r + "_AX_" + arg.CHidx + "\" class=\"colHeadTd" + arg.bottomClass + sortClass + "\">");
			po.push("<div class=\"tdRelBlock\">");
			po.push("<div class=\"colHeadNode" + colHeadTdText + "\" align=\"" + arg.align + "\" id=\"" + cfg.targetID + "_AX_colHeadText_AX_" + arg.r + "_AX_" + arg.CHidx + "\">");
			po.push(arg.tdHtml);
			po.push("</div>");
			if (toolUse && arg.colSeq != null && arg.colSeq != undefined) po.push("<a href=\"#AXexec\" class=\"colHeadTool\" id=\"" + cfg.targetID + "_AX_colHeadTool_AX_" + arg.r + "_AX_" + arg.CHidx + "\">T</a>");
			po.push("<div class=\"colHeadResizer\" id=\"" + cfg.targetID + "_AX_colHeadResizer_AX_" + arg.r + "_AX_" + arg.CHidx + "\"></div>");
			po.push("</div>");
			po.push("</td>");

			if (arg.sort) {
				var myColHead = cfg.colHead.rows[arg.r][arg.CHidx];
				var tdID = cfg.targetID + "_AX_colHead_AX_" + arg.r + "_AX_" + arg.CHidx;

				this.nowSortHeadID = tdID;
				this.nowSortHeadObj = myColHead;
			}

		}
		return po.join('');
	},
	setColHead: function () {
		var cfg = this.config;
		var po = [];

		//trace("fixedCol : " +  cfg.fixedColSeq);

		var getColHeadTd = this.getColHeadTd.bind(this);
		if (!this.hasFixed) {  ////////////////////////////////////////////////////////////////////////////////////////////// 일반 colHead 구현

			po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
			po.push(this.getColGroup("CH")); //colGroup 삽입
			po.push("<tbody>");
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var isLastTR = (cfg.colHead.rows.length - 1 == r);
				po.push("<tr>");
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.display && CH.colspan > 0) {
						//radio, check exception
						var tdHtml = CH.label || "untitle";
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\"";
						var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

						po.push(getColHeadTd({
							valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
							align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
							ghost: false
						}));
					}
				});
				po.push("</tr>");
			}
			po.push("</tbody>");
			po.push("</table>");

		} else { ////////////////////////////////////////////////////////////////////////////////////////////// fixedCol 구현

			po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.colWidth + "px;\">");
			po.push(this.getColGroup("CH")); //colGroup 삽입
			po.push("<tbody>");
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var isLastTR = (cfg.colHead.rows.length - 1 == r);
				po.push("<tr>");
				var colCount = 0;
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.display && CH.colspan > 0) {
						//radio, check exception
						var tdHtml = CH.label || "untitle";
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\"";
						var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

						po.push(getColHeadTd({
							valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
							align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
							ghost: (colCount < (cfg.fixedColSeq + 1))
						}));

						colCount += CH.colspan;
					}
				});
				po.push("</tr>");
			}
			po.push("</tbody>");
			po.push("</table>");

			var fpo = [];
			fpo.push("<div class=\"AXGridColHead fixedColHead\" id=\"" + cfg.targetID + "_AX_fixedColHead\" style=\"width:" + this.fixedColWidth + "px;\">");
			fpo.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"colHeadTable\" style=\"width:" + this.fixedColWidth + "px;\">");
			fpo.push(this.getColGroup("FC")); //colGroup 삽입
			fpo.push("<tbody>");
			for (var r = 0; r < cfg.colHead.rows.length; r++) {
				var isLastTR = (cfg.colHead.rows.length - 1 == r);
				fpo.push("<tr>");
				var colCount = 0;
				axf.each(cfg.colHead.rows[r], function (CHidx, CH) {
					if (CH.display && CH.isFixedCell && CH.colspan > 0) {
						//trace({CHidx:CHidx, fixedColSeq:(cfg.fixedColSeq+1)});
						//radio, check exception
						var tdHtml = CH.label || "untitle";
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\"";
						var bottomClass = (CH.isLastCell) ? "" : " colHeadBottomBorder";

						fpo.push(getColHeadTd({
							valign: valign, rowspan: rowspan, colspan: colspan, bottomClass: bottomClass, r: r, CHidx: CHidx,
							align: CH.align, colSeq: CH.colSeq, formatter: CH.formatter, sort: CH.sort, tdHtml: tdHtml,
							ghost: false
						}));
					}
					colCount += CH.colspan;
				});
				fpo.push("</tr>");
			}
			fpo.push("</tbody>");
			fpo.push("</table>");
			fpo.push("</div>");
		}
		////////////////////////////////////////////////////////////////////////////////////////////// fixedCol 구현

		this.colHead.html(po.join(''));
		axdom("#" + cfg.targetID + "_AX_fixedColHead").remove();
		if (fpo) this.colHead.after(fpo.join(''));

		//resizer 를 찾아 resizer의 부모와 같은 높이값을 가지도록 변경 합니다.
		//또 그와 관련된 개체의 높이와 패딩을 지정합니다.
		this.colHead.find(".colHeadResizer").each(function () {
			var resizerID = this.id;
			var tdID = resizerID.replace("colHeadResizer", "colHead");
			var txtID = resizerID.replace("colHeadResizer", "colHeadText");
			var toolID = resizerID.replace("colHeadResizer", "colHeadTool");
			var rowspan = axdom("#" + tdID).attr("rowspan");
			var valign = axdom("#" + tdID).attr("valign");
			if (!rowspan) rowspan = 1;
			var tdHeight = axdom("#" + tdID).height();
			axdom(this).css({ height: tdHeight });
			axdom(this).parent().css({ height: tdHeight });
			if (rowspan > 1) {
				var cellMarginTop = 0;
				if (valign == "bottom") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) + 5;
				if (valign == "middle") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) / 2 + 5;
				axdom("#" + txtID).css({ "padding-top": cellMarginTop + "px" });
				axdom("#" + toolID).css({ "top": (cellMarginTop - 5) + "px" });
			}
		});

		this.colHead.bind("mouseover", this.colHeadMouseOver.bind(this));
		this.colHead.bind("mouseout", this.colHeadMouseOut.bind(this));
		this.colHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
		this.colHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
		this.colHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
		this.colHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));

		if (this.hasFixed) { //fixedColHead에 대한 바인딩 및 처리
			this.fixedColHead = axdom("#" + cfg.targetID + "_AX_fixedColHead");

			this.fixedColHead.find(".colHeadResizer").each(function () {
				var resizerID = this.id;
				var tdID = resizerID.replace("colHeadResizer", "colHead");
				var txtID = resizerID.replace("colHeadResizer", "colHeadText");
				var toolID = resizerID.replace("colHeadResizer", "colHeadTool");
				var rowspan = axdom("#" + tdID).attr("rowspan");
				var valign = axdom("#" + tdID).attr("valign");
				if (!rowspan) rowspan = 1;
				var tdHeight = axdom("#" + tdID).height();
				axdom(this).css({ height: tdHeight });
				axdom(this).parent().css({ height: tdHeight });
				if (rowspan > 1) {
					var cellMarginTop = 0;
					if (valign == "bottom") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) + 5;
					if (valign == "middle") cellMarginTop = (tdHeight - axdom("#" + txtID).outerHeight()) / 2 + 5;
					axdom("#" + txtID).css({ "padding-top": cellMarginTop + "px" });
					axdom("#" + toolID).css({ "top": (cellMarginTop - 5) + "px" });
				}
			});

			this.fixedColHead.bind("mouseover", this.colHeadMouseOver.bind(this));
			this.fixedColHead.bind("mouseout", this.colHeadMouseOut.bind(this));
			this.fixedColHead.find(".colHeadNode").bind("click", this.colHeadNodeClick.bind(this));
			this.fixedColHead.find(".colHeadTool").bind("click", this.colHeadToolClick.bind(this));
			this.fixedColHead.find(".colHeadResizer").bind("mousedown", this.colHeadResizerMouseDown.bind(this));
			this.fixedColHead.find(".gridCheckBox").bind("click", this.colHeadCheckBoxClick.bind(this));
		}
	},
	/* colHead events */
	colHeadMouseOver: function (event) {
		var cfg = this.config;
		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("colHeadTd")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool ready
			var targetID = myTarget.id;
			var toolID = targetID.replace("colHead", "colHeadTool");
			axdom("#" + toolID).addClass("readyTool");
		}
	},
	colHeadMouseOut: function (event) {
		var cfg = this.config;
		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("AXGridColHead")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("colHeadTd")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool unready
			var targetID = myTarget.id;
			var toolID = targetID.replace("colHead", "colHeadTool");
			axdom("#" + toolID).removeClass("readyTool");
		}
	},
	colHeadResizerMouseDown: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var colSeq = this.getColSeqToHead(colHeadR, colHeadC);
		if (colSeq == null) return; // 예상할 수 없는 오류
		//resize 상태 해제
		if (this.colResizing) {
			this.colHeadResizerEnd();
		}
		var offset = axdom("#" + cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC).find(".tdRelBlock").position();
		var relBlockWidth = axdom("#" + cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC).find(".tdRelBlock").width();
		var rightPosition = offset.left.number() + relBlockWidth.number();
		var blockWidth = axdom("#" + cfg.targetID + "_AX_col_AX_" + colSeq + "_AX_CH").attr("width");
		this.colResizeTarget = { colSeq: colSeq, leftPosition: (rightPosition - blockWidth), blockWidth: blockWidth, newWidth: blockWidth };
		//trace(this.colResizeTarget);

		/* resize event bind */
		var colHeadResizerMouseMove = this.colHeadResizerMouseMove.bind(this);
		this.colHeadResizerMouseMoveBind = function (event) {
			colHeadResizerMouseMove(event);
		}
		var colHeadResizerMouseUp = this.colHeadResizerMouseUp.bind(this);
		this.colHeadResizerMouseUpBind = function (event) {
			colHeadResizerMouseUp(event);
		}
		axdom(document.body).bind("mousemove.AXTree", this.colHeadResizerMouseMoveBind);
		axdom(document.body).bind("mouseup.AXTree", this.colHeadResizerMouseUpBind);
		axdom(document.body).bind("mouseleave.AXTree", this.colHeadResizerMouseUpBind);
		axdom("iframe").bind("mouseover.AXTree", this.colHeadResizerMouseUpBind);

		axdom(document.body).attr("onselectstart", "return false");
		//axdom(document.body).addClass("AXUserSelectNone");
		/* resize event bind ~~~~~~~~~~~~~~~~~~~ */
	},
	colHeadResizerMouseMove: function (event) {
		if (!event.pageX) return;
		//드래그 감도 적용
		if (this.config.moveSens > this.moveSens) this.moveSens++;
		if (this.moveSens == this.config.moveSens) this.colHeadResizerMove(event);
	},
	colHeadResizerMove: function (event) {
		var cfg = this.config;
		var mouse = this.getHeadMousePosition(event);
		var newWidth = (this.colResizeTarget.leftPosition - mouse.x).abs();
		if (newWidth < 31) return;
		/* colHead/colBody colGroup width 조정 */
		axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CH").attr("width", newWidth);
		axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_CB").attr("width", newWidth);
		axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_EB").attr("width", newWidth);

		cfg.colGroup[this.colResizeTarget.colSeq].width = newWidth;

		if (this.hasFixed) {
			var fixedColSeq = this.fixedColSeq;

			axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FC").attr("width", newWidth);
			axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FB").attr("width", newWidth);
			axdom("#" + cfg.targetID + "_AX_col_AX_" + this.colResizeTarget.colSeq + "_AX_FE").attr("width", newWidth);

			//if(this.colResizeTarget.colSeq < fixedColSeq+1){

			var fixedColWidth = 0;
			axf.each(cfg.colGroup, function (cidx, CG) {
				if (CG.display && cidx < (fixedColSeq + 1)) {
					fixedColWidth += CG.width.number();
				}
			});
			this.fixedColWidth = fixedColWidth;

			axdom("#" + cfg.targetID + "_AX_fixedColHead").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedColHead").find(".colHeadTable").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedScrollContent").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedScrollContent").find(".gridFixedBodyTable").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedEditorContent").css({ width: fixedColWidth });
			axdom("#" + cfg.targetID + "_AX_fixedEditorContent").find(".gridFixedBodyTable").css({ width: fixedColWidth });
			//}

		}

		if (this.editorOpend) {
			var colSeq = this.colResizeTarget.colSeq;
			//
			for (var _m = 0; _m < cfg.editor._maps.length; _m++) {
				var rc = cfg.editor._maps[_m][colSeq];
				var CH = cfg.editor.rows[rc.r][rc.c];
				var formID = (CH.form.id) ? CH.form.id : cfg.targetID + "_AX_" + CH.key + "_AX_" + rc.r + "_AX_" + rc.c;
				//trace(formID);
				if (axf.getId(formID)) if (axf.getId(formID).tagName == "INPUT") AXInput.alignAnchor(formID);
			}
		}


		/* colHead colGroup width 조정 ------------------------------ */
		this.colResizeTarget.newWidth = newWidth;
		var newColWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
		this.colHead.find(".colHeadTable").css({ "width": newColWidth + "px" });
		//this.body.find(".gridBodyTable").css({"width":newColWidth+"px"});
	},
	colHeadResizerMouseUp: function (event) {
		if (this.colResizeTarget.blockWidth != this.colResizeTarget.newWidth) {
			this.colWidth = this.colWidth - (this.colResizeTarget.blockWidth - this.colResizeTarget.newWidth);
		}
		this.colHeadResizerEnd();
		this.contentScrollResize(false);
	},
	colHeadResizerEnd: function () {
		this.moveSens = 0;
		this.colResizing = false;
		axdom(document.body).unbind("mousemove.AXTree");
		axdom(document.body).unbind("mouseup.AXTree");
		axdom(document.body).unbind("mouseleave.AXTree");
		axdom("iframe").unbind("mouseover.AXTree");

		axdom(document.body).removeAttr("onselectstart");
		//axdom(document.body).removeClass("AXUserSelectNone");
	},
	colHeadNodeClick: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;

		if (this.editorOpend) {
			toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
			return; // 에디터가 오픈된 상태이면 비활성화
		}

		if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
			this.colHeadCheckBoxClick(event);
			return; // checkbox block click
		}
		if (axdom(eventTarget).hasClass("gridCheckBox")) return; // checkbox click

		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
		var tdID = cfg.targetID + "_AX_colHead_AX_" + colHeadR + "_AX_" + colHeadC;
		//trace(myColHead);

		if (myColHead.colSeq == undefined || myColHead.colSeq == null) {
			trace("정렬할 수 없는 컬럼 입니다.");
		} else {
			/* -- 현재 기술로는 정렬 지원 어려움
             if(this.nowSortHeadID){
             if(this.nowSortHeadID != tdID){
             axdom("#"+this.nowSortHeadID).removeClass("sortDesc");
             axdom("#"+this.nowSortHeadID).removeClass("sortAsc");
             this.nowSortHeadObj.sort = undefined;
             }
             }
             //trace(myColHead);
             if(cfg.colHead.rows[colHeadR][colHeadC].sort == "desc") axdom("#"+tdID).removeClass("sortDesc");
             else axdom("#"+tdID).removeClass("sortAsc");

             var nsort = "";
             if(myColHead.sort == "desc") nsort = "asc";
             else nsort = "desc";
             cfg.colHead.rows[colHeadR][colHeadC].sort = nsort;

             //sort 처리하기
             if(nsort == "desc"){
             axdom("#"+tdID).addClass("sortDesc");
             }else{
             axdom("#"+tdID).addClass("sortAsc");
             }

             this.list = this.sortList(nsort, myColHead, this.list);
             this.printList();

             this.nowSortHeadID = tdID;
             this.nowSortHeadObj = myColHead;
             */
		}

		if (cfg.colHead.onclick) { // onclick bind
			var sendObj = {
				index: null,
				r: colHeadR,
				c: colHeadC,
				list: this.list,
				colHead: myColHead,
				page: this.page
			};
			cfg.colHead.onclick.call(sendObj);
		}

	},
	colHeadToolClick: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;

		if (this.editorOpend) {
			toast.push("Editor 활성화 상태에서는 기능을 사용할 수 없습니다.");
			return; // 에디터가 오픈된 상태이면 비활성화
		}

		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var myColHead = cfg.colHead.rows[colHeadR][colHeadC];
		//toast.push("클릭된 colGroup seq : " + myColHead.colSeq);

		axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();

		var po = [];
		po.push("<div id=\"" + cfg.targetID + "_AX_colHeadMenu\" class=\"AXTreeColGroupListBox\">");
		axf.each(cfg.colGroup, function (cidx, CG) {
			var addClass = (CG.display) ? " on" : "";
			var lastClass = (cidx == cfg.colGroup.length - 1) ? " last" : "";
			po.push("<a href=\"#AXexec\" class=\"AXTreeColGroupListBoxItem" + addClass + lastClass + "\" id=\"" + cfg.targetID + "_AX_colHeadMenu_AX_" + CG.colSeq + "\">");
			po.push(CG.label);
			po.push("</a>");
		});
		po.push("</div>");
		axdom(document.body).append(po.join(''));

		var offset = axdom(eventTarget).offset();
		var css = {};
		css.top = offset.top - 5;
		css.left = offset.left - 20;
		axdom("#" + cfg.targetID + "_AX_colHeadMenu").css(css);

		/* colGroup click event bind */
		var colGroupListClick = this.colGroupListClick.bind(this);
		this.colGroupListClickBind = function (event) {
			colGroupListClick(event);
		}
		axdom(document).bind("click", this.colGroupListClickBind);
		axdom(document).bind("keydown", this.colGroupListClickBind);
		/* colGroup click bind ~~~~~~~~~~~~~~~~~~~ */
	},
	colGroupListClick: function (event) {
		var cfg = this.config;

		if (event.keyCode == AXUtil.Event.KEY_ESC) {
			axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
			axdom(document).unbind("keydown", this.colGroupListClickBind);
			axdom(document).unbind("click", this.colGroupListClickBind);
			return;
		}

		// event target search -
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("AXTreeColGroupListBoxItem") || axdom(evt).hasClass("colHeadTool")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			if (axdom(myTarget).hasClass("colHeadTool")) return;
			//colHeadTool ready
			var targetID = myTarget.id;
			var colSeq = targetID.split(/_AX_/g).last();
			//trace(cfg.colGroup[colSeq]);
			if (cfg.colGroup[colSeq].display) {
				cfg.colGroup[colSeq].display = false;
				axdom("#" + targetID).removeClass("on");
			} else {
				cfg.colGroup[colSeq].display = true;
				axdom("#" + targetID).addClass("on");
			}
			//redraw grid
			this.redrawGrid();
		} else {
			axdom("#" + cfg.targetID + "_AX_colHeadMenu").remove();
			axdom(document).unbind("keydown", this.colGroupListClickBind);
			axdom(document).unbind("click", this.colGroupListClickBind);
		}
	},
	colHeadCheckBoxClick: function (event) {
		var cfg = this.config;
		if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;

		if (axdom(eventTarget).hasClass("colHeadTdCheck")) {
			eventTarget = axdom(eventTarget).find("input").get(0);
			eventTarget.checked = !eventTarget.checked;
		}
		var lastIdx = eid.length - 1;
		var colHeadR = eid[lastIdx - 1];
		var colHeadC = eid[lastIdx];
		var myColHead = cfg.colHead.rows[colHeadR][colHeadC];

		this.checkedColSeq(myColHead.colSeq, eventTarget.checked);
	},
	/* colHead events ~~~~~~~~~~~~~~~~~*/
	/* colHead 영역  ~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	/* body */
	sortList: function (nsort, myColHead, list) {
		var cfg = this.config;

		var getValueForSort = function (item, itemIndex) {
			if (myColHead.formatter) {
				var result;
				if (myColHead.formatter == "money") {
					result = item[myColHead.key];
				} else if (myColHead.formatter == "dec") {
					result = item[myColHead.key].dec();
				} else if (myColHead.formatter == "html") {
					result = item[myColHead.key];
				} else if (myColHead.formatter == "checkbox") {
					result = item[myColHead.key];
				} else {
					var sendObj = {
						index: itemIndex,
						list: list,
						item: item,
						page: this.page
					}
					result = myColHead.formatter.call(sendObj);
					//result 값이 money 형식인지 체크 합니다.
					var moneyCheck = result.replace(/,/g, "");
					if (axdom.isNumeric(moneyCheck)) result = result.number();
				}
				return result;
			} else {
				return item[myColHead.key];
			}
		};

		if (nsort == "desc") {
			var listIndex = 0;
			list = list.sort(function (prevItem, nowItem) {
				if (prevItem[cfg.reserveKeys.hashKey].length == nowItem[cfg.reserveKeys.hashKey].length) {
					var v1 = getValueForSort(prevItem, listIndex);
					var v2 = getValueForSort(nowItem, listIndex);
					listIndex++;
					if (v1 < v2) return 1;
					else if (v1 > v2) return -1;
					else if (v1 == v2) return 0;
				} else {
					return 0;
				}
			});
		} else {
			var listIndex = 0;
			list = list.sort(function (prevItem, nowItem) {
				if (prevItem[cfg.reserveKeys.hashKey].length == nowItem[cfg.reserveKeys.hashKey].length) {
					var v1 = getValueForSort(prevItem, listIndex);
					var v2 = getValueForSort(nowItem, listIndex);
					listIndex++;
					if (v1 < v2) return -1;
					else if (v1 > v2) return 1;
					else if (v1 == v2) return 0;
				} else {
					return 0;
				}
			});
		}

		return list;
	},
	setBody: function (list) {
		var cfg = this.config;
		if (list) {
			this.list = list;
		}

		var po = [];
		po.push("<div id=\"" + cfg.targetID + "_AX_scrollContent\" class=\"treeScrollContent\">");
		po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"treeBodyTable\" style=\"\">");
		po.push(this.getColGroup("CB")); //colGroup 삽입
		po.push("<thead id=\"" + cfg.targetID + "_AX_thead\"></thead>");
		po.push("<tbody id=\"" + cfg.targetID + "_AX_tbody\">");
		po.push("<tr class=\"noListTr\">");
		po.push("<td colspan=\"" + (this.showColLen) + "\">");
		po.push("<div class=\"tdRelBlock\">");
		po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
		po.push(cfg.emptyListMSG);
		po.push("</div>");
		po.push("</div>");
		po.push("</td>");
		po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
		po.push("</tr>");
		po.push("</tbody>");
		po.push("<tfoot id=\"" + cfg.targetID + "_AX_tfoot\"></tfoot>");
		po.push("</table>");
		po.push("</div>");
		if (this.hasFixed) {
			po.push("<div id=\"" + cfg.targetID + "_AX_fixedScrollContent\" class=\"treeFixedScrollContent\" style=\"width:" + this.fixedColWidth + "px;\">");
			po.push("<table cellpadding=\"0\" cellspacing=\"0\" class=\"treeFixedBodyTable\" style=\"width:" + this.fixedColWidth + "px;\">");
			po.push(this.getColGroup("FB")); //colGroup 삽입
			po.push("<thead id=\"" + cfg.targetID + "_AX_fixedThead\"></thead>");
			po.push("<tbody id=\"" + cfg.targetID + "_AX_fixedTbody\">");
			po.push("<tr class=\"noListTr\">");
			po.push("<td colspan=\"" + (this.showColLen) + "\">");
			po.push("</td>");
			po.push("</tr>");
			po.push("</tbody>");
			po.push("<tfoot id=\"" + cfg.targetID + "_AX_fixedTfoot\"></tfoot>");
			po.push("</table>");
			po.push("</div>");
		}
		//po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackXY\" class=\"treeScrollTrackXY\"></div>");
		po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackY\" class=\"treeScrollTrackY\"><div id=\"" + cfg.targetID + "_AX_scrollYHandle\" class=\"treeScrollHandle\"></div></div>");
		po.push("<div id=\"" + cfg.targetID + "_AX_scrollTrackX\" class=\"treeScrollTrackX\"><div id=\"" + cfg.targetID + "_AX_scrollXHandle\" class=\"treeScrollHandle\"></div></div>");
		po.push("<div style=\"display:none;\">");
		po.push("<div id=\"" + cfg.targetID + "_AX_Selector\" class=\"AXtreeSelector\"></div>");
		po.push("</div>");
		this.body.html(po.join(''));

		if (this.list.length > 0) {
			this.setList(this.list, false);
		}

		// scroll event bind
		axdom("#" + cfg.targetID + "_AX_scrollYHandle").bind("mousedown", this.contentScrollScrollReady.bind(this));
		axdom("#" + cfg.targetID + "_AX_scrollXHandle").bind("mousedown", this.contentScrollScrollReady.bind(this));
		// scroll event bind ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	},
	listLoadingDisplay: function () {
		var cfg = this.config;
		var po = [];
		po.push("<tr class=\"noListTr\">");
		po.push("<td colspan=\"" + (this.showColLen) + "\">");
		po.push("<div class=\"tdRelBlock\">");
		po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
		po.push("	<div class=\"AXLoading\"></div>");
		po.push("</div>");
		po.push("</div>");
		po.push("</td>");
		po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
		po.push("</tr>");
		axdom("#" + cfg.targetID + "_AX_tbody").html(po.join(''));

		po = [];
		po.push("<tr class=\"noListTr\">");
		po.push("<td colspan=\"" + (this.showColLen) + "\">");
		po.push("</td>");
		po.push("</tr>");
		axdom("#" + cfg.targetID + "_AX_fixedTbody").html(po.join(''));
	},
	getAXTreeSplit: function(isFix){
		var cfg = this.config;
		var po = [];
		if(isFix == "n"){
			po.push("<tr class=\"AXTreeSplit\">");
			po.push("<td colspan=\"" + (this.showColLen) + "\">");
			po.push("</td>");
			po.push("<td class=\"bodyNullTd\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
			po.push("</tr>");
		}else{
			po.push("<tr class=\"AXTreeSplit\">");
			po.push("<td colspan=\"" + (this.showColLen) + "\">");
			po.push("</td>");
			po.push("</tr>");
		}
		return po.join('');
	},
	/**
	 * @method AXTree.setList
	 * @param {Array | Object} obj - example code 참고
	 * @param {String} [positioning] - 특정 자식개채를 지정해서 하위의 자식노드를 업데이트 합니다.
	 * @description
	 * 트리에 데이터를 전달합니다. 비동기 방식의 경우 직접데이터를 전달하지 않고 데이터의 전달자 정보를 정의하여 처리합니다.
	 * @example
	 * ```js
	 * //Array - list Array setConfig 에서 정의한 relation 의 부모, 자식키 값을 이용하여 list형 데이터를 tree형 데이터로 변환하여 트리를 구성합니다.
	 * var List = [
	 * 	 {no:1, nodeName:"LEVEL 1-1", writer:"tom", type:"0", pno:0},
	 * 	 {no:11, nodeName:"LEVEL 1-1-1", writer:"tom", type:"0", pno:1},
	 * 	 {no:2, nodeName:"LEVEL 2-1", writer:"tom", type:"0", pno:0},
	 * 	 {no:21, nodeName:"LEVEL 2-1-1", writer:"tom", type:"0", pno:2},
	 * 	 {no:24, nodeName:"LEVEL 2-1-4", writer:"tom", type:"0", pno:2},
	 * 	 {no:241, nodeName:"LEVEL 2-1-4-1", writer:"tom", type:"0", pno:24},
	 * 	 {no:2411, nodeName:"LEVEL 2-1-4-1-1", writer:"tom", type:"0", pno:241},
	 * 	 {no:2412, nodeName:"LEVEL 2-1-4-1-1", writer:"tom", type:"0", pno:241},
	 * 	 {no:25, nodeName:"LEVEL 2-1-2", writer:"tom", type:"0", pno:2},
	 * 	 {no:26, nodeName:"LEVEL 2-1-3", writer:"tom", type:"0", pno:2},
	 * 	 {no:3, nodeName:"LEVEL 3-1", writer:"tom", type:"0", pno:0},
	 * 	 {no:11, nodeName:"LEVEL 3-1", writer:"tom", type:"0", pno:0}
	 * 	 ];
	 * 	 myTree.setList(List);
	 *
	 * 	 var AJAXconfigs = {
	 *     ajaxUrl:"loadTree.php", //{String} - AJAX 호출 URL
	 *     ajaxPars:"param1=1&param2=2",   //{String} - AJAX 호출 URL 파라미터 (전송은 post 방식으로 이루어집니다.)
	 *     onLoad: function(){ //[Function] - AJAX 호출완료 이벤트 콜백함수
	 *     ...
	 *     }
	 * };
	 * myTree.setList(AJAXconfigs);
	 * ```
	 */
	setList: function (obj, positioning) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;

		this.listLoadingDisplay();

		axdom("#" + cfg.targetID + "_AX_scrollContent").css({ width: "auto" });

		if (obj.ajaxUrl)
		{
			this.ajaxInfo = obj;
			this.ajax_sortDisable = positioning;
			var sortDisable = positioning;
			this.pageActive = true;

			var url = obj.ajaxUrl;
			var appendPars = [
				"pageNo=" + this.page.pageNo,
				"pageSize=" + this.page.pageSize
			];
			var pars = (obj.ajaxPars) ? obj.ajaxPars + "&" + appendPars.join('&') : appendPars.join('&');

			var _method = "post";
			var _contentType = AXConfig.AXReq.contentType;
			var _headers = {};
			var _responseType = AXConfig.AXReq.responseType;
			var _dataType = AXConfig.AXReq.dataType;

			if (obj.method) _method = obj.method;
			if (obj.contentType) _contentType = obj.contentType;
			if (obj.headers) _headers = obj.headers;

			var ajaxGetList = this.ajaxGetList.bind(this);
			new AXReq(url, {
				type: _method,
				contentType: _contentType,
				responseType: _responseType,
				dataType: _dataType,
				headers: _headers,
				debug: obj.debug,
				pars: pars,
				debug: false,
                pars: pars,
                onsucc: function (res) {
					if (res.result == AXConfig.AXReq.okCode) {
						res._sortDisable = sortDisable;
						if (obj.response) {
							obj.response.call(res);
						} else {
							ajaxGetList(res, positioning);
						}
						if (obj.onLoad) obj.onLoad.call(res);
					} else {
						AXUtil.alert(res);
					}
				}
			});

		}
		else
		{
			this.ajaxInfo = null;
			if (axdom.isArray(obj)) {
				if (obj.length == 0) {

					/*
                     var po = [];
                     po.push("<div class=\"bodyNode bodyTdText\" align=\"center\">");
                     po.push("목록이 없습니다.");
                     po.push("</div>");
                     axdom("#" + cfg.targetID + "_AX_tbody").html(po.join(''));
                     */
					//return;
				}

				if (typeof positioning === "undefined") {
					this.list = this.positioningHashList(obj);
				} else {
					this.list = obj;
				}

				this.printList();
				this.pageActive = false;
			}
		}
	},
	reloadList: function () {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;

		if (this.ajaxInfo) {
			var obj = this.ajaxInfo;
			var sortDisable = this.ajax_sortDisable;
			this.pageActive = true;

			this.listLoadingDisplay();

			var url = obj.ajaxUrl;
			var appendPars = [
				"pageNo=" + this.page.pageNo,
				"pageSize=" + this.page.pageSize
			];
			var pars = (obj.ajaxPars) ? obj.ajaxPars + "&" + appendPars.join('&') : appendPars.join('&');

			var ajaxGetList = this.ajaxGetList.bind(this);
			new AXReq(url, {
				debug: false, pars: pars, onsucc: function (res) {
					if (res.result == AXConfig.AXReq.okCode) {
						res._sortDisable = sortDisable;
						if (obj.response) {
							obj.response.call(res);
						} else {
							ajaxGetList(res);
						}
					} else {
						AXUtil.alert(res);
					}
				}
			});

		}
	},
	ajaxGetList: function (res, positioning) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;

		if (res._sortDisable || !cfg.sort) {
			this.list = res[AXConfig.AXTree.keyList];
		} else {
			if (nowSortHeadID) {
				this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, res[AXConfig.AXTree.keyList]);
			} else {
				this.list = res[AXConfig.AXTree.keyList];
			}
		}
		//trace(this.list);
		if (positioning == undefined) {
			this.list = this.positioningHashList(this.list);
		} else {
			//this.list = obj;
		}

		//AXUtil.overwriteObject(this.page, res.page, true);
		this.printList();
	},
	/**
	 * @method AXTree.getFormatterValue
	 * @param {String|Function} formatter - config 의 colGroup이나 colHead에서 지정된 formatter
	 * @param {Object} item  - 대상 인덱스의 리스트 1개 열
	 * @param {Number} itemIndex  - 대상 인덱스
	 * @param {String} value - 표현 대상 값.
	 * @param {Object} key - config 의 colGroup 내부 key 값
	 * @param {Object} CH - 대상 그리드의 [열][행]
	 * @param {Number} CHidx - 대상 그리드의 [열][행] 중 행의 index
	 * @returns {String}
	 * @description 지정된 표현 형식으로 데이터를 HTML String 으로 변환 시킵니다.
	 */
	getFormatterValue: function (formatter, item, itemIndex, value, key, CH, CHidx) {
		var cfg = this.config;
		var result;
		if(CH.editor && (CH.editor.type == "checkbox" || CH.editor.type == "radio")){
			//
			// editCell 처리
			var checkedStr = "", disabled = "",
				that = {
					index: itemIndex,
					list: this.list,
					item: item,
					page: this.page,
					key: key,
					value: value
				};

			if(value && value.__checked) checkedStr = ' checked="checked"';
			else if(value == true || value == 1 || value == "1" || value == "Y") checkedStr = ' checked="checked"';
			if(CH.editor.disabled){
				if(CH.editor.disabled.call(that)){
					disabled = ' disabled="disabled"';
				}
			}

			result = '<input type="'+CH.editor.type+'" name="'+ key +'" data-editor-key="'+itemIndex+','+CHidx+'" class="inline-editor-checkbox" ' +
				checkedStr + disabled + ' onfocus="this.blur();" />';
			//"<input type=\"checkbox\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
		}
		else
		if (formatter == "money") {
			if (value == "" || value == "null" || value == null || value == undefined) {
				result = "0";
			} else {
				result = (value || 0).number().money();
			}
		} else if (formatter == "dec") {
			result = (value == undefined) ? "" : value.toString().dec();
		} else if (formatter == "html") {
			result = value;
		} else if (formatter == "checkbox" || formatter == "radio") {
			var checkedStr = "";
			var disabled = "";
			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item,
				page: this.page,
				key: key,
				value: value
			};

			/*
			if(this.list[itemIndex].___checked && this.list[itemIndex].___checked[CHidx]){
				if(this.list[itemIndex].___checked[CHidx]) checkedStr = " checked=\"checked\" ";
				//if(itemIndex == 0) console.log(this.list[itemIndex].___checked[CHidx], checkedStr);
			}
			*/
			if(this.list[itemIndex].__checked){
				checkedStr = " checked=\"checked\" ";
			}
			else if (Object.isFunction(CH.checked)) {
				if (CH.checked.call(sendObj)) {
					checkedStr = " checked=\"checked\" ";
					if(!this.list[itemIndex].___checked) this.list[itemIndex].___checked = {};
					this.list[itemIndex].___checked[CHidx] = true;
				}
			}

			if (CH.disabled) {
				if (CH.disabled.call(sendObj)) {
					disabled = " disabled=\"disabled\" ";
					if(!this.list[itemIndex].___checked) this.list[itemIndex].___disabled = {};
					this.list[itemIndex].___disabled[CHidx] = true;
				}
			}
			/*
			 result = "<label class=\"gridCheckboxLabel\">" +
			 "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />" +
			 "</label>";
			 */
			result = "<input type=\"" + formatter + "\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + CH.colSeq + "_AX_" + itemIndex + "\" value=\"" + value + "\" " + checkedStr + disabled + " onfocus=\"this.blur();\" />";
		} else {
			if(Object.isFunction(formatter)){
				var sendObj = {
					index: itemIndex,
					list: this.list,
					item: item,
					page: this.page,
					key: key,
					value: value
				};
				result = formatter.call(sendObj, itemIndex, item);
			} else {
				result = ((String(value) == "null") ? "" : value);
			}
		}
		return result;
	},
	getIconClassValue: function (getIconClass, item, itemIndex, value, key, CH) {
		var cfg = this.config;
		var iconClass;
		var sendObj = {
			index: itemIndex,
			list: this.list,
			item: item,
			page: this.page
		}
		iconClass = getIconClass.call(sendObj, itemIndex, item);
		return iconClass;
	},
	getTooltipValue: function (formatter, item, itemIndex, value, key, CH) {
		var cfg = this.config;
		var result;
		if (formatter == "money") {
			if (value == "" || value == "null") {
				result = "";
			} else {
				result = value.number().money();
			}
		} else if (formatter == "dec") {
			result = value.dec();
		} else if (formatter == "html") {
			result = value;
		} else if (formatter == "checkbox") {
			var checked = "";
			var disabled = "";

			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item
			}

			if (CH.checked) {
				var callCheckedResult = CH.checked.call(sendObj);
				if (callCheckedResult) {
					checked = " checked=\"checked\" ";
				}
			}

			if (CH.disabled) {
				var callDisabledResult = CH.disabled.call(sendObj);
				if (callDisabledResult) {
					disabled = " disable=\"disable\" ";
				}
			}
			result = "<input type=\"checkbox\" name=\"" + CH.label + "\" class=\"treeCheckBox_body_colSeq" + CH.colSeq + "\" id=\"" + cfg.targetID + "_AX_checkboxItem_AX_" + itemIndex + "\" value=\"" + value + "\" " + checked + disabled + " />";
		} else {
			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item,
				page: this.page
			}
			result = formatter.call(sendObj);
		}
		return result;
	},
	getItem: function (itemIndex, item, isfix, hasTr) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var tpo = [];
		var evenClassName = "line" + (itemIndex % 2);
		var hashClassName = "parentHash" + item[cfg.reserveKeys.parentHashKey];

		var getFormatterValue = this.getFormatterValue.bind(this);
		var getTooltipValue = this.getTooltipValue.bind(this);
		var getIconClassValue = this.getIconClassValue.bind(this);
		var hasFixed = this.hasFixed;
		var hasTrValue = (hasTr == undefined) ? true : false;
		var trAddClass = "";
		if (cfg.body.addClass) {
			try {
				trAddClass = cfg.body.addClass.call({
					index: itemIndex,
					item: item,
					list: this.list
				});
			} catch (e) {
				trace(e);
			}
		}
		var trStyles = [];
		var isDisplay = item[reserveKeys.displayKey];
		if (!isDisplay) trStyles.push("display:none;");

		var _tree = this.tree;

		for (var r = 0; r < cfg.body.rows.length; r++) {
			var isLastTR = (cfg.body.rows.length - 1 == r);
			if (hasTrValue) tpo.push("<tr class=\"gridBodyTr gridBodyTr_" + itemIndex + " " + evenClassName + " " + hashClassName + " " + trAddClass + "\" id=\"" + cfg.targetID + "_AX_tr_" + r + "_AX_" + (isfix || "n") + "_AX_" + itemIndex + "\" style=\"" + trStyles.join('') + "\">");
			var colCount = 0;
			axf.each(cfg.body.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == "n" || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";
						var bodyNodeStyles = [];
						var indentWidth = 0;
						var iconWidth = 0;
						if (CH.indent) {
							var hash = item[cfg.reserveKeys.hashKey];
							var re = new RegExp(cfg.hashSpliter, "g");
							indentWidth = ((hash.split(re).length - 1) * cfg.indentWidth) + 3;

							if (indentWidth > (cfg.indentWidth.number() + 3)) {
								indentWidth = indentWidth * cfg.indentRatio;
							}

							if (CH.getIconClass) {
								iconWidth = cfg.iconWidth;
							}
							if (CH.align == "left") {
								bodyNodeStyles.push("padding-left:" + (indentWidth + iconWidth) + "px;");
							} else {
								bodyNodeStyles.push("padding-right:" + (indentWidth + iconWidth) + "px;text-align:right;");
							}
						}
						/*trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});*/

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						var expandNodeClass = "";
						if (item[cfg.reserveKeys.openKey]) expandNodeClass = " expand";

						var iconClass = "";
						var tooltipValue = "";
						if (CH.tooltip) {
							tooltipValue = getTooltipValue(CH.tooltip, item, itemIndex, item[CH.key], CH.key, CH);
						}
						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "body_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\" title=\"" + tooltipValue + "\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" style=\"" + bodyNodeStyles.join(";") + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_bodyText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\">");

						if (CH.indent) {

							/*CH.align : left*/
							/*indentWidth : left position;*/
							if(cfg.showConnectionLine){
								/* line 표시 박스 구현	*/
								tpo.push("<span class=\"connectionLineContainer\">");
								var hashPosition = item[cfg.reserveKeys.hashKey].split(/_/g);
								for(var hp=2;hp<hashPosition.length;hp++){
									var hpLeft = ((hp - 2) * cfg.indentWidth) + 3;

									var hpIndentWidth = cfg.indentWidth * cfg.indentRatio;
									var connectionLineClass = [];
									var subTreeStr = "";
									if(hp < (hashPosition.length-1)){
										for (var i = 1; i < hp+1; i++) {
											if (i == 1) {
												subTreeStr += "[" + hashPosition[i].number() + "]";
											} else {
												subTreeStr += "[reserveKeys.subTree][" + hashPosition[i].number() + "]";
											}
										}
										var parentTree = null;
										try{
											eval("parentTree = _tree" + subTreeStr);
											if(parentTree.__isLastChild){
												connectionLineClass.push("isParentOutside");
											}else{
												connectionLineClass.push("isParentInside");
											}
										}catch(e){
											trace(e);
										}
									}else if(item.__isLastChild && hp == (hashPosition.length-1)){
										connectionLineClass.push("isLastChild");
									}
									tpo.push("<span class=\"connectionLine " + connectionLineClass.join(" ") + "\" style=\"" + CH.align + ":"+hpLeft+"px;width:" + hpIndentWidth + "px;\"></span>");
								}
								tpo.push("</span>");

								if (item.__subTreeLength == 0){
									expandNodeClass += " noChild";
								}

								tpo.push("<a class=\"bodyNodeIndent" + expandNodeClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIndent_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth - 20) + "px;");
								//if (item.__subTreeLength == 0) tpo.push("display:none;");
								tpo.push("\"></a>");
							}else{
								tpo.push("<a class=\"bodyNodeIndent" + expandNodeClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIndent_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth - 20) + "px;");
								if (item.__subTreeLength == 0) tpo.push("display:none;");
								tpo.push("\"></a>");
							}
						}
						if (CH.getIconClass) {
							iconClass = getIconClassValue(CH.getIconClass, item, itemIndex, item[CH.key], CH.key, CH);
							if(Object.isString(iconClass)){
								tpo.push("<a class=\"bodyNodeIcon " + iconClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIcon_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth) + "px;\"></a>");
							}else{
								tpo.push("<a class=\"bodyNodeIcon " + iconClass.addClass + "\" id=\"" + cfg.targetID + "_AX_bodyNodeIcon_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" style=\"" + CH.align + ":" + (indentWidth) + "px;\">"+ iconClass.html +"</a>");
							}
						}

						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
							} else {
								tpo.push(item[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}

						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == "n" && cfg.colHead.display) {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_null_AX_" + itemIndex + "\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlock_AX_" + itemIndex + "\">&nbsp;</div></td>");
			}
			if (hasTrValue) tpo.push("</tr>");
		}
		return tpo.join('');
	},
	getItemMarker: function (itemIndex, item, isfix) {
		var cfg = this.config;
		var tpo = [];
		var evenClassName = "gridBodyMarker";
		var getFormatterValue = this.getFormatterValue.bind(this);
		var hasFixed = this.hasFixed;

		for (var r = 0; r < cfg.body.marker.rows.length; r++) {
			var isLastTR = (cfg.body.marker.rows.length - 1 == r);
			tpo.push("<tr class=\"gridBodyTr gridBodyMarkerTr_" + itemIndex + " " + evenClassName + "\" id=\"" + cfg.targetID + "_AX_marker_" + r + "_AX_" + (isfix || "n") + "_AX_" + itemIndex + "\">");
			var colCount = 0;
			axf.each(cfg.body.marker.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == "n" || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

						//trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "bodyMarker_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_bodyMarkerText_AX_" + r + "_AX_" + CHidx + "_AX_" + itemIndex + "\">");
						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getFormatterValue(CH.formatter, item, itemIndex, item[CH.key], CH.key, CH));
							} else {
								tpo.push(item[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}
						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == "n") {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_nullMarker_AX_" + itemIndex + "\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\" id=\"" + cfg.targetID + "_AX_tdRelBlockMarker_AX_" + itemIndex + "\">&nbsp;</div></td>");
			}
			tpo.push("</tr>");
		}
		return tpo.join('');
	},
	getMarkerDisplay: function (itemIndex, item) {
		var cfg = this.config;
		var bodyHasMarker = this.bodyHasMarker;

		if (!bodyHasMarker) return false;
		var sendObj = {
			index: itemIndex,
			list: this.list,
			item: item,
			page: this.page
		}
		var markerDisplay = cfg.body.marker.display.call(sendObj);
		return markerDisplay;
	},
	printList: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var bodyHasMarker = this.bodyHasMarker;
		var getItem = this.getItem.bind(this);
		var getItemMarker = this.getItemMarker.bind(this);
		var getMarkerDisplay = this.getMarkerDisplay.bind(this);

		this.gridBodyOverBind = this.gridBodyOver.bind(this);
		this.gridBodyOutBind = this.gridBodyOut.bind(this);
		this.gridBodyClickBind = this.gridBodyClick.bind(this);
		this.gridBodyDBLClickBind = this.gridBodyDBLClick.bind(this);

		var getAXTreeSplit = this.getAXTreeSplit.bind(this);

		var po = [];
		axf.each(this.list, function (itemIndex, item) {
			if (!item.isRoot && !item._isDel) {
				if(item.AXTreeSplit){
					po.push(getAXTreeSplit("n"));
				}else{
					po.push(getItem(itemIndex, item, "n"));
					if (bodyHasMarker && getMarkerDisplay(itemIndex, item)) {
						po.push(getItemMarker(itemIndex, item, "n"));
					}
				}
			}
		});
		axdom("#" + cfg.targetID + "_AX_tbody").empty();
		axdom("#" + cfg.targetID + "_AX_tbody").append(po.join(''));

		if (this.hasFixed) {
			po = [];
			axf.each(this.list, function (itemIndex, item) {
				if (!item.isRoot && item[cfg.reserveKeys.displayKey] && !item._isDel) {
					if(item.AXTreeSplit){
						po.push(getAXTreeSplit("fix"));
					}else{
						po.push(getItem(itemIndex, item, "fix"));
						if (bodyHasMarker && getMarkerDisplay(itemIndex, item)) {
							po.push(getItemMarker(itemIndex, item, "fix"));
						}
					}
				}
			});
			axdom("#" + cfg.targetID + "_AX_fixedTbody").empty();
			axdom("#" + cfg.targetID + "_AX_fixedTbody").append(po.join(''));
		}

		this.selectedCells.clear(); // selectedCells clear

		//trace(this.list);
		//trace(this.tree);

		var _tree = this.tree;
		var list_pointer = {};
		axf.each(this.list, function (lidx, L) {
			list_pointer[L[cfg.reserveKeys.hashKey]] = lidx;
		});
		//trace(list_pointer);

		var _list = this.list;
		axf.each(this.list, function (lidx, L) {
			if(L.__checked){
				var hashs = L[cfg.reserveKeys.hashKey].split(/_/g);
				hashs.shift();
				//trace(hashs);
				for (var l = hashs.length - 1; l > -1; l--) {
					//trace(l);
					var subTreeStr = "";
					var checkHash = [];

					for (var i = 0; i < l + 1; i++) {
						checkHash.push(hashs[i]);
						if (i == 0) {
							subTreeStr += "[" + hashs[i].number() + "]";
						} else {
							subTreeStr += "[reserveKeys.subTree][" + hashs[i].number() + "]";
						}
					}
					//trace(checkHash);
					//trace(checkHash.join("_"));
					//trace(subTreeStr);
					var myTree = null;
					try{
						eval("myTree = _tree" + subTreeStr);
					}catch(e){

					}

					if(myTree != null){
						myTree.__checked = true;
						var findHash = "0".setDigit(cfg.hashDigit)+"_"+checkHash.join("_");
						//trace(findHash);
						if(list_pointer[findHash] != undefined){
							_list[list_pointer[findHash]].__checked = true;
						}
					}

				};
			}
		});

        for (var sr = 0; sr < this.selectedRow.length; sr++) {
			this.body.find(".gridBodyTr_" + this.selectedRow[sr]).addClass("selected");
		}
		this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOverBind);
		this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOutBind);
		this.body.find(".gridBodyTr").bind("click", this.gridBodyClickBind);
		if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClickBind);
		this.contentScrollResize();

		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;

        if (cfg.persistExpanded) {
            var expandedIndexs = axf.getCookie(cfg.cookiePrefix + cfg.targetID + "-expanded-index").split(/,/g);
            var expand = this.click.bind(this);
            axf.each(expandedIndexs, function(idx, item){
                expand(item, "expand", true);
            });
        }
        if (cfg.persistSelected) {
            var selectedIndex = axf.getCookie(cfg.cookiePrefix + cfg.targetID + "-selected-index");
            if (selectedIndex !== undefined) {
                this.click(selectedIndex);
            }
        }
	},
	updateList: function (itemIndex, item) {
		var cfg = this.config;

		var trAddClass = "";
		if (cfg.body.addClass) {
			try {
				trAddClass = cfg.body.addClass.call({
					index: itemIndex,
					item: item,
					list: this.list
				});
			} catch (e) {
				trace(e);
			}
		}

		var npo = this.getItem(itemIndex, item, "n", "notr");
		if (this.hasFixed) {
			var fpo = this.getItem(itemIndex, item, "fix", "notr");
		}

		axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).html(npo);
		if (this.hasFixed) {
			axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).html(npo);
		}

		if (trAddClass) {
			axdom("#" + cfg.targetID + "_AX_tbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
			if (this.hasFixed) {
				axdom("#" + cfg.targetID + "_AX_fixedTbody").find(".gridBodyTr_" + itemIndex).addClass(trAddClass);
			}
		}

		this.body.find(".gridBodyTr").unbind("mouseover", this.gridBodyOverBind);
		this.body.find(".gridBodyTr").unbind("mouseout", this.gridBodyOutBind);
		this.body.find(".gridBodyTr").unbind("click", this.gridBodyClickBind);
		if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) this.body.find(".gridBodyTr").unbind("dblclick", this.gridBodyDBLClickBind);

		this.body.find(".gridBodyTr").bind("mouseover", this.gridBodyOverBind);
		this.body.find(".gridBodyTr").bind("mouseout", this.gridBodyOutBind);
		this.body.find(".gridBodyTr").bind("click", this.gridBodyClickBind);
		if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) this.body.find(".gridBodyTr").bind("dblclick", this.gridBodyDBLClickBind);

		this.redrawDataSet();
	},
	/**
	 * @method AXTree.expandToggleList
	 * @param {Number} itemIndex - 아이템 인덱스
	 * @param {JSObject} item - 아이템 json
	 * @param {Boolean} expandStat - 트리 아이템 오픈 여부
	 * @description
	 * 아이템의 확장/축소 상태를 토글처리 합니다.
	 * @example
	 * ```js
	 * var iwantItemIndex = 10;
	 * var myitem = myTree.list[iwantItemIndex];
	 * myTree.expandToggleList(iwantItemIndex, myitem);
	 * myTree.expandToggleList(iwantItemIndex, myitem, true); // 노드를 열린 상태로 바꾸어 줍니다.
	 * ```
	 */
	expandToggleList: function (itemIndex, item, expandStat) {
		var cfg = this.config;

		this.gridBodyOverBind;
		this.gridBodyOutBind;
		this.gridBodyClickBind;
		this.gridBodyDBLClickBind;


		if (item[cfg.reserveKeys.openKey] && (typeof expandStat == "undefined" || expandStat == false)) {

			//자식 개체 모두 닫기 체크하기
			var pHash = item[cfg.reserveKeys.hashKey];
			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
			var lastR = cfg.body.rows.length - 1;
			for (var r = 0; r < cfg.body.rows.length; r++) {
				axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").removeClass("expand");
			}

			//trace(pHash);
			var removepHashs = [];
			axf.each(this.list, function (itemIndex, item) {
				if(!item.AXTreeSplit){
					if (pHash == item[cfg.reserveKeys.parentHashKey].left(pHash.length)) {
						removepHashs.push(item[cfg.reserveKeys.parentHashKey]);
						item[cfg.reserveKeys.displayKey] = false;
					}
				}
			});
			var _body = this.body;
			axf.each(removepHashs, function () {
				_body.find(".gridBodyTr.parentHash" + this).hide();
			});
			item[cfg.reserveKeys.openKey] = false;

			var myTree = this.tree;
			axf.each(hashs, function (hidx, HH) {
				if (hidx == 0) {

				} else if (hidx == 1) {
					myTree = myTree[HH.number()];
				} else {
					myTree = myTree[cfg.reserveKeys.subTree][HH.number()];
				}
			});
			myTree[cfg.reserveKeys.openKey] = false;

			this.contentScrollResize();

			this.contentScrollXAttr = null;
			this.contentScrollYAttr = null;

			//clear select

			this.clearFocus();

            if (cfg.persistExpanded) {
                var persistKey      = cfg.cookiePrefix + cfg.targetID + "-expanded-index";
                var expandedIndices = axf.getCookie(persistKey).split(/,/g);

                if (expandedIndices[0] === "") { expandedIndices.shift(); }

                for (var ei = expandedIndices.length - 1; ei >= 0; ei--) {
                    // 하위 노드 키도 삭제하기 위해서 hash로 비교한다.
                    var itemHash      = item[cfg.reserveKeys.hashKey];
                    var expandedIndex = expandedIndices[ei].number();
                    var expandedHash  = this.list[expandedIndex][cfg.reserveKeys.hashKey];
                    if (expandedHash.indexOf(itemHash) === 0) {
                        expandedIndices.splice(ei, 1);
                    }
                }

                axf.setCookie(persistKey, expandedIndices.join(","), cfg.cookieExpiredays);
            }

			if (cfg.body.oncontract) {
				//itemIndex, item, subTree
				//dialog.push(Object.toJSON(subTree));
				var sendObj = {
					index: itemIndex,
					list: this.list,
					list: this.tree,
					item: item,
					subTree: subTree,
					itemID: this.body.find(".gridBodyTr_" + itemIndex).attr("id")
				};
				cfg.body.oncontract.call(sendObj, itemIndex, item);
			}
		}
		else
		if(typeof expandStat == "undefined" || expandStat == true)
		{ // 자식개체 열기

			item[cfg.reserveKeys.openKey] = true;

			for (var r = 0; r < cfg.body.rows.length; r++) {
				axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").addClass("expand");
			}

			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

			//findTree Position


			var myTree = this.tree;
			axf.each(hashs, function (hidx, HH) {
				if (hidx == 0) {

				} else if (hidx == 1) {
					myTree = myTree[HH.number()];
				} else {
					myTree = myTree[cfg.reserveKeys.subTree][HH.number()];
				}
			});

			var addHashs = [];
			var preFixHash = hashs.join("_");
			var getAddHashs = function (_tree, pfHash) {
				addHashs.push(pfHash);
				axf.each(_tree, function (treeIndex, nTree) {
					if (nTree[cfg.reserveKeys.subTree].length > 0 && nTree[cfg.reserveKeys.openKey]) getAddHashs(nTree[cfg.reserveKeys.subTree], pfHash + "_" + treeIndex.setDigit(cfg.hashDigit));
				});
			};
			getAddHashs(myTree[cfg.reserveKeys.subTree], preFixHash);

			myTree[cfg.reserveKeys.openKey] = true;

			var subTree = [];
			var _list = this.list;
			var itemChangeDisplay = this.itemChangeDisplay.bind(this);
			var _body = this.body;
			axf.each(addHashs, function () {
				_body.find(".gridBodyTr.parentHash" + this).each(function () {
					var trIndex = this.id.split(/_AX_/g).last();
					itemChangeDisplay(trIndex, true);
					subTree.push(_list[trIndex]);
				});
				_body.find(".gridBodyTr.parentHash" + this).show();
			});

			this.contentScrollResize();

			this.contentScrollXAttr = null;
			this.contentScrollYAttr = null;

            if (cfg.persistExpanded) {
                var persistKey     = cfg.cookiePrefix + cfg.targetID + "-expanded-index";
                var expandedIndexs = axf.getCookie(persistKey).split(/,/g);

                if (expandedIndexs[0] === "") { expandedIndexs.shift(); }

                var isInclude = false;
                axf.each(expandedIndexs, function(idx, expandedIndex){
                    if (expandedIndex == item.__index) {
                        isInclude = true;
                        return false;
                    }
                });

                if (!isInclude) {
                    expandedIndexs.push(item.__index);
                }

                axf.setCookie(persistKey, expandedIndexs.join(","), cfg.cookieExpiredays);
            }

			if (cfg.body.onexpand) {
				//itemIndex, item, subTree
				//dialog.push(Object.toJSON(subTree));
				var sendObj = {
					index: itemIndex,
					list: this.list,
					list: this.tree,
					item: item,
					subTree: subTree,
					itemID: this.body.find(".gridBodyTr_" + itemIndex).attr("id")
				};
				cfg.body.onexpand.call(sendObj, itemIndex, item);
			}

		}

	},
	itemChangeDisplay: function (itemIndex, status) { // 입력받은 인덱스의 display 상태변경 함수
		var cfg = this.config;
		this.list[itemIndex][cfg.reserveKeys.displayKey] = status;
	},
	gridBodyOver: function (event) {
		var cfg = this.config;
		if (this.overedItemIndex) {
			this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
		}
		var itemIndex = (event.target.id).split(/_AX_/g).last();
		if (itemIndex != "") {
			this.body.find(".gridBodyTr_" + itemIndex).addClass("hover");
			this.overedItemIndex = itemIndex;
		}
	},
	gridBodyOut: function (event) {
		var cfg = this.config;
		if (this.overedItemIndex) {
			this.body.find(".gridBodyTr_" + this.overedItemIndex).removeClass("hover");
		}
	},
	gridBodyClick: function(event){
		var cfg = this.config;
		if (cfg.body.ondblclick) {
			if (AXUtil.browser.name == "ie" && AXUtil.browser.version == 8) {
				this.gridBodyClickAct(event);
			} else {
				if (this.bodyClickObserver){
					clearTimeout(this.bodyClickObserver);
					this.gridBodyDBLClick(event);
					this.bodyClickObserver = null;
					return;
				}
				var gridBodyClickAct = this.gridBodyClickAct.bind(this);
				this.bodyClickObserver = setTimeout(function () {
					gridBodyClickAct(event);
				}, 250);
			}
		}else{
			this.gridBodyClickAct(event);
		}
	},
	gridBodyClickAct: function (event) {
		this.bodyClickObserver = null;
		var cfg = this.config;
		// event target search -

		var eventTarget = event.target;
		var isoncheck = false;
		if (eventTarget.tagName.toLowerCase() == "input") {
			this.gridCheckClick(event);
			if (cfg.body.oncheck) {
				isoncheck = true;
			} else {
				// checkbox event bind
				return; //input 인 경우 제외
			}
		}

		//if(event.target.id == "" && event.target.tagName.toLowerCase() != "span") return;
		//var eid = event.target.id.split(/_AX_/g);
		// event target search ------------------------

		if (isoncheck) { //체크박스 구현
			var targetID = eventTarget.id;
			var itemIndex = targetID.split(/_AX_/g).last();
			var ids = targetID.split(/_AX_/g);
			var item = this.list[itemIndex];
			var r = ids[ids.length - 3];
			var c = ids[ids.length - 2];
			var target = event.target;
			var checked = event.target.checked;
			var sendObj = {
				index: itemIndex,
				target: event.target,
				checked: event.target.checked,
				r: r,
				c: c,
				list: this.list,
				item: item,
				page: this.page
			}
			//trace(sendObj);
			cfg.body.oncheck.call(sendObj, itemIndex, item);
		}
		else
		{

			var myTarget = this.getEventTarget({
				evt: eventTarget, evtIDs: "",
				until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false; },
				find: function (evt, evtIDs) { return (axdom(evt).hasClass("bodyTd") || axdom(evt).hasClass("bodyNodeIndent")) ? true : false; }
			});

			if (myTarget) {

				//colHeadTool ready
				var targetID = myTarget.id;
				var itemIndex = targetID.split(/_AX_/g).last();
				var ids = targetID.split(/_AX_/g);

				var clickNodeType = ids[(ids.length - 1) - 3];

				if (clickNodeType == "bodyNodeIndent") {
					var item = this.list[itemIndex];
					var r = ids[ids.length - 3];
					var c = ids[ids.length - 2];
					this.expandToggleList(itemIndex, item);
				} else if (this.readyMoved) {
					//이동명령 대기중 상태인경우 이동 처리
					//this.moveTarget = {itemIndex:itemIndex};
					this.moveTreeExec(this.moveTarget.itemIndex, itemIndex);
				} else {

					//trace({tagName:myTarget.tagName, id:myTarget.id, clickNodeType:clickNodeType});
					if (clickNodeType == "nbody" || clickNodeType == "fbody") {
						if (event.shiftKey) {

						} else if (event.ctrlKey) {
							if (this.selectedRow.length > 0) {
								var body = this.body;
								axf.each(this.selectedRow, function () {
									body.find(".gridBodyTr_" + this).removeClass("selected");
								});
								this.selectedRow.clear();
							}

							var hasID = false;
							var collect = [];
							axf.each(this.selectedCells, function () {
								if (this == targetID) {
									hasID = true;
								} else {
									collect.push(this);
								}
							});
							if (hasID) {
								axdom("#" + targetID).removeClass("selected");
								this.selectedCells = collect;
							} else {
								axdom("#" + targetID).addClass("selected");
								this.selectedCells.push(targetID);
							}
						} else {
							if (this.selectedCells.length > 0) {
								axf.each(this.selectedCells, function () {
									axdom("#" + this).removeClass("selected");
								});
								this.selectedCells.clear();
							}
							if (this.selectedRow.length > 0) {
								var body = this.body;
								axf.each(this.selectedRow, function () {
									body.find(".gridBodyTr_" + this).removeClass("selected");
								});
							}

							this.selectedRow.clear();
							this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
							this.selectedRow.push(itemIndex);

							var item = this.list[itemIndex];

                            if (cfg.persistSelected) {
                                var persistKey = cfg.cookiePrefix + cfg.targetID + "-selected-index";
                                axf.setCookie(persistKey, item.__index, cfg.cookieExpiredays);
                            }

                            if (cfg.body.onclick) {
								var r = ids[ids.length - 3];
								var c = ids[ids.length - 2];

								var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
								var subTree = this.tree;
								axf.each(hashs, function (idx, arg) {
									if (idx == 1) {
										subTree = subTree[this.number()];
									} else if (idx > 1) {
										subTree = subTree[cfg.reserveKeys.subTree][this.number()];
									}
								});

								var sendObj = {
									index: itemIndex,
									r: r,
									c: c,
									list: this.list,
									item: item,
									subTree: subTree,
									page: this.page
								};
								//trace(sendObj);

								cfg.body.onclick.call(sendObj, itemIndex, item);
							}
							//2013-01-23 오후 12:26:52 에디트 이벤트 변경
							//if(this.hasEditor) this.setEditor(item, itemIndex);
						}
					}
				}
			}
		}
	},
	gridBodyDBLClick: function (event) {

		//trace(event.type);

		var cfg = this.config;
		// event target search -
		//if(event.target.id == "") return;
		var eid = event.target.id.split(/_AX_/g);
		var eventTarget = event.target;
		if (eventTarget.tagName.toLowerCase() == "input") return; //input 인 경우 제외
		var myTarget = this.getEventTarget({
			evt: eventTarget, evtIDs: eid,
			until: function (evt, evtIDs) { return (axdom(evt.parentNode).hasClass("gridBodyTr")) ? true : false; },
			find: function (evt, evtIDs) { return (axdom(evt).hasClass("bodyTd")) ? true : false; }
		});
		// event target search ------------------------

		if (myTarget) {
			//colHeadTool ready
			//trace({tagName:myTarget.tagName, id:myTarget.id});
			var targetID = myTarget.id;
			var itemIndex = targetID.split(/_AX_/g).last();
			var ids = targetID.split(/_AX_/g);

			if (this.selectedRow.length > 0) {
				var body = this.body;
				axf.each(this.selectedRow, function () {
					body.find(".gridBodyTr_" + this).removeClass("selected");
				});
			}
			this.selectedRow.clear();
			this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
			this.selectedRow.push(itemIndex);

			if (cfg.body.ondblclick) {
				var r = ids[ids.length - 3];
				var c = ids[ids.length - 2];
				var item = this.list[itemIndex];
				var sendObj = {
					index: itemIndex,
					r: r,
					c: c,
					list: this.list,
					item: item,
					page: this.page
				}
				cfg.body.ondblclick.call(sendObj);
			}
		}

		this.stopEvent(event);
		this.clearRange();
	},
	gridCheckClick: function (event, tgId) {

		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		var _body = this.body;
		var checkboxRelationFixed = cfg.checkboxRelationFixed;
		if (typeof tgId != "undefined") {
			//var target = tgObj;
			var targetID = tgId;
			var checked = _body.find("#" + targetID).get(0).checked;
		} else {
			var targetID = event.target.id;
			var checked = event.target.checked;
		}
		//var target = event.target;
		//var checked = event.target.checked;
		//var targetID = target.id;
		var itemIndex = targetID.split(/_AX_/g).last();
		var ids = targetID.split(/_AX_/g);
		var item = this.list[itemIndex];
		var colSeq = ids[ids.length - 2];

		if (checked) { // 체크박스가 체크 된경우
			// 자식 개체를 찾아 체크 처리 합니다.
			var phash = item[reserveKeys.hashKey];

			var childIndex = [];
			axf.each(this.list, function (lidx, list) {
				if (!this.isRoot) {
					if (this[reserveKeys.hashKey].left(phash.length) == phash && this[reserveKeys.hashKey] != phash) {
						childIndex.push(lidx);
					}
				}
			});
			axf.each(childIndex, function () {
				if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0)) {
					_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0).checked = checked;
				}
			});

			// 해시 변수 준비
			var hashs = phash.split(/_/g);
			hashs.shift();

			// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- s
			var stree = this.tree;
			axf.each(hashs, function (hidx, H) {
				if (hidx == 0) {
					stree = stree[this.number()];
				} else {
					stree = stree[reserveKeys.subTree][this.number()];
				}
			});
			var subTreeChecked = function (T, checked) {
				axf.each(T[cfg.reserveKeys.subTree], function () {
					this.__checked = checked;
					if (this[cfg.reserveKeys.subTree]) subTreeChecked(this, checked);
				});
			};
			stree.__checked = checked;
			subTreeChecked(stree, checked);
			//trace(stree);
			// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- e

			// 부모 트리 찾기 -------------- s
			var ptree = this.tree;
			for (var hidx = 0; hidx < hashs.length - 1; hidx++) {
				if (hidx == 0) {
					ptree = ptree[hashs[hidx].number()];
				} else {
					ptree = ptree[reserveKeys.subTree][hashs[hidx].number()];
				}
			};
			//trace(ptree);

			var parentIsRootTree = false;
			if (this.tree == ptree) {
				parentIsRootTree = true;
			}
			// 부모 트리 찾기 -------------- e

			if (!parentIsRootTree) {
				var childIsAllChecked = true;
				/*
                 axf.each(ptree[reserveKeys.subTree], function(){
                 if(!this.__checked) childIsAllChecked = false;
                 });
                 */
				if (childIsAllChecked) {
					var findhash = ptree[reserveKeys.hashKey];

					var p_tree = this.tree;
					var checkedHashs = [];

					axf.each(hashs, function (hidx, H) {
						if (hidx == 0) {
							p_tree = p_tree[this.number()];
						} else {
							p_tree.__checked = true;
							checkedHashs.push(p_tree[reserveKeys.hashKey]);
							p_tree = p_tree[reserveKeys.subTree][this.number()];
						}
					});

					//ptree.__checked = true;
					//trace(findhash);
					//trace(checkedHashs);
					var _body = this.body;
					axf.each(this.list, function (lidx, list) {
						axf.each(checkedHashs, function () {
							if (list[reserveKeys.hashKey] == this) {
								if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0)) {
									_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0).checked = checked;
								}
							}
						});
					});

					// 부모가 더이상 없을때까지 찾기
				}
			}

			//trace(this.tree);
			this.list = this.convertHashListToTree(this.tree);

		} else { // 체크박스가 체크 해제 된경우

			if (checkboxRelationFixed != null) {
				var phash = item[reserveKeys.hashKey];
				var childIndex = [];
				axf.each(this.list, function (lidx, list) {
					if (!this.isRoot) {
						if (this[reserveKeys.hashKey].left(phash.length) == phash && this[reserveKeys.hashKey] != phash) {
							childIndex.push(lidx);
						}
					}
				});
				axf.each(childIndex, function () {
					if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0)) {
						_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + this).get(0).checked = checked;
					}
				});

				// 해시 변수 준비
				var hashs = phash.split(/_/g);
				hashs.shift();

				// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- s
				var stree = this.tree;
				axf.each(hashs, function (hidx, H) {
					if (hidx == 0) {
						stree = stree[this.number()];
					} else {
						stree = stree[reserveKeys.subTree][this.number()];
					}
				});
				var subTreeChecked = function (T, checked) {
					axf.each(T[cfg.reserveKeys.subTree], function () {
						this.__checked = checked;
						if (this[cfg.reserveKeys.subTree]) subTreeChecked(this, checked);
					});
				};
				stree.__checked = checked;
				subTreeChecked(stree, checked);
				// 자식 트리 개체에 checked 속성을 부여 합니다. -------------- e
			}
			//부모개체의 자식이 모두 제거 되었다면 체크를 해제 합니다.
			if (checkboxRelationFixed) {

				var p_tree = this.tree;
				var checkedHashs = [];
				//trace(hashs);

				for (var l = hashs.length - 1; l > -1; l--) {
					var subTreeStr = "";
					for (var i = 0; i < l + 1; i++) {
						if (i == 0) {
							subTreeStr += "[" + hashs[i].number() + "]";
						} else {
							subTreeStr += "[reserveKeys.subTree][" + hashs[i].number() + "]";
						}
					}
					var myTree;
					eval("myTree = this.tree" + subTreeStr);
					//trace(myTree[cfg.reserveKeys.hashKey]);
					var childIsAllUnChecked = true;
					axf.each(myTree[reserveKeys.subTree], function () {
						if (this.__checked) childIsAllUnChecked = false;
					});
					if (childIsAllUnChecked) {
						myTree.__checked = checked;
						checkedHashs.push(myTree[reserveKeys.hashKey]);
					}
				};

				//ptree.__checked = true;
				//trace(findhash);
				//trace(checkedHashs);
				var _body = this.body;
				axf.each(this.list, function (lidx, list) {
					axf.each(checkedHashs, function () {
						if (list[reserveKeys.hashKey] == this) {
							if (_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0)) {
								_body.find("#" + cfg.targetID + "_AX_checkboxItem_AX_" + colSeq + "_AX_" + lidx).get(0).checked = checked;
							}
						}
					});
				});
			}

			this.list = this.convertHashListToTree(this.tree);
		}

	},
	contentScrollResize: function (resetLeft) {
		var cfg = this.config;

		var bodyHeight = this.body.height();
		var scrollHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();

		var bodyWidth = this.body.width();
		var _colWidth = (this.colWidth.number() + cfg.fitToWidthRightMargin);
		var scrollWidth = (_colWidth > bodyWidth) ? _colWidth : bodyWidth;

		if (cfg.width == "auto") scrollWidth = axdom("#" + cfg.targetID + "_AX_scrollContent").find("table.treeBodyTable").width().number();

		axdom("#" + cfg.targetID + "_AX_scrollContent").css({ width: scrollWidth });
		this.colHead.css({ width: scrollWidth });  // colHead width 재정의

		if (this.hasEditor) this.editor.css({ width: scrollWidth });

		if (resetLeft != false) {
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ left: 0 });
			axdom("#" + cfg.targetID + "_AX_gridColHead").css({ left: 0 });
			axdom("#" + cfg.targetID + "_AX_scrollXHandle").css({ left: 0 });
			if (this.hasEditor) axdom("#" + cfg.targetID + "_AX_editorContent").css({ left: 0 });
		}

		if (bodyHeight < scrollHeight && cfg.height != "auto") {

			if (cfg.width == "auto") {
				//trace(scrollWidth);
				//trace(axdom("#" + cfg.targetID + "_AX_scrollContent").width());
				//scrollWidth += 50;
				axdom("#" + cfg.targetID + "_AX_scrollContent").css({ width: scrollWidth });
				//trace(axdom("#" + cfg.targetID + "_AX_scrollContent").width());
			}

			//axdom("#" + cfg.targetID + "_AX_scrollTrackXY").show();
			axdom("#" + cfg.targetID + "_AX_scrollTrackY").show();

			var scrollTrackYHeight = (cfg.xscroll) ? bodyHeight : bodyHeight;
			axdom("#" + cfg.targetID + "_AX_scrollTrackY").css({ height: scrollTrackYHeight });

			var scrollYHandleHeight = (bodyHeight * scrollTrackYHeight) / scrollHeight;
			axdom("#" + cfg.targetID + "_AX_scrollYHandle").css({ height: scrollYHandleHeight });



		} else {
			//axdom("#" + cfg.targetID + "_AX_scrollTrackXY").hide();
			axdom("#" + cfg.targetID + "_AX_scrollTrackY").hide();
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: 0 });
		}

		if (scrollWidth > bodyWidth && cfg.xscroll) {

			this.show_scrollTrackX = true;

			//axdom("#" + cfg.targetID + "_AX_scrollTrackXY").show();
			axdom("#" + cfg.targetID + "_AX_scrollTrackX").show();

			var scrollTrackXWidth = bodyWidth;
			axdom("#" + cfg.targetID + "_AX_scrollTrackX").css({ width: scrollTrackXWidth });
			var scrollXHandleWidth = ((bodyWidth) * scrollTrackXWidth) / (scrollWidth);

			axdom("#" + cfg.targetID + "_AX_scrollXHandle").css({ width: scrollXHandleWidth });

			// cfg.height == "auto" 길이 늘이기
			if (cfg.height == "auto") {
				var colHeadHeight = this.colHead.outerHeight();
				var scrollBodyHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
				var scrollTrackXHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackX").outerHeight();

				this.scrollBody.css({ height: (scrollBodyHeight + colHeadHeight + scrollTrackXHeight) }); //colhead + body height
				this.body.css({ top: colHeadHeight, height: (scrollBodyHeight + scrollTrackXHeight) }); // body Height
			}
		} else {
			this.show_scrollTrackX = false;
			axdom("#" + cfg.targetID + "_AX_scrollTrackX").hide();
			//axdom("#"+cfg.targetID+"_AX_scrollTrackXY").hide();

			if (cfg.height == "auto") {
				var colHeadHeight = this.colHead.outerHeight();
				var scrollBodyHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();

				this.scrollBody.css({ height: (scrollBodyHeight + colHeadHeight) }); //colhead + body height
				this.body.css({ top: colHeadHeight, height: (scrollBodyHeight) }); // body Height
			}
		}

	},
	contentScrollScrollSync: function (pos) {
		var cfg = this.config;

		if (pos.left != undefined) {
			if (!this.contentScrollXAttr) {
				var scrollWidth = (this.colWidth > this.body.width()) ? this.colWidth : this.body.width();
				this.contentScrollXAttr = {
					bodyWidth: this.body.width(),
					scrollWidth: scrollWidth,
					scrollTrackXWidth: axdom("#" + cfg.targetID + "_AX_scrollTrackX").width(),
					scrollXHandleWidth: axdom("#" + cfg.targetID + "_AX_scrollXHandle").outerHeight()
				};
			}

			//x 변경
			var L = (this.contentScrollXAttr.scrollWidth * (pos.left) / this.contentScrollXAttr.scrollTrackXWidth).round(0);
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ left: -L });
			axdom("#" + cfg.targetID + "_AX_treeColHead").css({ left: -L });
			if (this.hasEditor) axdom("#" + cfg.targetID + "_AX_editorContent").css({ left: -L });
			//trace({top:-L});
		} else {
			if (cfg.height == "auto") return;
			if (!this.contentScrollYAttr) {
				this.contentScrollYAttr = {
					bodyHeight: this.body.height(),
					scrollHeight: axdom("#" + cfg.targetID + "_AX_scrollContent").height(),
					scrollTrackYHeight: axdom("#" + cfg.targetID + "_AX_scrollTrackY").height(),
					scrollYHandleHeight: axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight()
				};
			}

			//y 변경
			var T = (this.contentScrollYAttr.scrollHeight * (pos.top) / this.contentScrollYAttr.scrollTrackYHeight).round(0);
			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: -T });
			if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) axdom("#" + cfg.targetID + "_AX_fixedScrollContent").css({ top: -T });
			if (this.editorOpend) {
				this.editor.css({ top: -T + this.editorOpenTop });
			}
			//trace({top:-T});
		}
	},
	contentScrollContentSync: function (pos) {
		var cfg = this.config;
		if (pos.left != undefined) {

		} else {
			if (cfg.height == "auto") return;
			if (!this.contentScrollYAttr) {
				this.contentScrollYAttr = {
					bodyHeight: this.body.height(),
					scrollHeight: axdom("#" + cfg.targetID + "_AX_scrollContent").height(),
					scrollTrackYHeight: axdom("#" + cfg.targetID + "_AX_scrollTrackY").height(),
					scrollYHandleHeight: axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight()
				};
			}

			//y 변경
			var T = (this.contentScrollYAttr.scrollYHandleHeight * (pos.top) / this.contentScrollYAttr.bodyHeight).round(0);
			var handleTop = -T;
			//trace({h1:(handleTop + this.contentScrollYAttr.handleHeight), trackHeight:this.contentScrollYAttr.trackHeight});
			//if((handleTop + this.contentScrollYAttr.handleHeight) > this.contentScrollYAttr.trackHeight) handleTop = this.contentScrollYAttr.trackHeight - this.contentScrollYAttr.handleHeight;

			axdom("#" + cfg.targetID + "_AX_scrollYHandle").css({ top: handleTop });
			if (axf.getId(cfg.targetID + "_AX_fixedScrollContent")) axdom("#" + cfg.targetID + "_AX_fixedScrollContent").css({ top: pos.top });
			if (this.editorOpend) {
				this.editor.css({ top: pos.top + this.editorOpenTop });
			}

		}
	},
	getMousePositionToContentScroll: function (event, contentScrollID) {
		var pos = axdom("#" + contentScrollID).offset();
		var x = (event.pageX - pos.left);
		var y = (event.pageY - pos.top);
		return { x: x, y: y };
	},
	getTouchPositionToContentScroll: function (event) {
		var cfg = this.config;
		var touch = event.touches[0];
		var pos = this.contentScrollIDOffset;
		if (cfg.touchDirection) {
			var x = (touch.pageX.round(1) - pos.left);
			var y = (touch.pageY.round(1) - pos.top);
		} else {
			var x = (-touch.pageX.round(1) - pos.left);
			var y = (-touch.pageY.round(1) - pos.top);
		}
		return { x: x, y: y };
	},
	contentScrollScrollReady: function (event) {
		var cfg = this.config;
		var handleName = (event.target.id).split(/_AX_/).last();
		//trace(handleName);
		this.contentScrollAttrs = { handleName: handleName };
		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;

		if (handleName == "scrollYHandle") {
			this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackY";
		} else {
			this.contentScrollAttrs.scrollTrack = cfg.targetID + "_AX_scrollTrackX";
		}

		axdom(event.target).addClass("hover");
		var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
		this.contentScrollAttrs.x = axdom(event.target).position().left - pos.x;
		this.contentScrollAttrs.y = axdom(event.target).position().top - pos.y;
		this.contentScrollAttrs.handleWidth = axdom(event.target).outerWidth();
		this.contentScrollAttrs.handleHeight = axdom(event.target).outerHeight();
		this.contentScrollAttrs.trackWidth = axdom("#" + this.contentScrollAttrs.scrollTrack).width();
		this.contentScrollAttrs.trackHeight = axdom("#" + this.contentScrollAttrs.scrollTrack).height();

		/* srcoll event bind */
		var contentScrollScrollMove = this.contentScrollScrollMove.bind(this);
		this.contentScrollScrollMoveBind = function (event) {
			contentScrollScrollMove(event);
		};
		var contentScrollScrollEnd = this.contentScrollScrollEnd.bind(this);
		this.contentScrollScrollEndBind = function (event) {
			contentScrollScrollEnd(event);
		};
		axdom(document.body).bind("mousemove.AXTree", this.contentScrollScrollMoveBind);
		axdom(document.body).bind("mouseup.AXTree", this.contentScrollScrollEndBind);
		axdom(document.body).bind("mouseleave.AXTree", this.contentScrollScrollEndBind);
		axdom("iframe").bind("mouseover.AXTree", this.contentScrollScrollEndBind);

		axdom(document.body).attr("onselectstart", "return false");
		//axdom(document.body).addClass("AXUserSelectNone");
		/* scroll event bind ~~~~~~~~~~~~~~~~~~~ */
	},
	contentScrollScrollMove: function (event) {
		var cfg = this.config;
		try {
			var pos = this.getMousePositionToContentScroll(event, this.contentScrollAttrs.scrollTrack);
			var handleName = this.contentScrollAttrs.handleName;

			var handleTop = 0;
			var handleLeft = 0;
			if (handleName == "scrollYHandle") {
				handleTop = pos.y + this.contentScrollAttrs.y;
				if (handleTop < 0) handleTop = 0;
				if ((handleTop + this.contentScrollAttrs.handleHeight) > this.contentScrollAttrs.trackHeight) handleTop = this.contentScrollAttrs.trackHeight - this.contentScrollAttrs.handleHeight;
				axdom("#" + cfg.targetID + "_AX_" + handleName).css({ top: handleTop });
				this.contentScrollScrollSync({ top: handleTop });
			} else {
				handleLeft = pos.x + this.contentScrollAttrs.x;
				if (handleLeft < 0) handleLeft = 0;
				if ((handleLeft + this.contentScrollAttrs.handleWidth) > this.contentScrollAttrs.trackWidth) handleLeft = this.contentScrollAttrs.trackWidth - this.contentScrollAttrs.handleWidth;
				axdom("#" + cfg.targetID + "_AX_" + handleName).css({ left: handleLeft });
				this.contentScrollScrollSync({ left: handleLeft });
			}
		} catch (e) {
			this.contentScrollScrollEnd(event);
		}
	},
	contentScrollScrollEnd: function (event) {
		var cfg = this.config;
		axdom(document.body).unbind("mousemove.AXTree");
		axdom(document.body).unbind("mouseup.AXTree");
		axdom(document.body).unbind("mouseleave.AXTree");
		axdom("iframe").unbind("mouseover.AXTree");

		axdom(document.body).removeAttr("onselectstart");
		//axdom(document.body).removeClass("AXUserSelectNone");

		axdom("#" + cfg.targetID + "_AX_" + this.contentScrollAttrs.handleName).removeClass("hover");
	},
	contentScrollScrollWheel: function (e) {
		var cfg = this.config;
		if (cfg.height != "auto") {
			var cfg = this.config;

			var event = window.event || e;
			var delta = event.detail ? event.detail * (-20) : event.wheelDelta / 2 //check for detail first so Opera uses that instead of wheelDelta

			var scrollTop = axdom("#" + cfg.targetID + "_AX_scrollContent").position().top;
			var scrollHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
			var bodyHeight = this.body.height();
			//var handleTop = axdom("#"+cfg.targetID+"_AX_scrollYHandle").position().top; i want this value
			var handleHeight = axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight();
			var trackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackY").height();

			if (scrollHeight < bodyHeight) {
				return;
			}

			//trace({scrollTop:scrollTop, bodyHeight:bodyHeight, scrollHeight:scrollHeight});
			var eventCancle = false;
			scrollTop += delta;

			if (scrollTop > 0) {
				scrollTop = 0;
				eventCancle = true;
			} else if (scrollTop.abs() + bodyHeight > scrollHeight) {
				scrollTop = bodyHeight - scrollHeight;
				eventCancle = true;
			} else if (scrollTop == 0) {
				scrollTop = 0;
				eventCancle = true;
			}

			axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: scrollTop });
			this.contentScrollContentSync({ top: scrollTop });

			if (!eventCancle) {
				if (event.preventDefault) event.preventDefault();
				if (event.stopPropagation) event.stopPropagation();
				event.cancelBubble = true;
				return false;
			}
		}
	},
	contentScrollTouchstart: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		this.contentScrollTouchMoved = true;
		this.contentScrollIDOffset = axdom("#" + cfg.targetID + "_AX_gridBody").offset();
		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;

		var pos = this.getTouchPositionToContentScroll(event);

		var YhandleTop = axdom("#" + cfg.targetID + "_AX_scrollYHandle").position().top;
		var YhandleHeight = axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight();
		var YtrackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackY").height();

		axdom("#" + cfg.targetID + "_AX_scrollYHandle").addClass("hover");

		var XhandleTop = axdom("#" + cfg.targetID + "_AX_scrollXHandle").position().left;
		var XhandleHeight = axdom("#" + cfg.targetID + "_AX_scrollXHandle").outerWidth();
		var XtrackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackX").width();

		axdom("#" + cfg.targetID + "_AX_scrollXHandle").addClass("hover");

		this.scrollTouchAttr = {
			y: (YhandleTop - pos.y).number(), h: YhandleHeight.number(), th: YtrackHeight,
			x: (XhandleTop - pos.x).number(), w: XhandleHeight.number(), tw: XtrackHeight
		};

		var contentScrollTouchEnd = this.contentScrollTouchEnd.bind(this);
		this.contentScrollTouchEndBind = function () {
			contentScrollTouchEnd(event);
		};

		var contentScrollTouchMove = this.contentScrollTouchMove.bind(this);
		this.contentScrollTouchMoveBind = function () {
			contentScrollTouchMove(event);
		};

		if (document.addEventListener) {
			document.addEventListener("touchend", this.contentScrollTouchEndBind, false);
			document.addEventListener("touchmove", this.contentScrollTouchMoveBind, false);
		}
	},
	contentScrollTouchMove: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		if (this.contentScrollTouchMoved) {
			var pos = this.getTouchPositionToContentScroll(event);
			var scrollTouchAttr = this.scrollTouchAttr;

			var htop = axdom("#" + cfg.targetID + "_AX_scrollYHandle").position().top;
			var handleTop = pos.y + scrollTouchAttr.y;
			if (handleTop < 0) handleTop = 0;
			if ((handleTop + scrollTouchAttr.h) > scrollTouchAttr.th) handleTop = scrollTouchAttr.th - scrollTouchAttr.h;

			if ((htop - handleTop).abs() > 2) {
				axdom("#" + cfg.targetID + "_AX_scrollYHandle").css({ top: handleTop });
				this.contentScrollScrollSync({ top: handleTop });
			}

			if (this.show_scrollTrackX) {
				var hleft = axdom("#" + cfg.targetID + "_AX_scrollXHandle").position().left;
				var handleLeft = pos.x + this.scrollTouchAttr.x;
				if (handleLeft < 0) handleLeft = 0;
				if ((handleLeft + scrollTouchAttr.w) > scrollTouchAttr.tw) handleLeft = scrollTouchAttr.tw - scrollTouchAttr.w;

				if ((hleft - handleLeft).abs() > 2) {
					axdom("#" + cfg.targetID + "_AX_scrollXHandle").css({ left: handleLeft });
					this.contentScrollScrollSync({ left: handleLeft });
				}
			}

			if (event.preventDefault) event.preventDefault();
			else return false;
		}
	},
	contentScrollTouchEnd: function (e) {
		var cfg = this.config;
		var event = window.event || e;
		if (this.contentScrollTouchMoved) {

			axdom("#" + cfg.targetID + "_AX_scrollXHandle").removeClass("hover");
			axdom("#" + cfg.targetID + "_AX_scrollYHandle").removeClass("hover");

			if (document.removeEventListener) {
				document.removeEventListener("touchend", this.contentScrollTouchEndBind, false);
				document.removeEventListener("touchmove", this.contentScrollTouchMoveBind, false);
			}
			this.contentScrollTouchMoved = false;
		}
	},
	/**
	 * @method AXTree.clearFocus
	 * @description
	 * 선택된 상태를 해제합니다.
	 * @example
	 ```
	 myTree.clearFocus();
	 ```
	 */
	clearFocus: function () {
		var cfg = this.config;

		if (this.selectedCells.length > 0) {
			axf.each(this.selectedCells, function () {
				axdom("#" + this).removeClass("selected");
			});
			this.selectedCells.clear();
		}
		if (this.selectedRow.length > 0) {
			var body = this.body;
			axf.each(this.selectedRow, function () {
				body.find(".gridBodyTr_" + this).removeClass("selected");
			});
		}

		this.selectedRow.clear();
	},

	/**
	 * @method AXTree.setFocus
	 * @param {Number} itemIndex
	 * @description
	 * index 위치로 트리바디의 포커스를 이동하고 선택된 상태로 변경합니다.
	 * @example
	 * ```js
	 * myTree.setFocus(3);
	 * ```
	 */
	setFocus: function (itemIndex) {
		var cfg = this.config;

		if(itemIndex < 0 || itemIndex > this.list.length-1){
			return false;
		}
		if(!this.body.find(".gridBodyTr_" + itemIndex).get(0)) return;

		if (this.selectedCells.length > 0) {
			axf.each(this.selectedCells, function () {
				axdom("#" + this).removeClass("selected");
			});
			this.selectedCells.clear();
		}
		if (this.selectedRow.length > 0) {
			var body = this.body;
			axf.each(this.selectedRow, function () {
				body.find(".gridBodyTr_" + this).removeClass("selected");
			});
		}

		this.selectedRow.clear();

		this.body.find(".gridBodyTr_" + itemIndex).addClass("selected");
		this.selectedRow.push(itemIndex);

		if(cfg.height != "auto"){

			var trTop = this.body.find(".gridBodyTr_" + itemIndex).position().top;
			var trHeight = this.body.find(".gridBodyTr_" + itemIndex).height();

			var scrollHeight = axdom("#" + cfg.targetID + "_AX_scrollContent").height();
			var bodyHeight = this.body.height();
			var handleHeight = axdom("#" + cfg.targetID + "_AX_scrollYHandle").outerHeight();
			var trackHeight = axdom("#" + cfg.targetID + "_AX_scrollTrackY").height();

			if (trTop.number() + trHeight.number() > bodyHeight) {
				var scrollTop = bodyHeight - (trTop.number() + trHeight.number());
				axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: scrollTop });
				this.contentScrollContentSync({ top: scrollTop });
			} else {
				if (trTop.number() == 0) {
					var scrollTop = 0;
					axdom("#" + cfg.targetID + "_AX_scrollContent").css({ top: scrollTop });
					this.contentScrollContentSync({ top: scrollTop });
				}
			}
		}
	},
	/**
	 * @method AXTree.click
	 * @param {Number} itemIndex - index of Array
	 * @param {String} open||expand - "open"이면 아이템개체 확장 후 선택, "expand"이면 아이템개체 확장만
	 * @param {Boolean} [doNotCallBack] - 아이템 개체 확장 처리후 클릭이벤트 발생 방지
	 * @returns {JSObject} - {"focusedID": ID } 대상아이디가 오브젝트로 옵니다.
	 * @description
	 * 아이템인덱스의 아이템 선택, 확장, 클릭이벤트 발생 처리를 합니다.
	 * @example
	 * ```js
	 * var findIndex = null;
	 * $.each(List, function(jindex, J){
	 *    if(this.id == "findid"){
	 *        findIndex = jindex;
	 *        return false;
	 *    }
	 * });
	 *	 if(findIndex != null){
	 *    var focusItem = myTree.click(findIndex, "open", true); // 아이템 확장처리만 원함.
	 * }
	 * ```
	 */
	click: function (itemIndex, open, doNotCallBack) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;

		var item = this.list[itemIndex];

		if(!item){
			return {focusedID:undefined};
		}

		var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
		var subTree = this.tree;

		var opendPath = [];
		axf.each(hashs, function (idx, arg) {
			if (idx == 1) {
				subTree = subTree[this.number()];
				opendPath.push(subTree[reserveKeys.hashKey]);
			} else if (idx > 1) {
				subTree = subTree[cfg.reserveKeys.subTree][this.number()];
				opendPath.push(subTree[reserveKeys.hashKey]);
			}
		});
        if (open !== "expand") {
            opendPath.pop();
        }

		if (cfg.body.onclick && !doNotCallBack) {
			var sendObj = {
				index: itemIndex,
				list: this.list,
				item: item,
				subTree: subTree,
				page: this.page
			};
			cfg.body.onclick.call(sendObj, itemIndex, item);
		}

		if(open == "open" || open == "expand"){
			var expandList = [];
			axf.each(this.list, function(lidx, L){
				axf.each(opendPath, function(pidx, P){
					if(L[reserveKeys.hashKey] == P){
						if(!L[reserveKeys.openKey]){
							expandList.push(lidx);
						}
					}
				});
			});
			//trace(expandList);
			for(var i=0;i<expandList.length;i++){
				this.expandToggleList(expandList[i], this.list[expandList[i]]);
			}
		}

        if (open !== "expand") {
            this.setFocus(itemIndex);
        }

        if (cfg.persistSelected && open !== "expand") { // printList에서 click 메서드를 호출시 "expand"를 사용한다.
            var persistKey = cfg.cookiePrefix + cfg.targetID + "-selected-index";
            axf.setCookie(persistKey, itemIndex, cfg.cookieExpiredays);
        }

		return {focusedID:this.body.find(".gridBodyTr_" + itemIndex).attr("id")};

		/*
         if (event.preventDefault) event.preventDefault();
         if (event.stopPropagation) event.stopPropagation();
         event.cancelBubble = true;
         return false;
         */
	},
	/* body 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ head & foot 영역  */
	getDataSetFormatterValue: function (formatter, dataSet, value, key, CH) {
		var cfg = this.config;
		var result;
		if (formatter == "money") {
			if (value == "" || value == "null" || value == undefined) {
				result = "";
			} else {
				result = value.number().money();
			}
		} else if (formatter == "dec") {
			result = (value == undefined) ? "" : value.dec();
		} else if (formatter == "html") {
			result = value;
		} else if (formatter == "checkbox") {
			result = value;
		} else {
			var sendObj = {
				index: null,
				list: this.list,
				item: dataSet,
				dataSet: dataSet,
				page: this.page
			};
			result = formatter.call(sendObj);
		}
		return result;
	},
	getHeadDataSet: function (dataSet, isfix) {
		var cfg = this.config;
		var tpo = [];
		var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
		//dataSet 빈 Key 채우기
		axf.each(cfg.colGroup, function () {
			if (dataSet[this.key] == undefined) dataSet[this.key] = "";
		});
		//dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~
		var hasFixed = this.hasFixed;

		for (var r = 0; r < cfg.head.rows.length; r++) {
			var isLastTR = (cfg.head.rows.length - 1 == r);
			tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_head_" + r + "_AX_" + (isfix || "n") + "\">");
			var colCount = 0;

			axf.each(cfg.head.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

						//trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "head_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_headText_AX_" + r + "_AX_" + CHidx + "\">");
						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
							} else {
								tpo.push(dataSet[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}
						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == undefined) {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_headnull\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
			}
			tpo.push("</tr>");
		}
		return tpo.join('');
	},
	getFootDataSet: function (dataSet, isfix) {
		var cfg = this.config;
		var tpo = [];
		var getDataSetFormatterValue = this.getDataSetFormatterValue.bind(this);
		//dataSet 빈 Key 채우기
		axf.each(cfg.colGroup, function () {
			if (dataSet[this.key] == undefined) dataSet[this.key] = "";
		});
		//dataSet 빈 Key 채우기 ~~~~~~~~~~~~~~~~
		var hasFixed = this.hasFixed;

		for (var r = 0; r < cfg.foot.rows.length; r++) {
			var isLastTR = (cfg.foot.rows.length - 1 == r);
			tpo.push("<tr class=\"gridBodyTr gridBodyTr_foot\" id=\"" + cfg.targetID + "_AX_foot_" + r + "_AX_" + (isfix || "n") + "\">");
			var colCount = 0;

			axf.each(cfg.foot.rows[r], function (CHidx, CH) {
				if (CH.display && CH.colspan > 0) {

					if (isfix == undefined || (isfix != undefined && colCount < (cfg.fixedColSeq + 1))) {

						colCount += CH.colspan;

						//radio, check exception
						var rowspan = (CH.rowspan > 1) ? " rowspan=\"" + CH.rowspan + "\"" : "";
						var colspan = (CH.colspan > 1) ? " colspan=\"" + CH.colspan + "\"" : "";
						var valign = " valign=\"" + CH.valign + "\" style=\"vertical-align:" + CH.valign + ";\"";
						var bottomClass = (CH.isLastCell) ? "" : " bodyBottomBorder";
						var fixedClass = (CH.isFixedEndCell) ? " fixedLine" : "";

						//trace({r:r, CHidx:CHifixedColSeq:cfg.fixedColSeq, colCount:colCount});

						var bodyNodeClass = "";
						if (CH.formatter == "checkbox") bodyNodeClass = " bodyTdCheckBox";
						else if (CH.formatter == "html") bodyNodeClass = " bodyTdHtml";

						tpo.push("<td" + valign + rowspan + colspan + " id=\"" + cfg.targetID + "_AX_" + (isfix || "n") + "foot_AX_" + r + "_AX_" + CHidx + "\" class=\"bodyTd" + bottomClass + fixedClass + "\">");
						tpo.push("<div class=\"tdRelBlock\">");
						tpo.push("<div class=\"bodyNode bodyTdText" + bodyNodeClass + "\" align=\"" + CH.align + "\" id=\"" + cfg.targetID + "_AX_footText_AX_" + r + "_AX_" + CHidx + "\">");
						if ((hasFixed && !CH.isFixedCell) || !hasFixed || isfix != undefined) {
							if (CH.formatter) {
								tpo.push(getDataSetFormatterValue(CH.formatter, dataSet, dataSet[CH.key], CH.key, CH));
							} else {
								tpo.push(dataSet[CH.key]);
							}
						} else {
							tpo.push("&nbsp;");
						}
						tpo.push("</div>");
						tpo.push("</div>");
						tpo.push("</td>");
					}
				}
			});
			if (r == 0 && isfix == undefined) {
				tpo.push("<td class=\"bodyNullTd\" id=\"" + cfg.targetID + "_AX_footnull\" rowspan=\"" + cfg.body.rows.length + "\"><div class=\"tdRelBlock\">&nbsp;</div></td>");
			}
			tpo.push("</tr>");
		}
		return tpo.join('');
	},
	setDataSet: function (obj) {
		var cfg = this.config;
		if (obj.ajaxUrl) {

		} else {
			if (axdom.isPlainObject(obj)) {
				this.dataSet = obj;
				if (cfg.head) this.printHead();
				if (cfg.foot) this.printFoot();
				this.contentScrollResize(false);
			}
		}
	},
	redrawDataSet: function () {
		var cfg = this.config;
		if (this.dataSet) {
			if (cfg.head) this.printHead();
			if (cfg.foot) this.printFoot();
		}
	},
	printHead: function () {
		var cfg = this.config;
		var getDataSet = this.getHeadDataSet.bind(this);
		var po = [];
		po.push(getDataSet(this.dataSet));
		axdom("#" + cfg.targetID + "_AX_thead").html(po.join(''));
		if (this.hasFixed) {
			po = [];
			po.push(getDataSet(this.dataSet, "fix"));
			axdom("#" + cfg.targetID + "_AX_fixedThead").html(po.join(''));
		}
	},
	printFoot: function () {
		var cfg = this.config;
		var getDataSet = this.getFootDataSet.bind(this);
		var po = [];
		po.push(getDataSet(this.dataSet));
		axdom("#" + cfg.targetID + "_AX_tfoot").html(po.join(''));
		if (this.hasFixed) {
			po = [];
			po.push(getDataSet(this.dataSet, "fix"));
			axdom("#" + cfg.targetID + "_AX_fixedTfoot").html(po.join(''));
		}
	},
	/* head & foot 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ editor 영역  */

	/* editor 영역 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	/* tree 추가 메서드  */
	/**
	 * @method AXTree.setTree
	 * @param {Array | Object} obj - example code 참고
	 * @description
	 * 트리에 데이터를 전달합니다. 비동기 방식의 경우 직접데이터를 전달하지 않고 데이터의 전달자 정보를 정의하여 처리합니다.
	 * @example
     * ```js
     * //Array - JSObject(tree형)
     * var Tree = [
     *	 {no:"1", type:"WBS", activity:"WBS 이름", desc:"", charger:"", admin:"", docs:"", open:true, subTree:[
     *	    {no:"1.1", type:"phase", activity:"기획 및 설계", desc:"M", charger:"최인석", admin:"", docs:"", open:true, subTree:[
     *		    {no:"1.1.1", type:"process", activity:"기획단계", desc:"M", charger:"최인석", admin:"", docs:"", open:true, subTree:[
     *			    {no:"1.1.1.1", type:"activity", activity:"요구사항정의", desc:"M", charger:"최인석/PM", admin:"홍길동", docs:"[필수]요구사항정의서", open:false, subTree:[]},
     *                {no:"1.1.1.2", type:"activity", activity:"업무분할", desc:"M", charger:"한승욱/기획", admin:"", docs:"[권고]요구사항정의서", open:false, subTree:[]}
     *            ]}
     *        ]}
     *    ]},
     *	 {no:"9", type:"WBS", activity:"WBS 이름", desc:"", charger:"", admin:"", docs:"", open:true, subTree:[]}
     *	 ];
     *	 myTree.setTree(Tree);
     *
     *	 var AJAXconfigs = {
     *    ajaxUrl:"loadTree.php", //{String} - AJAX 호출 URL
     *    ajaxPars:"param1=1&param2=2",   //{String} - AJAX 호출 URL 파라미터 (전송은 post 방식으로 이루어집니다.)
     *    onLoad: function(){ //[Function] - AJAX 호출완료 이벤트 콜백함수
     *        ...
     *    }
     *};
     * myTree.setTree(AJAXconfigs);
     * ```
	 */
	setTree: function (obj, sortDisable) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;
		this.listLoadingDisplay();

		if (obj.ajaxUrl) {
			this.ajaxInfo = obj;
			this.ajax_sortDisable = sortDisable;
			this.pageActive = true;

			var url = obj.ajaxUrl;
			/*
             var appendPars = [
             "pageNo="+this.page.pageNo,
             "pageSize="+this.page.pageSize
             ];
             var pars = (obj.ajaxPars) ? obj.ajaxPars + "&" +  appendPars.join('&') : appendPars.join('&') ;
             */
			var pars = (obj.ajaxPars) ? obj.ajaxPars : "";

			var ajaxGetTree = this.ajaxGetTree.bind(this);
			new AXReq(url, {
				debug: false, pars: pars, onsucc: function (res) {
					if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {
						res._sortDisable = sortDisable;
						if (obj.response) {
							obj.response.call(res);
						} else {
							ajaxGetTree(res);
						}
						if (obj.onLoad) obj.onLoad.call(res);
					} else {
						//AXUtil.alert(res);
						AXUtil.alert(res.msg);
					}
				}
			});
		} else {
			this.ajaxInfo = null;
			if (axdom.isArray(obj)) {
				this.tree = obj;
				this.list = this.convertHashListToTree(obj);
				//trace(this.list);
				this.setList(this.list, false);
			}
		}

	},
	ajaxGetTree: function (res) {
		var cfg = this.config;
		var nowSortHeadID = this.nowSortHeadID;
		var nowSortHeadObj = this.nowSortHeadObj;
		this.tree = res[AXConfig.AXTree.keyTree];

		this.list = this.convertHashListToTree(res[AXConfig.AXTree.keyTree]);
		if (res._sortDisable || !cfg.sort) {

		} else {
			if (nowSortHeadID) {
				this.list = this.sortList(nowSortHeadObj.sort, nowSortHeadObj, this.list);
			}
		}
		//AXUtil.overwriteObject(this.page, res.page, true);
		this.setList(this.list, false);
		//this.setPaging(); tree 에선 페이징 보류
	},
	setLoading: function (itemIndex, item) {
		var cfg = this.config;
		for (var r = 0; r < cfg.body.rows.length; r++) {
			axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").addClass("loading");
		}
	},
	endLoading: function (itemIndex, item) {
		var cfg = this.config;
		for (var r = 0; r < cfg.body.rows.length; r++) {
			axdom("#" + cfg.targetID + "_AX_tr_" + r + "_AX_n_AX_" + itemIndex).find(".bodyNodeIndent").removeClass("loading");
		}
	},
	/**
	 * @method AXTree.appendTree
	 * @param {Number} itemIndex - 부모아이템 인덱스
	 * @param {JSObject} item - 부모아이템
	 * @param {JSObject} subTree - 추가하려는 아이템
	 * @description
	 * 원하는 아이템 하위에 아이템을 추가합니다.
	 * @example
	 * ```js
	 * // 선택아이템의 자식 추가하기
	 * var obj = myTree.getSelectedList();
	 * myTree.appendTree(obj.index, obj.item, [{nodeID:"N", nodenm:frm.nodeName.value, writer:"mondo", type:"file", parentcd:obj.item.nodeID}]);
     *
	 * // 선택아이템의 형제 추가하기
	 * var obj = myTree.getSelectedListParent();
	 * myTree.appendTree(obj.index, obj.item, [{nodeID:"N", nodenm:frm.nodeName.value, writer:"mondo", type:"file", parentcd:(obj.item.nodeID|0)}]);
	 * ```
	 */

	appendTree: function (itemIndex, item, subTree) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;

		//trace({itemIndex:itemIndex, item:item, subTree:subTree});

		if (itemIndex == null || itemIndex == undefined || item == null || item == undefined) {

			var tree = this.tree;
			axf.each(subTree, function () {
				this[cfg.reserveKeys.subTree] = [];
				this._CUD = "C";
				tree.push(this);
			});

			var pushedList = this.appendSubTree("0".setDigit(cfg.hashDigit), true, subTree, this.tree);
			this.printList();

		} else { // 부모 하위 개체로 추가할 때에.

			axf.each(subTree, function () {
				if (!this[cfg.reserveKeys.subTree]) this[cfg.reserveKeys.subTree] = [];
			});
			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

			var tree = this.tree; // 추가될 트리 구하기
			axf.each(hashs, function (idx, T) {
				if (idx > 0) {
					if (idx == 1) tree = tree[T.number()];
					else tree = tree[cfg.reserveKeys.subTree][T.number()];
				}
			});

			//tree[cfg.reserveKeys.subTree] =
			//tree[reserveKeys.openKey] = true;
			axf.each(subTree, function () {
				this._CUD = "C";
				tree[reserveKeys.subTree].push(this);
			});

			this.list = this.convertHashListToTree(this.tree);
			this.printList();
		}

		this.contentScrollXAttr = null;
		this.contentScrollYAttr = null;
		/* */
	},
	appendSubTree: function (parentHash, parentOpened, arr, parentArr) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var appendSubTree = this.appendSubTree.bind(this);
		var appendSubTree_pushList = this.appendSubTree_pushList.bind(this);

		var returnList = [];
		var appendIndex = this.list.length;
		var parentSubTreeLength = 0;
		if (parentHash != "0".setDigit(cfg.hashDigit)) parentSubTreeLength = parentArr[reserveKeys.subTree].length;
		else parentSubTreeLength = parentArr.length;

		axf.each(arr, function (idx, A) {
			var pushItem = {};
			var hasOpenKey = false, hasSubTree = false;
			axf.each(A, function (k, v) {
				if (k == reserveKeys.openKey) {
					hasOpenKey = true;
					pushItem[k] = v;
				} else if (k == reserveKeys.subTree) {
					if(v.length > 0){
						hasSubTree = true;
						pushItem.__subTreeLength = v.length;
					}
				} else if (k == "__subTree") {
					hasSubTree = v;
					pushItem.__subTreeLength = v ? 1 : 0;
				} else {
					pushItem[k] = v;
				}
			});

			pushItem[reserveKeys.parentHashKey] = parentHash;
			pushItem[reserveKeys.hashKey] = parentHash + cfg.hashSpliter + (idx + parentSubTreeLength - 1).setDigit(cfg.hashDigit);
			if (!hasOpenKey) pushItem[reserveKeys.openKey] = true;

			//trace(pushItem[reserveKeys.openKey]);

			if (!hasSubTree) pushItem.__subTreeLength = 0;
			if (!pushItem[reserveKeys.subTree]) pushItem[reserveKeys.subTree] = [];
			pushItem[reserveKeys.displayKey] = parentOpened;
			if (pushItem[reserveKeys.openKey] && !parentOpened) pushItem[reserveKeys.openKey] = false; //부보가 닫힌 개체 이면 자식 개체도 닫힘

			//trace(pushItem);


			appendSubTree_pushList(pushItem);
			returnList.push({ itemIndex: appendIndex, item: pushItem });
			appendIndex++;

			if (!A[reserveKeys.subTree]) A[reserveKeys.subTree] = [];

			if (hasSubTree && A[reserveKeys.subTree].length > 0) {
				appendSubTree(pushItem[reserveKeys.hashKey], pushItem[reserveKeys.openKey], A[reserveKeys.subTree]);
			}
		});
		return returnList;
	},
	appendSubTree_pushList: function (item) {
		this.list.push(item);
	},
	fetchTree: function(subTree, parentItem){
		// TODO : fetchTree 속도 개선을 위해 추가된 아이템만 추가 하도록 함수 변경 필요
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var tree = this.tree;

		if(parentItem){

			var hashs = parentItem[cfg.reserveKeys.hashKey].split(/_/g);
			axf.each(hashs, function (idx, T) {
				if (idx > 0) {
					if (idx == 1) tree = tree[T.number()];
					else tree = tree[cfg.reserveKeys.subTree][T.number()];
				}
			});
			axf.each(subTree, function () {
				this[cfg.reserveKeys.subTree] = [];
				tree[reserveKeys.subTree].push(this);
			});

			this.list = this.convertHashListToTree(this.tree);
		}else{
			axf.each(subTree, function () {
				this[cfg.reserveKeys.subTree] = [];
				tree.push(this);
			});

			var pushedList = this.appendSubTree("0".setDigit(cfg.hashDigit), true, subTree, this.tree);
		}

		this.printList();
	},
	/**
	 * @method AXTree.updateTree
	 * @param {Number} itemIndex - 아이템 인덱스
	 * @param {JSObject} item - 아이템
	 * @param {JSObject} obj - 수정하려는 아이템 내용
	 * @description
	 * 원하는 아이템의 데이터를 수정합니다.
	 * @example
	 * ```js
	 * var obj = myTree.getSelectedList();
	 * myTree.updateTree(obj.index, obj.item, {nodenm:frm.nodeName.value});
	 * // 수정하려는 아이템의 일부 키만 전달 해도 수정이 가능합니다.
	 * ```
	 */
	updateTree: function (itemIndex, item, obj) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		AXUtil.overwriteObject(item, obj);

		if(item._CUD != "C") item._CUD = "U";

		//item[cfg.reserveKeys.subTree] = this.list[itemIndex][cfg.reserveKeys.subTree];
		this.list[itemIndex] = item;

		this.updateList(itemIndex, item);

		for(var idx=0;idx<this.list.length;idx++){
			this.list[idx][reserveKeys.parentHashKey] = undefined;
			this.list[idx][reserveKeys.hashKey] = undefined;
		}

		this.positioningHashList(this.list);
	},
	/**
	 * @method AXTree.removeTree
	 * @param {Number|null} itemIndex - 아이템 index, index는 항목은 null 로 정의해도 처리가 가능합니다.
	 * @param {JSObject} item - 아이템
	 * @description
	 * 원하는 아이템의 데이터를 수정합니다.
	 * @example
     * ```
     * var obj = myTree.getSelectedList();
     * if(obj.error){
     *     alert("개체를 선택해 주세요");
     *     return;
     * }
     * myTree.removeTree(obj.index, obj.item);
     * ```
	 */
	removeTree: function (itemIndex, item) {
		var cfg = this.config, _this = this;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		// this.list 와 this.tree 에서 해당 개체를 찾아 제거 한다.
		// tree 찾기
		var hashs = item[reserveKeys.hashKey].split(/_/g);
		var phash = item[reserveKeys.parentHashKey];
		var tree = this.tree;
		var ptree = this.tree;
		for (var idx = 1; idx < hashs.length; idx++) {
			var H = hashs[idx];
			if (idx == 1) tree = tree[H.number()];
			else tree = tree[cfg.reserveKeys.subTree][H.number()];
			if (idx == hashs.length - 2) {
				//부모 트리인 경우
				ptree = tree;
			}
		}

		tree._isDel = true;

		if(tree._CUD == "C"){
			tree._CUD = "";
		}else{
			tree._CUD = "D";
		}

		var applyDel = function (subTree) {
			for (var ti = 0; ti < subTree.length; ti++) {
				subTree[ti]._isDel = true;

				if(subTree[ti]._CUD == "C"){
					subTree[ti]._CUD = "";
				}else{
					subTree[ti]._CUD = "D";
				}

				if (subTree[ti][cfg.reserveKeys.subTree]) {
					applyDel(subTree[ti][cfg.reserveKeys.subTree]);
				}
			}
		};
		applyDel(tree[cfg.reserveKeys.subTree]);

		var __subTreeLength = 0;
		if (ptree[cfg.reserveKeys.subTree]) {
			axf.each(ptree[cfg.reserveKeys.subTree], function () {
				if (!this._isDel) __subTreeLength++;
			});
		}

		// 삭제할 item 에 종속된 itemIndex 구한다.
		var pItem = null;

		axf.each(this.list, function (idx, L) {

			if (L[reserveKeys.hashKey].left(item[reserveKeys.hashKey].length) == item[reserveKeys.hashKey]) {
				L._isDel = true;
				if(L._CUD == "C"){
					L._CUD = "";
				}else{
					L._CUD = "D";
				}
				_this.target.find(".gridBodyTr_" + idx).remove();
			}
			if (phash == L[reserveKeys.hashKey]) {
				pItem = { itemIndex: idx, item: L };
			}
		});

		//부모 ITEM 의 __subTreeLength 속성 변경하기
		if (pItem) {
			this.list[pItem.itemIndex].__subTreeLength = __subTreeLength;
			// appendList 구문 생성
			/*
             if (__subTreeLength == 0) {
             var lastR = cfg.body.rows.length - 1;
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_n_AX_" + pItem.itemIndex).find(".bodyNodeIndent").hide();
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_f_AX_" + pItem.itemIndex).find(".bodyNodeIndent").hide();
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_n_AX_" + pItem.itemIndex).find(".bodyNodeIndent").removeClass("expand");
             axdom("#" + cfg.targetID + "_AX_tr_" + lastR + "_AX_f_AX_" + pItem.itemIndex).find(".bodyNodeIndent").removeClass("expand");
             }
             */

			// 부모 ITEM 의 update
			var getItem = this.getItem.bind(this);
			var npo = "", lastR = cfg.body.rows.length - 1;
			npo = getItem(pItem.itemIndex, this.list[pItem.itemIndex], "n", "notr");
			_this.target.find(".gridBodyTr_" + pItem.itemIndex).html(npo);
		}

		if (this.selectedRow.length > 0) {
			var body = this.body;
			axf.each(this.selectedRow, function () {
				body.find(".gridBodyTr_" + this).removeClass("selected");
			});
			this.selectedRow.clear();
			AXContextMenu.close({ id: cfg.targetID + "ContextMenu" }); // event 직접 연결 방식
		}
	},
	moveUpTree: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		var selectedObject = this.getSelectedList();

		if (selectedObject.error) {
			toast.push(selectedObject.description);
			return;
		}

		var itemIndex = selectedObject.index;
		var item = this.list[selectedObject.index];

		var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);
		var myTree = this.tree;
		var nowChildIndex, changeChildIndex;
		var parentHashs = [];

		for (var hidx = 1; hidx < hashs.length - 1; hidx++) {
			if (hidx == 1) {
				myTree = myTree[hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			} else {
				myTree = myTree[cfg.reserveKeys.subTree][hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			}
			nowChildIndex = hashs[hidx + 1].number();
		}

		var isRootControl = false;
		if (myTree == this.tree) {
			isRootControl = true;
			nowChildIndex = hashs.last().number();
		}

		if (nowChildIndex < 1) {
			//이동불가
			toast.push("순서의 처음입니다.");
		} else {
			changeChildIndex = nowChildIndex - 1;

			try {
				if (isRootControl) {
					while (myTree[changeChildIndex]._isDel) {
						changeChildIndex--;
						if (changeChildIndex == 0) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[nowChildIndex]);

					myTree[nowChildIndex] = AXUtil.copyObject(myTree[changeChildIndex]);
					myTree[changeChildIndex] = tempObj;
					if(typeof myTree[nowChildIndex]._CUD == "undefined") myTree[nowChildIndex]._CUD = "U";
					if(typeof myTree[changeChildIndex]._CUD == "undefined") myTree[changeChildIndex]._CUD = "U";
				} else {
					while (myTree[cfg.reserveKeys.subTree][changeChildIndex]._isDel) {
						changeChildIndex--;
						if (changeChildIndex == 0) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + parentHashs.join("_") + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][nowChildIndex]);
					myTree[cfg.reserveKeys.subTree][nowChildIndex] = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][changeChildIndex]);
					myTree[cfg.reserveKeys.subTree][changeChildIndex] = tempObj;
					if(typeof myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD = "U";
					if(typeof myTree[cfg.reserveKeys.subTree][changeChildIndex]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][changeChildIndex]._CUD = "U";
				}
			} catch (e) {
				trace(e);
			}

			this.selectedCells.clear();
			this.selectedRow.clear();

			this.list = this.convertHashListToTree(this.tree);
			this.printList();

			var newSelecteIndex;
			for (var idx = 0; idx < this.list.length; idx++) {
				if (this.list[idx][reserveKeys.hashKey] == newSelectedHash) {
					newSelecteIndex = idx;
					this.body.find(".gridBodyTr_" + newSelecteIndex).addClass("selected");
					this.selectedRow.push(newSelecteIndex);
					break;
				}
			}

		}
	},
	moveDownTree: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		var selectedObject = this.getSelectedList();

		if (selectedObject.error) {
			toast.push(selectedObject.description);
			return;
		}

		var itemIndex = selectedObject.index;
		var item = this.list[selectedObject.index];
		var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

		var myTree = this.tree;
		var nowChildIndex, changeChildIndex;
		var parentHashs = [];
		for (var hidx = 1; hidx < hashs.length - 1; hidx++) {
			if (hidx == 1) {
				myTree = myTree[hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			} else {
				myTree = myTree[cfg.reserveKeys.subTree][hashs[hidx].number()];
				parentHashs.push(hashs[hidx]);
			}
			nowChildIndex = hashs[hidx + 1].number();
			//trace(myTree);
		}

		var isRootControl = false;
		var subTreeLength;
		if (myTree == this.tree) {
			isRootControl = true;
			//parentHashs.push(hashs.last();
			nowChildIndex = hashs.last().number();
			subTreeLength = myTree.length;
		} else {
			subTreeLength = myTree[cfg.reserveKeys.subTree].length;
		}

		if (nowChildIndex > subTreeLength - 2) {
			//이동불가
			toast.push("순서의 마지막입니다.");
		} else {
			changeChildIndex = nowChildIndex.number() + 1;

			try {
				if (isRootControl) {
					while(myTree[changeChildIndex]._isDel){
						changeChildIndex++;
						if(changeChildIndex == myTree.length-1) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[nowChildIndex]);
					myTree[nowChildIndex] = AXUtil.copyObject(myTree[changeChildIndex]);
					myTree[changeChildIndex] = tempObj;
					if(typeof myTree[nowChildIndex]._CUD == "undefined") myTree[nowChildIndex]._CUD = "U";
					if(typeof myTree[nowChildIndex + 1]._CUD == "undefined") myTree[nowChildIndex + 1]._CUD = "U";
				} else {
					while(myTree[cfg.reserveKeys.subTree][changeChildIndex]._isDel){
						changeChildIndex++;
						if(changeChildIndex == myTree[cfg.reserveKeys.subTree].length-1) break;
					}

					var newSelectedHash = "0".setDigit(cfg.hashDigit) + "_" + parentHashs.join("_") + "_" + (changeChildIndex).setDigit(cfg.hashDigit);
					var tempObj = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][nowChildIndex]);
					myTree[cfg.reserveKeys.subTree][nowChildIndex] = AXUtil.copyObject(myTree[cfg.reserveKeys.subTree][changeChildIndex]);
					myTree[cfg.reserveKeys.subTree][changeChildIndex] = tempObj;
					if(typeof myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][nowChildIndex]._CUD = "U";
					if(typeof myTree[cfg.reserveKeys.subTree][nowChildIndex + 1]._CUD == "undefined") myTree[cfg.reserveKeys.subTree][nowChildIndex + 1]._CUD = "U";
				}
			} catch (e) {
				trace(e);
			}

			this.selectedCells.clear();
			this.selectedRow.clear();

			this.list = this.convertHashListToTree(this.tree);
			this.printList();

			var newSelecteIndex;
			for (var idx = 0; idx < this.list.length; idx++) {
				if (this.list[idx][reserveKeys.hashKey] == newSelectedHash) {
					newSelecteIndex = idx;

					this.body.find(".gridBodyTr_" + newSelecteIndex).addClass("selected");
					this.selectedRow.push(newSelecteIndex);

					break;
				}
			};

		}

	},
	/**
	 * @method AXTree.moveTree
	 * @param {JSObject} Option - startMove, validate, endMove, Option에 3가지 함수를 정의합니다. example code 참고
	 * @description
	 * 원하는 아이템의 위치를 수정합니다.
	 * @example
     * ```js
     * myTree.moveTree({
     *     startMove: function(){      //moveTree가 발동 되었을 때 발생되는 콜백함수
     *         myTree.addClassItem({
     *             className:"disable",
     *             addClass:function(){
     *                 return (this.nodeID == "N");
     *             }
     *         });
     *     },
     *     validate:function(){        //moveTree가 활성화 된 상태에서 사용자의 선택을 검증하는 콜백함수
     *         //this.moveObj
     *         //this.targetObj
     *         if(this.targetObj.nodeID == "N"){
     *             alert("이동할 수 없는 대상을 선택하셨습니다.");
     *             return false;
     *         }else{
     *             return true;
     *         }
     *     },
     *     endMove: function(){        //moveTree가 완료 되었을때 발생되는 콜백함수
     *         myTree.removeClassItem({
     *             className:"disable",
     *             removeClass:function(){
     *                 return (this.nodeID == "N");
     *             }
     *         });
     *     }
     * });
     * ```
	 */
	moveTree: function (Option) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;
		var moveObj = Option.moveObj, targetObj = Option.targetObj;

		// TODO : MOVE Bug -----

		if (moveObj && targetObj) {
			//외부 이동 명령 처리
			//this.moveTreeExec(); 을 위한 필터링 
		} else {

			var selectedObject = this.getSelectedList();

			if (selectedObject.error) {
				toast.push(selectedObject.description);
				return;
			}

			var itemIndex = selectedObject.index;
			var item = this.list[selectedObject.index];
			var hashs = item[cfg.reserveKeys.hashKey].split(/_/g);

			this.body.find(".gridBodyTr_" + itemIndex).addClass("copied");
			toast.push({ type: "Warning", body: "선택하신 아이템을 이동시킬 부모 아이템을 선택하세요" });
			this.readyMoved = true;
			this.moveTarget = { itemIndex: itemIndex };
			this.moveValidate = Option.validate;
			this.moveEndFunction = Option.endMove;

			if (Option.startMove) {
				Option.startMove.call();
			}

			//직계 부모를 disable 처리 합니다.
			this.addClassItem({
				className: "disable",
				addClass: function () {
					return (item[reserveKeys.parentHashKey] == this[reserveKeys.hashKey] || item[reserveKeys.hashKey] == this[reserveKeys.hashKey].left(item[reserveKeys.hashKey].length));
				}
			});

			// key event ready
			var eventForDocument = this.onBodyKeydown.bind(this);
			this.eventForDocument = function (event) {
				eventForDocument(event);
			};
			axdom(document.body).bind("keydown", this.eventForDocument);

		}
	},
	moveTreeExec: function (moveIndex, targetIndex) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		if (moveIndex == targetIndex) {
			alert("이동 위치와 이동대상이 같습니다. 이동 할 수 없습니다.");
			return;
		}

		var moveObj = this.list[moveIndex];
		var targetObj = this.list[targetIndex];

		if (moveObj[reserveKeys.parentHashKey] == targetObj[reserveKeys.hashKey]) {
			alert("이동 위치가 현재 위치와 다르지 않습니다. 이동 할 수 없습니다.");
			return;
		}
		if (moveObj[reserveKeys.hashKey] == targetObj[reserveKeys.hashKey].left(moveObj[reserveKeys.hashKey].length)) {
			alert("이동 위치가 자식위치입니다. 이동 할 수 없습니다.");
			return;
		}

		if (this.moveValidate) {
			var validateResult = this.moveValidate.call({ moveObj: moveObj, targetObj: targetObj }, moveObj, targetObj);
			if (!validateResult) {
				return;
			}
		}

		//trace(this.tree);

		//아이템 복사 ~~~~~~~~~~~~~~~~~~
		var move_hashs = moveObj[reserveKeys.hashKey].split(/_/g);
		var move_Tree_parent = this.tree;
		for (var hidx = 1; hidx < move_hashs.length - 1; hidx++) {
			if (hidx == 1) {
				move_Tree_parent = move_Tree_parent[move_hashs[hidx].number()];
			} else {
				move_Tree_parent = move_Tree_parent[cfg.reserveKeys.subTree][move_hashs[hidx].number()];
			}
		}
		var copyObject = {};
		//trace("moveObj");
		//trace(moveObj);

		var move_Tree_parent_subTree = [];
		if (move_hashs.length == 2) { // root level
			move_Tree_parent_subTree = this.tree;
		} else {
			move_Tree_parent_subTree = move_Tree_parent[cfg.reserveKeys.subTree];
		}

		axf.each(move_Tree_parent_subTree, function (subTreeIndex, ST) {
			if (ST[relation.childKey] == moveObj[relation.childKey]) {
				copyObject = AXUtil.copyObject(ST);
			} else {

			}
		});
		//~~~~~~~~~~~~~~~~~~ 아이템 복사

		//아이템 이동 ~~~~~~~~~~~~~~~~~~
		var target_hashs = targetObj[reserveKeys.hashKey].split(/_/g);
		var target_Tree_parent = this.tree;

		//trace(this.tree);

		var newSelectedHashs = [];
		newSelectedHashs.push(target_hashs[0]);
		for (var hidx = 1; hidx < target_hashs.length; hidx++) {
			newSelectedHashs.push(target_hashs[hidx]);
			if (hidx == 1) {
				target_Tree_parent = target_Tree_parent[target_hashs[hidx].number()];
			} else {
				target_Tree_parent = target_Tree_parent[cfg.reserveKeys.subTree][target_hashs[hidx].number()];
			}
		}
		newSelectedHashs.push((target_Tree_parent[cfg.reserveKeys.subTree].length).setDigit(cfg.hashDigit));

		copyObject[relation.parentKey] = target_Tree_parent[relation.childKey];
		try {
			copyObject[relation.parentName] = target_Tree_parent[relation.childName];
		} catch (e) {

		}

		function treeExtend( _treeItems ){
			for(var ti = 0 ; ti < _treeItems.length ; ti++){
				if(typeof _treeItems[ti]._CUD == "undefined") _treeItems[ti]._CUD = "U";
				if( _treeItems[ti][cfg.reserveKeys.subTree] ){
					treeExtend( _treeItems[ti][cfg.reserveKeys.subTree] );
				}
			}
		}
		if(typeof copyObject._CUD == "undefined") copyObject._CUD = "U";
		treeExtend( copyObject[cfg.reserveKeys.subTree] );

		target_Tree_parent[cfg.reserveKeys.subTree].push(copyObject);
		var newSelectedHash = newSelectedHashs.join("_");

		//~~~~~~~~~~~~~~~~~~ 아이템 이동

		//이동된 아이템 제거
		var new_subTree = [];
		axf.each(move_Tree_parent_subTree, function (subTreeIndex, ST) {
			if (ST[relation.childKey] == moveObj[relation.childKey]) {

			} else {
				new_subTree.push(ST);
			}
		});

		if (move_hashs.length == 2) { // root level
			this.tree = new_subTree;
		} else {
			move_Tree_parent[cfg.reserveKeys.subTree] = new_subTree;
		}

		this.selectedCells.clear();
		this.selectedRow.clear();

		this.list = this.convertHashListToTree(this.tree);
		this.printList();

		var newSelecteIndex;
		for (var idx = 0; idx < this.list.length; idx++) {
			if (this.list[idx][reserveKeys.hashKey] == newSelectedHash) {
				newSelecteIndex = idx;

				this.body.find(".gridBodyTr_" + newSelecteIndex).addClass("selected");
				this.selectedRow.push(newSelecteIndex);

				break;
			}
		};

		this.cancelMove();
	},
	cancelMove: function () {
		this.readyMoved = false;
		this.body.find(".gridBodyTr_" + this.moveTarget.itemIndex).removeClass("copied");
		if (this.moveEndFunction) {
			this.moveEndFunction.call();
		}

		this.body.find(".gridBodyTr.disable").removeClass("disable");

		this.moveTarget = null;
		axdom(document.body).unbind("keydown", this.eventForDocument);
	},
	addClassItem: function (Option) {
		var body = this.body;

		axf.each(this.list, function (listIndex, item) {
			if (Option.addClass) {
				if (Option.addClass.call(item)) {
					body.find(".gridBodyTr_" + listIndex).addClass(Option.className);
				}
			}
		});
	},
	removeClassItem: function (Option) {
		var body = this.body;

		axf.each(this.list, function (listIndex, item) {
			if (Option.removeClass) {
				if (Option.removeClass.call(item)) {
					//trace(listIndex);
					body.find(".gridBodyTr_" + listIndex).removeClass(Option.className);
				}
			}
		});
	},
	/* tree 추가 메서드  */

	/* tree = list convert  */
	convertHashListToTree: function (Tree) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		this.hashList = [];
		var pushItem = { isRoot: true };
		pushItem[relation.childKey] = "0";
		pushItem[reserveKeys.hashKey] = "0".setDigit(cfg.hashDigit);
		pushItem[reserveKeys.parentHashKey] = "";
		pushItem[reserveKeys.openKey] = true;
		pushItem._subTreeLength = Tree.length;

		this.getSubTreeList(pushItem[reserveKeys.hashKey], pushItem[reserveKeys.openKey], pushItem, Tree);
		return this.hashList;
	},
	getSubTreeList: function (parentHash, parentOpened, parentItem, arr) {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		var getSubTreeList = this.getSubTreeList.bind(this);
		var pushHashList = this.pushHashList.bind(this);

		if (!arr[reserveKeys.subTree]) arr[reserveKeys.subTree] = [];

		axf.each(arr, function (idx, A) {
			var pushItem = {};
			var hasOpenKey = false, hasSubTree = false;

			delete A.__subTreeLength;
			axf.each(A, function (k, v) {
				if (k == reserveKeys.openKey) {
					hasOpenKey = true;
					pushItem[k] = v;
				} else if (k == reserveKeys.subTree) {
					if(v.length > 0){
						hasSubTree = true;
						pushItem.__subTreeLength = v.length;
					}
				} else if (k == "__subTree") {
					hasSubTree = v;
					pushItem.__subTreeLength = v ? 1 : 0;
				} else {
					pushItem[k] = v;
				}
			});
			pushItem[reserveKeys.parentHashKey] = parentHash;
			pushItem[reserveKeys.hashKey] = parentHash + cfg.hashSpliter + idx.setDigit(cfg.hashDigit);
			A[reserveKeys.hashKey] = parentHash + cfg.hashSpliter + idx.setDigit(cfg.hashDigit);
			if (!hasOpenKey) pushItem[reserveKeys.openKey] = false;
			if (!hasSubTree) pushItem.__subTreeLength = 0;
			pushItem[reserveKeys.displayKey] = parentOpened;
			if (pushItem[reserveKeys.openKey] && !parentOpened) pushItem[reserveKeys.openKey] = false; //부보가 닫힌 개체 이면 자식 개체도 닫힘

			if (pushItem[relation.parentKey] == undefined || pushItem[relation.parentKey] == relation.rootID) {
				pushItem[relation.parentKey] = parentItem[relation.childKey];
			}

			if(idx == (arr.length-1)){
				A.__isLastChild = true;
				pushItem.__isLastChild = true;
			}else{
				A.__isLastChild = false;
				pushItem.__isLastChild = false;
			}
			pushHashList(pushItem);

			if (!A[reserveKeys.subTree]) A[reserveKeys.subTree] = [];
			if (hasSubTree && A[reserveKeys.subTree].length > 0) {
				getSubTreeList(pushItem[reserveKeys.hashKey], pushItem[reserveKeys.openKey], pushItem, A[reserveKeys.subTree]);
			}
		});
	},
	pushHashList: function (item) {
		this.hashList.push(item);
	},
	convertTreeToHashList: function (List) {
		var cfg = this.config;
		reserveKeys = cfg.reserveKeys;
		//cfg.hashSpliter;
		var hashTree = [];

		for (var idx = 0; idx < List.length; idx++) {
			var item = List[idx];
			var re = new RegExp(cfg.hashSpliter, "g");
			var pHash = item[reserveKeys.parentHashKey];
			var hashs = item[reserveKeys.hashKey].split(re);
			var pushItem = {};
			axf.each(item, function (k, v) {
				var addOk = true;
				axf.each(reserveKeys, function (kk, vv) {
					if (k == vv) {
						addOk = false;
						return false;
					}
				});
				if (addOk) {
					pushItem[k] = v;
				}
			});
			pushItem[reserveKeys.hashKey] = item[reserveKeys.hashKey];
			pushItem[cfg.reserveKeys.subTree] = [];
			if (hashs.length == 2) {
				hashTree.push(pushItem);
			} else if (hashs.length > 2) {
				var pItem = hashTree.has(function () {
					return this.item[reserveKeys.hashKey] == pHash;
				});
				if (pItem) {
					pItem[cfg.reserveKeys.subTree].push(pushItem);
				}
			}
		}
	},
	positioningHashList: function (List) {
		var cfg = this.config;
		reserveKeys = cfg.reserveKeys;
		relation = cfg.relation;

		if (!relation) {
			toast.push("relation 속성이 지정되지 않아 요청을 수행 할 수 없습니다. relation:{parentKey:'', childKey:''}");
			return;
		}

		// make pointer;
		var tree = [];
		var pointer = {};
		var seq = 0, _parentCheckKey = 0;
		for (var idx = 0; idx < List.length; idx++) {
			var L = List[idx];
			if(idx == 0) _parentCheckKey =  L[relation.parentKey];
			if (!L.isRoot) {
				if(L.AXTreeSplit){

				}else{
                    L.__index = idx;
                    pointer[L[relation.childKey]] = idx;
                    if (L[reserveKeys.openKey] == undefined) L[reserveKeys.openKey] = false;
					if (L[relation.parentKey] == _parentCheckKey) {
						L[reserveKeys.subTree] = [];
						L.__subTreeLength = 0;
						L[reserveKeys.parentHashKey] = "0".setDigit(cfg.hashDigit);
						L[reserveKeys.hashKey] = "0".setDigit(cfg.hashDigit) + "_" + seq.setDigit(cfg.hashDigit);
						L[reserveKeys.displayKey] = true;
						tree.push(AXUtil.copyObject(L));
						seq++;
					} else {
						L.__subTreeLength = 0;
						L[reserveKeys.displayKey] = false;
					}
				}
			}
		}

		for (var idx = 0; idx < List.length; idx++) {
			var L = List[idx];
			if (L[reserveKeys.parentHashKey] == undefined && !L.isRoot) {

				if(L.AXTreeSplit) continue;

				var pItem = List[pointer[L[relation.parentKey]]];
				var pHash = pItem[reserveKeys.hashKey] || "";
				var pHashs = pHash.split(/_/g);
				var pTree = tree;
				axf.each(pHashs, function (idx, T) {
					if (idx > 0) pTree = pTree[T.number()][cfg.reserveKeys.subTree];
				});
				L[reserveKeys.subTree] = [];

				var __subTreeLength = pItem.__subTreeLength;
				var pOpend = pItem[reserveKeys.openKey];
				L[reserveKeys.parentHashKey] = pHash;
				L[reserveKeys.hashKey] = pHash + cfg.hashSpliter + __subTreeLength.setDigit(cfg.hashDigit);
				L[reserveKeys.displayKey] = pOpend;

				pTree.push(AXUtil.copyObject(L));
				pItem.__subTreeLength++;
			}
		}

		// hash 값대로 정렬을 합니다.
		List.sort(function(p, n){
			return (p[reserveKeys.hashKey] < n[reserveKeys.hashKey]) ? -1 : (p[reserveKeys.hashKey] > n[reserveKeys.hashKey]) ? 1 : 0;
		});

		if(cfg.showConnectionLine){
			this.tree = tree;
			List = this.convertHashListToTree(this.tree);
			//List = this.list;
		}else{
			this.tree = tree;
		}

		//trace(List);
		//trace(tree);

		return List;
	},

	/**
	 * @method AXTree.getSelectedList
	 * @returns {JSObject} - {index:1, item: {} }
	 * @description
	 * 현재 선택된 아이템을 반환합니다.
	 * (Number) index of Array 선택한 아이템들의 첫번째
	 *
	 * @example
	 * ```js
	 * var SL = AXTree.getSelectedList();
	 * trace(SL);
	 * ```
	 */
	getSelectedList: function () {
		if (this.selectedRow != undefined && this.selectedRow != null && this.selectedRow.length > 0) {
			return { index: this.selectedRow.first(), item: this.list[this.selectedRow.first()] };
		} else {
			return { error: "noselected", description: "선택된 item이 없습니다." };
		}
	},
	/**
	 * @method AXTree.getSelectedListParent
	 * @returns {JSObject} - {index:1, item: {} }
	 * @description
	 * 현재 선택된 아이템의 부모 아이템을 반환합니다.
	 * @example
	 * ```js
	 * var SL = AXTree.getSelectedListParent();
	 * trace(SL)
	 * ```
	 */
	getSelectedListParent: function () {
		var cfg = this.config;
		var reserveKeys = cfg.reserveKeys;
		var relation = cfg.relation;

		if (this.selectedRow != undefined && this.selectedRow != null && this.selectedRow.length > 0) {

			var item = this.list[this.selectedRow.first()];
			var pno = item[relation.parentKey];

			var parentIndex = null;
			if (pno != "0") {
				axf.each(this.list, function (findIndex, findItem) {
					if (findItem[relation.childKey] == pno) {
						parentIndex = findIndex;
						return false;
					}
				});
			}

			if (parentIndex == null) {
				return { index: null, item: null };
			} else {
				return { index: parentIndex, item: this.list[parentIndex] };
			}
		} else {
			return { index: null, item: null };
		}
	},

	/**
	 * @method AXTree.relationFixedSync
	 * @param {JSObject} options  - 설명
	 * @returns changed item of list {Array}
	 * @description 자식 항목에 체크된 경우 부모 값을 체크된 상태로 변경 해주는 메서드 입니다.
	 * @example
	 * ```js
	 * myTree.relationFixedSync();
	 * myTree.relationFixedSync({expandItem:true}); // 체크된 아이템을 확장상태로 변경합니다.
	 * ```
	 */
	relationFixedSync: function(options){
		var cfg = this.config;
		var _body = this.body, _this = this;
		var returnObject = [];
		axf.each(this.list, function(lidx, L){
			axdom("#" + cfg.targetID + "_AX_treeBody").find(".gridBodyTr_"+lidx+" .treeCheckBox_body").each(function(){
				if(L.__checked && (options && options.expandItem)) _this.expandToggleList(lidx, L, true);
				this.checked = L.__checked;
				returnObject.push(this);
			});
		});
		return returnObject;
	},

	/**
	 * @method AXTree.expandAll
	 * @param {(String|Null|Number)} [depth="all"} - 확장할 뎁스, 값을 주지 않거나 "all" 을 주면 전체 확장이됩니다.
	 * @description 트리의 노드를 확장시켜 줍니다.
	 * @example
	 * ```js
	 * myTree.expandAll(); //모두확장
	 * myTree.expandAll(1); //1 뎁스까지만 확장
	 * ```
	 */
	expandAll: function(depth){
		var cfg = this.config;
		var _body = this.body;
		axf.each(this.list, function (itemIndex, item) {
			if (typeof depth == "undefined" || depth == "all") {
				item[cfg.reserveKeys.openKey] = true;
			} else {
				var hashLevel = item[cfg.reserveKeys.parentHashKey].split(/_/g).length;
				if (hashLevel < depth.number()+1) item[cfg.reserveKeys.openKey] = true;
				else item[cfg.reserveKeys.openKey] = false;
			}
			item[cfg.reserveKeys.displayKey] = true;
			item[cfg.reserveKeys.parentHashKey] = undefined;
			item[cfg.reserveKeys.hashKey] = undefined;
		});
		this.list = this.positioningHashList(this.list);
		this.printList();
		return this;
	},
	/**
	 * @method AXTree.collapseAll
	 * @description
	 * 트리의 모든 아이템을 축소상태로 변경합니다.
	 * @example
	 * ```js
	 * myTree.collapseAll();
	 * ```
	 */
	collapseAll: function(){
		var cfg = this.config;
		var _body = this.body;
		axf.each(this.list, function (itemIndex, item) {
			item[cfg.reserveKeys.openKey] = false;
			if(item[cfg.relation.parentKey] == 0){
				item[cfg.reserveKeys.displayKey] = true;
			}else{
				item[cfg.reserveKeys.displayKey] = false;
			}
			item[cfg.reserveKeys.parentHashKey] = undefined;
			item[cfg.reserveKeys.hashKey] = undefined;
		});
		this.list = this.positioningHashList(this.list);
		this.printList();
		return this;
	},
    /**
     * item의 부모 item들을 포함해서 차례대로 확장합니다.
     *
     * @param {(Object|String)} - item or key ex) myTree.list[5](item) or myTree.list[5][relation.childKey](key)
     * @returns {AXTree}
     */
    expand: function(key){
        var targetItem;
        if (Object.isObject(key)) {
            targetItem = key;
        } else {
            var cfg = this.config;
            axf.each(this.list, function(itemIndex, item){
                if (item[cfg.relation.childKey] == key) {
                    targetItem = item;
                    return false;
                }
            });
        }

        if (!targetItem) {
            return {focusedID:undefined};
        }

        return this.click(targetItem.__index, "open", true);
    }
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */

/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov Nilz? and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFObject v2.2 <http://code.google.com/p/swfobject/>
 *    is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
 */

/* ******************* */
/* Constructor & Init  */
/* ******************* */

var SWFUpload;
var swfobject;

(function () {
    if (SWFUpload == undefined) {
        SWFUpload = function (settings) {
            this.initSWFUpload(settings);
        };
    }

    SWFUpload.prototype.initSWFUpload = function (userSettings) {
        try {
            this.customSettings = {};	// A container where developers can place their own settings associated with this instance.
            this.settings = {};
            this.eventQueue = [];
            this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
            this.movieElement = null;


            // Setup global control tracking
            SWFUpload.instances[this.movieName] = this;

            // Load the settings.  Load the Flash movie.
            this.initSettings(userSettings);
            this.loadSupport();
            if (this.swfuploadPreload()) {
                this.loadFlash();
            }

            this.displayDebugInfo();
        } catch (ex) {
            delete SWFUpload.instances[this.movieName];
            throw ex;
        }
    };

    /* *************** */
    /* Static Members  */
    /* *************** */
    SWFUpload.instances = {};
    SWFUpload.movieCount = 0;
    SWFUpload.version = "2.5.0 2010-01-15 Beta 2";
    SWFUpload.QUEUE_ERROR = {
        QUEUE_LIMIT_EXCEEDED: -100,
        FILE_EXCEEDS_SIZE_LIMIT: -110,
        ZERO_BYTE_FILE: -120,
        INVALID_FILETYPE: -130
    };
    SWFUpload.UPLOAD_ERROR = {
        HTTP_ERROR: -200,
        MISSING_UPLOAD_URL: -210,
        IO_ERROR: -220,
        SECURITY_ERROR: -230,
        UPLOAD_LIMIT_EXCEEDED: -240,
        UPLOAD_FAILED: -250,
        SPECIFIED_FILE_ID_NOT_FOUND: -260,
        FILE_VALIDATION_FAILED: -270,
        FILE_CANCELLED: -280,
        UPLOAD_STOPPED: -290,
        RESIZE: -300
    };
    SWFUpload.FILE_STATUS = {
        QUEUED: -1,
        IN_PROGRESS: -2,
        ERROR: -3,
        COMPLETE: -4,
        CANCELLED: -5
    };
    SWFUpload.UPLOAD_TYPE = {
        NORMAL: -1,
        RESIZED: -2
    };

    SWFUpload.BUTTON_ACTION = {
        SELECT_FILE: -100,
        SELECT_FILES: -110,
        START_UPLOAD: -120,
        JAVASCRIPT: -130,	// DEPRECATED
        NONE: -130
    };
    SWFUpload.CURSOR = {
        ARROW: -1,
        HAND: -2
    };
    SWFUpload.WINDOW_MODE = {
        WINDOW: "transparent",
        TRANSPARENT: "transparent",
        OPAQUE: "opaque"
    };

    SWFUpload.RESIZE_ENCODING = {
        JPEG: -1,
        PNG: -2
    };

    // Private: takes a URL, determines if it is relative and converts to an absolute URL
    // using the current site. Only processes the URL if it can, otherwise returns the URL untouched
    SWFUpload.completeURL = function (url) {
        try {
            var path = "", indexSlash = -1;
            if (typeof(url) !== "string" || url.match(/^https?:\/\//i) || url.match(/^\//) || url === "") {
                return url;
            }

            indexSlash = window.location.pathname.lastIndexOf("/");
            if (indexSlash <= 0) {
                path = "/";
            } else {
                path = window.location.pathname.substr(0, indexSlash) + "/";
            }

            return path + url;
        } catch (ex) {
            return url;
        }
    };

    // Public: assign a new function to onload to use swfobject's domLoad functionality
    SWFUpload.onload = function () {
    };


    /* ******************** */
    /* Instance Members  */
    /* ******************** */

    // Private: initSettings ensures that all the
    // settings are set, getting a default value if one was not assigned.
    SWFUpload.prototype.initSettings = function (userSettings) {

        this.ensureDefault = function (settingName, defaultValue) {
            var setting = userSettings[settingName];
            if (setting != undefined) {
                this.settings[settingName] = setting;
            } else {
                this.settings[settingName] = defaultValue;
            }
        };

        // Upload backend settings
        this.ensureDefault("upload_url", "");
        this.ensureDefault("preserve_relative_urls", false);
        this.ensureDefault("file_post_name", userSettings.uploadFileName);
        this.ensureDefault("post_params", {});
        this.ensureDefault("use_query_string", false);
        this.ensureDefault("requeue_on_error", false);
        this.ensureDefault("http_success", []);
        this.ensureDefault("assume_success_timeout", 0);

        // File Settings
        this.ensureDefault("file_types", userSettings.file_types);
        this.ensureDefault("file_types_description", "All Files");
        this.ensureDefault("file_size_limit", 0);	// Default zero means "unlimited"
        this.ensureDefault("file_upload_limit", 0);
        this.ensureDefault("file_queue_limit", 0);

        // Flash Settings
        this.ensureDefault("flash_url", "swfupload.swf");
        this.ensureDefault("flash9_url", "swfupload_fp9.swf");
        this.ensureDefault("prevent_swf_caching", true);

        // Button Settings
        this.ensureDefault("button_image_url", "");
        this.ensureDefault("button_width", 1);
        this.ensureDefault("button_height", 1);
        this.ensureDefault("button_text", "");
        this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
        this.ensureDefault("button_text_top_padding", 0);
        this.ensureDefault("button_text_left_padding", 0);
        this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
        this.ensureDefault("button_disabled", false);
        this.ensureDefault("button_placeholder_id", "");
        this.ensureDefault("button_placeholder", null);
        this.ensureDefault("button_cursor", SWFUpload.CURSOR.ARROW);
        this.ensureDefault("button_window_mode", SWFUpload.WINDOW_MODE.WINDOW);

        // Debug Settings
        this.ensureDefault("debug", false);
        this.settings.debug_enabled = this.settings.debug;	// Here to maintain v2 API

        // Option Setting
        this.ensureDefault("fileSelectAutoUpload", userSettings.fileSelectAutoUpload);

        // Event Handlers
        this.settings.return_upload_start_handler = this.returnUploadStart;
        this.ensureDefault("swfupload_preload_handler", null);
        this.ensureDefault("swfupload_load_failed_handler", null);
        this.ensureDefault("swfupload_loaded_handler", null);
        this.ensureDefault("file_dialog_start_handler", null);
        this.ensureDefault("file_queued_handler", null);
        this.ensureDefault("file_queue_error_handler", null);
        this.ensureDefault("file_dialog_complete_handler", null);

        this.ensureDefault("upload_resize_start_handler", null);
        this.ensureDefault("upload_start_handler", null);
        this.ensureDefault("upload_progress_handler", null);
        this.ensureDefault("upload_error_handler", null);
        this.ensureDefault("upload_success_handler", null);
        this.ensureDefault("upload_complete_handler", null);

        this.ensureDefault("mouse_click_handler", null);
        this.ensureDefault("mouse_out_handler", null);
        this.ensureDefault("mouse_over_handler", null);

        this.ensureDefault("debug_handler", this.debugMessage);

        this.ensureDefault("custom_settings", {});

        // Other settings
        this.customSettings = this.settings.custom_settings;

        // Update the flash url if needed
        if (!!this.settings.prevent_swf_caching) {
            this.settings.flash_url = this.settings.flash_url + (this.settings.flash_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
            this.settings.flash9_url = this.settings.flash9_url + (this.settings.flash9_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
        }

        if (!this.settings.preserve_relative_urls) {
            this.settings.upload_url = SWFUpload.completeURL(this.settings.upload_url);
            this.settings.button_image_url = SWFUpload.completeURL(this.settings.button_image_url);
        }

        delete this.ensureDefault;
    };

    // Initializes the supported functionality based the Flash Player version, state, and event that occur during initialization
    SWFUpload.prototype.loadSupport = function () {
        this.support = {
            loading: swfobject.hasFlashPlayerVersion("9.0.28"),
            imageResize: swfobject.hasFlashPlayerVersion("10.0.0")
        };

    };

    // Private: loadFlash replaces the button_placeholder element with the flash movie.
    SWFUpload.prototype.loadFlash = function () {
        var targetElement, tempParent, wrapperType, flashHTML, els;

        if (!this.support.loading) {
            this.queueEvent("swfupload_load_failed_handler", ["Flash Player doesn't support SWFUpload"]);
            return;
        }

        // Make sure an element with the ID we are going to use doesn't already exist
        if (document.getElementById(this.movieName) !== null) {
            this.support.loading = false;
            this.queueEvent("swfupload_load_failed_handler", ["Element ID already in use"]);
            return;
        }

        // Get the element where we will be placing the flash movie
        targetElement = document.getElementById(this.settings.button_placeholder_id) || this.settings.button_placeholder;

        if (targetElement == undefined) {
            this.support.loading = false;
            this.queueEvent("swfupload_load_failed_handler", ["button place holder not found"]);
            return;
        }

        wrapperType = (targetElement.currentStyle && targetElement.currentStyle["display"] || window.getComputedStyle && document.defaultView.getComputedStyle(targetElement, null).getPropertyValue("display")) !== "block" ? "span" : "div";

        // Append the container and load the flash
        tempParent = document.createElement(wrapperType);

        flashHTML = this.getFlashHTML();

        try {
            tempParent.innerHTML = flashHTML;	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
        } catch (ex) {
            this.support.loading = false;
            this.queueEvent("swfupload_load_failed_handler", ["Exception loading Flash HTML into placeholder"]);
            return;
        }

        // Try to get the movie element immediately
        els = tempParent.getElementsByTagName("object");
        if (!els || els.length > 1 || els.length === 0) {
            this.support.loading = false;
            this.queueEvent("swfupload_load_failed_handler", ["Unable to find movie after adding to DOM"]);
            return;
        } else if (els.length === 1) {
            this.movieElement = els[0];
        }

        targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);

        // Fix IE Flash/Form bug
        if (window[this.movieName] == undefined) {
            window[this.movieName] = this.getMovieElement();
        }
    };

    // Private: getFlashHTML generates the object tag needed to embed the flash in to the document
    SWFUpload.prototype.getFlashHTML = function (flashVersion) {
        // Flash Satay object syntax: http://www.alistapart.com/articles/flashsatay
        return ['<object id="', this.movieName, '" type="application/x-shockwave-flash" data="', (this.support.imageResize ? this.settings.flash_url : this.settings.flash9_url), '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
            '<param name="wmode" value="', this.settings.button_window_mode, '" />',
            '<param name="movie" value="', (this.support.imageResize ? this.settings.flash_url : this.settings.flash9_url), '" />',
            '<param name="quality" value="high" />',
            '<param name="allowScriptAccess" value="always" />',
            '<param name="flashvars" value="' + this.getFlashVars() + '" />',
            '</object>'].join("");
    };

    // Private: getFlashVars builds the parameter string that will be passed
    // to flash in the flashvars param.
    SWFUpload.prototype.getFlashVars = function () {
        // Build a string from the post param object
        var httpSuccessString, paramString;

        paramString = this.buildParamString();
        httpSuccessString = this.settings.http_success.join(",");

        // Build the parameter string
        return ["movieName=", encodeURIComponent(this.movieName),
            "&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
            "&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
            "&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
            "&amp;httpSuccess=", encodeURIComponent(httpSuccessString),
            "&amp;assumeSuccessTimeout=", encodeURIComponent(this.settings.assume_success_timeout),
            "&amp;params=", encodeURIComponent(paramString),
            "&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
            "&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
            "&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
            "&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
            "&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
            "&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
            "&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
            "&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
            "&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
            "&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
            "&amp;buttonText=", encodeURIComponent(this.settings.button_text),
            "&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
            "&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
            "&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
            "&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
            "&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
            "&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
        ].join("");
    };

    // Public: get retrieves the DOM reference to the Flash element added by SWFUpload
    // The element is cached after the first lookup
    SWFUpload.prototype.getMovieElement = function () {
        if (this.movieElement == undefined) {
            this.movieElement = document.getElementById(this.movieName);
        }

        if (this.movieElement === null) {
            throw "Could not find Flash element";
        }

        return this.movieElement;
    };

    // Private: buildParamString takes the name/value pairs in the post_params setting object
    // and joins them up in to a string formatted "name=value&amp;name=value"
    SWFUpload.prototype.buildParamString = function () {
        var name, postParams, paramStringPairs = [];

        postParams = this.settings.post_params;

        if (typeof(postParams) === "object") {
            for (name in postParams) {
                if (postParams.hasOwnProperty(name)) {
                    paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
                }
            }
        }

        return paramStringPairs.join("&amp;");
    };

    // Public: Used to remove a SWFUpload instance from the page. This method strives to remove
    // all references to the SWF, and other objects so memory is properly freed.
    // Returns true if everything was destroyed. Returns a false if a failure occurs leaving SWFUpload in an inconsistant state.
    // Credits: Major improvements provided by steffen
    SWFUpload.prototype.destroy = function () {
        var movieElement;

        try {
            // Make sure Flash is done before we try to remove it
            this.cancelUpload(null, false);

            movieElement = this.cleanUp();

            // Remove the SWFUpload DOM nodes
            if (movieElement) {
                // Remove the Movie Element from the page
                try {
                    movieElement.parentNode.removeChild(movieElement);
                } catch (ex) {
                }
            }

            // Remove IE form fix reference
            window[this.movieName] = null;

            // Destroy other references
            SWFUpload.instances[this.movieName] = null;
            delete SWFUpload.instances[this.movieName];

            this.movieElement = null;
            this.settings = null;
            this.customSettings = null;
            this.eventQueue = null;
            this.movieName = null;


            return true;
        } catch (ex2) {
            return false;
        }
    };


    // Public: displayDebugInfo prints out settings and configuration
    // information about this SWFUpload instance.
    // This function (and any references to it) can be deleted when placing
    // SWFUpload in production.
    SWFUpload.prototype.displayDebugInfo = function () {
        this.debug(
            [
                "---SWFUpload Instance Info---\n",
                "Version: ", SWFUpload.version, "\n",
                "Movie Name: ", this.movieName, "\n",
                "Settings:\n",
                "\t", "upload_url:               ", this.settings.upload_url, "\n",
                "\t", "flash_url:                ", this.settings.flash_url, "\n",
                "\t", "flash9_url:                ", this.settings.flash9_url, "\n",
                "\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
                "\t", "requeue_on_error:         ", this.settings.requeue_on_error.toString(), "\n",
                "\t", "http_success:             ", this.settings.http_success.join(", "), "\n",
                "\t", "assume_success_timeout:   ", this.settings.assume_success_timeout, "\n",
                "\t", "file_post_name:           ", this.settings.file_post_name, "\n",
                "\t", "post_params:              ", this.settings.post_params.toString(), "\n",
                "\t", "file_types:               ", this.settings.file_types, "\n",
                "\t", "file_types_description:   ", this.settings.file_types_description, "\n",
                "\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
                "\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
                "\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
                "\t", "debug:                    ", this.settings.debug.toString(), "\n",

                "\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

                "\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
                "\t", "button_placeholder:       ", (this.settings.button_placeholder ? "Set" : "Not Set"), "\n",
                "\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
                "\t", "button_width:             ", this.settings.button_width.toString(), "\n",
                "\t", "button_height:            ", this.settings.button_height.toString(), "\n",
                "\t", "button_text:              ", this.settings.button_text.toString(), "\n",
                "\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
                "\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
                "\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
                "\t", "button_action:            ", this.settings.button_action.toString(), "\n",
                "\t", "button_cursor:            ", this.settings.button_cursor.toString(), "\n",
                "\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

                "\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
                "Event Handlers:\n",
                "\t", "swfupload_preload_handler assigned:  ", (typeof this.settings.swfupload_preload_handler === "function").toString(), "\n",
                "\t", "swfupload_load_failed_handler assigned:  ", (typeof this.settings.swfupload_load_failed_handler === "function").toString(), "\n",
                "\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
                "\t", "mouse_click_handler assigned:       ", (typeof this.settings.mouse_click_handler === "function").toString(), "\n",
                "\t", "mouse_over_handler assigned:        ", (typeof this.settings.mouse_over_handler === "function").toString(), "\n",
                "\t", "mouse_out_handler assigned:         ", (typeof this.settings.mouse_out_handler === "function").toString(), "\n",
                "\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
                "\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
                "\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
                "\t", "upload_resize_start_handler assigned:      ", (typeof this.settings.upload_resize_start_handler === "function").toString(), "\n",
                "\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
                "\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
                "\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
                "\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
                "\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
                "\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n",

                "Support:\n",
                "\t", "Load:                     ", (this.support.loading ? "Yes" : "No"), "\n",
                "\t", "Image Resize:             ", (this.support.imageResize ? "Yes" : "No"), "\n"

            ].join("")
        );
    };

    /* Note: addSetting and getSetting are no longer used by SWFUpload but are included
     the maintain v2 API compatibility
     */
    // Public: (Deprecated) addSetting adds a setting value. If the value given is undefined or null then the default_value is used.
    SWFUpload.prototype.addSetting = function (name, value, default_value) {
        if (value == undefined) {
            return (this.settings[name] = default_value);
        } else {
            return (this.settings[name] = value);
        }
    };

    // Public: (Deprecated) getSetting gets a setting. Returns an empty string if the setting was not found.
    SWFUpload.prototype.getSetting = function (name) {
        if (this.settings[name] != undefined) {
            return this.settings[name];
        }

        return "";
    };


    // Private: callFlash handles function calls made to the Flash element.
    // Calls are made with a setTimeout for some functions to work around
    // bugs in the ExternalInterface library.
    SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
        var movieElement, returnValue, returnString;

        argumentArray = argumentArray || [];
        movieElement = this.getMovieElement();

        // Flash's method if calling ExternalInterface methods (code adapted from MooTools).
        try {
            if (movieElement != undefined) {
                returnString = movieElement.CallFunction('<invoke name="' + functionName + '" returntype="javascript">' + __flash__argumentsToXML(argumentArray, 0) + '</invoke>');
                returnValue = eval(returnString);
            } else {
                this.debug("Can't call flash because the movie wasn't found.");
            }
        } catch (ex) {
            this.debug("Exception calling flash function '" + functionName + "': " + ex.message);
        }

        // Unescape file post param values
        if (returnValue != undefined && typeof returnValue.post === "object") {
            returnValue = this.unescapeFilePostParams(returnValue);
        }

        return returnValue;
    };

    /* *****************************
     -- Flash control methods --
     Your UI should use these
     to operate SWFUpload
     ***************************** */

    // WARNING: this function does not work in Flash Player 10
    // Public: selectFile causes a File Selection Dialog window to appear.  This
    // dialog only allows 1 file to be selected.
    SWFUpload.prototype.selectFile = function () {
        this.callFlash("SelectFile");
    };

    // WARNING: this function does not work in Flash Player 10
    // Public: selectFiles causes a File Selection Dialog window to appear/ This
    // dialog allows the user to select any number of files
    // Flash Bug Warning: Flash limits the number of selectable files based on the combined length of the file names.
    // If the selection name length is too long the dialog will fail in an unpredictable manner.  There is no work-around
    // for this bug.
    SWFUpload.prototype.selectFiles = function () {
        this.callFlash("SelectFiles");
    };


    // Public: startUpload starts uploading the first file in the queue unless
    // the optional parameter 'fileID' specifies the ID
    SWFUpload.prototype.startUpload = function (fileID) {
        //trace(this.settings.fileSelectAutoUpload);
        //trace(this.allowUpload);
        if (this.settings.fileSelectAutoUpload || this.settings.allowUpload == true) {
            this.callFlash("StartUpload", [fileID]);
        }
    };

    // Public: startUpload starts uploading the first file in the queue unless
    // the optional parameter 'fileID' specifies the ID
    SWFUpload.prototype.startResizedUpload = function (fileID, width, height, encoding, quality, allowEnlarging) {
        this.callFlash("StartUpload", [fileID, {"width": width, "height": height, "encoding": encoding, "quality": quality, "allowEnlarging": allowEnlarging}]);
    };

    // Public: cancelUpload cancels any queued file.  The fileID parameter may be the file ID or index.
    // If you do not specify a fileID the current uploading file or first file in the queue is cancelled.
    // If you do not want the uploadError event to trigger you can specify false for the triggerErrorEvent parameter.
    SWFUpload.prototype.cancelUpload = function (fileID, triggerErrorEvent) {
        if (triggerErrorEvent !== false) {
            triggerErrorEvent = true;
        }
        this.callFlash("CancelUpload", [fileID, triggerErrorEvent]);
    };

    // Public: stopUpload stops the current upload and requeues the file at the beginning of the queue.
    // If nothing is currently uploading then nothing happens.
    SWFUpload.prototype.stopUpload = function () {
        this.callFlash("StopUpload");
    };


    // Public: requeueUpload requeues any file. If the file is requeued or already queued true is returned.
    // If the file is not found or is currently uploading false is returned.  Requeuing a file bypasses the
    // file size, queue size, upload limit and other queue checks.  Certain files can't be requeued (e.g, invalid or zero bytes files).
    SWFUpload.prototype.requeueUpload = function (indexOrFileID) {
        return this.callFlash("RequeueUpload", [indexOrFileID]);
    };


    /* ************************
     * Settings methods
     *   These methods change the SWFUpload settings.
     *   SWFUpload settings should not be changed directly on the settings object
     *   since many of the settings need to be passed to Flash in order to take
     *   effect.
     * *********************** */

    // Public: getStats gets the file statistics object.
    SWFUpload.prototype.getStats = function () {
        return this.callFlash("GetStats");
    };

    // Public: setStats changes the SWFUpload statistics.  You shouldn't need to
    // change the statistics but you can.  Changing the statistics does not
    // affect SWFUpload accept for the successful_uploads count which is used
    // by the upload_limit setting to determine how many files the user may upload.
    SWFUpload.prototype.setStats = function (statsObject) {
        this.callFlash("SetStats", [statsObject]);
    };

    // Public: getFile retrieves a File object by ID or Index.  If the file is
    // not found then 'null' is returned.
    SWFUpload.prototype.getFile = function (fileID) {
        if (typeof(fileID) === "number") {
            return this.callFlash("GetFileByIndex", [fileID]);
        } else {
            return this.callFlash("GetFile", [fileID]);
        }
    };

    // Public: getFileFromQueue retrieves a File object by ID or Index.  If the file is
    // not found then 'null' is returned.
    SWFUpload.prototype.getQueueFile = function (fileID) {
        if (typeof(fileID) === "number") {
            return this.callFlash("GetFileByQueueIndex", [fileID]);
        } else {
            return this.callFlash("GetFile", [fileID]);
        }
    };


    // Public: addFileParam sets a name/value pair that will be posted with the
    // file specified by the Files ID.  If the name already exists then the
    // exiting value will be overwritten.
    SWFUpload.prototype.addFileParam = function (fileID, name, value) {
        return this.callFlash("AddFileParam", [fileID, name, value]);
    };

    // Public: removeFileParam removes a previously set (by addFileParam) name/value
    // pair from the specified file.
    SWFUpload.prototype.removeFileParam = function (fileID, name) {
        this.callFlash("RemoveFileParam", [fileID, name]);
    };

    // Public: setUploadUrl changes the upload_url setting.
    SWFUpload.prototype.setUploadURL = function (url) {
        this.settings.upload_url = url.toString();
        this.callFlash("SetUploadURL", [url]);
    };

    // Public: setPostParams changes the post_params setting
    SWFUpload.prototype.setPostParams = function (paramsObject) {
        this.settings.post_params = paramsObject;
        this.callFlash("SetPostParams", [paramsObject]);
    };

    // Public: addPostParam adds post name/value pair.  Each name can have only one value.
    SWFUpload.prototype.addPostParam = function (name, value) {
        this.settings.post_params[name] = value;
        this.callFlash("SetPostParams", [this.settings.post_params]);
    };

    // Public: removePostParam deletes post name/value pair.
    SWFUpload.prototype.removePostParam = function (name) {
        delete this.settings.post_params[name];
        this.callFlash("SetPostParams", [this.settings.post_params]);
    };

    // Public: setFileTypes changes the file_types setting and the file_types_description setting
    SWFUpload.prototype.setFileTypes = function (types, description) {
        this.settings.file_types = types;
        this.settings.file_types_description = description;
        this.callFlash("SetFileTypes", [types, description]);
    };

    // Public: setFileSizeLimit changes the file_size_limit setting
    SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
        this.settings.file_size_limit = fileSizeLimit;
        this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
    };

    // Public: setFileUploadLimit changes the file_upload_limit setting
    SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
        this.settings.file_upload_limit = fileUploadLimit;
        this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
    };

    // Public: setFileQueueLimit changes the file_queue_limit setting
    SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
        this.settings.file_queue_limit = fileQueueLimit;
        this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
    };

    // Public: setFilePostName changes the file_post_name setting
    SWFUpload.prototype.setFilePostName = function (filePostName) {
        this.settings.file_post_name = filePostName;
        this.callFlash("SetFilePostName", [filePostName]);
    };

    // Public: setUseQueryString changes the use_query_string setting
    SWFUpload.prototype.setUseQueryString = function (useQueryString) {
        this.settings.use_query_string = useQueryString;
        this.callFlash("SetUseQueryString", [useQueryString]);
    };

    // Public: setRequeueOnError changes the requeue_on_error setting
    SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
        this.settings.requeue_on_error = requeueOnError;
        this.callFlash("SetRequeueOnError", [requeueOnError]);
    };

    // Public: setHTTPSuccess changes the http_success setting
    SWFUpload.prototype.setHTTPSuccess = function (http_status_codes) {
        if (typeof http_status_codes === "string") {
            http_status_codes = http_status_codes.replace(" ", "").split(",");
        }

        this.settings.http_success = http_status_codes;
        this.callFlash("SetHTTPSuccess", [http_status_codes]);
    };

    // Public: setHTTPSuccess changes the http_success setting
    SWFUpload.prototype.setAssumeSuccessTimeout = function (timeout_seconds) {
        this.settings.assume_success_timeout = timeout_seconds;
        this.callFlash("SetAssumeSuccessTimeout", [timeout_seconds]);
    };

    // Public: setDebugEnabled changes the debug_enabled setting
    SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
        this.settings.debug_enabled = debugEnabled;
        this.callFlash("SetDebugEnabled", [debugEnabled]);
    };

    // Public: setButtonImageURL loads a button image sprite
    SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
        if (buttonImageURL == undefined) {
            buttonImageURL = "";
        }

        this.settings.button_image_url = buttonImageURL;
        this.callFlash("SetButtonImageURL", [buttonImageURL]);
    };

    // Public: setButtonDimensions resizes the Flash Movie and button
    SWFUpload.prototype.setButtonDimensions = function (width, height) {
        this.settings.button_width = width;
        this.settings.button_height = height;

        var movie = this.getMovieElement();
        if (movie != undefined) {
            movie.style.width = width + "px";
            movie.style.height = height + "px";
        }

        this.callFlash("SetButtonDimensions", [width, height]);
    };
    // Public: setButtonText Changes the text overlaid on the button
    SWFUpload.prototype.setButtonText = function (html) {
        this.settings.button_text = html;
        this.callFlash("SetButtonText", [html]);
    };
    // Public: setButtonTextPadding changes the top and left padding of the text overlay
    SWFUpload.prototype.setButtonTextPadding = function (left, top) {
        this.settings.button_text_top_padding = top;
        this.settings.button_text_left_padding = left;
        this.callFlash("SetButtonTextPadding", [left, top]);
    };

    // Public: setButtonTextStyle changes the CSS used to style the HTML/Text overlaid on the button
    SWFUpload.prototype.setButtonTextStyle = function (css) {
        this.settings.button_text_style = css;
        this.callFlash("SetButtonTextStyle", [css]);
    };
    // Public: setButtonDisabled disables/enables the button
    SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
        this.settings.button_disabled = isDisabled;
        this.callFlash("SetButtonDisabled", [isDisabled]);
    };
    // Public: setButtonAction sets the action that occurs when the button is clicked
    SWFUpload.prototype.setButtonAction = function (buttonAction) {
        this.settings.button_action = buttonAction;
        this.callFlash("SetButtonAction", [buttonAction]);
    };

    // Public: setButtonCursor changes the mouse cursor displayed when hovering over the button
    SWFUpload.prototype.setButtonCursor = function (cursor) {
        this.settings.button_cursor = cursor;
        this.callFlash("SetButtonCursor", [cursor]);
    };

    /* *******************************
     Flash Event Interfaces
     These functions are used by Flash to trigger the various
     events.

     All these functions a Private.

     Because the ExternalInterface library is buggy the event calls
     are added to a queue and the queue then executed by a setTimeout.
     This ensures that events are executed in a determinate order and that
     the ExternalInterface bugs are avoided.
     ******************************* */

    SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
        // Warning: Don't call this.debug inside here or you'll create an infinite loop
        var self = this;

        if (argumentArray == undefined) {
            argumentArray = [];
        } else if (!(argumentArray instanceof Array)) {
            argumentArray = [argumentArray];
        }

        if (typeof this.settings[handlerName] === "function") {
            // Queue the event
            this.eventQueue.push(function () {
                this.settings[handlerName].apply(this, argumentArray);
            });

            // Execute the next queued event
            setTimeout(function () {
                self.executeNextEvent();
            }, 0);

        } else if (this.settings[handlerName] !== null) {
            throw "Event handler " + handlerName + " is unknown or is not a function";
        }
    };

    // Private: Causes the next event in the queue to be executed.  Since events are queued using a setTimeout
    // we must queue them in order to garentee that they are executed in order.
    SWFUpload.prototype.executeNextEvent = function () {
        // Warning: Don't call this.debug inside here or you'll create an infinite loop

        var f = this.eventQueue ? this.eventQueue.shift() : null;
        if (typeof(f) === "function") {
            f.apply(this);
        }

    };

    // Private: unescapeFileParams is part of a workaround for a flash bug where objects passed through ExternalInterface cannot have
    // properties that contain characters that are not valid for JavaScript identifiers. To work around this
    // the Flash Component escapes the parameter names and we must unescape again before passing them along.
    SWFUpload.prototype.unescapeFilePostParams = function (file) {
        var reg = /[$]([0-9a-f]{4})/i, unescapedPost = {}, uk, k, match;

        if (file != undefined) {
            for (k in file.post) {
                if (file.post.hasOwnProperty(k)) {
                    uk = k;
                    while ((match = reg.exec(uk)) !== null) {
                        uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
                    }
                    unescapedPost[uk] = file.post[k];
                }
            }

            file.post = unescapedPost;
        }

        return file;
    };

    // Private: This event is called by SWFUpload Init after we've determined what the user's Flash Player supports.
    // Use the swfupload_preload_handler event setting to execute custom code when SWFUpload has loaded.
    // Return false to prevent SWFUpload from loading and allow your script to do something else if your required feature is
    // not supported
    SWFUpload.prototype.swfuploadPreload = function () {
        var returnValue;
        if (typeof this.settings.swfupload_preload_handler === "function") {
            returnValue = this.settings.swfupload_preload_handler.call(this);
        } else if (this.settings.swfupload_preload_handler != undefined) {
            throw "upload_start_handler must be a function";
        }

        // Convert undefined to true so if nothing is returned from the upload_start_handler it is
        // interpretted as 'true'.
        if (returnValue === undefined) {
            returnValue = true;
        }

        return !!returnValue;
    }

    // Private: This event is called by Flash when it has finished loading. Don't modify this.
    // Use the swfupload_loaded_handler event setting to execute custom code when SWFUpload has loaded.
    SWFUpload.prototype.flashReady = function () {
        // Check that the movie element is loaded correctly with its ExternalInterface methods defined
        var movieElement = this.cleanUp();

        if (!movieElement) {
            this.debug("Flash called back ready but the flash movie can't be found.");
            return;
        }

        this.queueEvent("swfupload_loaded_handler");
    };

    // Private: removes Flash added fuctions to the DOM node to prevent memory leaks in IE.
    // This function is called by Flash each time the ExternalInterface functions are created.
    SWFUpload.prototype.cleanUp = function () {
        var key, movieElement = this.getMovieElement();

        // Pro-actively unhook all the Flash functions
        try {
            if (movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
                this.debug("Removing Flash functions hooks (this should only run in IE and should prevent memory leaks)");
                for (key in movieElement) {
                    try {
                        if (typeof(movieElement[key]) === "function") {
                            movieElement[key] = null;
                        }
                    } catch (ex) {
                    }
                }
            }
        } catch (ex1) {

        }

        // Fix Flashes own cleanup code so if the SWF Movie was removed from the page
        // it doesn't display errors.
        window["__flash__removeCallback"] = function (instance, name) {
            try {
                if (instance) {
                    instance[name] = null;
                }
            } catch (flashEx) {

            }
        };

        return movieElement;
    };

    /* When the button_action is set to None this event gets fired and executes the mouse_click_handler */
    SWFUpload.prototype.mouseClick = function () {
        this.queueEvent("mouse_click_handler");
    };
    SWFUpload.prototype.mouseOver = function () {
        this.queueEvent("mouse_over_handler");
    };
    SWFUpload.prototype.mouseOut = function () {
        this.queueEvent("mouse_out_handler");
    };

    /* This is a chance to do something before the browse window opens */
    SWFUpload.prototype.fileDialogStart = function () {
        this.queueEvent("file_dialog_start_handler");
    };


    /* Called when a file is successfully added to the queue. */
    SWFUpload.prototype.fileQueued = function (file) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("file_queued_handler", file);
    };


    /* Handle errors that occur when an attempt to queue a file fails. */
    SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
    };

    /* Called after the file dialog has closed and the selected files have been queued.
     You could call startUpload here if you want the queued files to begin uploading immediately. */
    SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued, numFilesInQueue) {
        this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued, numFilesInQueue]);
    };

    SWFUpload.prototype.uploadResizeStart = function (file, resizeSettings) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("upload_resize_start_handler", [file, resizeSettings.width, resizeSettings.height, resizeSettings.encoding, resizeSettings.quality]);
    };

    SWFUpload.prototype.uploadStart = function (file) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("return_upload_start_handler", file);
    };

    SWFUpload.prototype.returnUploadStart = function (file) {
        var returnValue;
        if (typeof this.settings.upload_start_handler === "function") {
            file = this.unescapeFilePostParams(file);
            returnValue = this.settings.upload_start_handler.call(this, file);
        } else if (this.settings.upload_start_handler != undefined) {
            throw "upload_start_handler must be a function";
        }

        // Convert undefined to true so if nothing is returned from the upload_start_handler it is
        // interpretted as 'true'.
        if (returnValue === undefined) {
            returnValue = true;
        }

        returnValue = !!returnValue;

        this.callFlash("ReturnUploadStart", [returnValue]);
    };


    SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
    };

    SWFUpload.prototype.uploadError = function (file, errorCode, message) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("upload_error_handler", [file, errorCode, message]);
    };

    SWFUpload.prototype.uploadSuccess = function (file, serverData, responseReceived) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("upload_success_handler", [file, serverData, responseReceived]);
    };

    SWFUpload.prototype.uploadComplete = function (file) {
        file = this.unescapeFilePostParams(file);
        this.queueEvent("upload_complete_handler", file);
    };

    /* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
     internal debug console.  You can override this event and have messages written where you want. */
    SWFUpload.prototype.debug = function (message) {
        this.queueEvent("debug_handler", message);
    };


    /* **********************************
     Debug Console
     The debug console is a self contained, in page location
     for debug message to be sent.  The Debug Console adds
     itself to the body if necessary.

     The console is automatically scrolled as messages appear.

     If you are using your own debug handler or when you deploy to production and
     have debug disabled you can remove these functions to reduce the file size
     and complexity.
     ********************************** */

    // Private: debugMessage is the default debug_handler.  If you want to print debug messages
    // call the debug() function.  When overriding the function your own function should
    // check to see if the debug setting is true before outputting debug information.
    SWFUpload.prototype.debugMessage = function (message) {
        var exceptionMessage, exceptionValues, key;

        if (this.settings.debug) {
            exceptionValues = [];

            // Check for an exception object and print it nicely
            if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
                for (key in message) {
                    if (message.hasOwnProperty(key)) {
                        exceptionValues.push(key + ": " + message[key]);
                    }
                }
                exceptionMessage = exceptionValues.join("\n") || "";
                exceptionValues = exceptionMessage.split("\n");
                exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
                SWFUpload.Console.writeLine(exceptionMessage);
            } else {
                SWFUpload.Console.writeLine(message);
            }
        }
    };

    SWFUpload.Console = {};
    SWFUpload.Console.writeLine = function (message) {
        var console, documentForm;

        try {
            console = document.getElementById("SWFUpload_Console");

            if (!console) {
                documentForm = document.createElement("form");
                document.getElementsByTagName("body")[0].appendChild(documentForm);

                console = document.createElement("textarea");
                console.id = "SWFUpload_Console";
                console.style.fontFamily = "monospace";
                console.setAttribute("wrap", "off");
                console.wrap = "off";
                console.style.overflow = "auto";
                console.style.width = "700px";
                console.style.height = "350px";
                console.style.margin = "5px";
                documentForm.appendChild(console);
            }

            console.value += message + "\n";

            console.scrollTop = console.scrollHeight - console.clientHeight;
        } catch (ex) {
            alert("Exception: " + ex.name + " Message: " + ex.message);
        }
    };


    /*	SWFObject v2.2 <http://code.google.com/p/swfobject/>
     is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
     */
    swfobject = function () {
        var D = "undefined", r = "object", S = "Shockwave Flash", W = "ShockwaveFlash.ShockwaveFlash", q = "application/x-shockwave-flash", R = "SWFObjectExprInst", x = "onreadystatechange", O = window, j = document, t = navigator, T = false, U = [h], o = [], N = [], I = [], l, Q, E, B, J = false, a = false, n, G, m = true, M = function () {
            var aa = typeof j.getElementById != D && typeof j.getElementsByTagName != D && typeof j.createElement != D, ah = t.userAgent.toLowerCase(), Y = t.platform.toLowerCase(), ae = Y ? /win/.test(Y) : /win/.test(ah), ac = Y ? /mac/.test(Y) : /mac/.test(ah), af = /webkit/.test(ah) ? parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, X = !+"\v1", ag = [0, 0, 0], ab = null;
            if (typeof t.plugins != D && typeof t.plugins[S] == r) {
                ab = t.plugins[S].description;
                if (ab && !(typeof t.mimeTypes != D && t.mimeTypes[q] && !t.mimeTypes[q].enabledPlugin)) {
                    T = true;
                    X = false;
                    ab = ab.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
                    ag[0] = parseInt(ab.replace(/^(.*)\..*$/, "$1"), 10);
                    ag[1] = parseInt(ab.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
                    ag[2] = /[a-zA-Z]/.test(ab) ? parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0
                }
            } else {
                if (typeof O.ActiveXObject != D) {
                    try {
                        var ad = new ActiveXObject(W);
                        if (ad) {
                            ab = ad.GetVariable("$version");
                            if (ab) {
                                X = true;
                                ab = ab.split(" ")[1].split(",");
                                ag = [parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10)]
                            }
                        }
                    } catch (Z) {
                    }
                }
            }
            return {w3: aa, pv: ag, wk: af, ie: X, win: ae, mac: ac}
        }(), k = function () {
            if (!M.w3) {
                return
            }
            if ((typeof j.readyState != D && j.readyState == "complete") || (typeof j.readyState == D && (j.getElementsByTagName("body")[0] || j.body))) {
                f()
            }
            if (!J) {
                if (typeof j.addEventListener != D) {
                    j.addEventListener("DOMContentLoaded", f, false)
                }
                if (M.ie && M.win) {
                    j.attachEvent(x, function () {
                        if (j.readyState == "complete") {
                            j.detachEvent(x, arguments.callee);
                            f()
                        }
                    });
                    if (O == top) {
                        (function () {
                            if (J) {
                                return
                            }
                            try {
                                j.documentElement.doScroll("left")
                            } catch (X) {
                                setTimeout(arguments.callee, 0);
                                return
                            }
                            f()
                        })()
                    }
                }
                if (M.wk) {
                    (function () {
                        if (J) {
                            return
                        }
                        if (!/loaded|complete/.test(j.readyState)) {
                            setTimeout(arguments.callee, 0);
                            return
                        }
                        f()
                    })()
                }
                s(f)
            }
        }();

        function f() {
            if (J) {
                return
            }
            try {
                var Z = j.getElementsByTagName("body")[0].appendChild(C("span"));
                Z.parentNode.removeChild(Z)
            } catch (aa) {
                return
            }
            J = true;
            var X = U.length;
            for (var Y = 0; Y < X; Y++) {
                U[Y]()
            }
        }

        function K(X) {
            if (J) {
                X()
            } else {
                U[U.length] = X
            }
        }

        function s(Y) {
            if (typeof O.addEventListener != D) {
                O.addEventListener("load", Y, false)
            } else {
                if (typeof j.addEventListener != D) {
                    j.addEventListener("load", Y, false)
                } else {
                    if (typeof O.attachEvent != D) {
                        i(O, "onload", Y)
                    } else {
                        if (typeof O.onload == "function") {
                            var X = O.onload;
                            O.onload = function () {
                                X();
                                Y()
                            }
                        } else {
                            O.onload = Y
                        }
                    }
                }
            }
        }

        function h() {
            if (T) {
                V()
            } else {
                H()
            }
        }

        function V() {
            var X = j.getElementsByTagName("body")[0];
            var aa = C(r);
            aa.setAttribute("type", q);
            var Z = X.appendChild(aa);
            if (Z) {
                var Y = 0;
                (function () {
                    if (typeof Z.GetVariable != D) {
                        var ab = Z.GetVariable("$version");
                        if (ab) {
                            ab = ab.split(" ")[1].split(",");
                            M.pv = [parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10)]
                        }
                    } else {
                        if (Y < 10) {
                            Y++;
                            setTimeout(arguments.callee, 10);
                            return
                        }
                    }
                    X.removeChild(aa);
                    Z = null;
                    H()
                })()
            } else {
                H()
            }
        }

        function H() {
            var ag = o.length;
            if (ag > 0) {
                for (var af = 0; af < ag; af++) {
                    var Y = o[af].id;
                    var ab = o[af].callbackFn;
                    var aa = {success: false, id: Y};
                    if (M.pv[0] > 0) {
                        var ae = c(Y);
                        if (ae) {
                            if (F(o[af].swfVersion) && !(M.wk && M.wk < 312)) {
                                w(Y, true);
                                if (ab) {
                                    aa.success = true;
                                    aa.ref = z(Y);
                                    ab(aa)
                                }
                            } else {
                                if (o[af].expressInstall && A()) {
                                    var ai = {};
                                    ai.data = o[af].expressInstall;
                                    ai.width = ae.getAttribute("width") || "0";
                                    ai.height = ae.getAttribute("height") || "0";
                                    if (ae.getAttribute("class")) {
                                        ai.styleclass = ae.getAttribute("class")
                                    }
                                    if (ae.getAttribute("align")) {
                                        ai.align = ae.getAttribute("align")
                                    }
                                    var ah = {};
                                    var X = ae.getElementsByTagName("param");
                                    var ac = X.length;
                                    for (var ad = 0; ad < ac; ad++) {
                                        if (X[ad].getAttribute("name").toLowerCase() != "movie") {
                                            ah[X[ad].getAttribute("name")] = X[ad].getAttribute("value")
                                        }
                                    }
                                    P(ai, ah, Y, ab)
                                } else {
                                    p(ae);
                                    if (ab) {
                                        ab(aa)
                                    }
                                }
                            }
                        }
                    } else {
                        w(Y, true);
                        if (ab) {
                            var Z = z(Y);
                            if (Z && typeof Z.SetVariable != D) {
                                aa.success = true;
                                aa.ref = Z
                            }
                            ab(aa)
                        }
                    }
                }
            }
        }

        function z(aa) {
            var X = null;
            var Y = c(aa);
            if (Y && Y.nodeName == "OBJECT") {
                if (typeof Y.SetVariable != D) {
                    X = Y
                } else {
                    var Z = Y.getElementsByTagName(r)[0];
                    if (Z) {
                        X = Z
                    }
                }
            }
            return X
        }

        function A() {
            return !a && F("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312)
        }

        function P(aa, ab, X, Z) {
            a = true;
            E = Z || null;
            B = {success: false, id: X};
            var ae = c(X);
            if (ae) {
                if (ae.nodeName == "OBJECT") {
                    l = g(ae);
                    Q = null
                } else {
                    l = ae;
                    Q = X
                }
                aa.id = R;
                if (typeof aa.width == D || (!/%$/.test(aa.width) && parseInt(aa.width, 10) < 310)) {
                    aa.width = "310"
                }
                if (typeof aa.height == D || (!/%$/.test(aa.height) && parseInt(aa.height, 10) < 137)) {
                    aa.height = "137"
                }
                j.title = j.title.slice(0, 47) + " - Flash Player Installation";
                var ad = M.ie && M.win ? "ActiveX" : "PlugIn", ac = "MMredirectURL=" + O.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + ad + "&MMdoctitle=" + j.title;
                if (typeof ab.flashvars != D) {
                    ab.flashvars += "&" + ac
                } else {
                    ab.flashvars = ac
                }
                if (M.ie && M.win && ae.readyState != 4) {
                    var Y = C("div");
                    X += "SWFObjectNew";
                    Y.setAttribute("id", X);
                    ae.parentNode.insertBefore(Y, ae);
                    ae.style.display = "none";
                    (function () {
                        if (ae.readyState == 4) {
                            ae.parentNode.removeChild(ae)
                        } else {
                            setTimeout(arguments.callee, 10)
                        }
                    })()
                }
                u(aa, ab, X)
            }
        }

        function p(Y) {
            if (M.ie && M.win && Y.readyState != 4) {
                var X = C("div");
                Y.parentNode.insertBefore(X, Y);
                X.parentNode.replaceChild(g(Y), X);
                Y.style.display = "none";
                (function () {
                    if (Y.readyState == 4) {
                        Y.parentNode.removeChild(Y)
                    } else {
                        setTimeout(arguments.callee, 10)
                    }
                })()
            } else {
                Y.parentNode.replaceChild(g(Y), Y)
            }
        }

        function g(ab) {
            var aa = C("div");
            if (M.win && M.ie) {
                aa.innerHTML = ab.innerHTML
            } else {
                var Y = ab.getElementsByTagName(r)[0];
                if (Y) {
                    var ad = Y.childNodes;
                    if (ad) {
                        var X = ad.length;
                        for (var Z = 0; Z < X; Z++) {
                            if (!(ad[Z].nodeType == 1 && ad[Z].nodeName == "PARAM") && !(ad[Z].nodeType == 8)) {
                                aa.appendChild(ad[Z].cloneNode(true))
                            }
                        }
                    }
                }
            }
            return aa
        }

        function u(ai, ag, Y) {
            var X, aa = c(Y);
            if (M.wk && M.wk < 312) {
                return X
            }
            if (aa) {
                if (typeof ai.id == D) {
                    ai.id = Y
                }
                if (M.ie && M.win) {
                    var ah = "";
                    for (var ae in ai) {
                        if (ai[ae] != Object.prototype[ae]) {
                            if (ae.toLowerCase() == "data") {
                                ag.movie = ai[ae]
                            } else {
                                if (ae.toLowerCase() == "styleclass") {
                                    ah += ' class="' + ai[ae] + '"'
                                } else {
                                    if (ae.toLowerCase() != "classid") {
                                        ah += " " + ae + '="' + ai[ae] + '"'
                                    }
                                }
                            }
                        }
                    }
                    var af = "";
                    for (var ad in ag) {
                        if (ag[ad] != Object.prototype[ad]) {
                            af += '<param name="' + ad + '" value="' + ag[ad] + '" />'
                        }
                    }
                    aa.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + ah + ">" + af + "</object>";
                    N[N.length] = ai.id;
                    X = c(ai.id)
                } else {
                    var Z = C(r);
                    Z.setAttribute("type", q);
                    for (var ac in ai) {
                        if (ai[ac] != Object.prototype[ac]) {
                            if (ac.toLowerCase() == "styleclass") {
                                Z.setAttribute("class", ai[ac])
                            } else {
                                if (ac.toLowerCase() != "classid") {
                                    Z.setAttribute(ac, ai[ac])
                                }
                            }
                        }
                    }
                    for (var ab in ag) {
                        if (ag[ab] != Object.prototype[ab] && ab.toLowerCase() != "movie") {
                            e(Z, ab, ag[ab])
                        }
                    }
                    aa.parentNode.replaceChild(Z, aa);
                    X = Z
                }
            }
            return X
        }

        function e(Z, X, Y) {
            var aa = C("param");
            aa.setAttribute("name", X);
            aa.setAttribute("value", Y);
            Z.appendChild(aa)
        }

        function y(Y) {
            var X = c(Y);
            if (X && X.nodeName == "OBJECT") {
                if (M.ie && M.win) {
                    X.style.display = "none";
                    (function () {
                        if (X.readyState == 4) {
                            b(Y)
                        } else {
                            setTimeout(arguments.callee, 10)
                        }
                    })()
                } else {
                    X.parentNode.removeChild(X)
                }
            }
        }

        function b(Z) {
            var Y = c(Z);
            if (Y) {
                for (var X in Y) {
                    if (typeof Y[X] == "function") {
                        Y[X] = null
                    }
                }
                Y.parentNode.removeChild(Y)
            }
        }

        function c(Z) {
            var X = null;
            try {
                X = j.getElementById(Z)
            } catch (Y) {
            }
            return X
        }

        function C(X) {
            return j.createElement(X)
        }

        function i(Z, X, Y) {
            Z.attachEvent(X, Y);
            I[I.length] = [Z, X, Y]
        }

        function F(Z) {
            var Y = M.pv, X = Z.split(".");
            X[0] = parseInt(X[0], 10);
            X[1] = parseInt(X[1], 10) || 0;
            X[2] = parseInt(X[2], 10) || 0;
            return (Y[0] > X[0] || (Y[0] == X[0] && Y[1] > X[1]) || (Y[0] == X[0] && Y[1] == X[1] && Y[2] >= X[2])) ? true : false
        }

        function v(ac, Y, ad, ab) {
            if (M.ie && M.mac) {
                return
            }
            var aa = j.getElementsByTagName("head")[0];
            if (!aa) {
                return
            }
            var X = (ad && typeof ad == "string") ? ad : "screen";
            if (ab) {
                n = null;
                G = null
            }
            if (!n || G != X) {
                var Z = C("style");
                Z.setAttribute("type", "text/css");
                Z.setAttribute("media", X);
                n = aa.appendChild(Z);
                if (M.ie && M.win && typeof j.styleSheets != D && j.styleSheets.length > 0) {
                    n = j.styleSheets[j.styleSheets.length - 1]
                }
                G = X
            }
            if (M.ie && M.win) {
                if (n && typeof n.addRule == r) {
                    n.addRule(ac, Y)
                }
            } else {
                if (n && typeof j.createTextNode != D) {
                    n.appendChild(j.createTextNode(ac + " {" + Y + "}"))
                }
            }
        }

        function w(Z, X) {
            if (!m) {
                return
            }
            var Y = X ? "visible" : "hidden";
            if (J && c(Z)) {
                c(Z).style.visibility = Y
            } else {
                v("#" + Z, "visibility:" + Y)
            }
        }

        function L(Y) {
            var Z = /[\\\"<>\.;]/;
            var X = Z.exec(Y) != null;
            return X && typeof encodeURIComponent != D ? encodeURIComponent(Y) : Y
        }

        var d = function () {
            if (M.ie && M.win) {
                window.attachEvent("onunload", function () {
                    var ac = I.length;
                    for (var ab = 0; ab < ac; ab++) {
                        I[ab][0].detachEvent(I[ab][1], I[ab][2])
                    }
                    var Z = N.length;
                    for (var aa = 0; aa < Z; aa++) {
                        y(N[aa])
                    }
                    for (var Y in M) {
                        M[Y] = null
                    }
                    M = null;
                    for (var X in swfobject) {
                        swfobject[X] = null
                    }
                    swfobject = null
                })
            }
        }();
        return {
            registerObject: function (ab, X, aa, Z) {
                if (M.w3 && ab && X) {
                    var Y = {};
                    Y.id = ab;
                    Y.swfVersion = X;
                    Y.expressInstall = aa;
                    Y.callbackFn = Z;
                    o[o.length] = Y;
                    w(ab, false)
                } else {
                    if (Z) {
                        Z({success: false, id: ab})
                    }
                }
            }, getObjectById: function (X) {
                if (M.w3) {
                    return z(X)
                }
            }, embedSWF: function (ab, ah, ae, ag, Y, aa, Z, ad, af, ac) {
                var X = {success: false, id: ah};
                if (M.w3 && !(M.wk && M.wk < 312) && ab && ah && ae && ag && Y) {
                    w(ah, false);
                    K(function () {
                        ae += "";
                        ag += "";
                        var aj = {};
                        if (af && typeof af === r) {
                            for (var al in af) {
                                aj[al] = af[al]
                            }
                        }
                        aj.data = ab;
                        aj.width = ae;
                        aj.height = ag;
                        var am = {};
                        if (ad && typeof ad === r) {
                            for (var ak in ad) {
                                am[ak] = ad[ak]
                            }
                        }
                        if (Z && typeof Z === r) {
                            for (var ai in Z) {
                                if (typeof am.flashvars != D) {
                                    am.flashvars += "&" + ai + "=" + Z[ai]
                                } else {
                                    am.flashvars = ai + "=" + Z[ai]
                                }
                            }
                        }
                        if (F(Y)) {
                            var an = u(aj, am, ah);
                            if (aj.id == ah) {
                                w(ah, true)
                            }
                            X.success = true;
                            X.ref = an
                        } else {
                            if (aa && A()) {
                                aj.data = aa;
                                P(aj, am, ah, ac);
                                return
                            } else {
                                w(ah, true)
                            }
                        }
                        if (ac) {
                            ac(X)
                        }
                    })
                } else {
                    if (ac) {
                        ac(X)
                    }
                }
            }, switchOffAutoHideShow: function () {
                m = false
            }, ua: M, getFlashPlayerVersion: function () {
                return {major: M.pv[0], minor: M.pv[1], release: M.pv[2]}
            }, hasFlashPlayerVersion: F, createSWF: function (Z, Y, X) {
                if (M.w3) {
                    return u(Z, Y, X)
                } else {
                    return undefined
                }
            }, showExpressInstall: function (Z, aa, X, Y) {
                if (M.w3 && A()) {
                    P(Z, aa, X, Y)
                }
            }, removeSWF: function (X) {
                if (M.w3) {
                    y(X)
                }
            }, createCSS: function (aa, Z, Y, X) {
                if (M.w3) {
                    v(aa, Z, Y, X)
                }
            }, addDomLoadEvent: K, addLoadEvent: s, getQueryParamValue: function (aa) {
                var Z = j.location.search || j.location.hash;
                if (Z) {
                    if (/\?/.test(Z)) {
                        Z = Z.split("?")[1]
                    }
                    if (aa == null) {
                        return L(Z)
                    }
                    var Y = Z.split("&");
                    for (var X = 0; X < Y.length; X++) {
                        if (Y[X].substring(0, Y[X].indexOf("=")) == aa) {
                            return L(Y[X].substring((Y[X].indexOf("=") + 1)))
                        }
                    }
                }
                return ""
            }, expressInstallCallback: function () {
                if (a) {
                    var X = c(R);
                    if (X && l) {
                        X.parentNode.replaceChild(l, X);
                        if (Q) {
                            w(Q, true);
                            if (M.ie && M.win) {
                                l.style.display = "block"
                            }
                        }
                        if (E) {
                            E(B)
                        }
                    }
                    a = false
                }
            }
        }
    }();
    swfobject.addDomLoadEvent(function () {
        if (typeof(SWFUpload.onload) === "function") {
            SWFUpload.onload.call(window);
        }
    });
})();

// ---------------------------------------------------------------------------------------- swfobject end

/**
 * AXUpload5
 * @class AXUpload5
 * @extends AXJ
 * @version v1.4.6
 * @author tom@axisj.com
 * @logs
 "2013-10-02 오후 2:19:36 - 시작 tom",
 "2013-10-12 오전 11:13:06 - 업로드 서버오류 예외 처리 tom",
 "2013-10-29 오후 3:26:33 - 최지연 : 기타 버그 패치",
 "2013-10-30 오후 3:38:05 - config.uploadPars, config.deletePars 초기 설정값 패치 by tom",
 "2013-12-11 오후 5:15:51 - tom&root setUploadedList, setUpoadeFile 버그패치",
 "2013-12-17 오전 11:24:38 - tom : AXUploadPreview css 적용",
 "2014-02-11 오후 3:29:51 - tom : deleteFile 개선, 서버 JSON에 error 가 없으면 정상 처리 되도록 변경",
 "2014-02-23 오후 7:39:11 - tom : this.uploadedList 초기화 버그 픽스",
 "2014-02-23 오후 8:44:07 - <base> attr 인식 처리 구문 추가",
 "2014-04-10 - tom : 설정에 선언된 파일타입 체크하여 파일 셀렉트와 드랍 방지 처리 구문 추가",
 "2014-04-10 - tom : fileSelectAutoUpload 옵션 flash 모드에서 작동 하도록 픽스",
 "2014-05-15 - tom : 파일선택 갯수 선택오류 버그 픽스 / fileSelectAutoUpload 버그 픽스",
 "2014-05-23 - tom : file mimeType 이 없는 경우 업로드 지원 구문 추가"
 "2014-06-04 tom : in single upload, reupload bugfix"
 "2014-06-14 tom : extend config option flash_file_types, flash_file_types_description"
 "2014-06-17 tom : [bugfix] file_types undefined"
 "2014-06-26 tom : [bugfix] http error exception when delete runs "
 "2014-12-22 tom : [bugfix] manual 업로드 갯수제한 버그 픽스 "
 "2015-01-04 tom : thumbUrl 값이 없을 때 썸네일 배경 예외 처리 "
 "2015-01-05 tom : queuebox class 가 listType일 때 progressbar 위치 조정"
 "2015-01-09 tom : onFileDrop uploadedCount 증가구문 수정 https://github.com/axisj-com/axisj/issues/385"
 "2015-01-16 tom : setUploadedList bug fix"
 "2015-02-06 John : getItemTag : openMode (view 모드 추가) list 모드 css 적용"
 "2015-02-07 tom : single 모드에서 fileDisplayHide: true 속성 추가"
 "2015-03-28 tom : https://github.com/axisj-com/axisj/issues/501 삭제후 리스트가 비었을 때 onDeleteAll 호출"
 "2015-04-01 tom : fileKeys 에 id 값 정의 기능 추가"
 "2015-04-06 tom : fileKeys 기본 맵핑방식 수정"
 "2015-05-14 HJ.Park : SWFUpload 모드에서 파일 사이즈 초과시 onError 메서드 호출하도록 수정 https://github.com/axisj-com/axisj/issues/559"
 "2015-05-21 tom : singleUpload setUploadedList 버그픽스 https://github.com/axisj-com/axisj/issues/580"
 "2015-08-02 tom : 업로드 버튼 태그 수정 / 업로드 완료시에 엘리먼트 초기화 기능 보류"
 "2015-08-03 tom : setUploadedList queue box clear"
 "2015-08-07 tom : 내부 키 id > _id_ 로 교체"
 "2015-11-24 tom : queueBoxAppendType:"prepend" 버그 픽스
 "drag & drop 버그 픽스 quebox.empty를 해서 dropZone 이 사라진 문제.
 "2016-08-10 tom : upload후 같은 파일 업로드 안되는 문제 해결
 * @description
 *
 ```js
 var myUpload = new AXUpload5();
 myUpload.setConfig(classConfig:JSObject);
 ```
 *
 */

/**
 * @method initialize.setConig
 * @param {Object} config - gridConfig
 * @description
 * 선언된 클래스를 사용하기 위해 속성을 정의합니다.
 * @example
 ```js
 var myUpload = new AXUPload5();
 myUpload.setConfig({
	targetID:"AXUpload5",               //{String} - 업로드 버튼 엘리먼트 아이디
	openMode: "view",                   //{String} - 업로드된 파일 삭제 아이콘 숨김
	buttonTxt:"파일올리기",              //[String] - 업로드 버튼 문구. 사용자가 지정하지 않으면 AXConfig 에서 정의한 값을 사용합니다.
	targetButtonClass:"Green",          //[String] - 업로드 버튼에 추가될 CSS 클래스
	uploadFileName:"files[]",           //{String} - 서버에 전송될 파일 파라미터 키이름
	file_types:"*.*",                   //{String} - upload 할 파일타입( *.* | audio/* | video/* | image/* | MIME_type (accept) )
	dropBoxID:"uploadQueueBox",         //{String} - 드래그 드랍 타겟 엘리먼트 아이디
	queueBoxID:"uploadQueueBox",        //{String} - 업로드된 파일 목록을 보여주는 업로드 큐박스 엘리먼트 아이디
	flash_url : "../../_AXJ/lib/swfupload.swf",         //[String] - html 5를 지원하지 않는 브라우저를 위한 swf upload 설정 원치 않는 경우엔 선언 하지 않아도 됩니다.
	flash9_url : "../../_AXJ/lib/swfupload_fp9.swf",    //[String] - html 5를 지원하지 않는 브라우저를 위한 swf upload 설정 원치 않는 경우엔 선언 하지 않아도 됩니다.
	onClickUploadedItem: function(){    //[fn] 업로드된 목록을 클릭했을 때 이벤트 콜백함수
		window.open(this.uploadedPath.dec() + this.saveName.dec(), "_blank", "width=500,height=500");
	},
	uploadMaxFileSize:(10*1024*1024),   //{Number} - 업로드 될 개별 파일 사이즈(클라이언트에서 제한하는 사이즈이며, 서버에서 설정되는 값이 아닙니다.)
	uploadMaxFileCount:3,               //{Number} - 업로드될 파일갯수 제한 0 은 무제한
	uploadUrl:"uploadFile.asp",         //{String} - 서버전송 URL
	uploadPars:{userID:"tom", userName:"액시스"},  //[JSObject] - 서버전송 URL 파라미터
	deleteUrl:"deleteFile.asp",         //{String} - 서버전송 URL
	deletePars:{userID:"tom", userName:"액시스"},  //[JSObject] - 서버전송 URL 파라미터
	fileKeys:{                          //[JSObject] - 서버에서 리턴하는 json key 정의 (id는 예약어 사용할 수 없음)
		id:"id",
		name:"name",
		type:"type",
		saveName:"saveName",
		fileSize:"fileSize",
		uploadedPath:"uploadedPath",
		thumbPath:"thumbUrl"            // 서버에서 키값을 다르게 설정 할 수 있다는 것을 확인 하기 위해 이름을 다르게 처리한 예제 입니다.
	},
	onbeforeFileSelect: function(){     //[fn] - 드랍되거나 파일이 선택되기 전에 이벤트 return true; 리턴하지 않으면 진행을 중지 합니다.
		trace(this);
		return true;
	},
	onUpload: function(){               //[fn] - 업로드가 완료되는 이벤트 콜백함수
		trace(this);
		//trace("onUpload");
	},
	onComplete: function(){             //[fn] - 업로드가 모두 완료되는 이벤트 콜백함수
		//trace(this);
		//trace("onComplete");
		$("#uploadCancelBtn").get(0).disabled = true; // 전송중지 버튼 제어
	},
	onStart: function(){                //[fn] - 업로드가 시작되는 이벤트 콜백함수
		//trace(this);
		//trace("onStart");
		$("#uploadCancelBtn").get(0).disabled = false; // 전송중지 버튼 제어
	},
	onDelete: function(){               //[fn] - 파일 삭제 완료되는 이벤트 콜백함수
		//trace(this);
		//trace("onDelete");
	},
	onError: function(errorType, extData){  //[fn] - 에러가 발생되었을 때 이벤트 콜백함수 [errorType, extData] 인자 사용
		if(errorType == "html5Support"){
			//dialog.push("The File APIs are not fully supported in this browser.");
		}else if(errorType == "fileSize"){
			trace(extData);
			alert("파일사이즈가 초과된 파일을 업로드 할 수 없습니다. 업로드 목록에서 제외 합니다.("+extData.name+" : "+extData.size.byte()+")");
		}else if(errorType == "fileCount"){
			alert("업로드 갯수 초과 초과된 아이템은 업로드 되지 않습니다.");
		}
	}
});

 ```
 */

var AXUpload5 = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.uploadedList = [];
        this.uploadingObj = null;
        this.queue = [];
        this.queueLive = false;
        this.isSingleUpload = false;
        this.config.uploadFileName = "fileData";
        this.config.file_types = "*.*";
        this.config.fileSelectAutoUpload = true;
        this.supportHtml5 = false;
        if (window.File && window.FileReader && window.FileList && window.Blob) this.supportHtml5 = true;
        if (!AXConfig.AXUpload5) {
            AXConfig.AXUpload5 = {buttonTxt: "Upload files"};
        }
        this.config.buttonTxt = AXConfig.AXUpload5.buttonTxt;
        this.fileKeys = { // 서버에서 리턴하는 json key 정의 (id 는 예약어 입니다.)
            _id_: "_id_",
            name: "name",
            type: "type",
            saveName: "saveName",
            fileSize: "fileSize",
            uploadedPath: "uploadedPath",
            thumbPath: "thumbPath"
        };
        this.config.flash_url = "/_AXJ/lib/swfupload.swf";
        this.config.flash9_url = "/_AXJ/lib/swfupload_fp9.swf";
        this.config.uploadPars = {};
        this.config.deletePars = {};
        this.config.queueBoxAppendType = "append";
    },
    init: function (reset) {
        var cfg = this.config;
        // 파일키 덮어쓰기 빠진 키 초기값으로 정의
        for (k in this.fileKeys) {
            if (typeof this.config.fileKeys === "undefined" || typeof this.config.fileKeys[k] === "undefined") this.config.fileKeys[k] = this.fileKeys[k];
        }
        if (reset == undefined) {
            if (!this.supportHtml5) {
                if (cfg.onError) cfg.onError("html5Support");
                this.swfinit(reset);
                return;
            }
        } else {
            if (!this.supportHtml5) {
                return;
            }
        }

        var baseUrl = axdom("base").attr("href");
        if (axf.isEmpty(baseUrl)) baseUrl = "";
        if (cfg.uploadUrl.left(1) == "/") {
            cfg.uploadUrl = baseUrl + cfg.uploadUrl;
        }
        if (cfg.deleteUrl.left(1) == "/") {
            cfg.deleteUrl = baseUrl + cfg.deleteUrl;
        }
        /* dropBoxID, queueBoxID 자동 생성 */
        if (cfg.dropBoxTarget) {
            if (cfg.dropBoxTarget.id === undefined || cfg.dropBoxTarget.id == "") {
                axdom(cfg.dropBoxTarget).attr("id", cfg.dropBoxTarget.id = cfg.dropBoxID = "AXJUnique_dropBox_" + axf.getUniqueId());
            } else if (axf.isEmpty(cfg.dropBoxID)) {
                cfg.dropBoxID = cfg.dropBoxTarget.id;
            }
        }
        if (cfg.queueBoxTarget) {
            if (cfg.queueBoxTarget.id === undefined || cfg.queueBoxTarget.id == "") {
                axdom(cfg.queueBoxTarget).attr("id", cfg.queueBoxTarget.id = cfg.queueBoxID = "AXJUnique_queueBox_" + axf.getUniqueId());
                alert(cfg.queueBoxID);
            } else if (axf.isEmpty(cfg.queueBoxID)) {
                cfg.queueBoxID = cfg.queueBoxTarget.id;
            }
        }

        this.target = axdom("#" + cfg.targetID);
        if (reset == undefined) {
            this.target.empty();
            this.uploadedList = [];
        }

        var inputFileMultiple = 'multiple="multiple"';
        var inputFileAccept = cfg.file_types;
        if (cfg.isSingleUpload) {
            inputFileMultiple = '';
        }
        if (!this.supportHtml5) {
            inputFileMultiple = '';
        }

        var po = [];
        /*
         po.push('<div style="position:relative;">');
         po.push('	<table style=""><tbody><tr><td id="'+cfg.targetID+'_AX_selectorTD">');
         po.push('	<input type="file" id="'+cfg.targetID+'_AX_files" '+inputFileMultiple+' accept="'+inputFileAccept+'" style="position:absolute;left:0px;top:0px;margin:0px;padding:0px;-moz-opacity: 0.0;opacity:.00;filter: alpha(opacity=0);" />');
         po.push('	<button type="button" class="AXButton '+cfg.targetButtonClass+'" id="'+cfg.targetID+'_AX_selector"><span class="AXFileSelector">'+(cfg.buttonTxt)+'</span></button>');
         po.push('	</td>');

         if(cfg.isSingleUpload && cfg.fileDisplayHide != true){
         po.push('<td>');
         po.push('<div class="AXFileDisplay" id="'+cfg.targetID+'_AX_display">'+AXConfig.AXUpload5.uploadSelectTxt+'</div>');
         po.push('</td>');
         }

         po.push('	</tr></tbody></table>');
         */

        po.push('<div style="position:relative;">');

        po.push('   <div style="float:left;">');
        po.push('	    <input type="file" id="' + cfg.targetID + '_AX_files" ' + inputFileMultiple + ' accept="' + inputFileAccept + '" style="position:absolute;left:0px;top:0px;margin:0px;padding:0px;-moz-opacity: 0.0;opacity:.00;filter: alpha(opacity=0);" />');
        po.push('	    <button type="button" class="AXButton ' + cfg.targetButtonClass + '" id="' + cfg.targetID + '_AX_selector"><span class="AXFileSelector">' + (cfg.buttonTxt) + '</span></button>');
        po.push('   </div>');

        if (cfg.isSingleUpload && cfg.fileDisplayHide != true) {
            po.push('   <div style="float:left;">');
            po.push('       <div class="AXFileDisplay" style="padding:3px; 5px;" id="' + cfg.targetID + '_AX_display">' + AXConfig.AXUpload5.uploadSelectTxt + '</div>');
            po.push('   </div>');
        }
        po.push('   <div style="clear:both;"></div>');

        po.push('</div>');
        this.target.empty();
        this.target.append(po.join(''));

        axdom('#' + cfg.targetID + '_AX_selectorTD').css({width: axdom('#' + cfg.targetID + '_AX_selector').outerWidth() + 5});
        axdom('#' + cfg.targetID + '_AX_files').css({width: axdom('#' + cfg.targetID + '_AX_selector').outerWidth(), height: axdom('#' + cfg.targetID + '_AX_selector').outerHeight()});

        var pauseQueue = this.pauseQueue.bind(this);
        var _this = this;

        axdom('#' + cfg.targetID + '_AX_selector').click(function (event) {

            if (cfg.onbeforeFileSelect) {
                if (!cfg.onbeforeFileSelect.call({
                        uploadedList: _this.uploadedList,
                        uploadMaxFileSize: cfg.uploadMaxFileSize,
                        uploadMaxFileCount: cfg.uploadMaxFileCount
                    })) {
                    return false;
                }
            }

            if (!cfg.isSingleUpload && cfg.uploadMaxFileCount != 0) {
                if (_this.uploadedList.length >= cfg.uploadMaxFileCount) {
                    cfg.onError("fileCount");
                    return false;
                }
            }

            pauseQueue();
            axdom('#' + cfg.targetID + '_AX_files').click();
        });

        var onFileSelect = this.onFileSelect.bind(this);
        var fileSelector = document.getElementById(cfg.targetID + '_AX_files');
        if (axf.browser.name == "ie" && axf.browser.version < 9) {

        } else {
            fileSelector.addEventListener('change', onFileSelect, false);
        }

        if (reset == undefined) {


            if (cfg.dropBoxID && this.supportHtml5) {

                axdom("#" + cfg.dropBoxID)
                    .addClass("allowDrop")
                    .html('<div class="dropZoneBox" id="' + cfg.dropBoxID + '_dropZoneBox" style="border:3px dashed #d7d7d7;display:none;"></div>');

                // ---------------- 옵션사항 s
                /*
                 axdom("#"+cfg.dropBoxID+"_dropZoneBox").show();
                 axdom("#"+cfg.dropBoxID+"_dropZoneBox").css({height:axdom("#"+cfg.dropBoxID).innerHeight()-6, width:axdom("#"+cfg.dropBoxID).innerWidth()-6});
                 setTimeout(function(){
                 axdom("#"+cfg.dropBoxID+"_dropZoneBox").fadeOut();
                 }, 2000);
                 */
                // ---------------- 옵션사항 e

                var onFileDragOver = this.onFileDragOver.bind(this);
                var onFileDrop = this.onFileDrop.bind(this);
                var dragZone = document.getElementById(cfg.dropBoxID);
                dragZone.addEventListener('dragover', function (evt) {
                    onFileDragOver(evt)
                }, false);

                var dropZone = document.getElementById(cfg.dropBoxID + "_dropZoneBox");
                dropZone.addEventListener('drop', function (evt) {

                    if (cfg.onbeforeFileSelect) {
                        if (!cfg.onbeforeFileSelect.call({
                                uploadedList: _this.uploadedList,
                                uploadMaxFileSize: cfg.uploadMaxFileSize,
                                uploadMaxFileCount: cfg.uploadMaxFileCount
                            })) {
                            evt.stopPropagation();
                            evt.preventDefault();
                            axdom("#" + cfg.dropBoxID).removeClass("onDrop");
                            axdom("#" + cfg.dropBoxID + "_dropZoneBox").hide();
                            return false;
                        }
                    }

                    if (!cfg.isSingleUpload && cfg.uploadMaxFileCount != 0) {
                        if (_this.uploadedList.length >= cfg.uploadMaxFileCount) {
                            evt.stopPropagation();
                            evt.preventDefault();
                            axdom("#" + cfg.dropBoxID).removeClass("onDrop");
                            axdom("#" + cfg.dropBoxID + "_dropZoneBox").hide();
                            cfg.onError("fileCount");
                            return false;
                        }
                    }

                    onFileDrop(evt)
                }, false);
            }

            if (cfg.queueBoxID) {
                this.multiSelector = new AXMultiSelect();
                this.multiSelector.setConfig({
                    selectStage: cfg.queueBoxID,
                    selectClassName: "readyselect",
                    beselectClassName: "beSelected",
                    selectingClassName: "AX_selecting"
                });
            }
        }
    },
    swfinit: function (reset) {
        var cfg = this.config;
        this.target = axdom("#" + cfg.targetID);

        var po = [];
        po.push('<div style="position:relative;">');
        po.push('	<table style="table-layout:fixed;width:100%;"><tbody><tr><td id="' + cfg.targetID + '_AX_selectorTD">');
        po.push('	<button type="button" class="AXButton ' + cfg.targetButtonClass + '" id="' + cfg.targetID + '_AX_selector"><span class="AXFileSelector">' + (cfg.buttonTxt) + '</span></button>');
        po.push('	<span id="spanButtonPlaceholder" class="AXUpload5flashUploadButton"></span>');
        po.push('	</td>');

        if (cfg.isSingleUpload) {
            po.push('<td>');
            po.push('<div class="AXFileDisplay" id="' + cfg.targetID + '_AX_display">' + AXConfig.AXUpload5.uploadSelectTxt + '</div>');
            po.push('</td>');
        }

        po.push('	<tr></tbody></table>');
        po.push('</div>');
        this.target.empty();
        this.target.append(po.join(''));

        axdom('#' + cfg.targetID + '_AX_selectorTD').css({width: axdom('#' + cfg.targetID + '_AX_selector').outerWidth() + 5});

        var btnW = axdom('#' + cfg.targetID + '_AX_selector').outerWidth();
        var btnH = axdom('#' + cfg.targetID + '_AX_selector').outerHeight();

        // functions --------------------------------------------------------------- s
        var uploadSuccess = this.uploadSuccess.bind(this);
        var onClickDeleteButton = this.onClickDeleteButton.bind(this);
        var onClickFileTitle = this.onClickFileTitle.bind(this);

        var file_dialog_complete_handler = function (numFilesSelected, numFilesQueued) {
            if (numFilesSelected > 0) {
                if (this.swfu.getStats().files_queued > 0) {
                    //if(this.settings.onStartUpload) this.settings.onStartUpload();
                    if (cfg.onStart) cfg.onStart.call(this.queue);
                }
            }
            this.swfu.startUpload();
        };
        var file_dialog_complete_handler_bind = file_dialog_complete_handler.bind(this);
        //--
        var file_queued_handler = function (file) {
            if (cfg.isSingleUpload) {
                var myFile = this.uploadedList.first();
                if (myFile) {
                    if (!confirm(AXConfig.AXUpload5.deleteConfirm)) {
                        this.cancelUpload();
                    }
                    ;
                    var uploadFn = function () {
                        var itemID = 'AX_' + file[cfg.fileKeys._id_];
                        this.queue.push({_id_: itemID, file: file});
                        axdom("#" + cfg.targetID + '_AX_display').empty();
                        axdom("#" + cfg.targetID + '_AX_display').append(this.getItemTag(itemID, file));
                    };
                    this.deleteFile(myFile, uploadFn.bind(this));
                    return;
                } else {
                    var itemID = 'AX_' + file[cfg.fileKeys._id_];
                    this.queue.push({_id_: itemID, file: file});
                    axdom("#" + cfg.targetID + '_AX_display').empty();
                    axdom("#" + cfg.targetID + '_AX_display').append(this.getItemTag(itemID, file));
                }
            } else {
                //cfg.uploadMaxFileCount
                if (cfg.uploadMaxFileCount != 0) {
                    if (this.uploadedList.length >= cfg.uploadMaxFileCount) {
                        cfg.onError("fileCount");
                        this.cancelUpload();
                        return;
                    }
                }

                //trace(file);
                //{"filestatus":-1, "name":"20130708175735_1.jpg", "type":".jpg", "id":"SWFUpload_0_0", "index":0, "modificationdate":"2013-10-04T08:51:27Z", "uploadtype":0, "post":{}, "size":891324, "creationdate":"2013-10-04T08:52:02Z"}
                var itemID = 'AX_' + file[cfg.fileKeys._id_];
                this.queue.push({_id_: itemID, file: file});
                //큐박스에 아이템 추가
                if (cfg.queueBoxAppendType == "prepend") axdom("#" + cfg.queueBoxID).prepend(this.getItemTag(itemID, file));
                else axdom("#" + cfg.queueBoxID).append(this.getItemTag(itemID, file));
                axdom("#" + cfg.queueBoxID).find("#" + itemID).fadeIn();
            }
        };
        var file_queued_handler_bind = file_queued_handler.bind(this);
        //--
        var file_queue_error_handler = function (file, errorCode, message) {
            try {
                if (errorCode === SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED) {
                    alert("You have attempted to queue too many files.\n" + (message === 0 ? "You have reached the upload limit." : "You may select " + (message > 1 ? "up to " + message + " files." : "one file.")));
                    return;
                }
                this.cancelUpload();
                if (cfg.onComplete) cfg.onComplete.call(this.uploadedList, this.uploadedList);

                switch (errorCode) {
                    case SWFUpload.QUEUE_ERROR.FILE_EXCEEDS_SIZE_LIMIT:
                        this.showMSG("File is too big.");
                        this.swfu.debug("Error Code: File too big, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
                        break;
                    case SWFUpload.QUEUE_ERROR.ZERO_BYTE_FILE:
                        this.showMSG("Cannot upload Zero Byte files.");
                        this.swfu.debug("Error Code: Zero byte file, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
                        break;
                    case SWFUpload.QUEUE_ERROR.INVALID_FILETYPE:
                        this.showMSG("Invalid File Type.");
                        this.swfu.debug("Error Code: Invalid File Type, File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
                        break;
                    default:
                        if (file !== null) {
                            this.showMSG("Unhandled Error");
                        }
                        this.swfu.debug("Error Code: " + errorCode + ", File name: " + file.name + ", File size: " + file.size + ", Message: " + message);
                        break;
                }
            } catch (ex) {
                this.debug(ex);
            }
        };
        var file_queue_error_handler_bind = file_queue_error_handler.bind(this);
        //--
        var upload_start_handler = function () {
            if (this.isSingleUpload) {

            } else {
                if (cfg.uploadMaxFileCount != 0) {
                    if (cfg.uploadMaxFileCount <= this.uploadedList.length) {
                        this.cancelUpload();
                    }
                }
            }
        };
        var upload_start_handler_bind = upload_start_handler.bind(this);
        //--
        var upload_progress_handler = function (file, bytesLoaded, bytesTotal) {
            var itemID = 'AX_' + file[cfg.fileKeys._id_];
            if (cfg.isSingleUpload) {
                axdom("#" + itemID).find(".AXUploadProcessBar").width(((bytesLoaded / bytesTotal) * 100).round(2) + "%");
            } else {
                axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadProcessBar").width(((bytesLoaded / bytesTotal) * 100).round(2) + "%");
            }
        };
        var upload_progress_handler_bind = upload_progress_handler.bind(this);
        //--
        var upload_error_handler = function (file, errorCode, message) {
            if (cfg.onError) {
                if (errorCode == SWFUpload.UPLOAD_ERROR.HTTP_ERROR && message == 413) {
                    errorCode = "fileSize";
                }

                cfg.onError(errorCode, file);
            }
        };
        var upload_error_handler_bind = upload_error_handler.bind(this);
        //--
        var upload_success_handler = function (file, res) {
            var itemID = 'AX_' + file[cfg.fileKeys._id_];

            try {
                if (typeof res == "string") res = res.object();
            } catch (e) {
                trace(e);
            }
            if (cfg.isSingleUpload) {

                axdom("#" + itemID + " .AXUploadBtns").show();
                axdom("#" + itemID + " .AXUploadLabel").show();
                axdom("#" + itemID + " .AXUploadTit").show();

                axdom("#" + itemID + " .AXUploadProcess").hide();

                uploadSuccess(file, itemID, res);
                // --------------------- s
                axdom("#" + itemID + " .AXUploadBtnsA").bind("click", function () {
                    onClickDeleteButton(itemID);
                });
                if (cfg.onClickUploadedItem) {
                    axdom("#" + itemID + " .AXUploadDownload").bind("click", function () {
                        onClickFileTitle(itemID);
                    });
                }

            } else {

                axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadBtns").show();
                axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadLabel").show();
                axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadProcess").hide();

                if (res[cfg.fileKeys.thumbPath]) {
                    axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadIcon").css({
                        "background-image": "url('" + (res[cfg.fileKeys.thumbPath] || "").dec() + "')"
                    }).addClass("AXUploadPreview").find("img.preview").remove();
                } else {
                    axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadIcon").css({"background-image": "url()"});
                    axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadIcon").html((res[cfg.fileKeys.type] || "").dec().replace(".", ""));
                }

                uploadSuccess(file, itemID, res);
                // --------------------- s
                axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadBtnsA").bind("click", function () {
                    onClickDeleteButton(itemID);
                });
                if (cfg.onClickUploadedItem) {
                    axdom("#" + cfg.queueBoxID).find("#" + itemID + " .AXUploadDownload").bind("click", function () {
                        onClickFileTitle(itemID);
                    });
                }
            }

            //큐에서 제거
            var updateQueue = [];
            axdom.each(this.queue, function () {
                if (this.id != itemID) updateQueue.push(this);
            });
            this.queue = updateQueue;
        };
        var upload_success_handler_bind = upload_success_handler.bind(this);
        //--
        var upload_complete_handler = function () {
            if (this.isSingleUpload) {
                this.uploadComplete();
            } else {
                if (this.swfu.getStats().files_queued === 0) {
                    this.uploadComplete();
                    this.swfu.settings.allowUpload = false;
                } else {
                    this.swfu.startUpload();
                }
            }
        };
        var upload_complete_handler_bind = upload_complete_handler.bind(this);
        //--
        var queue_complete_handler = function () {
            //alert("end");
        };
        var queue_complete_handler_bind = queue_complete_handler.bind(this);
        // functions --------------------------------------------------------------- e

        var settings = {
            flash_url: cfg.flash_url,
            flash9_url: cfg.flash9_url,
            upload_url: cfg.uploadUrl,
            file_post_name: cfg.uploadFileName,
            post_params: cfg.uploadPars,
            file_size_limit: cfg.uploadMaxFileSize,
            fileSelectAutoUpload: cfg.fileSelectAutoUpload,
            file_types: cfg.flash_file_types || "*.*",
            file_types_description: cfg.flash_file_types_description || "all",
            file_upload_limit: 0, //cfg.uploadMaxFileCount,
            file_queue_limit: 0,
            debug: false,

            // Button Settings
            button_image_url: "null",
            button_placeholder_id: "spanButtonPlaceholder",
            button_width: btnW,
            button_height: btnH,

            // The event handler functions are defined in handlers.js
            swfupload_preload_handler: function () {
            },
            swfupload_load_failed_handler: function () {
            },
            swfupload_loaded_handler: function () {
            },
            file_queued_handler: file_queued_handler_bind,
            file_queue_error_handler: file_queue_error_handler_bind,
            file_dialog_complete_handler: file_dialog_complete_handler_bind,
            upload_start_handler: upload_start_handler_bind,
            upload_progress_handler: upload_progress_handler_bind,
            upload_error_handler: upload_error_handler_bind,
            upload_success_handler: upload_success_handler_bind,
            upload_complete_handler: upload_complete_handler_bind,
            queue_complete_handler: queue_complete_handler_bind	// Queue plugin event
        };
        this.swfu = new SWFUpload(settings);

        if (cfg.queueBoxID) {
            this.multiSelector = new AXMultiSelect();
            this.multiSelector.setConfig({
                selectStage: cfg.queueBoxID,
                selectClassName: "readyselect",
                beselectClassName: "beSelected"
            });
        }
    },
    getItemTag: function (itemID, f) {
        var cfg = this.config;
        var po = [];

        if (cfg.isSingleUpload) {
            po.push('<div class="AXUploadItem ' + (cfg.openMode || "") + '" id="' + itemID + '">');
            po.push('	<div class="AXUploadBtns" style="display:none;">');
            po.push('		<a href="#AXExecption" class="AXUploadBtnsA" id="' + itemID + '_AXUploadBtns_deleteFile">del</a>');
            po.push('	</div>');
            po.push('	<div class="AXUploadLabel ' + (cfg.openMode || "") + '" style="display:none;">');
            if (cfg.openMode != "view") po.push('		<a href="#AXExecption" id="' + itemID + '_AXUploadLabel_download" class="AXUploadDownload">download</a>');
            po.push('	</div>');
            po.push('	<div class="AXUploadProcess">');
            po.push('		<div class="AXUploadProcessBar"></div>');
            po.push('	</div>');
            po.push('	<div class="AXUploadTit" title="' + f.name.dec() + '" style="display:none;">' + f.name.dec() + '</div>');
            po.push('</div>');
        } else {
            po.push('<div class="AXUploadItem ' + cfg.openMode + '" id="' + itemID + '" style=\"display:none;\">');
            po.push('	<div class="AXUploadIcon">');
            po.push('		<img id="' + itemID + '_preview" class="preview" src="" />');
            po.push('	</div>');
            po.push('	<div class="AXUploadType"><span class="AXUploadSize">' + f.size.number().byte() + '</span></div>');
            //view 모드인경우 파일명을 클릭하면 다운로드 이벤트를 발생시킨다
            if (cfg.openMode == "view") {
                po.push('    <a href="#AXExecption" id="' + itemID + '_AXUploadLabel_download" class="AXUploadDownload">');
                po.push('    <div class="AXUploadTit" title="' + f.name.dec() + '">' + f.name.dec());
                po.push('    </div>');
                po.push('    </a>');
            }
            else {
                po.push('	<div class="AXUploadTit" title="' + f.name.dec() + '">' + f.name.dec() + '</div>');
            }
            po.push('	<div class="AXUploadProcess">');
            po.push('		<div class="AXUploadProcessBar"></div>');
            po.push('	</div>');
            po.push('	<div class="AXUploadBtns" style="display:none;">');
            if (cfg.openMode != "view") po.push('		<a href="#AXExecption" class="AXUploadBtnsA" id="' + itemID + '_AXUploadBtns_deleteFile">del</a>');
            po.push('	</div>');
            po.push('	<div class="AXUploadLabel ' + cfg.openMode + '" style="display:none;">');

            if (cfg.formatter) {
                var uf = {};
                //uf.id =  (f.id) ? f.id : itemID;
                uf.id = itemID;
                uf.name = f.name;
                uf.type = f.type;
                uf.size = f.size;

                var returnStr = cfg.formatter.call(uf, uf);
                if (returnStr) po.push(returnStr);
            }
            po.push('		<a href="#AXExecption" id="' + itemID + '_AXUploadLabel_download" class="AXUploadDownload">download</a>');
            po.push('	</div>');
        }
        return po.join('');
    },
    onFileSelect: function (evt) {
        var cfg = this.config, _this = this;
        if (this.supportHtml5) {
            var files = evt.target.files; // FileList object
            if(files && files.length > 0) {
                if (cfg.isSingleUpload) {

                    var myFile = this.uploadedList.first();
                    if (myFile) {
                        this.__tempFiles = files[0];
                        if (!confirm(AXConfig.AXUpload5.deleteConfirm)) return;
                        var uploadFn = function () {
                            var itemID = 'AX' + AXUtil.timekey() + '_AX_0';
                            this.queue.push({_id_: itemID, file: _this.__tempFiles});
                            axdom("#" + cfg.targetID + '_AX_display').empty();
                            axdom("#" + cfg.targetID + '_AX_display').append(_this.getItemTag(itemID, _this.__tempFiles));

                            _this.queueLive = true;
                            if (cfg.onStart) cfg.onStart.call(_this.queue, _this.queue);
                            _this.uploadQueue();
                            itemID = null;
                            _this.__tempFiles = null;
                        };
                        this.deleteFile(myFile, uploadFn.bind(this));
                        return;
                    } else {
                        var i = 0;
                        var f = files[i];
                        var itemID = 'AX' + AXUtil.timekey() + '_AX_' + i;
                        this.queue.push({_id_: itemID, file: f});
                        axdom("#" + cfg.targetID + '_AX_display').empty();
                        axdom("#" + cfg.targetID + '_AX_display').append(this.getItemTag(itemID, f));
                    }

                }
                else {
                    var hasSizeOverFile = false;
                    var sizeOverFile;
                    if (!cfg.file_types) cfg.file_types = ".";
                    if (cfg.file_types == "*.*") cfg.file_types = "*/*";

                    for (var i = 0; i < files.length; i++) {
                        var f = files[i];
                        if (f.size > cfg.uploadMaxFileSize) {
                            hasSizeOverFile = true;
                            sizeOverFile = f;
                            break;
                        }
                    }
                    if (hasSizeOverFile) cfg.onError("fileSize", {name: sizeOverFile.name, size: sizeOverFile.size});

                    //todo : 업로드 갯수 제한 확인 1
                    var uploadedCount = this.uploadedList.length;
                    var queueCount = this.queue.length;
                    //trace(uploadedCount, queueCount, (uploadedCount-1+queueCount));
                    for (var i = 0; i < files.length; i++) {
                        var f = files[i];
                        if (f.size <= cfg.uploadMaxFileSize && ( (new RegExp(cfg.file_types.replace(/\*/g, "[a-z]"), "ig")).test(f.type.toString()) || (cfg.file_types == "*/*" && f.type == "") )) {
                            if ((uploadedCount + queueCount) < cfg.uploadMaxFileCount || cfg.uploadMaxFileCount == 0) {
                                var itemID = 'AX' + AXUtil.timekey() + '_AX_' + i;
                                this.queue.push({_id_: itemID, file: f});
                                //큐박스에 아이템 추가

                                if (cfg.queueBoxAppendType == "prepend") axdom("#" + cfg.queueBoxID).prepend(this.getItemTag(itemID, f));
                                else axdom("#" + cfg.queueBoxID).append(this.getItemTag(itemID, f));

                                this.setLocalPreview(itemID, f);

                                axdom("#" + cfg.queueBoxID).find("#" + itemID).fadeIn();

                                uploadedCount++;

                                //trace(uploadedCount, this.queue.length);

                            } else {
                                cfg.onError("fileCount");
                                break;
                            }
                        }
                    }
                    ;
                }
            }
        } else {
            alert("not support HTML5");
        }
        this.queueLive = true;
        if (cfg.onStart) cfg.onStart.call(this.queue, this.queue);
        this.uploadQueue();
    },
    onFileDragOver: function (evt) {
        var cfg = this.config;
        axdom("#" + cfg.dropBoxID).addClass("onDrop");
        axdom("#" + cfg.dropBoxID + "_dropZoneBox").show();
        /*axdom("#"+cfg.dropBoxID+"_dropZoneBox").css({height:axdom("#"+cfg.dropBoxID).innerHeight()-6, width:axdom("#"+cfg.dropBoxID).innerWidth()-6}); 라르게덴 2013-10-29 오후 3:21:45 */
        axdom("#" + cfg.dropBoxID + "_dropZoneBox").css({height: axdom("#" + cfg.dropBoxID).prop("scrollHeight") - 6, width: axdom("#" + cfg.dropBoxID).innerWidth() - 6});

        var dropZone = document.getElementById(cfg.dropBoxID + "_dropZoneBox");
        dropZone.addEventListener('dragleave', function (evt) {
            axdom("#" + cfg.dropBoxID).removeClass("onDrop");
            axdom("#" + cfg.dropBoxID + "_dropZoneBox").hide();
        }, false);

        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    },
    onFileDrop: function (evt) {
        var cfg = this.config, quebox = axdom("#" + cfg.queueBoxID);
        evt.stopPropagation();
        evt.preventDefault();
        axdom("#" + cfg.dropBoxID).removeClass("onDrop");
        axdom("#" + cfg.dropBoxID + "_dropZoneBox").hide()

        var files = evt.dataTransfer.files; // FileList object.

        var hasSizeOverFile = false;
        var sizeOverFile;
        for (var i = 0, f; f = files[i]; i++) {
            if (f.size > cfg.uploadMaxFileSize) {
                hasSizeOverFile = true;
                sizeOverFile = f;
                break;
            }
        }
        if (hasSizeOverFile) cfg.onError("fileSize", {name: sizeOverFile.name, size: sizeOverFile.size});
        if (!cfg.file_types) cfg.file_types = ".";
        if (cfg.file_types == "*.*") cfg.file_types = "*/*";
        var fileTypeRe = new RegExp(cfg.file_types.replace(/\*/g, "[a-z]"), "ig");
        // todo : 업로드 갯수 제한 확인
        var uploadedCount = this.uploadedList.length;
        var queueCount = this.queue.length;
        for (var i = 0, f; f = files[i]; i++) {
            if (f.size <= cfg.uploadMaxFileSize && ( (new RegExp(cfg.file_types.replace(/\*/g, "[a-z]"), "ig")).test(f.type.toString()) || (cfg.file_types == "*/*" && f.type == "") )) {
                if ((uploadedCount + queueCount) < cfg.uploadMaxFileCount || cfg.uploadMaxFileCount == 0) {
                    uploadedCount++;
                    var itemID = 'AX' + AXUtil.timekey() + '_AX_' + i;
                    this.queue.push({_id_: itemID, file: f});
                    //큐박스에 아이템 추가
                    if (cfg.queueBoxAppendType == "prepend") quebox.prepend(this.getItemTag(itemID, f));
                    else quebox.append(this.getItemTag(itemID, f));

                    this.setLocalPreview(itemID, f);

                    quebox.find("#" + itemID).fadeIn();
                } else {
                    cfg.onError("fileCount");
                    break;
                }
            }
        }
        ;

        this.queueLive = true;
        if (cfg.onStart) cfg.onStart.call(this.queue);
        this.uploadQueue();
    },
    pauseQueue: function () {
        this.queueLive = false;
    },
    uploadQueue: function (fileUpload) {
        var cfg = this.config;

        if (cfg.fileSelectAutoUpload == false && fileUpload == undefined) {
            return;
        }

        if (cfg.fileSelectAutoUpload == false && fileUpload != undefined && this.swfu) {
            this.swfu.settings.allowUpload = true;
            this.swfu.startUpload();
        }

        if (!this.queueLive) return;
        if (this.queue.length == 0) {
            //trace("uploadEnd");
            this.uploadComplete();
            return;
        }

        var uploadQueue = this.uploadQueue.bind(this);
        var cancelUpload = this.cancelUpload.bind(this);
        var uploadSuccess = this.uploadSuccess.bind(this);
        var onClickDeleteButton = this.onClickDeleteButton.bind(this);
        var onClickFileTitle = this.onClickFileTitle.bind(this);

        var obj = this.queue.shift();
        this.uploadingObj = obj;
        var formData = new FormData();
        //서버로 전송해야 할 추가 파라미터 정보 설정
        axdom.each(cfg.uploadPars, function (k, v) {
            formData.append(k, v);
        });
        //formData.append(obj.file.name, obj.file);
        formData.append(cfg.uploadFileName, obj.file);

        //obj.id
        var itemID = obj._id_, quebox = axdom("#" + cfg.queueBoxID), itembox = axdom("#" + itemID);

        this.xhr = new XMLHttpRequest();
        this.xhr.open('POST', cfg.uploadUrl, true);
        this.xhr.onload = function (e) {
            var res = e.target.response;
            try {
                if (typeof res == "string") res = res.object();
            } catch (e) {
                trace(e);
                cancelUpload();
                return;
            }

            if (res.result == "err" || res.error) {
                alert("파일전송에 실패 하였습니다. 서버에서 에러가 리턴되었습니다. 콘솔창을 확인 하세요.");
                trace(res);
                axdom("#" + itemID).fadeOut("slow");
                cancelUpload();
                return;
            }

            if (cfg.isSingleUpload) {

                itembox.find(".AXUploadBtns").show();
                itembox.find(".AXUploadLabel").show();
                itembox.find(".AXUploadTit").show();

                itembox.find(".AXUploadProcess").hide();

                uploadSuccess(obj.file, itemID, res);
                // --------------------- s
                itembox.find(".AXUploadBtnsA").bind("click", function () {
                    onClickDeleteButton(itemID);
                });
                if (cfg.onClickUploadedItem) {
                    itembox.find(".AXUploadDownload").bind("click", function () {
                        onClickFileTitle(itemID);
                    });
                }

            }
            else {

                itembox.find(".AXUploadBtns").show();
                itembox.find(".AXUploadLabel").show();
                itembox.find(".AXUploadProcess").hide();

                var _res = (Object.isArray(res)) ? res[0] : res;
                /* Array 타입 예외처리 */

                if (_res[cfg.fileKeys.thumbPath]) {
                    itembox.find(".AXUploadIcon").css({
                        "background-image": "url('" + (_res[cfg.fileKeys.thumbPath] || "").dec() + "')"
                    }).addClass("AXUploadPreview").find("img.preview").remove();
                } else {
                    itembox.find(".AXUploadIcon").css({"background-image": "url()"});
                    itembox.find(".AXUploadIcon").html((_res[cfg.fileKeys.type] || "").dec().replace(".", ""));
                }

                uploadSuccess(obj.file, itemID, _res);

                // --------------------- s
                itembox.find(".AXUploadBtnsA").bind("click", function () {
                    onClickDeleteButton(itemID);
                });
                if (cfg.onClickUploadedItem) {
                    itembox.find(".AXUploadDownload").bind("click", function () {
                        onClickFileTitle(itemID);
                    });
                }
            }

            // --------------------- e
            uploadQueue(fileUpload);
        };
        var setUploadingObj = function () {
            this.uploadingObj = null;
        };
        var setUploadingObjBind = setUploadingObj.bind(this);
        this.xhr.upload.onprogress = function (e) {
            if (cfg.isSingleUpload) {
                if (e.lengthComputable) {
                    itembox.find(".AXUploadProcessBar").width(((e.loaded / e.total) * 100).round(2) + "%");
                }
            } else {
                if (e.lengthComputable) {
                    itembox.find(".AXUploadProcessBar").width(((e.loaded / e.total) * 100).round(2) + "%");
                }
            }
            if (e.lengthComputable) {
                if (e.loaded > e.total * 0.9) {
                    setUploadingObjBind();
                }
            }
        };
        this.xhr.send(formData);  // multipart/form-data
    },
    uploadSuccess: function (file, itemID, res) { // 업로드 아이템별 이벤트
        var cfg = this.config;
        var uploadedItem = {};
        uploadedItem[cfg.fileKeys._id_] = itemID;

        var _res = (Object.isArray(res)) ? res[0] : res;
        /* Array 타입 예외처리 */
        axdom.each(_res, function (k, v) {
            uploadedItem[k] = v;
        });
        if (cfg.queueBoxAppendType == "prepend") {
            //this.uploadedList.push(uploadedItem);
            this.uploadedList.splice(0, 0, uploadedItem);
        }
        else {
            this.uploadedList.push(uploadedItem);
            /*
             var uploadedList = [];
             uploadedList.push(uploadedItem);
             axdom.each(this.uploadedList, function(){
             uploadedList.push(this);
             });
             */
            //this.uploadedList = this.uploadedList.concat(uploadedItem);
        }
        axdom("#" + itemID).addClass("readyselect");
        if (cfg.onUpload) cfg.onUpload.call(uploadedItem, uploadedItem);
    },
    clearQueue: function () {
        //큐제거
        axdom.each(this.queue, function () {
            axdom("#" + this.id).hide(function () {
                axdom(this).remove();
            });
        });
        this.queue = [];
    },
    uploadComplete: function () {
        var cfg = this.config;
        //trace("uploadComplete");
        if (AXgetId(cfg.targetID + '_AX_files')) { // 2015-08-02 업로드 완료 방식 변경 체크중

            document.getElementById(cfg.targetID + '_AX_files').value = "";

            /*
             axdom('#'+cfg.targetID+'_AX_files').remove();

             var inputFileMultiple = 'multiple="multiple"';
             var inputFileAccept = cfg.file_types;
             if(cfg.isSingleUpload){
             inputFileMultiple = '';
             }
             if(!this.supportHtml5){
             inputFileMultiple = '';
             }

             var  po = ['	<input type="file" id="'+cfg.targetID+'_AX_files" '+inputFileMultiple+' accept="'+inputFileAccept+'" style="position:absolute;left:0px;top:0px;margin:0px;padding:0px;-moz-opacity: 0.0;opacity:.00;filter: alpha(opacity=0);" />'];
             axdom("#"+cfg.targetID+"_AX_selectorTD").prepend(po.join(''));
             axdom('#'+cfg.targetID+'_AX_files').css({width:axdom('#'+cfg.targetID+'_AX_selector').outerWidth(),height:axdom('#'+cfg.targetID+'_AX_selector').outerHeight()});

             var onFileSelect = this.onFileSelect.bind(this);

             setTimeout(function(){
             var fileSelector = document.getElementById(cfg.targetID+'_AX_files');
             if(AXUtil.browser.name == "ie" && AXUtil.browser.version < 9){

             }else{
             fileSelector.addEventListener('change', onFileSelect, false);
             }
             }, 100);
             */
        }
        if (cfg.queueBoxID) {
            this.multiSelector.collect();
        }
        if (cfg.onComplete) cfg.onComplete.call(this.uploadedList, this.uploadedList);
    },
    cancelUpload: function () {
        var cfg = this.config;
        if (this.swfu) {
            this.swfu.stopUpload();
            var stats = this.swfu.getStats();
            while (stats.files_queued > 0) {
                this.swfu.cancelUpload();
                stats = this.swfu.getStats();
            }
            stats = null;
            this.pauseQueue();
            this.clearQueue();
        } else {
            if (this.uploadingObj) {
                this.xhr.abort();
                axdom("#" + this.uploadingObj.id).remove();
                this.uploadingObj = null;
            }
            this.pauseQueue();
            this.clearQueue();
        }
        if (cfg.onComplete) cfg.onComplete.call(this.uploadedList, this.uploadedList);
    },
    onClickDeleteButton: function (itemID) {
        var cfg = this.config;
        if (cfg.isSingleUpload) {
            var myFile;
            axdom.each(this.uploadedList, function () {
                if (this[cfg.fileKeys._id_] == itemID) {
                    myFile = this;
                    return false;
                }
            });
            if (myFile) {
                if(this.deleteFile(myFile) != false){
                    this.init("reset");
                }
            }
            myFile = null;
        } else {
            var myFile;
            axdom.each(this.uploadedList, function () {
                if (this[cfg.fileKeys._id_] == itemID) {
                    myFile = this;
                    return false;
                }
            });
            if (myFile) {
                this.deleteFile(myFile);
                if (cfg.queueBoxID) {
                    this.multiSelector.clearSelects();
                }
            }
            myFile = null;
        }

    },
    onClickFileTitle: function (itemID) {
        var cfg = this.config;
        //trace(itemID);
        if (cfg.onClickUploadedItem) {
            var myFile;
            axdom.each(this.uploadedList, function () {
                if (this[cfg.fileKeys._id_] == itemID) {
                    myFile = this;
                    return false;
                }
            });
            cfg.onClickUploadedItem.call(myFile, myFile);
        }
    },
    deleteFile: function (file, onEnd, withOutServer) {
        var cfg = this.config;
        if (!onEnd) if (!confirm(AXConfig.AXUpload5.deleteConfirm)) return false;
        var removeUploadedList = this.removeUploadedList.bind(this);

        //trace(file);
        //{"id":"AXA220125984_AX_0", "name":"38540011%2EJPG", "type":"%2EJPG", "saveName":"0DA0316011A0001%2EJPG", "fileSize":"3172720", "uploadedPath":"%2F%5Ffile%2F1%2F", "thumbPath":"%2F%5Ffile%2F1%2FT%5F0DA0316011A0001%2EJPG"}
        if (file != undefined) {

            if (withOutServer == "withOutServer") {
                if (cfg.isSingleUpload) {
                    axdom('#' + cfg.targetID + '_AX_display').html(AXConfig.AXUpload5.uploadSelectTxt);
                } else {
                    axdom("#" + file[cfg.fileKeys._id_]).hide(function () {
                        axdom(this).remove();
                    });
                }
                removeUploadedList(file[cfg.fileKeys._id_]);
                if (cfg.onDelete) cfg.onDelete.call({file: file, response: withOutServer}, file);
                if (onEnd) onEnd();
                return;
            }

            var pars = [];
            var sendPars = "";
            axdom.each(file, function (k, v) {
                if (k != "downloadPath") pars.push(k + '=' + v);
            });

            if (typeof(cfg.deletePars) === "object") {
                axdom.each(cfg.deletePars, function (k, v) {
                    pars.push(k + '=' + v);
                });
                sendPars = pars.join("&");
            } else {
                sendPars = pars.join("&") + "&" + cfg.deletePars;
            }

            if (cfg.isSingleUpload) {
                axdom("#" + file[cfg.fileKeys._id_] + " .AXUploadBtns").hide();
            } else {
                axdom("#" + cfg.queueBoxID).find("#" + file[cfg.fileKeys._id_] + " .AXUploadBtns").hide();
            }

            new AXReq(cfg.deleteUrl, {
                method: (cfg.deleteMethod || "POST"),
                debug: false,
                pars: sendPars,
                onsucc: function (res) {
                    if ((res.result && res.result == AXConfig.AXReq.okCode) || (res.result == undefined && !res.error)) {

                        if (onEnd) setTimeout(onEnd, 1);



                        if (cfg.isSingleUpload) {
                            axdom('#' + cfg.targetID + '_AX_display').html(AXConfig.AXUpload5.uploadSelectTxt);
                        } else {
                            axdom("#" + file[cfg.fileKeys._id_]).hide(function () {
                                axdom(this).remove();
                            });
                        }
                        if (cfg.onDelete) cfg.onDelete.call({file: file, response: res}, file);
                        removeUploadedList(file[cfg.fileKeys._id_]);

                    } else {
                        if (cfg.isSingleUpload) {
                            axdom("#" + file[cfg.fileKeys._id_] + " .AXUploadBtns").show();
                        } else {
                            axdom("#" + cfg.queueBoxID).find("#" + file[cfg.fileKeys._id_] + " .AXUploadBtns").show();
                        }
                    }
                },
                onerr: function () {
                    if (cfg.isSingleUpload) {
                        axdom("#" + file[cfg.fileKeys._id_] + " .AXUploadBtns").show();
                    } else {
                        axdom("#" + cfg.queueBoxID).find("#" + file[cfg.fileKeys._id_] + " .AXUploadBtns").show();
                    }
                }
            });

        } else {
            trace("file undefined");
        }
    },
    deleteSelect: function (arg, withOutServer) {
        var cfg = this.config;
        if (arg == "all") {
            var deleteQueue = [];
            axdom.each(this.uploadedList, function () {
                deleteQueue.push(this[cfg.fileKeys._id_]);
            });
            this.ccDelete(deleteQueue, 0, withOutServer);
            deleteQueue = null;
        } else {
            if (!this.multiSelector) return;
            var selectObj = this.multiSelector.getSelects();
            if (selectObj.length > 0) {
                var deleteQueue = [];
                axdom.each(selectObj, function () {
                    deleteQueue.push(this.id);
                });
                this.ccDelete(deleteQueue, 0, withOutServer);
                deleteQueue = null;
            } else {
                alert("삭제하실 파일을 선택해 주세요");
            }
        }
    },
    ccDelete: function (deleteQueue, index, withOutServer) {
        var cfg = this.config;
        if (deleteQueue.length > index) {
            var myFile;
            axdom.each(this.uploadedList, function () {
                if (this[cfg.fileKeys._id_] == deleteQueue[index]) {
                    myFile = this;
                    return false;
                }
            });
            var ccDelete = this.ccDelete.bind(this);
            this.deleteFile(myFile, function () {
                ccDelete(deleteQueue, (index + 1), withOutServer);
            }, withOutServer);
        }
    },
    removeUploadedList: function (fid) {
        var cfg = this.config;
        var newUploadedList = [];
        axdom.each(this.uploadedList, function () {
            if (this[cfg.fileKeys._id_] != fid) newUploadedList.push(this);
        });
        this.uploadedList = newUploadedList;
        newUploadedList = null;
        if (this.config.onDeleteAll && this.uploadedList.length < 1)  this.config.onDeleteAll.call();

        this.multiSelector.collect();
    },
    showMSG: function (msg) {
        dialog.push(msg);
    },

    /**
     * @method AXUpload5.setUploadedList
     * @param {Array} files - example code 참고
     * @returns {type} name
     * @description
     * 업로드된 목록을 지정합니다.
     * @example
     ```
     ex1)
     var myFileList = [];
     var fileItem = {
    name		: 'fileName', //{string} - setConfig.fileKeys 에서 정의한 json key
    type		: 'fileType', //{string} - setConfig.fileKeys 에서 정의한 json key
    saveName	: 'saveName', //{string} - setConfig.fileKeys 에서 정의한 json key
    fileSize	: 'fileSize', //{string} - setConfig.fileKeys 에서 정의한 json key
    uploadedPath: 'filePath', //{string} - setConfig.fileKeys 에서 정의한 json key
    thumbPath	: 'thumbPath' //{string} - setConfig.fileKeys 에서 정의한 json key
};
     myFileList.push(fileItem);
     myUpload.setUploadedList(myFileList);

     ex2)
     var url = "loadFileList";               //해당 url 에서 예제1의 myFileList 구조에 맞는 json을 내려 줍니다.
     var pars = "dummy="+AXUtil.timekey();
     new AXReq(url, {pars:pars, onsucc:function(res){
	if(res.result == "ok"){
		myUpload.setUploadedList(res.ds);
	}else{
		alert(res.msg.dec());
	}
}});
     ```
     */
    setUploadedList: function (files) {
        var cfg = this.config;

        var getItemTag = this.getItemTag.bind(this);
        var onClickDeleteButton = this.onClickDeleteButton.bind(this);
        var onClickFileTitle = this.onClickFileTitle.bind(this);

        if (cfg.isSingleUpload) {
            this.uploadedList = [];
            var f;
            if (axdom.isArray(files)) {
                if (Object.isObject(files[0])) {
                    f = files[0];
                }
            } else {
                if (Object.isObject(files)) {
                    f = files;
                }
            }
            if (!f) return;
            if (!f[cfg.fileKeys._id_]) {
                if (f["id"]) {
                    f[cfg.fileKeys._id_] = f["id"];
                } else {
                    return;
                }
            }

            this.uploadedList.push(f);

            var itemID = (f[cfg.fileKeys._id_] || f["id"]), itembox;

            var uf = {
                id: itemID,
                name: f[cfg.fileKeys.name],
                size: f[cfg.fileKeys.fileSize]
            };

            itembox = axdom("#" + cfg.targetID + '_AX_display');
            if (cfg.queueBoxAppendType == "prepend") itembox.empty().prepend(this.getItemTag(itemID, uf));
            else itembox.empty().append(this.getItemTag(itemID, uf));


            itembox.find(".AXUploadBtns").show();
            itembox.find(".AXUploadLabel").show();
            itembox.find(".AXUploadTit").show();
            itembox.find(".AXUploadProcess").hide();

            itembox.find(".AXUploadBtnsA").bind("click", function () {
                onClickDeleteButton(itemID);
            });
            if (cfg.onClickUploadedItem) {
                itembox.find(".AXUploadDownload").bind("click", function () {
                    onClickFileTitle(itemID);
                });
            }

        }
        else {

            //this.uploadedList = files;
            this.uploadedList = [];
            var uploadedList = [];

            axf.each(files, function () {
                if (this) uploadedList.push(this);
            });
            this.uploadedList = uploadedList;

            if (cfg.queueBoxID) {
                var quebox = axdom("#" + cfg.queueBoxID);
                quebox.find('.dropZoneBox').empty();
                // @panic910
                quebox.remove('.AXUploadItem');
                axdom.each(this.uploadedList, function (fidx, f) {
                    if (f[cfg.fileKeys._id_] == undefined) {
                        if (f["id"]) {
                            f[cfg.fileKeys._id_] = f["id"];
                        } else {
                            trace([cfg.fileKeys._id_] + " key는 필수 항목 입니다.");
                            return false;
                        }
                    }
                    var itemID = f[cfg.fileKeys._id_], itembox;
                    var uf = {
                        id: itemID,
                        name: f[cfg.fileKeys.name],
                        size: f[cfg.fileKeys.fileSize]
                    };

                    if (cfg.queueBoxAppendType == "prepend") quebox.prepend(getItemTag(itemID, uf));
                    else quebox.append(getItemTag(itemID, uf));


                    itembox = axdom("#" + itemID);
                    itembox.fadeIn();

                    // --------------------- s
                    itembox.find(".AXUploadBtns").show();
                    itembox.find(".AXUploadLabel").show();
                    itembox.find(".AXUploadProcess").hide();

                    if (f[cfg.fileKeys.thumbPath]) {
                        itembox.find(".AXUploadIcon").css({
                            "background-image": "url('" + (f[cfg.fileKeys.thumbPath] || "").dec() + "')"
                        }).addClass("AXUploadPreview").find("img.preview").remove();
                    } else {
                        itembox.find(".AXUploadIcon").css({"background-image": "none"});
                        itembox.find(".AXUploadIcon").html((f[cfg.fileKeys.type] || "").dec().replace(".", ""));
                    }

                    itembox.find(".AXUploadBtnsA").bind("click", function () {
                        onClickDeleteButton(itemID);
                    });
                    if (cfg.onClickUploadedItem) {
                        itembox.find(".AXUploadDownload").bind("click", function () {
                            onClickFileTitle(itemID);
                        });
                    }
                    if (f['mainImage']) {
                        $("#" + f['id'] + "_AXUploadLabel_mainImageFile").show();
                    }
                    // --------------------- e

                    itembox.addClass("readyselect");
                });
                this.multiSelector.collect();
            }
        }
    },

    /**
     * @method AXUpload5.getUploadedList
     * @param {string} arg - ("param"|"json") 옵션에 따라 파라미터 타입 또는 JSObject 형태로 리턴 타입을 지정합니다.
     * @returns {String | JSObject}
     * @description
     * 업로드된 파일목록을 반환합니다.
     * @example
     ```
     var list = myUpload.getUploadedList("json");
     trace(list);
     toast.push(Object.toJSON(list));
     ```
     */
    getUploadedList: function (arg) {
        var cfg = this.config;

        if (cfg.uploadedListSort) {
            this.uploadedList = cfg.uploadedListSort.call(this, this.uploadedList);
        }

        if (arg == "param") {
            try {
                var pars = [];
                if (this.uploadedList) {
                    axdom.each(this.uploadedList, function () {
                        if (this != "") pars.push(axdom.param(this));
                    });
                }
                return pars.join("&");
                pars = null;
            } catch (e) {
                trace(e);
            }
        } else {
            return this.uploadedList;
        }
    },

    /**
     * @method AXUpload5.getSelectUploadedList
     * @param {string} arg - ("param"|"json") 옵션에 따라 파라미터 타입 또는 JSObject 형태로 리턴 타입을 지정합니다.
     * @returns {String | JSObject}
     * @description
     * 업로드된 파일 목록 중에서 선택된 아이템을 반환합니다.
     * @example
     ```
     var list = myUpload.getSelectUploadedList("json");
     trace(list);
     toast.push(Object.toJSON(list));
     ```
     */
    getSelectUploadedList: function (arg) {
        if (!this.multiSelector) return;
        var selectObj = this.multiSelector.getSelects();
        if (arg == "param") {
            var pars = [];
            axdom.each(this.uploadedList, function () {
                for (var a = 0; a < selectObj.length; a++) {
                    if (this.id == selectObj[a].id) pars.push(axdom.param(this));
                }
            });
            return pars.join("&");
            pars = null;
        } else {
            var pars = [];
            axdom.each(this.uploadedList, function () {
                for (var a = 0; a < selectObj.length; a++) {
                    if (this.id == selectObj[a].id) pars.push(this);
                }
            });
            return pars;
            pars = null;
        }
    },
    setUploadedFile: function (file) {

        if (!file) return;
        if (!file[this.config.fileKeys.id]) return;

        this.uploadedList = [];
        this.uploadedList.push(file);
        fileNameMaxLen = this.settings.fileNameMaxLen;
        var po = [];

        var dfileicon = this.settings.dfileicon;

        var UploadDisplay_id = this.settings.UploadDisplay_id;
        var onClickButton = this.onClickButton.bind(this);
        var AXfile = this.uploadedList.first();

        var po = [];
        po.push("<div class='AXFileTitleBlock'>");
        po.push("<a href='#AXexec' class='AXFileTitle'>" + AXfile.ti.dec() + "</a>");
        po.push("<a href='#AXexec' class='AXFileDelete'>X</a>");
        po.push("</div>");
        axdom("#" + UploadDisplay_id).html(po.join(''));
        axdom("#" + UploadDisplay_id).find(".AXFileDelete").bind("click", onClickButton);

        if (this.settings.onclick) {
            var onclick = this.settings.onclick.bind(this);
            axdom("#" + UploadDisplay_id).find(".AXFileTitle").bind("click", function () {
                onclick(AXfile);
            });
        }

        po = null;
        fileNameMaxLen = null;
    },
    getUploadedFile: function () {
        return this.uploadedList.first();
    },

    addKeyInUploadedListItem: function (objID, obj) {
        var uploadedList = this.uploadedList;

        axdom.each(uploadedList, function (idx, o) {
            if (o.id == objID) {
                axdom.each(obj, function (k, v) {
                    o[k] = v;
                });
            } else {
                axdom.each(obj, function (k, v) {
                    o[k] = '';
                });
            }
        });
    },

    setLocalPreview: function (itemID, file) {
        if (!this.supportHtml5 || this.config.isSingleUpload) {
            return;
        }
        if (!this.supportHtml5 || this.config.isSingleUpload) {
            return;
        }

        try {
            var previewId = itemID + "_preview";
            var preview = axf.getId(previewId);
            var reader = new FileReader(previewId);

            reader.onloadend = function () {
                try {
                    preview.src = reader.result;
                } catch (ex) {
                    trace(ex);
                }
            };

            if (file) {
                reader.readAsDataURL(file);
            }
        } catch (e) {
            trace(e);
        }
    },

    nothing: function () {

    }
});

// axdom extend
/* ---------------------------- */
var AXUserSelect = Class.create(AXJ, {
    initialize: function(AXJ_super) {
        AXJ_super();
        this.config.className = "";
        this.ds = [];
    },
    init: function() {
        var config = this.config;
        this.myDrag = new AXDrag();
        
        if (!config.containerID || !jQuery("#" + config.containerID).get(0)) {
            alert("컨테이너 아이디가 지정되지 않아 modsTab 초기화에 실패 하였습니다.");
            return;
        }
        this.CT = jQuery("#" + config.containerID);

        var po = [];
        po.push("<div class=\"" + config.className + " readyDrop\" id=\"" + config.containerID + "_AX_UserSelectBox\" style='height:100%;'>");
        po.push("</div>");
        this.CT.html(po.join(''));


        var onSort = this.onSort.bind(this);
        var onDrop = this.onDrop.bind(this);

        this.myDrag.setConfig({
            dragStage: config.containerID + "_AX_UserSelectBox",
            dragBoxClassName: "modsDragBox",
            bedragClassName: "bedraged",
            bedropClassName: "bedroped",
            dragClassName: "readyDrag",
            dropClassName: "readyDrop",
            //onDrag: fnObj.portlet.onDrag,
            onDrop: onDrop,
            onSort: onSort,
            multiSelector: {
                selectStage: config.containerID + "_AX_UserSelectBox",
                selectClassName: "readyDrag",
                beselectClassName: "beSelected"
            },
            sort: {
                sorter: "<div class=\"modsSortGhost\"></div>"
            }
        });
        // 3 : 활성화
        this.myDrag.active();

    },
/**
 * @method AXUserSelect.push
 * @param ds {Array} 추가할 아이템 배열
 * @returns null
 * @description UserSelect 개체에 아이템을 추가합니다.
 * @example
```
var ds = [];
ds.push({
	id:AXUtil.timekey(),
    nm:AXUtil.timekey(),
    desc:"AXISJ"
});
myUserBox.push(ds);
```
 */
    push: function(ds) {
        var config = this.config;
        var myds = this.ds;
        var po = [];
        jQuery.each(ds, function(i, D) {
            var addOk = 1;
            jQuery.each(myds, function() {
                if (this.id == D.id) {
                    addOk = 0;
                    return false;
                }
            });
            if (addOk == 1) {
                po.push("<div class=\"readyDrag\" id=\"" + config.containerID + "userSelectItem_AX_" + this.id + "\">");
                po.push("	<div class=\"userSelectItemBody\">");
                po.push("	<input type=\"hidden\" name=\"id\" id=\"" + config.containerID + "userSelectItemID_AX_" + this.id + "\" value=\"" + this.id + "\" /> ");
                po.push("	<input type=\"hidden\" name=\"nm\" id=\"" + config.containerID + "userSelectItemNM_AX_" + this.id + "\" value=\"" + this.nm + "\" /> ");
                po.push("	<input type=\"hidden\" name=\"desc\" id=\"" + config.containerID + "userSelectItemDESC_AX_" + this.id + "\" value=\"" + (this.desc||"") + "\" /> ");
                po.push("	" + this.nm.dec() + " ");
                po.push("	" + (this.desc||"").dec() + " ");
                //po.push("	<a href=\"#modsExec\" class=\"del\">삭제</a>");
                po.push("	</div>");
                po.push("</div>");
                myds.push(this);
            }
        });

        jQuery("#" + config.containerID + "_AX_UserSelectBox").append(po.join(''));


        this.dragCollect();
    },
    del: function(select) {
        var config = this.config;
        var myDS = [];
        jQuery.each(this.ds, function() {
            var delOK = 0;
            for (var a = 0; a < select.length; a++) {
                if (select[a].id.split(/_AX_/g).last() == this.id) {
                    delOK = 1;
                }
            }
            if (delOK == 1) {
                jQuery("#" + config.containerID + "userSelectItem_AX_" + this.id).remove();
            } else {
                myDS.push(this);
            }
        });
        this.ds = myDS;
        this.dragCollect();
    },
    _del: function(select) {
        var config = this.config;
        var myDS = [];
        axf.each(this.ds, function() {
            var delOK = 0;
            for (var a = 0; a < select.length; a++) {
                if (select[a] == this.id) {
                    delOK = 1;
                }
            }
            if (delOK == 1) {
                axdom("#" + config.containerID + "userSelectItem_AX_" + this.id).remove();
            } else {
                myDS.push(this);
            }
        });
        this.ds = myDS;
        this.dragCollect();
    },    
    dragCollect: function() {
        this.myDrag.collectItem();
    },
    onSort: function(res) {
	    var _this = this, that;
        var dragCollect = this.dragCollect.bind(this);
        if (axdom(res.dragItem).html() == axdom(res.sortItem).html()) return;
        if (res.dragItem == res.sortItem) return;
        axdom(res.dragItem).fadeOut("fast", function() {
            axdom(res.sortItem).before(this);
            axdom(this).show("fast");
            dragCollect();
	        if(_this.config.onchange){
		        that = {
			        containerID: _this.config.containerID,
			        list : _this.getDS()
		        };
		        _this.config.onchange.call(that);
	        }
        });
	    
	    return this;
    },
    onDrop: function(res) {
	    var _this = this, that;
        var dragCollect = this.dragCollect.bind(this);
        axdom(res.dragItem).fadeOut("fast", function() {
            jQuery("#" + _this.config.containerID + "_AX_UserSelectBox").append(this); //예외 경우
            jQuery(this).show("fast");
            dragCollect();
	        if(_this.config.onchange){
		        that = {
			        containerID: _this.config.containerID,
			        list : _this.getDS()
		        };
		        _this.config.onchange.call(that);
	        }
        });
	    return this;
    },
    moveup: function() {
	    var _this = this, that, select = this.getSelect();

        axf.each(select, function() {
            var prev = axdom(this).prev();
            prev.before(axdom(this));
        });

	    if(_this.config.onchange){
		    that = {
			    containerID: _this.config.containerID,
			    list : _this.getDS()
		    };
		    _this.config.onchange.call(that);
	    }
	    return this;
    },
    movedown: function() {
	    var _this = this, that, select = this.getSelect();

        axf.each(select, function() {
            var next = axdom(this).next();
            next.after(axdom(this));
        });

	    if(_this.config.onchange){
		    that = {
			    containerID: _this.config.containerID,
			    list : _this.getDS()
		    };
		    _this.config.onchange.call(that);
	    }
	    return this;
    },    
    getSelect: function() {
        return this.myDrag.mselector.getSelects();
    },
    empty: function() {
        var config = this.config;
        jQuery("#" + config.containerID + "_AX_UserSelectBox").empty();
        this.ds = [];
        this.dragCollect();
    },
    getDS: function() {
        var config = this.config;
        var myDS = [];
        jQuery("#" + config.containerID + "_AX_UserSelectBox").find(".readyDrag").each(function() {
            var id = this.id.split(/_AX_/g).last();
            var nm = jQuery("#" + config.containerID + "userSelectItemNM_AX_" + id).val();
            var desc = jQuery("#" + config.containerID + "userSelectItemDESC_AX_" + id).val();
            myDS.push({id:id, nm:nm, desc:desc});
        });
        return myDS;
    },
	getSelectDS: function() {
		var config = this.config;
		var myDS = [];
		var sls = this.myDrag.mselector.getSelects();
		if(sls.length > 0){
			for(var i=0;i<sls.length;i++){
				var id = sls[i].id.split(/_AX_/g).last();
				var nm = jQuery("#" + config.containerID + "userSelectItemNM_AX_" + id).val();
				var desc = jQuery("#" + config.containerID + "userSelectItemDESC_AX_" + id).val();
				myDS.push({id:id, nm:nm, desc:desc});
			}
		}
		return myDS;
	}
});
/* ---------------------------- */
var AXValidator = Class.create(AXJ, {
    initialize: function (AXJ_super) {
        AXJ_super();
        this.Observer = null;
        this.form = null;
        this.elements = [];
        this.errElements = [];
        this.errMessagePattern = "[{label}] {message}";
        this.config = {
            targetID: null,
            clazz: "av-"
        };

		if(AXConfig.AXValidator && AXConfig.AXValidator.validateErrMessage){
			this.config.validateErrMessage = AXConfig.AXValidator.validateErrMessage;
		}else{
			this.config.validateErrMessage = {
				/* for element */
				required: "[{label}](은)는 필수입력 사항입니다.",
				requiredstring: "반드시 {required}(으)로 입력하셔야 하는 사항입니다.",
				match: "[{label}](은)는 입력된 내용이 일치하지 않습니다.",
				invalid: "[{label}](은)는 입력된 내용이 올바르지 않습니다.",
				min: "[{label}](은)는 {min} 이상의 값을 입력해주세요.",
				max: "[{label}](은)는 {max} 이하의 값을 입력해주세요.",
				minbyte: "[{label}]의 입력된 내용의 길이가 {minbyte}Byte 이상이어야 합니다.",
				maxbyte: "[{label}]의 입력된 내용의 길이가 {maxbyte}Byte를 초과할 수 없습니다.",
				minlength: "[{label}]의 입력된 내용의 length가 {minlength} 이상이어야 합니다.",
				maxlength: "[{label}]의 입력된 내용의 length가 {maxlength}을 초과할 수 없습니다.",

				/* for format */
				number: "숫자로만 입력하셔야 합니다.",
				email: "이메일 형식이 올바르지 않습니다.",
				hangul: "한글로만 입력하셔야 합니다.",
				engonly: "영문으로만 입력하셔야 합니다.",
				residentno: "주민등록번호 형식이 올바르지 않습니다.",
				foreignerno: "외국인등록번호 형식이 올바르지 않습니다.",
				bizno: "사업자등록번호 형식이 올바르지 않습니다.",
				phone: "전화번호 형식이 올바르지 않습니다.",
				isdate: "날짜 형식이 올바르지 않습니다.",
				zip: "우편번호 형식이 올바르지 않습니다.",
				money: "화폐형식으로만 입력하셔야 합니다.",
				earlierThan: "[{label}] 보다 빠른 날짜를 입력해야 합니다.",
				laterThan: "[{label}] 보다 느린 날짜를 입력해야 합니다.",

				exception: "not found errmessage"
			};
		}

    },
    init: function () {
        var cfg = this.config;
        if (Object.isUndefined(cfg.targetFormName)) {
            trace("need targetID - setConfig({targetFormName:''})");
            return;
        }

        if (!document[cfg.targetFormName]) {
            // 엘리먼트가 존재 하지 않는 경우 예외 처리
            trace("not found form element");
            return;
        }

        this.form = $(document[cfg.targetFormName]);
        this.findElement();
    },
    findElement: function () {
        var cfg = this.config;
        var allElements = this.form.serializeObject();
        var _elements = this.elements;
        var checkClass = this.validateCheckClass;

        axdom.each(allElements, function (eidx, Elem) {
            try {
                var config = {};
                var isValidate = false;
                axdom.each(checkClass, function (k, v) {
                    if (Elem.id) {
                        if (axdom("#" + Elem.id).hasClass(cfg.clazz + k)) {
                            config[k] = v;
                            isValidate = true;
                        }
                    } else if (Elem.name) {
                        if ($(document[cfg.targetFormName][Elem.name]).hasClass(cfg.clazz + k)) {
                            config[k] = v;
                            isValidate = true;
                        }
                    }
                });
                if (isValidate) {
                    delete Elem.value;
                    Elem.config = config;
                    _elements.push(Elem);
                }
            } catch (e) {

            }
        });
	    // checkbox, radio 수집
	    var checkedItems = {};
	    axdom(this.form).find("input[type=checkbox], input[type=radio]").each(function(eidx, Elem){

		    var config = {};
		    var isValidate = false, label = "";
		    axdom.each(checkClass, function (k, v) {
				if (Elem.name) {
				    if ($(document[cfg.targetFormName][Elem.name]).hasClass(cfg.clazz + k)) {
					    config[k] = v;
					    isValidate = true;
					    if(label == "") label = (Elem.title || Elem.placeholder || "");
				    }
			    }
		    });

		    if (isValidate) {
			    if(checkedItems[this.name]){
				    checkedItems[this.name].push({index:0, type:this.type, value:this.value, id:this.id, checked:this.checked, label:label});
			    }else{
				    checkedItems[this.name] = [{index:0, type:this.type, value:this.value, id:this.id,  checked:this.checked, config:config, label:label}];
			    }
		    }
	    });

	    axf.each(checkedItems, function(k, v){
		    var item = {
			    "id":"",
			    "name":k,
			    "type":v[0].type,
			    "label":v[0].label,
			    "multi":true,
			    "config":v[0].config
		    };
		    /*
		    for(var aa=0;aa<v.length;aa++){
			    if(item.id == ""){
				    item.id = v[aa].id;
			    }else{
				    item.id += "," + v[aa].id;
			    }
		    }
		    */
		    _elements.push(item);
	    });
	    
	    //config에 checkCrlf 옵션이 있을 경우
	    if(cfg.checkCrlf){
	    	axdom(this.form).find("textarea[maxlength]").each(function(index, element){
	    		
	    		var item = {
	    			"id":element.id,
	    			"name":element.name,
	    			"type":"textarea",
	    			"value":"",
	    			"label":element.title||element.placeholder||"",
	    			"config":{"maxlength":element.maxLength}
	    		};
	    		
	    		_elements.push(item);
	    	});
	    }

        this.elements = _elements;
    },

/**
 * @method AXValidator.add
 * @param {JSObject} - example code 참고
 * @description
 * validate 대상 아이템을 추가합니다.
 * @example
 ```

var jsObjectSample = {
    id: "userID",           //{string} - 아이템식별자
    label: "아이디",        //{string} - 아이템라벨
    config: {               //필요한 조합을 object로 정의합니다.
        required: true,		//[boolean=true] - 필수입력 체크
        number: true, 		//[boolean=true] - 숫자입력 체크
        email: true, 		//[boolean=true] - 이메일형식 체크
        hangul: true, 		//[boolean=true] - 한글형식 체크
        engonly: true, 		//[boolean=true] - 영문형식 체크
        residentno: true, 	//[boolean=true] - 주민등록번호형식 체크
        foreignerno: true,	//[boolean=true] - 외국인번호형식 체크
        bizno: true, 		//[boolean=true] - 사업자등록번호형식 체크
        phone: true, 		//[boolean=true] - 전화번호형식 체크
        isdate: true, 		//[boolean=true] - 날짜형식 체크
        zip: true, 			//[boolean=true] - 우편번호형식 체크
        money: true, 		//[boolean=true] - 숫자에 , 포함 체크
        earlierThan:{
            id: "targetId",			//{string} - 대상의 아이디. 현재 아이템의 값이 대상보다 커야함
            label:	"targetLabel"	//{string} - 대상의 라벨
        },
        laterThan:{
            id: "targetId",			//{string} - 대상의 아이디. 현재 아이템의 값이 대상보다 작아야함
            label:	"targetLabel"	//{string} - 대상의 라벨
        },
        min: true, 			//[boolean=true] - 최소값
        max: true, 			//[boolean=true] - 최대값
        minbyte: true, 		//[boolean=true] - 최소바이트값
        maxbyte: true, 		//[boolean=true] - 최대바이트값
        minlength: true, 	//[boolean=true] - 최소길이
        maxlength: true 	//[boolean=true] - 최대길이
    },
    realtime:{			    //특정이벤트 발생시 액션정의
        event: "keydown",	//{String} - 발생하는 이벤트 종류
        response: function(){   //{fn} - 정의된 이벤트에 따른 실시간 이벤트 콜백함수
            //trace(this);
        }
    },
    onblur: function(){     //[fn] - 대상 아이템에 블러 이벤트 발생 콜백함수
        //trace(this);
    }
};

var myValidator = new AXValidator();
myValidator.add({
    id: "userID",           //{string} - 아이템식별자
    label: "아이디",        //{string} - 아이템라벨
    config: {
        required: true,     //[boolean=true] - 필수입력 체크
        minbyte:10,         //[boolean=true] - 최소바이트값
        maxbyte:20          //[boolean=true] - 최대바이트값
    },
    realtime: {
        event: "keydown",           //{String} - 발생하는 이벤트 종류
        response: function () {     //{fn} - 정의된 이벤트에 따른 실시간 이벤트 콜백함수
        	if(this.result){
        		$("#userID_realtime").html("OK");
        	}else{
            	$("#userID_realtime").html(this.message);
           }
			if (this.validateKey == "maxbyte" || this.validateKey == "maxlength") {
			    return false; //키 입력 중지
			} else {
			    return true; //키 입력 제어 안함
			}
        }
    },
	onblur: function(){ //[fn] - 대상 아이템에 블러 이벤트 발생 콜백함수
		trace(this);
	}
});

myValidator.add({
	id:"enddate",   //{string} - 아이템 식별자
	label:"종료일",  //{string} - 아이템 라벨
	config:{
	    isdate:true,    //[boolean=true] - 날짜형식 체크
	    laterThan:{
	        id:"regdate",   //{string} - 대상의 아이디. 현재 아이템의 값이 대상보다 작아야함
	        label:"등록일"  //{string} - 대상의 라벨
        }
    },
	onblur: function(){     //[fn] - 대상 아이템에 블러 이벤트 발생 콜백함수
        trace(this);
	}
});

 ```
 */
    add: function (addObj) {
        var cfg = this.config;
        var addedObject;
        var addElement = this.addElement.bind(this);
        var getElement = this.getElement.bind(this);
        var isActiveFormControl = this.isActiveFormControl.bind(this);
        var element = getElement(addObj);
        if (!isActiveFormControl(element)) return false;

        if (addObj.id) {
            var findIndex = null;
            axdom.each(this.elements, function (eidx, elem) {
                if (this.id == addObj.id) {
                    findIndex = eidx;
                    return false;
                }
            });
            if (findIndex != null) {
                addElement(addObj, findIndex);
                addedObject = this.elements[findIndex];
            } else {
                addObj.name = axdom("#" + addObj.id).attr("name");
                this.elements.push(addObj);
                addedObject = this.elements.last();
            }
        } else if (addObj.name) {
            var findIndex = null;
            axdom.each(this.elements, function (eidx, elem) {
                if (this.name == addObj.name) {
                    findIndex = eidx;
                    return false;
                }
            });
            if (findIndex != null) {
                addElement(addObj, findIndex);
                addedObject = this.elements[findIndex];
            } else {
                addObj.id = $(document[cfg.targetFormName][addObj.name]).attr("id");
                this.elements.push(addObj);
                addedObject = this.elements.last();
            }

        }

        var raiseError = this.raiseError.bind(this);
        var validateFormatter = this.validateFormatter.bind(this);
        var targetElem;
        var targetElemForSelect;

        if (addedObject.id) {
            targetElem = axdom("#" + addedObject.id);
            targetElemForSelect = AXgetId(addedObject.id);
        } else if (addedObject.name) {
            targetElem = $(document[cfg.targetFormName][addedObject.name]);
            targetElemForSelect = document[cfg.targetFormName][addedObject.name];
        }
        var Elem = addedObject;
        var displayFormatter = this.displayFormatter.bind(this);

        // realtime 지원 함수 구문 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if (addedObject.realtime) {
            //Elem.realtime.validate = Elem.config;

            Elem.needRealtimeCheck = false;
            Elem.realtimeCheck = {};

            axdom.each(Elem.config, function (k, v) {
                if (k == "maxlength" || k == "maxbyte") {
                    Elem.needRealtimeCheck = true;
                    Elem.realtimeCheck[k] = v;
                }
            });

            if (Elem.needRealtimeCheck) {
                targetElem.unbind("keydown.validate");
                targetElem.bind("keydown.validate", function (e) {
                    var event = window.event || e;
                    if (!event.keyCode || event.keyCode == 9 || event.keyCode == 16) return;
                    var _val = this.value;
                    var returnObject = null;
                    var eventBlock = true;

                    if (document.selection && document.selection.createRange) {
                        var range = document.selection.createRange();
                        if (range.text != "") eventBlock = false;
                    } else if (window.getSelection) {

                        if (AXUtil.browser.name == "mozilla") {
                            //trace({ maxlength: Elem.realtimeCheck.maxlength, selectionStart: targetElemForSelect.selectionStart });
                            if (Elem.realtimeCheck.maxlength > targetElemForSelect.selectionStart) {
                                eventBlock = false;
                            }
                        } else {
                            selectedText = window.getSelection().toString();
                            if (selectedText != "") eventBlock = false;
                        }
                    }


                    axdom.each(Elem.realtimeCheck, function (k, v) {
                        var val = targetElem.val() + "A";
                        if (!validateFormatter(Elem, val, k, v, "realtime")) { // 값 검증 처리
                            returnObject = raiseError(Elem, val, k, v);
                            return false;
                        }
                    });

                    var responseResult = true;
                    if (returnObject == null) {
                        Elem.realtime.response.call({ result: true });
                    } else {
                        returnObject.result = false;
                        responseResult = Elem.realtime.response.call(returnObject);
                    }

                    if (responseResult == false) {
                        if (eventBlock) {
                            if (event.keyCode != AXUtil.Event.KEY_DELETE
                                && event.keyCode != AXUtil.Event.KEY_BACKSPACE
                                && event.keyCode != AXUtil.Event.KEY_LEFT
                                && event.keyCode != AXUtil.Event.KEY_RIGHT) {

                                if (event.preventDefault) event.preventDefault();
                                if (event.stopPropagation) event.stopPropagation();
                                event.cancelBubble = true;
                                return false;
                            }
                        }
                    }

                });
            }



            //trace(Elem.config);

            targetElem.unbind("keyup.validate").bind("keyup.validate", function (e) {
                var event = window.event || e;
                // ignore tab & shift key 스킵
                if (!event.keyCode || event.keyCode == 9 || event.keyCode == 16) return;

                var _val = this.value;
                var returnObject = null;
                var vKey;
                axdom.each(Elem.config, function (k, v) {

                    //trace(k);

                    vKey = k;
                    var val = targetElem.val();
                    if (!validateFormatter(Elem, val, k, v, "realtime")) { // 값 검증 처리
                        returnObject = raiseError(Elem, val, k, v);
                        return false;
                    }
                });

                var responseResult = true;
                if (returnObject == null) {
                    Elem.__prevValue = _val;
                    Elem.realtime.response.call({ result: true });
                } else {
                    returnObject.result = false;
                    responseResult = Elem.realtime.response.call(returnObject);
                }



                if (responseResult == false) {
                    if (event.keyCode != AXUtil.Event.KEY_DELETE
                        && event.keyCode != AXUtil.Event.KEY_BACKSPACE
                        && event.keyCode != AXUtil.Event.KEY_LEFT
                        && event.keyCode != AXUtil.Event.KEY_RIGHT
                        ) {

                        if ((Elem.__prevValue || "").length > _val.length) {
                            this.value = "";
                        } else {
                            if (displayFormatter((Elem.__prevValue || ""), vKey) != "") this.value = displayFormatter((Elem.__prevValue || ""), vKey);
                        }

                        if (event.preventDefault) event.preventDefault();
                        if (event.stopPropagation) event.stopPropagation();
                        event.cancelBubble = true;
                        return false;
                    }
                } else {
                    //realtime에서 체크시 백시켜서 오류
                    if (displayFormatter(this.value, vKey) != "") this.value = displayFormatter(this.value, vKey);
                }

            });

        }
        // realtime 지원 함수 구문 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


        //trace(addedObject);

        // blur 지원
        if (addedObject.onblur) {
            targetElem.unbind("blur.validate").bind("blur.validate", function (e) {
                var returnObject = {result:true};
                axdom.each(Elem.config, function (k, v) {
                    var val = targetElem.val();
                    if (!validateFormatter(Elem, val, k, v, "")) {
                        returnObject = raiseError(Elem, val, k, v);
                        returnObject.config = Elem.config;
                        returnObject.result = false;
                        return false;
                    }
                });
                if(returnObject.result){
                    returnObject.element = Elem;
                    returnObject.value = targetElem.val();
                    returnObject.config = Elem.config;
                }
                var responseResult = Elem.onblur.call(returnObject);
            });
        }

    },

/**
 * @method AXValidator.del
 * @param {JSObject} - example code 참고
 * @description
 * validate 대상 아이템을 제거합니다.
 * @example
 ```
 myValidator.del( {id:"userID"});   //아이템식별자

 ```
 */
    del: function (delObj) {
        var cfg = this.config;
        var deledObject;

        var findIndex = null;
        if (delObj.id) {
            $.each(this.elements, function (eidx, elem) {
                if (this.id == delObj.id) {
                    findIndex = eidx;
                    return false;
                }
            });
        } else if (delObj.name) {
            $.each(this.elements, function (eidx, elem) {
                if (this.name == delObj.name) {
                    findIndex = eidx;
                    return false;
                }
            });
        }

        if (findIndex != null) {
            deledObject = this.elements[findIndex];
            $("#" + deledObject.id).unbind("keydown.validate");
            $("#" + deledObject.id).unbind("keyup.validate");
            $("#" + deledObject.id).unbind("blur.validate");
            this.elements.splice(findIndex, 1);
        }

        //trace(this.elements);
    },

    addElement: function (addObj, findIndex) {
        AXUtil.overwriteObject(this.elements[findIndex].config, addObj.config, true);
        if (addObj.onblur) this.elements[findIndex].onblur = addObj.onblur;
        if (addObj.realtime) this.elements[findIndex].realtime = addObj.realtime;
        if (addObj.message) this.elements[findIndex].message = addObj.message;
        if (addObj.label) this.elements[findIndex].label = addObj.label;
    },

/**
 * @method AXValidator.validate
 * @returns {boolean} - 정의된 규칙에 따라 (true|false) 로 결과를 리턴합니다.
 * @description
 * validate 처리결과를 리턴합니다.
 * @example
 ```
var validateResult = myValidator.validate();
 ```
 */
    validate: function (filterOption) {
        var cfg = this.config;
        var raiseError = this.raiseError.bind(this);
        var validateFormatter = this.validateFormatter.bind(this);

        var returnObject = null;
        for (var Elem, eidx= 0, __arr = this.elements; (eidx < __arr.length && (Elem = __arr[eidx])); eidx++) {
            var targetElem;
            if (Elem.id && !Elem.multi) {
                targetElem = axdom("#" + Elem.id);
            } else if (Elem.name) {
                targetElem = axdom( document[cfg.targetFormName][Elem.name] );
            }

	        if(Elem.name == "bizno") {
		        //alert(Elem.name);
		        //alert(document[cfg.targetFormName][Elem.name]);
	        }

            var isCheck = true;
            if(filterOption){
                if(filterOption.filterType == "include"){
                    isCheck = false;
                    for (var f, fidx= 0, __arr2 = filterOption.list; (fidx < __arr2.length && (f = __arr2[fidx])); fidx++) {
                        if(f.id && f.id == Elem.id){
                            isCheck = true;
                            break;
                        }else if(f.name && f.name == Elem.name){
                            isCheck = true;
                            break;
                        }
                    }
                }else{
                    isCheck = true;
                    for (var f, fidx= 0, __arr2 = filterOption.list; (fidx < __arr2.length && (f = __arr2[fidx])); fidx++) {
                        if(f.id && f.id == Elem.id){
                            isCheck = false;
                            break;
                        }else if(f.name && f.name == Elem.name){
                            isCheck = false;
                            break;
                        }
                    }
                }
            }

            if (targetElem && isCheck) {
	            var val = "";
	            if(Elem.type == "radio" || Elem.type == "checkbox"){
		            targetElem.each(function(){
			            if(this.checked){
				            if(val == "") val = this.value;
				            else val += "," + this.value;
			            }
		            });
	            }else{
		            val = targetElem.val();
	            }

                var _end = false;

                axdom.each(Elem.config, function (k, v) {
                    if (!validateFormatter(Elem, val, k, v, "")) { // 값 검증 처리
                        returnObject = raiseError(Elem, val, k, v);
                        _end = true;
                        return false;
                    }
                });
                if (_end) return false;
            }
        };

        if (returnObject == null) {
            this.errElements = [];
            return true;
        } else {
            return false;
        }

    },
    raiseError: function (elem, elemVal, validateKey, validateVal) {
        var messageConvert = this.messageConvert.bind(this);
        var message = messageConvert(elem, validateKey, validateVal);
        var returnObject = {
            element: elem,
            value: elemVal,
            validateKey: validateKey,
            validateVal: validateVal,
            message: message
        };
        this.errElements.push(returnObject);
        return returnObject;
    },
    messageConvert: function (elementObj, validateKey, validateVal) {
        var validateErrMessage = this.config.validateErrMessage;
        var vKey = "exception";
        var vVal = "";
        if (validateKey != undefined) vKey = validateKey;
        if (validateVal != undefined) vVal = validateVal;

        var element = elementObj;
        if (!element) {
            return null;
        }
        var label;
        if (element.label) {
            label = element.label.length > 0 ? element.label : (element.id || element.name);
        } else {
            label = (element.id || element.name);
        }

        if(vKey == "earlierThan" || vKey == "laterThan"){
            label = (validateVal.label||label);
        }

        var errMessage = validateErrMessage[vKey];
        if (element.message == undefined) {
            var typeMessage = errMessage;
        } else {
            var typeMessage = (element.message[vKey] || errMessage);
        }

        if (typeMessage != undefined) {
            var message = typeMessage.replace(/{label}/, label);
            message = message.replace("{" + vKey + "}", vVal);
        } else {
            message = "";
        }
        return message;
    },
    //-------------------- validate check - formatter - message Set [S] ----------------------
    validateCheckClass: {
        // element에서 클래스 검사 항목
        required: true,     //필수
        number: true,        //숫자 형식
        email: true,         //이메일 형식
        hangul: true,        //한글 형식
        engonly: true,       //영문 형식
        residentno: true,    //주민등록 번호 형식
        foreignerno: true,   //외국인 번호 형식
        bizno: true,         //사업자 등록 형식
        phone: true,         //전화번호 형식
        isdate: true,        //날짜 형식
        zip: true,           //우편번호 형식
        money: true          //',' 포함한 숫자
    },
    validateFormatter: function (Elem, ElemValue, validateKey, validateValue, realtime) {
        var cfg = this.config;
        var result = true;
        var lenMargin = 1; // 최소 최대 비교시 하나 커야 함.
        if (realtime == "realtime") lenMargin = 0; // realtime 실행 시는 마진 없음.
        try {

	        if (ElemValue != "" && validateKey == "residentno") {

	        }

            /* for element */
            if (validateKey == "required") {
                result = (ElemValue.trim() != "");
            } else if (ElemValue != "" && validateKey == "min") {
                result = (ElemValue.number() + lenMargin > validateValue);
            } else if (ElemValue != "" && validateKey == "max") {
                result = (ElemValue.number() - lenMargin <= validateValue);
            } else if (ElemValue != "" && validateKey == "minbyte") {
                result = (ElemValue.getByte().number() + lenMargin > validateValue);
            } else if (ElemValue != "" && validateKey == "maxbyte") {
                result = (ElemValue.getByte().number() - lenMargin <= validateValue);
            } else if (ElemValue != "" && validateKey == "minlength") {
                result = (ElemValue.length.number() >= validateValue);
            } else if (ElemValue != "" && validateKey == "maxlength") {
            	var crlfLength = 0;
            	if(cfg.checkCrlf){
            		var __matchedArr = ElemValue.match(/(\r\n|\n|\r)/g);
            		if(__matchedArr){
            			crlfLength = __matchedArr.length * 1;
            			trace(crlfLength);
            		}
            	}
                result = (ElemValue.length.number() + crlfLength <= validateValue);
                /* for format */
            } else if (ElemValue != "" && validateKey == "number") {
                //var pattern = /^[0-9]+$/;
                result = axdom.isNumeric(ElemValue.trim());
            } else if (ElemValue != "" && validateKey == "email") {
                var pattern = /^[_a-zA-Z0-9-\.]+@[\.a-zA-Z0-9-]+\.[a-zA-Z]+$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "hangul") {
                var pattern = /^[가-힣0-9]+$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "engonly") {
                var pattern = /^[a-zA-Z0-9_]+$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "residentno") {


	            var pattern = /^(?:[0-9]{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[1,2][0-9]|3[0,1]))-?[1-4][0-9]{6}$/;
	            var num = ElemValue;

	            //trace(pattern.test(num), "test");

	            if (!pattern.test(num)){
		            result = false;
	            }

	            function checkJumin(p_juminno) {
		            try {
			            // 파라미터로 전달받은 p_juminno가 공백이거나, 13자리를 넘어가거나, 숫자가 아닐경우 false 리턴
			            if(p_juminno == '' || p_juminno.length != 13 || typeof(Number(p_juminno)) != 'number') {
				            return false;
			            }

			            isKorean = true;
			            // 주민번호 뒷자리 첫번째 수가 4보다 크거나, 9보다 작으면 외국인
			            if(Number(p_juminno.charAt(6)) > 4 && Number(p_juminno.charAt(6)) < 9) {
				            isKorean = false;
			            }

			            // 아래부터는 검증 로직임.
			            var check = 0;
			            for(var i=0; i<12; i++) {
				            if(isKorean) {
					            check = check + ((i % 8 + 2) * Number(p_juminno.charAt(i)));
				            } else {
					            check = check + ((9 - i % 8) * Number(p_juminno.charAt(i)));
				            }
			            }
			            if(isKorean) {
				            check = 11 - (check % 11);
				            check = check % 10;
			            } else {
				            var remainder = check % 11;
				            if(remainder == 0) {
					            check = 1;
				            } else if(remainder==10) {
					            check = 0;
				            } else {
					            check = remainder;
				            }
				            var check2 = check + 2;
				            if(check2 > 9) {
					            check = check2 - 10;
				            } else {
					            check = check2;
				            }
			            }
			            if(check == Number(p_juminno.charAt(12))) {
				            return true;
			            } else {
				            return false;
			            }
		            } catch(e) {
			            alert(e.description);
		            }
	            }
	            if(result != false) {
		            result = checkJumin(num.replace(/\D/g, ""));
	            }
            } else if (ElemValue != "" && validateKey == "foreignerno") {
                var pattern = /^(\d{6})-?(\d{5}[7-9]\d{1})$/;
                var num = ElemValue;

	            if (!pattern.test(num)){
		            result = false;
	            }

	            if(result != false) {
		            num = RegExp.$1 + RegExp.$2;
		            //if ((num[7] * 10 + num[8]) % 2) return "foreignerno";

		            var sum = 0;
		            var last = num.charCodeAt(12) - 0x30;
		            var bases = "234567892345";
		            for (var i = 0; i < 12; i++) {
			            if (isNaN(num.substring(i, i + 1))) return "foreignerno";
			            sum += (num.charCodeAt(i) - 0x30) * (bases.charCodeAt(i) - 0x30);
		            }
		            var mod = sum % 11;
		            result = ((11 - mod + 2) % 10 == last);
	            }

            } else if (ElemValue != "" && validateKey == "bizno") {
                var pattern = /([0-9]{3})-?([0-9]{2})-?([0-9]{5})/;
                var num = ElemValue;
	            if(num.replace(/\D/g, "").length != 10){
		            result = false;
	            }
	            if (!pattern.test(num)){
		            result = false;
	            }

                num = RegExp.$1 + RegExp.$2 + RegExp.$3;
	            if(result != false) {
		            var vencod = num, sum = 0, getlist = new Array(10), chkvalue = new Array("1", "3", "7", "1", "3", "7", "1", "3", "5");
		            for (var i = 0; i < 10; i++) { getlist[i] = vencod.substring(i, i + 1); }
		            for (var i = 0; i < 9; i++) { sum += getlist[i] * chkvalue[i]; }
		            sum = sum + parseInt((getlist[8] * 5) / 10);
		            sidliy = sum % 10;
		            sidchk = (sidliy != 0) ? 10 - sidliy : 0;
		            result = (sidchk != getlist[9]) ? false : true;
		            /*
		            var cVal = 0;
		            for (var i = 0; i < 8; i++) {
			            var cKeyNum = parseInt(((_tmp = i % 3) == 0) ? 1 : (_tmp == 1) ? 3 : 7);
			            cVal += (parseFloat(num.substring(i, i + 1)) * cKeyNum) % 10;
		            }
		            ;
		            var li_temp = parseFloat(num.substring(i, i + 1)) * 5 + "0";
		            cVal += parseFloat(li_temp.substring(0, 1)) + parseFloat(li_temp.substring(1, 2));
		            result = (parseInt(num.substring(9, 10)) == 10 - (cVal % 10) % 10);
		            */
	            }

            } else if (ElemValue != "" && validateKey == "phone") {
                if (realtime == "realtime") {
                    var pattern = /[\D]+/;
                    var num = ElemValue.replace(/\-/g, "");
                    result = pattern.test(num) ? false : true;
                } else {
                    var pattern = /^(0[2-8][0-5]?|01[01346-9])-?([1-9]{1}[0-9]{2,3})-?([0-9]{4})$/;
                    var pattern15xx = /^(1544|1566|1577|1588|1644|1688)-?([0-9]{4})$/;
                    var patternHand = /^(01[01346-9])-?([1-9]{1}[0-9]{2,3})-?([0-9]{4})$/;
                    var num = ElemValue;
                    result = pattern.test(num) || pattern15xx.test(num) || patternHand.test(num) ? true : false;
                }
            } else if (ElemValue != "" && validateKey == "isdate") {
                result = true;

                var iDate = ElemValue.replace(/-/g, "");
                if (iDate.length != 8) {
                    return result = false;
                }

                var oDate = new Date(parseInt(iDate.substr(0, 4), 10), parseInt(iDate.substr(4, 2), 10) - 1, parseInt(iDate.substr(6, 2), 10));
                if (oDate.getFullYear() != parseInt(iDate.substr(0, 4), 10)
                    || oDate.getMonth() != parseInt(iDate.substr(4, 2), 10)-1
                    || oDate.getDate() != parseInt(iDate.substr(6, 2), 10)) {
                    return result = false;
                }else{
                    return result = true;
                }
            } else if (ElemValue != "" && validateKey == "zip") {
                var pattern = /^[0-9]{3}\-[0-9]{3}$/;
                result = pattern.test(ElemValue);
            } else if (ElemValue != "" && validateKey == "money") {
                var value = ElemValue.replace(",").replace(".");
                //실제 money형식
                var pattern = /^\$?[0-9]+(,[0-9]{3})*(\.[0-9]*)?$/;
                //var pattern = /^[1-9]\d*(((,\d{3}){1})?(\.\d{0,2})?)$/;
                result = pattern.test(ElemValue);
            } else if (validateKey == "earlierThan") {
                if(ElemValue == ""){
                    result = true;
                }else{
                    var st_date = ElemValue;
                    var ed_date = axdom("#" + validateValue.id).val().trim();
                    if(ed_date != ""){
                        if (st_date.date().diff(ed_date) < 0) {
                            result = false;
                        }else{
                            result = true;
                        }
                    }else{
                        result = false;
                    }
                }
            } else if (validateKey == "laterThan") {
                if(ElemValue == ""){
                    result = true;
                }else{
                    var ed_date = ElemValue;
                    var st_date = axdom("#" + validateValue.id).val().trim();
                    if(st_date != ""){
                        //trace(st_date, ed_date, st_date.date());
                        if (st_date.date().diff(ed_date) < 0) {
                            result = false;
                        }else{
                            result = true;
                        }
                    }else{
                        result = false;
                    }
                }
            } else {
                if (axdom.isFunction(validateValue)) {
                    result = validateValue.call({
                        Elem: Elem,
                        ElemValue: ElemValue,
                        validateKey: validateKey
                    });
                }
            }
        } catch (e) {
            trace("validateFormatter-catch:662", e);
            result = false;
        }

        return result;
    },
    //-------------------- validate check - formatter - message Set [E] ----------------------
    //-------------------- validate static 지원 함수 Set [S] ---------------------------------
/**
 * @method AXValidator.getErrorMessage
 * @returns {string} - 에러메세지
 * @description
 * 에러메세지를 리턴합니다.
 * @example
 ```
var validateResult = myValidator.validate();
if (!validateResult) {
	var msg = myValidator.getErrorMessage();    //에러메세지를 리턴합니다.
	alert(msg);
	myValidator.getErrorElement().focus();      //에러가 발생된 엘리먼트를 리턴합니다.
	return false;
}else{
	alert( validateResult );
}
 ```
 */
    getErrorMessage: function (errorMessagePattern) {
        if (!this.errElements) {
            return null;
        }
        if (this.errElements.length == 0) {
            return "Err 메세지가 없습니다.";
        }
        var errObj = this.errElements.last();
        var errElement = errObj.element;
        var messageConvert = this.messageConvert.bind(this);
        var message = messageConvert(errElement, errObj.validateKey, errObj.validateVal);

        return message;
    },

/**
 * @method AXValidator.getErrorElement
 * @returns {HTMLElement} - 에러가 발생된 엘리먼트
 * @description
 * 에러가 발생된 엘리먼트를 리텀합니다.
 * @example
 ```
var validateResult = myValidator.validate();
if (!validateResult) {
	var msg = myValidator.getErrorMessage();    //에러메세지를 리턴합니다.
	alert(msg);
	myValidator.getErrorElement().focus();      //에러가 발생된 엘리먼트를 리턴합니다.
	return false;
}else{
	alert( validateResult );
}
 ```
 */
    getErrorElement: function () {
        var cfg = this.config;
        if (!this.errElements) {
            return null;
        }
        if (this.errElements.length == 0) {
            return null;
        }
        var errObj = this.errElements.last();
        var errElement = errObj.element;
        return axdom("#" + errElement.id).length > 0 ? axdom("#" + errElement.id) : axdom(document[cfg.targetFormName][errElement.name]);
    },
    getElement: function (elementObj) {
        var cfg = this.config;
        var element;
        try {
            if (elementObj.id) {
                element = AXgetId(elementObj.id);
            } else {
                element = document[cfg.targetFormName][elementObj.name];
            }
        } catch (e) {
            return false;
        }
        if (element == null) {
            AXUtil.alert((elementObj.id || elementObj.name) + " not found");
            return null;
        } else {
            return element;
        }
    },
    isActiveFormControl: function (element) {
        if (!element) return false;
        if (!(__rinput.test(element.type) || __rselectTextarea.test(element.type)) || element.disabled) return false;
        return true;
    },
    displayFormatter: function (elemValue, validateKey) {
        if (elemValue == "" || elemValue == null) return "";

        var value = elemValue;
        var dataFormat = "";

        if (value != "") {
            if (validateKey == "phone") {
                var pattern = /[^0-9]/g;
                var parintPattern = "";
                value = value.replace(pattern, "");

                //문자열 길이에 따른 값 처리
                if (value.length < 4) return value;
                if (value.length > 3 && value.length < 7) {
                    dataFormat = "$1-$2";
                    parintPattern = /([0-9]{3})([0-9]+)/;
                } else if (value.length == 7) {
                    dataFormat = "$1-$2";
                    parintPattern = /([0-9]{3})([0-9]{4})/;
                } else if (value.length == 9) {
                    dataFormat = "$1-$2-$3";
                    parintPattern = /([0-9]{2})([0-9]{3})([0-9]+)/;
                }
                else if (value.length == 10) {
                    if (value.substring(0, 2) == "02") {
                        dataFormat = "$1-$2-$3";
                        parintPattern = /([0-9]{2})([0-9]{4})([0-9]+)/;
                    } else {
                        dataFormat = "$1-$2-$3";
                        parintPattern = /([0-9]{3})([0-9]{3})([0-9]+)/;
                    }
                } else if (value.length > 10) {
                    dataFormat = "$1-$2-$3";
                    parintPattern = /([0-9]{3})([0-9]{4})([0-9]+)/;
                }
                value = value.replace(parintPattern, dataFormat);

            } else if (validateKey == "isdate") {
                var pattern = /[^0-9]/g;
                var parintPattern = "";

                value = value.replace(pattern, "");
                if (value.length < 4) return value;
                if (value.length > 4 && value.length < 7) {
                    dataFormat = "$1-$2";
                    parintPattern = /([0-9]{4})([0-9]+)/;
                } else if (value.length < 10) {
                    dataFormat = "$1-$2-$3";
                    parintPattern = /([0-9]{4})([0-9]{2})([0-9]+)/;
                }
                value = value.replace(parintPattern, dataFormat);
            }
            else {
                return "";
            }
        }

        return value;
    }
    //-------------------- validate static 지원 함수 Set [E] ---------------------------------
});
/* ---------------------------- */
/* http://www.axisj.com, license : http://www.axisj.com/license */
 
var AXWaterfall = Class.create(AXJ, {
	version: "AXWaterfall v1.1",
	author: "tom@axisj.com",
	logs: [
		"2012-10-11 오후 1:40:26",
		"2013-11-07 오전 9:58:41 - tom : 최소사이즈 버그 픽스"
	],
	initialize: function(AXJ_super) {
		AXJ_super();
		this.CT_className = "AXWaterfall";
		this.I_className = "WaterBox";
		this.I_classNameMobile = "WaterBoxMobile";
		this.config.boxWidth = 224;
		this.config.boxMargin = 10;
		this.config.pageSize = 5;
		this.config.mobileSize = 300;
		this.config.autoResize = true;
		this.Observer = null;
		this.player = null;
		this.played = false;
		this.targetWidth = null;
	},
	init: function(){
		var config = this.config;
		if(Object.isUndefined(config.targetID)){
			trace("need targetID - setConfig({targetID:''})");
			return;
		}
		axdom("#"+config.targetID).addClass(this.CT_className);
		axdom("#"+config.targetID).find("."+config.fallClassName).addClass(this.I_className);
		
		var bodyWidth = (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
		this.targetWidth = bodyWidth;
		axdom("#"+config.targetID).css({width:"auto", minWidth:"auto", maxWidth:"auto"});
		
		axdom("#"+config.targetID).find("."+config.fallClassName).hide();
		
		this.waterFall();
		this.bindEvent();
	},
	onresize: function(){
		var config = this.config;
		var bodyWidth = (AXUtil.docTD == "Q") ? document.body.clientWidth : document.documentElement.clientWidth;
		if(this.targetWidth == bodyWidth) return;
		this.targetWidth = bodyWidth;
		
		axdom("#"+config.targetID).css({width:"auto", minWidth:"auto", maxWidth:"auto"});
		if (this.Observer) clearTimeout(this.Observer); //닫기 명령 제거
		var waterFall = this.waterFall.bind(this);
		this.Observer = setTimeout(function() {
			axdom("#"+config.targetID).find("."+config.fallClassName).hide();
		   waterFall();
		}, 100);
	},
	waterFall: function(){
		//if(this.played) return;
		
		var config = this.config;
		var CTw = axdom("#"+config.targetID).innerWidth() - config.boxMargin;
		var CW = config.boxWidth + config.boxMargin + 2;
		this.Clen = parseInt(CTw.div(CW));
		
		var targetWidth = (CW * this.Clen);
		if(targetWidth < CW){			
			axdom("#"+config.targetID).css({width:"auto"});
		}else{
			axdom("#"+config.targetID).css({width:targetWidth+"px"});
		}

		if(this.Clen == 1){
			axdom("#"+config.targetID).find("."+config.fallClassName).addClass(this.I_classNameMobile);	
		}else{
			axdom("#"+config.targetID).find("."+config.fallClassName).removeClass(this.I_classNameMobile);	
		}
		this.grid = [];
		this.colsGrid = [];
		for(var a=0;a<this.Clen;a++) this.colsGrid.push(0);
		this.itemLen = axdom("#"+config.targetID).find("."+config.fallClassName).length;
		
		axdom("#"+config.targetID).find("."+config.fallClassName).each(function(index, O){
			var boxID = config.targetID+"_AX_"+index;
			axdom(O).attr("id", boxID);
			//axdom(O).html(index);
		});
		
		if(this.player) clearTimeout(this.player); //실행 중지
		this.playWaterFall(0);
	},
	
	playWaterFall: function(pageNo){
		var config = this.config;
		var stIndex = pageNo * config.pageSize;
		var edIndex = (pageNo+1) * config.pageSize;
		var l = 0, t = 0, et = 0, c = 0;
		
		for(var a = stIndex;a < edIndex;a++){
			var boxID = config.targetID+"_AX_"+a;
			if(a < this.Clen){
				t = 0;
				l = (a * config.boxWidth) + (config.boxMargin * a);
				c = a;
			}else{
				var minH = null;
				var minC = null;
				axdom.each(this.colsGrid, function(index, O){
					if(minH == null || minH > O){
						minH = O;
						minC = index;	
						c = index;
						l = (index * config.boxWidth) + (config.boxMargin * index);
					}
				});
				t = minH + config.boxMargin;
			}
			if(AXgetId(boxID)){
				var myBox = axdom("#"+boxID);
				myBox.css({left:l, top:t});
				myBox.show();
				var et = t + myBox.outerHeight();
				this.grid.push({id:boxID, left:l, top:t, et:et, col:c});
				this.colsGrid[c] = et;
				//trace({id:boxID, left:l, top:t, et:et, col:c});
			}else{
				break;	
			}
		}
		
		//trace(pageNo+" == "+(this.itemLen / config.pageSize));
		
		if((pageNo+1) > this.itemLen / config.pageSize){
			//play end
			var maxH = null;
			axdom.each(this.colsGrid, function(index, O){
				if(maxH == null || maxH < O){
					maxH = O;
				}
			});
			var itemWidth = this.Clen * (config.boxWidth + config.boxMargin) - config.boxMargin;
			var leftPadding = (axdom("#"+config.targetID).innerWidth() - itemWidth) /2;
			axdom("#"+config.targetID).css({height:maxH+config.boxMargin});
			this.played = false;
		}else{
			var playWaterFall = this.playWaterFall.bind(this);
			this.player = setTimeout(function(){
				playWaterFall((pageNo+1));
			}, 10);
		}
	},
	
	bindEvent: function(){
		var config = this.config;
		if(this.config.autoResize)
			axdom(window).resize(this.onresize.bind(this));
	}
});